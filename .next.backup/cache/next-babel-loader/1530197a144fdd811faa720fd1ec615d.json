{"ast":null,"code":"function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\nimport { JSBI, Fraction, Percent, Token, WETH, ChainId } from '@uniswap/sdk';\nimport { isAddress, toWei, fromWei } from 'web3-utils';\nimport { isIPFS } from './constants'; // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions#Escaping\n\nexport function escapeRegExp(string) {\n  return string.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&'); // $& means the whole matched string\n}\nexport function shortenHex(hex, length = 4) {\n  return `${hex.substring(0, length + 2)}…${hex.substring(hex.length - length)}`;\n}\nexport const CHAIN_ID_NAMES = {\n  0: 'Bitcoin',\n  1: 'Ethereum Mainnet',\n  3: 'Ropsten',\n  4: 'Rinkeby',\n  5: 'Görli',\n  42: 'Kovan',\n  80001: 'Mumbai',\n  137: 'Polygon',\n  97: 'bnbsc',\n  100: 'xDai',\n  56: 'Binance Smart Chain',\n  250: 'Fantom',\n  1313161554: 'Aurora'\n};\nexport const INFURA_PREFIXES = {\n  0: 'bitcoin',\n  1: 'mainnet',\n  3: 'ropsten',\n  4: 'rinkeby',\n  5: 'goerli',\n  42: 'kovan',\n  80001: 'mumbai',\n  137: 'matic',\n  97: 'bnbsc',\n  100: 'xdai',\n  56: 'bsc',\n  250: 'fantom',\n  1313161554: 'aurora'\n};\nexport let ExplorerTXType;\n\n(function (ExplorerTXType) {\n  ExplorerTXType[ExplorerTXType[\"Account\"] = 0] = \"Account\";\n  ExplorerTXType[ExplorerTXType[\"TokenBalance\"] = 1] = \"TokenBalance\";\n  ExplorerTXType[ExplorerTXType[\"Transaction\"] = 2] = \"Transaction\";\n  ExplorerTXType[ExplorerTXType[\"Token\"] = 3] = \"Token\";\n})(ExplorerTXType || (ExplorerTXType = {}));\n\nexport const EXPLORER_PREFIXES = {\n  1: 'etherscan.io',\n  3: 'ropsten.etherscan.io',\n  4: 'rinkeby.etherscan.io',\n  5: 'goerli.',\n  42: 'kovan.',\n  80001: 'mumbai-explorer.matic.today',\n  137: 'polygonscan.com',\n  97: 'bnbsc',\n  100: 'blockscout.com/xdai/mainnet',\n  56: 'bscscan.com',\n  250: 'ftmscan.com',\n  1313161554: 'aurorascan.dev'\n};\nexport const NETWORK_SHORTNAMES = {\n  1: 'eth',\n  3: 'ropsten',\n  4: 'rinkeby',\n  5: 'goerli',\n  42: 'kovan',\n  80001: 'mumbai',\n  137: 'matic',\n  97: 'bsctest',\n  100: 'xdai',\n  56: 'bsc',\n  250: 'fantom',\n  1313161554: 'aurora'\n};\nexport function formatEtherscanLink(type, data) {\n  switch (type) {\n    case ExplorerTXType.Account:\n      {\n        const [chainId, address] = data;\n        return `https://${EXPLORER_PREFIXES[chainId]}/address/${address}`;\n      }\n\n    case ExplorerTXType.TokenBalance:\n      {\n        const [token, address] = data;\n        return `https://${EXPLORER_PREFIXES[token.chainId]}/token/${token.address}?a=${address}`;\n      }\n\n    case ExplorerTXType.Transaction:\n      {\n        const [chainId, hash] = data;\n        return `https://${EXPLORER_PREFIXES[chainId]}/tx/${hash}`;\n      }\n\n    case ExplorerTXType.Token:\n      {\n        const [chainId, hash] = data;\n        return `https://${EXPLORER_PREFIXES[chainId]}/token/${hash}`;\n      }\n  }\n}\nconst SAI = new Token(ChainId.MAINNET, '0x89d24A6b4CcB1B6fAA2625fE562bDD9a23260359', 18);\nexport function getTokenDisplayValue(token) {\n  var _token$symbol;\n\n  return token.equals(WETH[token.chainId]) ? 'ETH' : token.equals(SAI) ? 'SAI' : (_token$symbol = token.symbol) !== null && _token$symbol !== void 0 ? _token$symbol : 'UNKNOWN';\n}\nexport function getPercentChange(referenceRate, newRate, flipOrder = false) {\n  // calculate (referenceRate - newRate) / referenceRate or (newRate - referenceRate) / referenceRate\n  const difference = new Fraction(flipOrder ? JSBI.subtract(JSBI.multiply(newRate.adjusted.numerator, referenceRate.adjusted.denominator), JSBI.multiply(referenceRate.adjusted.numerator, newRate.adjusted.denominator)) : JSBI.subtract(JSBI.multiply(referenceRate.adjusted.numerator, newRate.adjusted.denominator), JSBI.multiply(newRate.adjusted.numerator, referenceRate.adjusted.denominator)), JSBI.multiply(referenceRate.adjusted.denominator, newRate.adjusted.denominator));\n  const percentChange = difference.multiply(referenceRate.adjusted.invert());\n  return new Percent(percentChange.numerator, percentChange.denominator);\n}\nexport function modifyUrlObjectForIPFS(url) {\n  const parsedUrl = typeof url === 'string' ? {\n    pathname: url\n  } : url;\n\n  const {\n    pathname\n  } = parsedUrl,\n        rest = _objectWithoutProperties(parsedUrl, [\"pathname\"]);\n\n  const modifiedPathname = pathname === '/' ? './' : `.${pathname}${isIPFS ? '.html' : ''}`;\n  return {\n    href: parsedUrl,\n    as: _objectSpread(_objectSpread({}, rest), {}, {\n      pathname: modifiedPathname\n    })\n  };\n}\nexport function validImage(data) {\n  if (data && (data.includes('http') || data.includes('data:image'))) {\n    return true;\n  } else {\n    return false;\n  }\n}\nexport function isETHAddress(address) {\n  return isAddress(address);\n}\nexport function toContractValue(amount, decimal) {\n  return toWei(amount, decimal);\n}\nexport function fromContractValue(amount, decimal) {\n  return Number(fromWei(amount, decimal));\n}","map":null,"metadata":{},"sourceType":"module"}