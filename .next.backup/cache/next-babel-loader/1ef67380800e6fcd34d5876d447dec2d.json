{"ast":null,"code":"var _jsxFileName = \"/Users/shannoncode/repo/Emblem.Currentwork/emblem-vault-site/components/Swap.tsx\";\nimport React from \"react\";\nvar __jsx = React.createElement;\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport { useReducer, useState, useEffect } from 'react';\nimport { useRouter } from 'next/router';\nimport Link from 'next/link';\nimport { useWeb3React } from '@web3-react/core';\nimport { parseUnits } from '@ethersproject/units';\nimport { Contract } from '@ethersproject/contracts';\nimport { BigNumber } from '@ethersproject/bignumber';\nimport { TradeType, TokenAmount, JSBI, WETH, Percent } from '@uniswap/sdk';\nimport { hexDataSlice } from '@ethersproject/bytes';\nimport { id } from '@ethersproject/hash';\nimport { defaultAbiCoder } from '@ethersproject/abi';\nimport IERC20 from '@uniswap/v2-core/build/IERC20.json';\nimport { abi as IUniswapV2Router02ABI } from '@uniswap/v2-periphery/build/IUniswapV2Router02.json';\nimport { Stack, Button, Text } from '@chakra-ui/core';\nimport AmountInput from '../components/AmountInput';\nimport TokenSelect from '../components/TokenSelect';\nimport { useTokenByAddressAndAutomaticallyAdd } from '../tokens';\nimport { useRoute, useContract, useQueryParameters, useTrade, useUSDTokenPrice } from '../hooks';\nimport { useTokenBalance, useTokenAllowance, useETHBalance } from '../data';\nimport { ROUTER_ADDRESS, ZERO, MAX_UINT256, QueryParameters, PERMIT_AND_CALL_ADDRESS, GAS_LIMIT_WHEN_MOCKING } from '../constants';\nimport { useSlippage, useDeadline, useApproveMax, useTransactions, useFirstToken, useSecondToken, useShowUSD } from '../context';\nimport TradeSummary from '../components/TradeSummary';\nimport { canPermit, gatherPermit } from '../permits';\nimport { modifyUrlObjectForIPFS } from '../utils';\nvar Field;\n\n(function (Field) {\n  Field[Field[\"INPUT\"] = 0] = \"INPUT\";\n  Field[Field[\"OUTPUT\"] = 1] = \"OUTPUT\";\n})(Field || (Field = {}));\n\nfunction initializeSentenceState(partialState) {\n  var _partialState$Field$I, _partialState$Field$O;\n\n  return {\n    independentField: partialState.independentField,\n    value: '',\n    [Field.INPUT]: {\n      address: (_partialState$Field$I = partialState[Field.INPUT]) === null || _partialState$Field$I === void 0 ? void 0 : _partialState$Field$I.address\n    },\n    [Field.OUTPUT]: {\n      address: (_partialState$Field$O = partialState[Field.OUTPUT]) === null || _partialState$Field$O === void 0 ? void 0 : _partialState$Field$O.address\n    }\n  };\n}\n\nvar ActionType;\n\n(function (ActionType) {\n  ActionType[ActionType[\"SELECT_TOKEN\"] = 0] = \"SELECT_TOKEN\";\n  ActionType[ActionType[\"TYPE\"] = 1] = \"TYPE\";\n  ActionType[ActionType[\"RESET\"] = 2] = \"RESET\";\n})(ActionType || (ActionType = {}));\n\nfunction reducer(state, action) {\n  switch (action.type) {\n    case ActionType.SELECT_TOKEN:\n      {\n        const {\n          field,\n          address\n        } = action.payload;\n\n        if (!!address && address === state[field === Field.INPUT ? Field.OUTPUT : Field.INPUT].address) {\n          return _objectSpread(_objectSpread({}, state), {}, {\n            value: '',\n            [Field.INPUT]: state[Field.OUTPUT],\n            [Field.OUTPUT]: state[Field.INPUT]\n          });\n        } else {\n          return _objectSpread(_objectSpread({}, state), {}, {\n            [field]: {\n              address\n            }\n          });\n        }\n      }\n\n    case ActionType.TYPE:\n      {\n        const {\n          field,\n          value\n        } = action.payload;\n        return _objectSpread(_objectSpread({}, state), {}, {\n          independentField: field,\n          value\n        });\n      }\n\n    case ActionType.RESET:\n      {\n        const {\n          field\n        } = action.payload;\n        return initializeSentenceState({\n          independentField: field\n        });\n      }\n  }\n}\n\nfunction SwapText(_ref) {\n  let {\n    children\n  } = _ref,\n      rest = _objectWithoutProperties(_ref, [\"children\"]);\n\n  return __jsx(Text, _extends({\n    fontSize: \"3xl\",\n    lineHeight: 1,\n    py: \"0.3rem\"\n  }, rest, {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 138,\n      columnNumber: 5\n    }\n  }), children);\n}\n\nexport default function Swap({\n  buy\n}) {\n  var _tokens$Field$INPUT, _tokens$Field$INPUT2, _ref2, _tokens$Field$INPUT3, _formatted$Field$INPU, _tokens$Field$INPUT4, _tokens$Field$INPUT5, _tokens$Field$INPUT6, _tokens$Field$OUTPUT, _tokens$Field$OUTPUT2;\n\n  const {\n    query,\n    pathname,\n    replace\n  } = useRouter();\n  const queryParameters = useQueryParameters();\n  const {\n    account,\n    chainId,\n    library\n  } = useWeb3React();\n  const [approveMax] = useApproveMax();\n  const [deadlineDelta] = useDeadline();\n  const [slippage] = useSlippage();\n  const [, {\n    addTransaction\n  }] = useTransactions(); // reducer state\n\n  const {\n    0: state,\n    1: dispatch\n  } = useReducer(reducer, {\n    independentField: buy ? Field.OUTPUT : Field.INPUT,\n    [Field.INPUT]: {\n      address: queryParameters[QueryParameters.INPUT]\n    },\n    [Field.OUTPUT]: {\n      address: queryParameters[QueryParameters.OUTPUT]\n    }\n  }, initializeSentenceState);\n\n  const {\n    independentField,\n    value\n  } = state,\n        tokenAddresses = _objectWithoutProperties(state, [\"independentField\", \"value\"]); // derived state\n\n\n  const dependentField = independentField === Field.INPUT ? Field.OUTPUT : Field.INPUT;\n  const tradeType = independentField === Field.INPUT ? TradeType.EXACT_INPUT : TradeType.EXACT_OUTPUT; // sdk tokens\n\n  const tokens = {\n    [Field.INPUT]: useTokenByAddressAndAutomaticallyAdd(tokenAddresses[Field.INPUT].address),\n    [Field.OUTPUT]: useTokenByAddressAndAutomaticallyAdd(tokenAddresses[Field.OUTPUT].address)\n  }; // keep global token state in sync\n\n  const [, setFirstToken] = useFirstToken();\n  const [, setSecondToken] = useSecondToken();\n  useEffect(() => {\n    setFirstToken(tokens[buy ? Field.OUTPUT : Field.INPUT]);\n    setSecondToken(tokens[buy ? Field.INPUT : Field.OUTPUT]);\n  }); // sdk route\n\n  const [naiveRoute, allPairs] = useRoute(tokens[Field.INPUT], tokens[Field.OUTPUT]); // parse user value\n\n  const parsed = {};\n\n  if (value !== '' && value !== '.' && tokens[independentField]) {\n    try {\n      var _tokens$independentFi;\n\n      const valueParsed = parseUnits(value, (_tokens$independentFi = tokens[independentField]) === null || _tokens$independentFi === void 0 ? void 0 : _tokens$independentFi.decimals).toString();\n\n      if (valueParsed !== '0') {\n        parsed[independentField] = new TokenAmount(tokens[independentField], valueParsed);\n      }\n    } catch {// should only fail if the user specifies too many decimal places of precision (or maybe exceed max uint?)\n    }\n  } // sdk trade\n\n\n  const trade = useTrade(tokens[Field.INPUT], tokens[Field.OUTPUT], allPairs, parsed[independentField], tradeType);\n  const route = trade ? trade.route : naiveRoute; // populate the parsed dependent field\n\n  if (trade) {\n    if (tradeType === TradeType.EXACT_INPUT) {\n      parsed[dependentField] = trade.minimumAmountOut(new Percent(`${slippage}`, `${10000}`));\n    } else {\n      parsed[dependentField] = trade.maximumAmountIn(new Percent(`${slippage}`, `${10000}`));\n    }\n  } // usd values\n\n\n  const [showUSD] = useShowUSD();\n  const USDPrices = {\n    [Field.INPUT]: useUSDTokenPrice(tokens[Field.INPUT]),\n    [Field.OUTPUT]: useUSDTokenPrice(tokens[Field.OUTPUT])\n  };\n  const USDAmountsFormatted = {\n    [Field.INPUT]: parsed[Field.INPUT] && USDPrices[Field.INPUT] ? parsed[Field.INPUT].multiply(USDPrices[Field.INPUT]).toFixed(2, {\n      groupSeparator: ','\n    }) : undefined,\n    [Field.OUTPUT]: parsed[Field.OUTPUT] && USDPrices[Field.OUTPUT] ? parsed[Field.OUTPUT].multiply(USDPrices[Field.OUTPUT]).toFixed(2, {\n      groupSeparator: ','\n    }) : undefined\n  }; // calculate the formatted values from the parsed\n\n  const formatted = {\n    [independentField]: value,\n    [dependentField]: parsed[dependentField] ? parsed[dependentField].toSignificant(4, {\n      groupSeparator: ','\n    }) : ''\n  }; // reset when the network changes\n\n  useEffect(() => {\n    if (typeof chainId === 'number') {\n      return () => {\n        dispatch({\n          type: ActionType.RESET,\n          payload: {\n            field: buy ? Field.OUTPUT : Field.INPUT\n          }\n        });\n      };\n    }\n  }, [chainId, buy]); // clear url params\n\n  useEffect(() => {\n    if (Object.keys(query).length > 0) {\n      const {\n        href,\n        as\n      } = modifyUrlObjectForIPFS(pathname);\n      replace(href, as, {\n        shallow: true\n      });\n    }\n  }); // get input allowance for validation purposes\n\n  const {\n    data: _allowance\n  } = useTokenAllowance(tokens[Field.INPUT], account, ROUTER_ADDRESS);\n  const allowance = ((_tokens$Field$INPUT = tokens[Field.INPUT]) === null || _tokens$Field$INPUT === void 0 ? void 0 : _tokens$Field$INPUT.equals(WETH[tokens[Field.INPUT].chainId])) ? new TokenAmount(WETH[tokens[Field.INPUT].chainId], MAX_UINT256) : _allowance; // get permitAndCall allowance if the input token supports permit\n\n  const {\n    data: permitAndCallAllowance\n  } = useTokenAllowance(canPermit(tokens[Field.INPUT]) ? tokens[Field.INPUT] : undefined, account, PERMIT_AND_CALL_ADDRESS); // get input balance for validation purposes\n\n  const ETHBalance = useETHBalance(account);\n\n  const _balance = useTokenBalance(tokens[Field.INPUT], account);\n\n  const balance = ((_tokens$Field$INPUT2 = tokens[Field.INPUT]) === null || _tokens$Field$INPUT2 === void 0 ? void 0 : _tokens$Field$INPUT2.equals(WETH[(_ref2 = tokens[Field.INPUT]) === null || _ref2 === void 0 ? void 0 : _ref2.chainId])) ? ETHBalance.data : _balance.data; // compute flags for warning states\n\n  const warning = !!trade && Number.parseFloat(trade.slippage.toSignificant(2)) >= 5;\n  const danger = !!trade && Number.parseFloat(trade.slippage.toSignificant(2)) >= 10; // compute validation flags\n\n  const isInvalidBalance = parsed[Field.INPUT] && balance ? JSBI.greaterThan(parsed[Field.INPUT].raw, balance.raw) : false;\n  const isInvalidRoute = route === null && value.length > 0;\n  const isInvalidTrade = route && parsed[independentField] ? !!!trade : false; // compute flag for whether maxing is allowed\n\n  const canMax = !((_tokens$Field$INPUT3 = tokens[Field.INPUT]) === null || _tokens$Field$INPUT3 === void 0 ? void 0 : _tokens$Field$INPUT3.equals(WETH[tokens[Field.INPUT].chainId])) && !isInvalidRoute && ((_formatted$Field$INPU = formatted[Field.INPUT]) === null || _formatted$Field$INPU === void 0 ? void 0 : _formatted$Field$INPU.length) === 0 && !!balance && JSBI.greaterThan(balance.raw, ZERO); // function to perform the swap\n\n  const {\n    0: swapping,\n    1: setSwapping\n  } = useState(false);\n  const inputToken = useContract((_tokens$Field$INPUT4 = tokens[Field.INPUT]) === null || _tokens$Field$INPUT4 === void 0 ? void 0 : _tokens$Field$INPUT4.address, IERC20.abi, true);\n  const router = useContract(ROUTER_ADDRESS, IUniswapV2Router02ABI, true);\n\n  async function swap() {\n    setSwapping(true);\n\n    async function innerSwap(deadline, mockGas = false, permit) {\n      let routerFunctionNames;\n      let routerArguments; // eslint-disable-line @typescript-eslint/no-explicit-any\n\n      let value = 0;\n\n      if ((trade === null || trade === void 0 ? void 0 : trade.tradeType) === TradeType.EXACT_INPUT) {\n        if (tokens[Field.INPUT].equals(WETH[tokens[Field.INPUT].chainId])) {\n          routerFunctionNames = ['swapExactETHForTokens', 'swapExactETHForTokensSupportingFeeOnTransferTokens'];\n          routerArguments = [`0x${parsed[Field.OUTPUT].raw.toString(16)}`, route.path.map(token => token.address), account, deadline];\n          value = `0x${parsed[Field.INPUT].raw.toString(16)}`;\n        } else if (tokens[Field.OUTPUT].equals(WETH[tokens[Field.OUTPUT].chainId])) {\n          routerFunctionNames = ['swapExactTokensForETH', 'swapExactTokensForETHSupportingFeeOnTransferTokens'];\n          routerArguments = [`0x${parsed[Field.INPUT].raw.toString(16)}`, `0x${parsed[Field.OUTPUT].raw.toString(16)}`, route.path.map(token => token.address), account, deadline];\n        } else {\n          routerFunctionNames = ['swapExactTokensForTokens', 'swapExactTokensForTokensSupportingFeeOnTransferTokens'];\n          routerArguments = [`0x${parsed[Field.INPUT].raw.toString(16)}`, `0x${parsed[Field.OUTPUT].raw.toString(16)}`, route.path.map(token => token.address), account, deadline];\n        }\n      } else {\n        if (tokens[Field.INPUT].equals(WETH[tokens[Field.INPUT].chainId])) {\n          routerFunctionNames = ['swapETHForExactTokens'];\n          routerArguments = [`0x${parsed[Field.OUTPUT].raw.toString(16)}`, route.path.map(token => token.address), account, deadline];\n          value = `0x${parsed[Field.INPUT].raw.toString(16)}`;\n        } else if (tokens[Field.OUTPUT].equals(WETH[tokens[Field.OUTPUT].chainId])) {\n          routerFunctionNames = ['swapTokensForExactETH'];\n          routerArguments = [`0x${parsed[Field.OUTPUT].raw.toString(16)}`, `0x${parsed[Field.INPUT].raw.toString(16)}`, route.path.map(token => token.address), account, deadline];\n        } else {\n          routerFunctionNames = ['swapTokensForExactTokens'];\n          routerArguments = [`0x${parsed[Field.OUTPUT].raw.toString(16)}`, `0x${parsed[Field.INPUT].raw.toString(16)}`, route.path.map(token => token.address), account, deadline];\n        }\n      } // we have an approve tx pending\n\n\n      if (mockGas) {\n        // because we can't estimate gas, as it will fail b/c of the approve, we are forced to use the first function\n        const routerFunctionName = routerFunctionNames[0];\n        return await router[routerFunctionName](...routerArguments, {\n          value,\n          gasLimit: GAS_LIMIT_WHEN_MOCKING\n        }).catch(error => {\n          if ((error === null || error === void 0 ? void 0 : error.code) !== 4001) {\n            console.log(`${routerFunctionName} failed with a mocked gas limit.`, error);\n          }\n\n          throw error;\n        });\n      } // we have permit data\n\n\n      if (permit) {\n        const permitAndCall = new Contract(PERMIT_AND_CALL_ADDRESS, ['function permitAndCall(address token, uint256 value, bytes4 permitSelector, bytes calldata permitData, bytes4 routerFunctionSelector, bytes calldata routerFunctionData)'], library.getSigner(account).connectUnchecked()); // try to get a gas limit for each function name in turn\n\n        for (const routerFunctionName of routerFunctionNames) {\n          const routerFunctionFragment = router.interface.fragments.filter(({\n            name\n          }) => name === routerFunctionName)[0];\n          const routerFunctionSelector = hexDataSlice(id(`${routerFunctionName}(${routerFunctionFragment === null || routerFunctionFragment === void 0 ? void 0 : routerFunctionFragment.inputs.map(({\n            type\n          }) => type).join(',')})`), 0, 4);\n          const permitAndCallArguments = [tokens[Field.INPUT].address, `0x${parsed[Field.INPUT].raw.toString(16)}`, permit.permitSelector, permit.permitData, routerFunctionSelector, defaultAbiCoder.encode(routerFunctionFragment.inputs, routerArguments)];\n          const gasLimit = await permitAndCall.estimateGas.permitAndCall(...permitAndCallArguments, {\n            value\n          }).then(gasLimit => gasLimit.mul(105).div(100)).catch(error => {\n            console.log(`estimateGas failed for ${routerFunctionName} via permitAndCall.`, error);\n          });\n\n          if (BigNumber.isBigNumber(gasLimit)) {\n            return await permitAndCall.permitAndCall(...permitAndCallArguments, {\n              value,\n              gasLimit\n            }).catch(error => {\n              if ((error === null || error === void 0 ? void 0 : error.code) !== 4001) {\n                console.log(`${routerFunctionName} failed via permitAndCall.`, error);\n              }\n\n              throw error;\n            });\n          }\n        } // if we're here, it means all estimateGas calls failed\n\n\n        console.log(routerFunctionNames.length === 1 ? \"If you're trying to swap a token that takes a transfer fee, you must specify an exact input amount.\" : \"If you're trying to swap a token that takes a transfer fee, ensure your slippage tolerance is higher than the fee.\");\n        throw Error();\n      } // try to get a gas limit for each function name in turn\n\n\n      for (const routerFunctionName of routerFunctionNames) {\n        const gasLimit = await router.estimateGas[routerFunctionName](...routerArguments, {\n          value\n        }).then(gasLimit => gasLimit.mul(105).div(100)).catch(error => {\n          console.log(`estimateGas failed for ${routerFunctionName}.`, error);\n        });\n\n        if (BigNumber.isBigNumber(gasLimit)) {\n          return await router[routerFunctionName](...routerArguments, {\n            value,\n            gasLimit\n          }).catch(error => {\n            if ((error === null || error === void 0 ? void 0 : error.code) !== 4001) {\n              console.log(`${routerFunctionName} failed.`, error);\n            }\n\n            throw error;\n          });\n        }\n      } // if we're here, it means all estimateGas calls failed\n\n\n      console.log(routerFunctionNames.length === 1 ? \"If you're trying to swap a token that takes a transfer fee, you must specify an exact input amount.\" : \"If you're trying to swap a token that takes a transfer fee, ensure your slippage tolerance is higher than the fee.\");\n      throw Error();\n    }\n\n    const deadline = Math.floor(Date.now() / 1000) + deadlineDelta;\n    let approved = JSBI.greaterThanOrEqual(allowance.raw, parsed[Field.INPUT].raw);\n    let mockGas = false;\n    let permit;\n\n    if (!approved) {\n      let tryToManuallyApprove = true; // attempt to gather a permit signature where possible\n\n      if (canPermit(tokens[Field.INPUT])) {\n        // in the slightly weird case where the user has already approved PermitAndCall, just fake the permit\n        if (permitAndCallAllowance && JSBI.greaterThanOrEqual(permitAndCallAllowance.raw, parsed[Field.INPUT].raw)) {\n          approved = true;\n          tryToManuallyApprove = false;\n          permit = {\n            permitSelector: '0x00000000',\n            permitData: '0x'\n          };\n        } else {\n          await gatherPermit(account, deadline, approveMax, tokens[Field.INPUT], library).then(gatheredPermit => {\n            approved = true;\n            tryToManuallyApprove = false;\n            permit = gatheredPermit;\n          }).catch(error => {\n            // if the error code is 4001 (EIP-1193 user rejected request), we don't want to try a manual approve\n            if ((error === null || error === void 0 ? void 0 : error.code) === 4001) {\n              tryToManuallyApprove = false;\n            } else {\n              console.log(`permit failed.`, error);\n            }\n          });\n        }\n      }\n\n      if (tryToManuallyApprove) {\n        await inputToken.approve(ROUTER_ADDRESS, `0x${(approveMax ? MAX_UINT256 : parsed[Field.INPUT].raw).toString(16)}`).then(({\n          hash\n        }) => {\n          addTransaction(chainId, hash);\n          approved = true;\n          mockGas = true;\n        }).catch(error => {\n          if ((error === null || error === void 0 ? void 0 : error.code) !== 4001) {\n            console.log(`approve failed.`, error);\n          }\n        });\n      }\n    }\n\n    if (approved) {\n      return innerSwap(deadline, mockGas, permit).then(({\n        hash\n      }) => {\n        addTransaction(chainId, hash);\n        dispatch({\n          type: ActionType.TYPE,\n          payload: {\n            field: independentField,\n            value: ''\n          }\n        });\n        setSwapping(false);\n      }) // we don't do anything with the error here, innerSwap is responsible for handling it\n      .catch(() => {\n        setSwapping(false);\n      });\n    } else {\n      setSwapping(false);\n    }\n  }\n\n  return __jsx(Stack, {\n    direction: \"column\",\n    align: \"center\",\n    spacing: \"6rem\",\n    flexGrow: 1,\n    justifyContent: \"center\",\n    px: \"2.5rem\",\n    py: \"8rem\",\n    shouldWrapChildren: true,\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 549,\n      columnNumber: 5\n    }\n  }, __jsx(Stack, {\n    direction: \"row\",\n    align: \"flex-start\",\n    spacing: \"1rem\",\n    flexWrap: \"wrap\",\n    shouldWrapChildren: true,\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 559,\n      columnNumber: 7\n    }\n  }, __jsx(SwapText, {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 560,\n      columnNumber: 9\n    }\n  }, \"I want to\"), !!!trade ? __jsx(Link, _extends({}, modifyUrlObjectForIPFS({\n    pathname: buy ? '/sell' : '/buy',\n    query: _objectSpread(_objectSpread({}, ((_tokens$Field$INPUT5 = tokens[Field.INPUT]) === null || _tokens$Field$INPUT5 === void 0 ? void 0 : _tokens$Field$INPUT5.address) ? {\n      [QueryParameters.INPUT]: (_tokens$Field$INPUT6 = tokens[Field.INPUT]) === null || _tokens$Field$INPUT6 === void 0 ? void 0 : _tokens$Field$INPUT6.address\n    } : {}), ((_tokens$Field$OUTPUT = tokens[Field.OUTPUT]) === null || _tokens$Field$OUTPUT === void 0 ? void 0 : _tokens$Field$OUTPUT.address) ? {\n      [QueryParameters.OUTPUT]: (_tokens$Field$OUTPUT2 = tokens[Field.OUTPUT]) === null || _tokens$Field$OUTPUT2 === void 0 ? void 0 : _tokens$Field$OUTPUT2.address\n    } : {})\n  }), {\n    passHref: true,\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 563,\n      columnNumber: 11\n    }\n  }), __jsx(Button, {\n    as: \"a\",\n    variant: \"ghost\",\n    variantColor: buy ? 'green' : 'red',\n    p: \"0.5rem\",\n    mt: \"-0.2rem\",\n    fontSize: \"3xl\",\n    lineHeight: 1,\n    height: \"min-content\",\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 573,\n      columnNumber: 13\n    }\n  }, buy ? 'Buy' : 'Sell')) : __jsx(Button, {\n    variant: \"solid\",\n    variantColor: !warning ? buy ? 'green' : 'red' : 'yellow',\n    p: \"0.75rem\",\n    mt: \"-0.45rem\",\n    fontSize: \"3xl\",\n    lineHeight: 1,\n    height: \"min-content\",\n    leftIcon: !warning ? undefined : !danger ? 'warning-2' : 'not-allowed',\n    isDisabled: !account || isInvalidBalance || isInvalidTrade,\n    isLoading: swapping,\n    cursor: warning ? 'not-allowed' : 'pointer',\n    onClick: swap,\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 587,\n      columnNumber: 11\n    }\n  }, buy ? 'Buy' : 'Sell'), trade && independentField === (buy ? Field.INPUT : Field.OUTPUT) ? __jsx(SwapText, {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 606,\n      columnNumber: 11\n    }\n  }, buy ? 'at least' : 'at most') : null, __jsx(AmountInput, {\n    controlled: independentField === (buy ? Field.OUTPUT : Field.INPUT),\n    isDisabled: showUSD || swapping,\n    isInvalid: isInvalidTrade || !buy && isInvalidBalance,\n    value: showUSD && USDAmountsFormatted[buy ? Field.OUTPUT : Field.INPUT] ? `$${USDAmountsFormatted[buy ? Field.OUTPUT : Field.INPUT]}` : formatted[buy ? Field.OUTPUT : Field.INPUT],\n    onChange: value => {\n      dispatch({\n        type: ActionType.TYPE,\n        payload: {\n          field: buy ? Field.OUTPUT : Field.INPUT,\n          value\n        }\n      });\n    },\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 609,\n      columnNumber: 9\n    }\n  }), !buy && canMax ? __jsx(Button, {\n    size: \"sm\",\n    mt: \"0.3rem\",\n    onClick: () => {\n      dispatch({\n        type: ActionType.TYPE,\n        payload: {\n          field: Field.INPUT,\n          value: balance === null || balance === void 0 ? void 0 : balance.toExact()\n        }\n      });\n    },\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 627,\n      columnNumber: 11\n    }\n  }, \"Max\") : null, __jsx(TokenSelect, {\n    tokenAddress: tokenAddresses[buy ? Field.OUTPUT : Field.INPUT].address,\n    isInvalid: isInvalidRoute,\n    isDisabled: swapping,\n    onAddressSelect: address => {\n      dispatch({\n        type: ActionType.SELECT_TOKEN,\n        payload: {\n          field: buy ? Field.OUTPUT : Field.INPUT,\n          address\n        }\n      });\n    },\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 641,\n      columnNumber: 9\n    }\n  }), __jsx(SwapText, {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 653,\n      columnNumber: 9\n    }\n  }, buy ? 'with' : 'for', trade && independentField === (buy ? Field.OUTPUT : Field.INPUT) ? buy ? ' at most' : ' at least' : ''), __jsx(AmountInput, {\n    controlled: independentField === (buy ? Field.INPUT : Field.OUTPUT),\n    isDisabled: showUSD || swapping,\n    isInvalid: isInvalidTrade || buy && isInvalidBalance,\n    value: showUSD && USDAmountsFormatted[buy ? Field.INPUT : Field.OUTPUT] ? `$${USDAmountsFormatted[buy ? Field.INPUT : Field.OUTPUT]}` : formatted[buy ? Field.INPUT : Field.OUTPUT],\n    onChange: value => {\n      dispatch({\n        type: ActionType.TYPE,\n        payload: {\n          field: buy ? Field.INPUT : Field.OUTPUT,\n          value\n        }\n      });\n    },\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 658,\n      columnNumber: 9\n    }\n  }), buy && canMax ? __jsx(Button, {\n    size: \"sm\",\n    mt: \"0.3rem\",\n    onClick: () => {\n      dispatch({\n        type: ActionType.TYPE,\n        payload: {\n          field: Field.INPUT,\n          value: balance === null || balance === void 0 ? void 0 : balance.toExact()\n        }\n      });\n    },\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 676,\n      columnNumber: 11\n    }\n  }, \"Max\") : null, __jsx(TokenSelect, {\n    tokenAddress: tokenAddresses[buy ? Field.INPUT : Field.OUTPUT].address,\n    isInvalid: isInvalidRoute,\n    isDisabled: swapping,\n    onAddressSelect: address => {\n      dispatch({\n        type: ActionType.SELECT_TOKEN,\n        payload: {\n          field: buy ? Field.INPUT : Field.OUTPUT,\n          address\n        }\n      });\n    },\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 690,\n      columnNumber: 9\n    }\n  }), __jsx(SwapText, {\n    fontSize: \"3xl\",\n    lineHeight: 1,\n    pt: \"0.3rem\",\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 702,\n      columnNumber: 9\n    }\n  }, \".\")), __jsx(TradeSummary, {\n    route: route,\n    trade: trade,\n    warning: warning,\n    danger: danger,\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 707,\n      columnNumber: 7\n    }\n  }));\n}","map":{"version":3,"sources":["/Users/shannoncode/repo/Emblem.Currentwork/emblem-vault-site/components/Swap.tsx"],"names":["useReducer","useState","useEffect","useRouter","Link","useWeb3React","parseUnits","Contract","BigNumber","TradeType","TokenAmount","JSBI","WETH","Percent","hexDataSlice","id","defaultAbiCoder","IERC20","abi","IUniswapV2Router02ABI","Stack","Button","Text","AmountInput","TokenSelect","useTokenByAddressAndAutomaticallyAdd","useRoute","useContract","useQueryParameters","useTrade","useUSDTokenPrice","useTokenBalance","useTokenAllowance","useETHBalance","ROUTER_ADDRESS","ZERO","MAX_UINT256","QueryParameters","PERMIT_AND_CALL_ADDRESS","GAS_LIMIT_WHEN_MOCKING","useSlippage","useDeadline","useApproveMax","useTransactions","useFirstToken","useSecondToken","useShowUSD","TradeSummary","canPermit","gatherPermit","modifyUrlObjectForIPFS","Field","initializeSentenceState","partialState","independentField","value","INPUT","address","OUTPUT","ActionType","reducer","state","action","type","SELECT_TOKEN","field","payload","TYPE","RESET","SwapText","children","rest","Swap","buy","query","pathname","replace","queryParameters","account","chainId","library","approveMax","deadlineDelta","slippage","addTransaction","dispatch","tokenAddresses","dependentField","tradeType","EXACT_INPUT","EXACT_OUTPUT","tokens","setFirstToken","setSecondToken","naiveRoute","allPairs","parsed","valueParsed","decimals","toString","trade","route","minimumAmountOut","maximumAmountIn","showUSD","USDPrices","USDAmountsFormatted","multiply","toFixed","groupSeparator","undefined","formatted","toSignificant","Object","keys","length","href","as","shallow","data","_allowance","allowance","equals","permitAndCallAllowance","ETHBalance","_balance","balance","warning","Number","parseFloat","danger","isInvalidBalance","greaterThan","raw","isInvalidRoute","isInvalidTrade","canMax","swapping","setSwapping","inputToken","router","swap","innerSwap","deadline","mockGas","permit","routerFunctionNames","routerArguments","path","map","token","routerFunctionName","gasLimit","catch","error","code","console","log","permitAndCall","getSigner","connectUnchecked","routerFunctionFragment","interface","fragments","filter","name","routerFunctionSelector","inputs","join","permitAndCallArguments","permitSelector","permitData","encode","estimateGas","then","mul","div","isBigNumber","Error","Math","floor","Date","now","approved","greaterThanOrEqual","tryToManuallyApprove","gatheredPermit","approve","hash","toExact"],"mappings":"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","sourcesContent":["import { useReducer, useState, useEffect } from 'react'\nimport { useRouter } from 'next/router'\nimport Link from 'next/link'\nimport { useWeb3React } from '@web3-react/core'\nimport { parseUnits } from '@ethersproject/units'\nimport { PayableOverrides, Contract } from '@ethersproject/contracts'\nimport { BigNumber } from '@ethersproject/bignumber'\nimport { TradeType, TokenAmount, JSBI, WETH, Percent, Token, Route, Fraction } from '@uniswap/sdk'\nimport { hexDataSlice } from '@ethersproject/bytes'\nimport { id } from '@ethersproject/hash'\nimport { defaultAbiCoder } from '@ethersproject/abi'\nimport IERC20 from '@uniswap/v2-core/build/IERC20.json'\nimport { abi as IUniswapV2Router02ABI } from '@uniswap/v2-periphery/build/IUniswapV2Router02.json'\nimport { Stack, Button, Text, BoxProps } from '@chakra-ui/core'\n\nimport AmountInput from '../components/AmountInput'\nimport TokenSelect from '../components/TokenSelect'\nimport { useTokenByAddressAndAutomaticallyAdd } from '../tokens'\nimport { useRoute, useContract, useQueryParameters, useTrade, useUSDTokenPrice } from '../hooks'\nimport { useTokenBalance, useTokenAllowance, useETHBalance } from '../data'\nimport {\n  ROUTER_ADDRESS,\n  ZERO,\n  MAX_UINT256,\n  QueryParameters,\n  PERMIT_AND_CALL_ADDRESS,\n  GAS_LIMIT_WHEN_MOCKING,\n} from '../constants'\nimport {\n  useSlippage,\n  useDeadline,\n  useApproveMax,\n  useTransactions,\n  useFirstToken,\n  useSecondToken,\n  useShowUSD,\n} from '../context'\nimport TradeSummary from '../components/TradeSummary'\nimport { canPermit, gatherPermit, Permit } from '../permits'\nimport { modifyUrlObjectForIPFS } from '../utils'\n\ninterface ErrorWithCode extends Error {\n  code?: number\n}\n\nenum Field {\n  INPUT,\n  OUTPUT,\n}\n\ninterface SentenceState {\n  independentField: Field\n  value: string\n  [Field.INPUT]: {\n    address: string | undefined\n  }\n  [Field.OUTPUT]: {\n    address: string | undefined\n  }\n}\n\nfunction initializeSentenceState(\n  partialState: Pick<SentenceState, 'independentField'> & Partial<Pick<SentenceState, Field.INPUT | Field.OUTPUT>>\n): SentenceState {\n  return {\n    independentField: partialState.independentField,\n    value: '',\n    [Field.INPUT]: {\n      address: partialState[Field.INPUT]?.address,\n    },\n    [Field.OUTPUT]: {\n      address: partialState[Field.OUTPUT]?.address,\n    },\n  }\n}\n\nenum ActionType {\n  SELECT_TOKEN,\n  TYPE,\n  RESET,\n}\n\ninterface ActionPayload {\n  [ActionType.SELECT_TOKEN]: {\n    field: Field\n    address: string\n  }\n  [ActionType.TYPE]: {\n    field: Field\n    value: string\n  }\n  [ActionType.RESET]: {\n    field: Field\n  }\n}\n\nfunction reducer(\n  state: SentenceState,\n  action: {\n    type: ActionType\n    payload: ActionPayload[ActionType]\n  }\n): SentenceState {\n  switch (action.type) {\n    case ActionType.SELECT_TOKEN: {\n      const { field, address } = action.payload as ActionPayload[ActionType.SELECT_TOKEN]\n      if (!!address && address === state[field === Field.INPUT ? Field.OUTPUT : Field.INPUT].address) {\n        return {\n          ...state,\n          value: '',\n          [Field.INPUT]: state[Field.OUTPUT],\n          [Field.OUTPUT]: state[Field.INPUT],\n        }\n      } else {\n        return {\n          ...state,\n          [field]: { address },\n        }\n      }\n    }\n    case ActionType.TYPE: {\n      const { field, value } = action.payload as ActionPayload[ActionType.TYPE]\n      return {\n        ...state,\n        independentField: field,\n        value,\n      }\n    }\n    case ActionType.RESET: {\n      const { field } = action.payload as ActionPayload[ActionType.RESET]\n      return initializeSentenceState({ independentField: field })\n    }\n  }\n}\n\nfunction SwapText({ children, ...rest }: BoxProps): JSX.Element {\n  return (\n    <Text fontSize=\"3xl\" lineHeight={1} py=\"0.3rem\" {...rest}>\n      {children}\n    </Text>\n  )\n}\n\nexport default function Swap({ buy }: { buy: boolean }): JSX.Element {\n  const { query, pathname, replace } = useRouter()\n\n  const queryParameters = useQueryParameters()\n\n  const { account, chainId, library } = useWeb3React()\n\n  const [approveMax] = useApproveMax()\n  const [deadlineDelta] = useDeadline()\n  const [slippage] = useSlippage()\n  const [, { addTransaction }] = useTransactions()\n\n  // reducer state\n  const [state, dispatch] = useReducer(\n    reducer,\n    {\n      independentField: buy ? Field.OUTPUT : Field.INPUT,\n      [Field.INPUT]: {\n        address: queryParameters[QueryParameters.INPUT],\n      },\n      [Field.OUTPUT]: {\n        address: queryParameters[QueryParameters.OUTPUT],\n      },\n    },\n    initializeSentenceState\n  )\n  const { independentField, value, ...tokenAddresses } = state\n\n  // derived state\n  const dependentField = independentField === Field.INPUT ? Field.OUTPUT : Field.INPUT\n  const tradeType = independentField === Field.INPUT ? TradeType.EXACT_INPUT : TradeType.EXACT_OUTPUT\n\n  // sdk tokens\n  const tokens = {\n    [Field.INPUT]: useTokenByAddressAndAutomaticallyAdd(tokenAddresses[Field.INPUT].address),\n    [Field.OUTPUT]: useTokenByAddressAndAutomaticallyAdd(tokenAddresses[Field.OUTPUT].address),\n  }\n\n  // keep global token state in sync\n  const [, setFirstToken] = useFirstToken()\n  const [, setSecondToken] = useSecondToken()\n  useEffect(() => {\n    setFirstToken(tokens[buy ? Field.OUTPUT : Field.INPUT])\n    setSecondToken(tokens[buy ? Field.INPUT : Field.OUTPUT])\n  })\n\n  // sdk route\n  const [naiveRoute, allPairs] = useRoute(tokens[Field.INPUT], tokens[Field.OUTPUT])\n\n  // parse user value\n  const parsed: { [field: number]: TokenAmount } = {}\n  if (value !== '' && value !== '.' && tokens[independentField]) {\n    try {\n      const valueParsed = parseUnits(value, tokens[independentField]?.decimals).toString()\n      if (valueParsed !== '0') {\n        parsed[independentField] = new TokenAmount(tokens[independentField] as Token, valueParsed)\n      }\n    } catch {\n      // should only fail if the user specifies too many decimal places of precision (or maybe exceed max uint?)\n    }\n  }\n\n  // sdk trade\n  const trade = useTrade(tokens[Field.INPUT], tokens[Field.OUTPUT], allPairs, parsed[independentField], tradeType)\n\n  const route = trade ? trade.route : naiveRoute\n\n  // populate the parsed dependent field\n  if (trade) {\n    if (tradeType === TradeType.EXACT_INPUT) {\n      parsed[dependentField] = trade.minimumAmountOut(new Percent(`${slippage}`, `${10000}`))\n    } else {\n      parsed[dependentField] = trade.maximumAmountIn(new Percent(`${slippage}`, `${10000}`))\n    }\n  }\n\n  // usd values\n  const [showUSD] = useShowUSD()\n  const USDPrices = {\n    [Field.INPUT]: useUSDTokenPrice(tokens[Field.INPUT]),\n    [Field.OUTPUT]: useUSDTokenPrice(tokens[Field.OUTPUT]),\n  }\n  const USDAmountsFormatted = {\n    [Field.INPUT]:\n      parsed[Field.INPUT] && USDPrices[Field.INPUT]\n        ? parsed[Field.INPUT].multiply(USDPrices[Field.INPUT] as Fraction).toFixed(2, { groupSeparator: ',' })\n        : undefined,\n    [Field.OUTPUT]:\n      parsed[Field.OUTPUT] && USDPrices[Field.OUTPUT]\n        ? parsed[Field.OUTPUT].multiply(USDPrices[Field.OUTPUT] as Fraction).toFixed(2, { groupSeparator: ',' })\n        : undefined,\n  }\n\n  // calculate the formatted values from the parsed\n  const formatted = {\n    [independentField]: value,\n    [dependentField]: parsed[dependentField] ? parsed[dependentField].toSignificant(4, { groupSeparator: ',' }) : '',\n  }\n\n  // reset when the network changes\n  useEffect(() => {\n    if (typeof chainId === 'number') {\n      return (): void => {\n        dispatch({\n          type: ActionType.RESET,\n          payload: { field: buy ? Field.OUTPUT : Field.INPUT },\n        })\n      }\n    }\n  }, [chainId, buy])\n\n  // clear url params\n  useEffect(() => {\n    if (Object.keys(query).length > 0) {\n      const { href, as } = modifyUrlObjectForIPFS(pathname)\n      replace(href, as, { shallow: true })\n    }\n  })\n\n  // get input allowance for validation purposes\n  const { data: _allowance } = useTokenAllowance(tokens[Field.INPUT], account, ROUTER_ADDRESS)\n  const allowance = tokens[Field.INPUT]?.equals(WETH[(tokens[Field.INPUT] as Token).chainId])\n    ? new TokenAmount(WETH[(tokens[Field.INPUT] as Token).chainId], MAX_UINT256)\n    : _allowance\n\n  // get permitAndCall allowance if the input token supports permit\n  const { data: permitAndCallAllowance } = useTokenAllowance(\n    canPermit(tokens[Field.INPUT]) ? tokens[Field.INPUT] : undefined,\n    account,\n    PERMIT_AND_CALL_ADDRESS\n  )\n\n  // get input balance for validation purposes\n  const ETHBalance = useETHBalance(account)\n  const _balance = useTokenBalance(tokens[Field.INPUT], account)\n  const balance = tokens[Field.INPUT]?.equals(WETH[(tokens[Field.INPUT] as Token)?.chainId])\n    ? ETHBalance.data\n    : _balance.data\n\n  // compute flags for warning states\n  const warning = !!trade && Number.parseFloat(trade.slippage.toSignificant(2)) >= 5\n  const danger = !!trade && Number.parseFloat(trade.slippage.toSignificant(2)) >= 10\n\n  // compute validation flags\n  const isInvalidBalance =\n    parsed[Field.INPUT] && balance ? JSBI.greaterThan(parsed[Field.INPUT].raw, balance.raw) : false\n  const isInvalidRoute = route === null && value.length > 0\n  const isInvalidTrade = route && parsed[independentField] ? !!!trade : false\n\n  // compute flag for whether maxing is allowed\n  const canMax =\n    !tokens[Field.INPUT]?.equals(WETH[(tokens[Field.INPUT] as Token).chainId]) &&\n    !isInvalidRoute &&\n    formatted[Field.INPUT]?.length === 0 &&\n    !!balance &&\n    JSBI.greaterThan(balance.raw, ZERO)\n\n  // function to perform the swap\n  const [swapping, setSwapping] = useState(false)\n  const inputToken = useContract(tokens[Field.INPUT]?.address, IERC20.abi, true)\n  const router = useContract(ROUTER_ADDRESS, IUniswapV2Router02ABI, true)\n  async function swap(): Promise<void> {\n    setSwapping(true)\n\n    async function innerSwap(deadline: number, mockGas = false, permit?: Permit): Promise<{ hash: string }> {\n      let routerFunctionNames: string[]\n      let routerArguments: any[] // eslint-disable-line @typescript-eslint/no-explicit-any\n      let value: Required<PayableOverrides>['value'] = 0\n\n      if (trade?.tradeType === TradeType.EXACT_INPUT) {\n        if ((tokens[Field.INPUT] as Token).equals(WETH[(tokens[Field.INPUT] as Token).chainId])) {\n          routerFunctionNames = ['swapExactETHForTokens', 'swapExactETHForTokensSupportingFeeOnTransferTokens']\n          routerArguments = [\n            `0x${parsed[Field.OUTPUT].raw.toString(16)}`,\n            (route as Route).path.map((token) => token.address),\n            account,\n            deadline,\n          ]\n          value = `0x${parsed[Field.INPUT].raw.toString(16)}`\n        } else if ((tokens[Field.OUTPUT] as Token).equals(WETH[(tokens[Field.OUTPUT] as Token).chainId])) {\n          routerFunctionNames = ['swapExactTokensForETH', 'swapExactTokensForETHSupportingFeeOnTransferTokens']\n          routerArguments = [\n            `0x${parsed[Field.INPUT].raw.toString(16)}`,\n            `0x${parsed[Field.OUTPUT].raw.toString(16)}`,\n            (route as Route).path.map((token) => token.address),\n            account,\n            deadline,\n          ]\n        } else {\n          routerFunctionNames = ['swapExactTokensForTokens', 'swapExactTokensForTokensSupportingFeeOnTransferTokens']\n          routerArguments = [\n            `0x${parsed[Field.INPUT].raw.toString(16)}`,\n            `0x${parsed[Field.OUTPUT].raw.toString(16)}`,\n            (route as Route).path.map((token) => token.address),\n            account,\n            deadline,\n          ]\n        }\n      } else {\n        if ((tokens[Field.INPUT] as Token).equals(WETH[(tokens[Field.INPUT] as Token).chainId])) {\n          routerFunctionNames = ['swapETHForExactTokens']\n          routerArguments = [\n            `0x${parsed[Field.OUTPUT].raw.toString(16)}`,\n            (route as Route).path.map((token) => token.address),\n            account,\n            deadline,\n          ]\n          value = `0x${parsed[Field.INPUT].raw.toString(16)}`\n        } else if ((tokens[Field.OUTPUT] as Token).equals(WETH[(tokens[Field.OUTPUT] as Token).chainId])) {\n          routerFunctionNames = ['swapTokensForExactETH']\n          routerArguments = [\n            `0x${parsed[Field.OUTPUT].raw.toString(16)}`,\n            `0x${parsed[Field.INPUT].raw.toString(16)}`,\n            (route as Route).path.map((token) => token.address),\n            account,\n            deadline,\n          ]\n        } else {\n          routerFunctionNames = ['swapTokensForExactTokens']\n          routerArguments = [\n            `0x${parsed[Field.OUTPUT].raw.toString(16)}`,\n            `0x${parsed[Field.INPUT].raw.toString(16)}`,\n            (route as Route).path.map((token) => token.address),\n            account,\n            deadline,\n          ]\n        }\n      }\n\n      // we have an approve tx pending\n      if (mockGas) {\n        // because we can't estimate gas, as it will fail b/c of the approve, we are forced to use the first function\n        const routerFunctionName = routerFunctionNames[0]\n        return await (router as Contract)\n          [routerFunctionName](...routerArguments, {\n            value,\n            gasLimit: GAS_LIMIT_WHEN_MOCKING,\n          })\n          .catch((error: ErrorWithCode) => {\n            if (error?.code !== 4001) {\n              console.log(`${routerFunctionName} failed with a mocked gas limit.`, error)\n            }\n            throw error\n          })\n      }\n\n      // we have permit data\n      if (permit) {\n        const permitAndCall = new Contract(\n          PERMIT_AND_CALL_ADDRESS,\n          [\n            'function permitAndCall(address token, uint256 value, bytes4 permitSelector, bytes calldata permitData, bytes4 routerFunctionSelector, bytes calldata routerFunctionData)',\n          ],\n          library.getSigner(account).connectUnchecked()\n        )\n\n        // try to get a gas limit for each function name in turn\n        for (const routerFunctionName of routerFunctionNames) {\n          const routerFunctionFragment = (router as Contract).interface.fragments.filter(\n            ({ name }) => name === routerFunctionName\n          )[0]\n          const routerFunctionSelector = hexDataSlice(\n            id(`${routerFunctionName}(${routerFunctionFragment?.inputs.map(({ type }) => type).join(',')})`),\n            0,\n            4\n          )\n          const permitAndCallArguments = [\n            (tokens[Field.INPUT] as Token).address,\n            `0x${parsed[Field.INPUT].raw.toString(16)}`,\n            permit.permitSelector,\n            permit.permitData,\n            routerFunctionSelector,\n            defaultAbiCoder.encode(routerFunctionFragment.inputs, routerArguments),\n          ]\n          const gasLimit: BigNumber | void = await permitAndCall.estimateGas\n            .permitAndCall(...permitAndCallArguments, { value })\n            .then((gasLimit) => gasLimit.mul(105).div(100))\n            .catch((error) => {\n              console.log(`estimateGas failed for ${routerFunctionName} via permitAndCall.`, error)\n            })\n          if (BigNumber.isBigNumber(gasLimit)) {\n            return await permitAndCall\n              .permitAndCall(...permitAndCallArguments, {\n                value,\n                gasLimit,\n              })\n              .catch((error: ErrorWithCode) => {\n                if (error?.code !== 4001) {\n                  console.log(`${routerFunctionName} failed via permitAndCall.`, error)\n                }\n                throw error\n              })\n          }\n        }\n        // if we're here, it means all estimateGas calls failed\n        console.log(\n          routerFunctionNames.length === 1\n            ? \"If you're trying to swap a token that takes a transfer fee, you must specify an exact input amount.\"\n            : \"If you're trying to swap a token that takes a transfer fee, ensure your slippage tolerance is higher than the fee.\"\n        )\n        throw Error()\n      }\n\n      // try to get a gas limit for each function name in turn\n      for (const routerFunctionName of routerFunctionNames) {\n        const gasLimit: BigNumber | void = await (router as Contract).estimateGas[\n          routerFunctionName\n        ](...routerArguments, { value })\n          .then((gasLimit) => gasLimit.mul(105).div(100))\n          .catch((error) => {\n            console.log(`estimateGas failed for ${routerFunctionName}.`, error)\n          })\n        if (BigNumber.isBigNumber(gasLimit)) {\n          return await (router as Contract)\n            [routerFunctionName](...routerArguments, { value, gasLimit })\n            .catch((error: ErrorWithCode) => {\n              if (error?.code !== 4001) {\n                console.log(`${routerFunctionName} failed.`, error)\n              }\n              throw error\n            })\n        }\n      }\n      // if we're here, it means all estimateGas calls failed\n      console.log(\n        routerFunctionNames.length === 1\n          ? \"If you're trying to swap a token that takes a transfer fee, you must specify an exact input amount.\"\n          : \"If you're trying to swap a token that takes a transfer fee, ensure your slippage tolerance is higher than the fee.\"\n      )\n      throw Error()\n    }\n\n    const deadline = Math.floor(Date.now() / 1000) + deadlineDelta\n    let approved = JSBI.greaterThanOrEqual((allowance as TokenAmount).raw, parsed[Field.INPUT].raw)\n    let mockGas = false\n    let permit: Permit | undefined\n    if (!approved) {\n      let tryToManuallyApprove = true\n\n      // attempt to gather a permit signature where possible\n      if (canPermit(tokens[Field.INPUT])) {\n        // in the slightly weird case where the user has already approved PermitAndCall, just fake the permit\n        if (permitAndCallAllowance && JSBI.greaterThanOrEqual(permitAndCallAllowance.raw, parsed[Field.INPUT].raw)) {\n          approved = true\n          tryToManuallyApprove = false\n          permit = {\n            permitSelector: '0x00000000',\n            permitData: '0x',\n          }\n        } else {\n          await gatherPermit(account as string, deadline, approveMax, tokens[Field.INPUT] as Token, library)\n            .then((gatheredPermit) => {\n              approved = true\n              tryToManuallyApprove = false\n              permit = gatheredPermit\n            })\n            .catch((error) => {\n              // if the error code is 4001 (EIP-1193 user rejected request), we don't want to try a manual approve\n              if (error?.code === 4001) {\n                tryToManuallyApprove = false\n              } else {\n                console.log(`permit failed.`, error)\n              }\n            })\n        }\n      }\n\n      if (tryToManuallyApprove) {\n        await (inputToken as Contract)\n          .approve(ROUTER_ADDRESS, `0x${(approveMax ? MAX_UINT256 : parsed[Field.INPUT].raw).toString(16)}`)\n          .then(({ hash }: { hash: string }) => {\n            addTransaction(chainId as number, hash)\n            approved = true\n            mockGas = true\n          })\n          .catch((error: ErrorWithCode) => {\n            if (error?.code !== 4001) {\n              console.log(`approve failed.`, error)\n            }\n          })\n      }\n    }\n\n    if (approved) {\n      return (\n        innerSwap(deadline, mockGas, permit)\n          .then(({ hash }) => {\n            addTransaction(chainId as number, hash)\n            dispatch({\n              type: ActionType.TYPE,\n              payload: { field: independentField, value: '' },\n            })\n            setSwapping(false)\n          })\n          // we don't do anything with the error here, innerSwap is responsible for handling it\n          .catch(() => {\n            setSwapping(false)\n          })\n      )\n    } else {\n      setSwapping(false)\n    }\n  }\n\n  return (\n    <Stack\n      direction=\"column\"\n      align=\"center\"\n      spacing=\"6rem\"\n      flexGrow={1}\n      justifyContent=\"center\"\n      px=\"2.5rem\"\n      py=\"8rem\"\n      shouldWrapChildren\n    >\n      <Stack direction=\"row\" align=\"flex-start\" spacing=\"1rem\" flexWrap=\"wrap\" shouldWrapChildren>\n        <SwapText>I want to</SwapText>\n\n        {!!!trade ? (\n          <Link\n            {...modifyUrlObjectForIPFS({\n              pathname: buy ? '/sell' : '/buy',\n              query: {\n                ...(tokens[Field.INPUT]?.address ? { [QueryParameters.INPUT]: tokens[Field.INPUT]?.address } : {}),\n                ...(tokens[Field.OUTPUT]?.address ? { [QueryParameters.OUTPUT]: tokens[Field.OUTPUT]?.address } : {}),\n              },\n            })}\n            passHref\n          >\n            <Button\n              as=\"a\"\n              variant=\"ghost\"\n              variantColor={buy ? 'green' : 'red'}\n              p=\"0.5rem\"\n              mt=\"-0.2rem\"\n              fontSize=\"3xl\"\n              lineHeight={1}\n              height=\"min-content\"\n            >\n              {buy ? 'Buy' : 'Sell'}\n            </Button>\n          </Link>\n        ) : (\n          <Button\n            variant=\"solid\"\n            variantColor={!warning ? (buy ? 'green' : 'red') : 'yellow'}\n            p=\"0.75rem\"\n            mt=\"-0.45rem\"\n            fontSize=\"3xl\"\n            lineHeight={1}\n            height=\"min-content\"\n            leftIcon={!warning ? undefined : !danger ? 'warning-2' : 'not-allowed'}\n            isDisabled={!account || isInvalidBalance || isInvalidTrade}\n            isLoading={swapping}\n            cursor={warning ? 'not-allowed' : 'pointer'}\n            onClick={swap}\n          >\n            {buy ? 'Buy' : 'Sell'}\n          </Button>\n        )}\n\n        {trade && independentField === (buy ? Field.INPUT : Field.OUTPUT) ? (\n          <SwapText>{buy ? 'at least' : 'at most'}</SwapText>\n        ) : null}\n\n        <AmountInput\n          controlled={independentField === (buy ? Field.OUTPUT : Field.INPUT)}\n          isDisabled={showUSD || swapping}\n          isInvalid={isInvalidTrade || (!buy && isInvalidBalance)}\n          value={\n            showUSD && USDAmountsFormatted[buy ? Field.OUTPUT : Field.INPUT]\n              ? `$${USDAmountsFormatted[buy ? Field.OUTPUT : Field.INPUT]}`\n              : formatted[buy ? Field.OUTPUT : Field.INPUT]\n          }\n          onChange={(value): void => {\n            dispatch({\n              type: ActionType.TYPE,\n              payload: { field: buy ? Field.OUTPUT : Field.INPUT, value },\n            })\n          }}\n        />\n\n        {!buy && canMax ? (\n          <Button\n            size=\"sm\"\n            mt=\"0.3rem\"\n            onClick={(): void => {\n              dispatch({\n                type: ActionType.TYPE,\n                payload: { field: Field.INPUT, value: balance?.toExact() },\n              })\n            }}\n          >\n            Max\n          </Button>\n        ) : null}\n\n        <TokenSelect\n          tokenAddress={tokenAddresses[buy ? Field.OUTPUT : Field.INPUT].address}\n          isInvalid={isInvalidRoute}\n          isDisabled={swapping}\n          onAddressSelect={(address): void => {\n            dispatch({\n              type: ActionType.SELECT_TOKEN,\n              payload: { field: buy ? Field.OUTPUT : Field.INPUT, address },\n            })\n          }}\n        />\n\n        <SwapText>\n          {buy ? 'with' : 'for'}\n          {trade && independentField === (buy ? Field.OUTPUT : Field.INPUT) ? (buy ? ' at most' : ' at least') : ''}\n        </SwapText>\n\n        <AmountInput\n          controlled={independentField === (buy ? Field.INPUT : Field.OUTPUT)}\n          isDisabled={showUSD || swapping}\n          isInvalid={isInvalidTrade || (buy && isInvalidBalance)}\n          value={\n            showUSD && USDAmountsFormatted[buy ? Field.INPUT : Field.OUTPUT]\n              ? `$${USDAmountsFormatted[buy ? Field.INPUT : Field.OUTPUT]}`\n              : formatted[buy ? Field.INPUT : Field.OUTPUT]\n          }\n          onChange={(value): void => {\n            dispatch({\n              type: ActionType.TYPE,\n              payload: { field: buy ? Field.INPUT : Field.OUTPUT, value },\n            })\n          }}\n        />\n\n        {buy && canMax ? (\n          <Button\n            size=\"sm\"\n            mt=\"0.3rem\"\n            onClick={(): void => {\n              dispatch({\n                type: ActionType.TYPE,\n                payload: { field: Field.INPUT, value: balance?.toExact() },\n              })\n            }}\n          >\n            Max\n          </Button>\n        ) : null}\n\n        <TokenSelect\n          tokenAddress={tokenAddresses[buy ? Field.INPUT : Field.OUTPUT].address}\n          isInvalid={isInvalidRoute}\n          isDisabled={swapping}\n          onAddressSelect={(address): void => {\n            dispatch({\n              type: ActionType.SELECT_TOKEN,\n              payload: { field: buy ? Field.INPUT : Field.OUTPUT, address },\n            })\n          }}\n        />\n\n        <SwapText fontSize=\"3xl\" lineHeight={1} pt=\"0.3rem\">\n          .\n        </SwapText>\n      </Stack>\n\n      <TradeSummary route={route} trade={trade} warning={warning} danger={danger} />\n    </Stack>\n  )\n}\n"]},"metadata":{},"sourceType":"module"}