{"ast":null,"code":"import _regeneratorRuntime from \"@babel/runtime/regenerator\";\nimport _toConsumableArray from \"@babel/runtime/helpers/esm/toConsumableArray\";\nimport _asyncToGenerator from \"@babel/runtime/helpers/esm/asyncToGenerator\";\nimport _slicedToArray from \"@babel/runtime/helpers/esm/slicedToArray\";\nimport _extends from \"@babel/runtime/helpers/esm/extends\";\nimport _objectWithoutProperties from \"@babel/runtime/helpers/esm/objectWithoutProperties\";\nimport _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nvar _excluded = [\"children\"],\n    _excluded2 = [\"independentField\", \"value\"];\nimport React from \"react\";\nvar __jsx = React.createElement;\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nimport { useReducer, useState, useEffect } from 'react';\nimport { useRouter } from 'next/router';\nimport Link from 'next/link';\nimport { useWeb3React } from '@web3-react/core';\nimport { parseUnits } from '@ethersproject/units';\nimport { Contract } from '@ethersproject/contracts';\nimport { BigNumber } from '@ethersproject/bignumber';\nimport { TradeType, TokenAmount, JSBI, WETH, Percent } from '@uniswap/sdk';\nimport { hexDataSlice } from '@ethersproject/bytes';\nimport { id } from '@ethersproject/hash';\nimport { defaultAbiCoder } from '@ethersproject/abi';\nimport IERC20 from '@uniswap/v2-core/build/IERC20.json';\nimport { abi as IUniswapV2Router02ABI } from '@uniswap/v2-periphery/build/IUniswapV2Router02.json';\nimport { Stack, Button, Text } from '@chakra-ui/core';\nimport AmountInput from '../components/AmountInput';\nimport TokenSelect from '../components/TokenSelect';\nimport { useTokenByAddressAndAutomaticallyAdd } from '../tokens';\nimport { useRoute, useContract, useQueryParameters, useTrade, useUSDTokenPrice } from '../hooks';\nimport { useTokenBalance, useTokenAllowance, useETHBalance } from '../data';\nimport { ROUTER_ADDRESS, ZERO, MAX_UINT256, QueryParameters, PERMIT_AND_CALL_ADDRESS, GAS_LIMIT_WHEN_MOCKING } from '../constants';\nimport { useSlippage, useDeadline, useApproveMax, useTransactions, useFirstToken, useSecondToken, useShowUSD } from '../context';\nimport TradeSummary from '../components/TradeSummary';\nimport { canPermit, gatherPermit } from '../permits';\nimport { modifyUrlObjectForIPFS } from '../utils';\nvar Field;\n\n(function (Field) {\n  Field[Field[\"INPUT\"] = 0] = \"INPUT\";\n  Field[Field[\"OUTPUT\"] = 1] = \"OUTPUT\";\n})(Field || (Field = {}));\n\nfunction initializeSentenceState(partialState) {\n  var _partialState$Field$I, _partialState$Field$O, _ref;\n\n  return _ref = {\n    independentField: partialState.independentField,\n    value: ''\n  }, _defineProperty(_ref, Field.INPUT, {\n    address: (_partialState$Field$I = partialState[Field.INPUT]) === null || _partialState$Field$I === void 0 ? void 0 : _partialState$Field$I.address\n  }), _defineProperty(_ref, Field.OUTPUT, {\n    address: (_partialState$Field$O = partialState[Field.OUTPUT]) === null || _partialState$Field$O === void 0 ? void 0 : _partialState$Field$O.address\n  }), _ref;\n}\n\nvar ActionType;\n\n(function (ActionType) {\n  ActionType[ActionType[\"SELECT_TOKEN\"] = 0] = \"SELECT_TOKEN\";\n  ActionType[ActionType[\"TYPE\"] = 1] = \"TYPE\";\n  ActionType[ActionType[\"RESET\"] = 2] = \"RESET\";\n})(ActionType || (ActionType = {}));\n\nfunction reducer(state, action) {\n  switch (action.type) {\n    case ActionType.SELECT_TOKEN:\n      {\n        var _ref2 = action.payload,\n            _field = _ref2.field,\n            address = _ref2.address;\n\n        if (!!address && address === state[_field === Field.INPUT ? Field.OUTPUT : Field.INPUT].address) {\n          var _objectSpread2;\n\n          return _objectSpread(_objectSpread({}, state), {}, (_objectSpread2 = {\n            value: ''\n          }, _defineProperty(_objectSpread2, Field.INPUT, state[Field.OUTPUT]), _defineProperty(_objectSpread2, Field.OUTPUT, state[Field.INPUT]), _objectSpread2));\n        } else {\n          return _objectSpread(_objectSpread({}, state), {}, _defineProperty({}, _field, {\n            address: address\n          }));\n        }\n      }\n\n    case ActionType.TYPE:\n      {\n        var _ref3 = action.payload,\n            _field2 = _ref3.field,\n            value = _ref3.value;\n        return _objectSpread(_objectSpread({}, state), {}, {\n          independentField: _field2,\n          value: value\n        });\n      }\n\n    case ActionType.RESET:\n      {\n        var _ref4 = action.payload,\n            _field3 = _ref4.field;\n        return initializeSentenceState({\n          independentField: _field3\n        });\n      }\n  }\n}\n\nfunction SwapText(_ref5) {\n  var children = _ref5.children,\n      rest = _objectWithoutProperties(_ref5, _excluded);\n\n  return __jsx(Text, _extends({\n    fontSize: \"3xl\",\n    lineHeight: 1,\n    py: \"0.3rem\"\n  }, rest), children);\n}\n\nexport default function Swap(_ref6) {\n  var _useReducer2, _tokens, _USDPrices, _USDAmountsFormatted, _formatted, _tokens$Field$INPUT, _tokens$Field$INPUT2, _tokens$Field$INPUT3, _tokens$Field$INPUT4, _formatted$Field$INPU, _tokens$Field$INPUT5, _tokens$Field$INPUT6, _tokens$Field$INPUT7, _tokens$Field$OUTPUT, _tokens$Field$OUTPUT2;\n\n  var buy = _ref6.buy;\n\n  var _useRouter = useRouter(),\n      query = _useRouter.query,\n      pathname = _useRouter.pathname,\n      replace = _useRouter.replace;\n\n  var queryParameters = useQueryParameters();\n\n  var _useWeb3React = useWeb3React(),\n      account = _useWeb3React.account,\n      chainId = _useWeb3React.chainId,\n      library = _useWeb3React.library;\n\n  var _useApproveMax = useApproveMax(),\n      _useApproveMax2 = _slicedToArray(_useApproveMax, 1),\n      approveMax = _useApproveMax2[0];\n\n  var _useDeadline = useDeadline(),\n      _useDeadline2 = _slicedToArray(_useDeadline, 1),\n      deadlineDelta = _useDeadline2[0];\n\n  var _useSlippage = useSlippage(),\n      _useSlippage2 = _slicedToArray(_useSlippage, 1),\n      slippage = _useSlippage2[0];\n\n  var _useTransactions = useTransactions(),\n      _useTransactions2 = _slicedToArray(_useTransactions, 2),\n      addTransaction = _useTransactions2[1].addTransaction; // reducer state\n\n\n  var _useReducer = useReducer(reducer, (_useReducer2 = {\n    independentField: buy ? Field.OUTPUT : Field.INPUT\n  }, _defineProperty(_useReducer2, Field.INPUT, {\n    address: queryParameters[QueryParameters.INPUT]\n  }), _defineProperty(_useReducer2, Field.OUTPUT, {\n    address: queryParameters[QueryParameters.OUTPUT]\n  }), _useReducer2), initializeSentenceState),\n      state = _useReducer[0],\n      dispatch = _useReducer[1];\n\n  var independentField = state.independentField,\n      value = state.value,\n      tokenAddresses = _objectWithoutProperties(state, _excluded2); // derived state\n\n\n  var dependentField = independentField === Field.INPUT ? Field.OUTPUT : Field.INPUT;\n  var tradeType = independentField === Field.INPUT ? TradeType.EXACT_INPUT : TradeType.EXACT_OUTPUT; // sdk tokens\n\n  var tokens = (_tokens = {}, _defineProperty(_tokens, Field.INPUT, useTokenByAddressAndAutomaticallyAdd(tokenAddresses[Field.INPUT].address)), _defineProperty(_tokens, Field.OUTPUT, useTokenByAddressAndAutomaticallyAdd(tokenAddresses[Field.OUTPUT].address)), _tokens); // keep global token state in sync\n\n  var _useFirstToken = useFirstToken(),\n      _useFirstToken2 = _slicedToArray(_useFirstToken, 2),\n      setFirstToken = _useFirstToken2[1];\n\n  var _useSecondToken = useSecondToken(),\n      _useSecondToken2 = _slicedToArray(_useSecondToken, 2),\n      setSecondToken = _useSecondToken2[1];\n\n  useEffect(function () {\n    setFirstToken(tokens[buy ? Field.OUTPUT : Field.INPUT]);\n    setSecondToken(tokens[buy ? Field.INPUT : Field.OUTPUT]);\n  }); // sdk route\n\n  var _useRoute = useRoute(tokens[Field.INPUT], tokens[Field.OUTPUT]),\n      _useRoute2 = _slicedToArray(_useRoute, 2),\n      naiveRoute = _useRoute2[0],\n      allPairs = _useRoute2[1]; // parse user value\n\n\n  var parsed = {};\n\n  if (value !== '' && value !== '.' && tokens[independentField]) {\n    try {\n      var _tokens$independentFi;\n\n      var valueParsed = parseUnits(value, (_tokens$independentFi = tokens[independentField]) === null || _tokens$independentFi === void 0 ? void 0 : _tokens$independentFi.decimals).toString();\n\n      if (valueParsed !== '0') {\n        parsed[independentField] = new TokenAmount(tokens[independentField], valueParsed);\n      }\n    } catch (_unused) {// should only fail if the user specifies too many decimal places of precision (or maybe exceed max uint?)\n    }\n  } // sdk trade\n\n\n  var trade = useTrade(tokens[Field.INPUT], tokens[Field.OUTPUT], allPairs, parsed[independentField], tradeType);\n  var route = trade ? trade.route : naiveRoute; // populate the parsed dependent field\n\n  if (trade) {\n    if (tradeType === TradeType.EXACT_INPUT) {\n      parsed[dependentField] = trade.minimumAmountOut(new Percent(\"\".concat(slippage), \"\".concat(10000)));\n    } else {\n      parsed[dependentField] = trade.maximumAmountIn(new Percent(\"\".concat(slippage), \"\".concat(10000)));\n    }\n  } // usd values\n\n\n  var _useShowUSD = useShowUSD(),\n      _useShowUSD2 = _slicedToArray(_useShowUSD, 1),\n      showUSD = _useShowUSD2[0];\n\n  var USDPrices = (_USDPrices = {}, _defineProperty(_USDPrices, Field.INPUT, useUSDTokenPrice(tokens[Field.INPUT])), _defineProperty(_USDPrices, Field.OUTPUT, useUSDTokenPrice(tokens[Field.OUTPUT])), _USDPrices);\n  var USDAmountsFormatted = (_USDAmountsFormatted = {}, _defineProperty(_USDAmountsFormatted, Field.INPUT, parsed[Field.INPUT] && USDPrices[Field.INPUT] ? parsed[Field.INPUT].multiply(USDPrices[Field.INPUT]).toFixed(2, {\n    groupSeparator: ','\n  }) : undefined), _defineProperty(_USDAmountsFormatted, Field.OUTPUT, parsed[Field.OUTPUT] && USDPrices[Field.OUTPUT] ? parsed[Field.OUTPUT].multiply(USDPrices[Field.OUTPUT]).toFixed(2, {\n    groupSeparator: ','\n  }) : undefined), _USDAmountsFormatted); // calculate the formatted values from the parsed\n\n  var formatted = (_formatted = {}, _defineProperty(_formatted, independentField, value), _defineProperty(_formatted, dependentField, parsed[dependentField] ? parsed[dependentField].toSignificant(4, {\n    groupSeparator: ','\n  }) : ''), _formatted); // reset when the network changes\n\n  useEffect(function () {\n    if (typeof chainId === 'number') {\n      return function () {\n        dispatch({\n          type: ActionType.RESET,\n          payload: {\n            field: buy ? Field.OUTPUT : Field.INPUT\n          }\n        });\n      };\n    }\n  }, [chainId, buy]); // clear url params\n\n  useEffect(function () {\n    if (Object.keys(query).length > 0) {\n      var _modifyUrlObjectForIP = modifyUrlObjectForIPFS(pathname),\n          href = _modifyUrlObjectForIP.href,\n          as = _modifyUrlObjectForIP.as;\n\n      replace(href, as, {\n        shallow: true\n      });\n    }\n  }); // get input allowance for validation purposes\n\n  var _useTokenAllowance = useTokenAllowance(tokens[Field.INPUT], account, ROUTER_ADDRESS),\n      _allowance = _useTokenAllowance.data;\n\n  var allowance = (_tokens$Field$INPUT = tokens[Field.INPUT]) !== null && _tokens$Field$INPUT !== void 0 && _tokens$Field$INPUT.equals(WETH[tokens[Field.INPUT].chainId]) ? new TokenAmount(WETH[tokens[Field.INPUT].chainId], MAX_UINT256) : _allowance; // get permitAndCall allowance if the input token supports permit\n\n  var _useTokenAllowance2 = useTokenAllowance(canPermit(tokens[Field.INPUT]) ? tokens[Field.INPUT] : undefined, account, PERMIT_AND_CALL_ADDRESS),\n      permitAndCallAllowance = _useTokenAllowance2.data; // get input balance for validation purposes\n\n\n  var ETHBalance = useETHBalance(account);\n\n  var _balance = useTokenBalance(tokens[Field.INPUT], account);\n\n  var balance = (_tokens$Field$INPUT2 = tokens[Field.INPUT]) !== null && _tokens$Field$INPUT2 !== void 0 && _tokens$Field$INPUT2.equals(WETH[(_tokens$Field$INPUT3 = tokens[Field.INPUT]) === null || _tokens$Field$INPUT3 === void 0 ? void 0 : _tokens$Field$INPUT3.chainId]) ? ETHBalance.data : _balance.data; // compute flags for warning states\n\n  var warning = !!trade && Number.parseFloat(trade.slippage.toSignificant(2)) >= 5;\n  var danger = !!trade && Number.parseFloat(trade.slippage.toSignificant(2)) >= 10; // compute validation flags\n\n  var isInvalidBalance = parsed[Field.INPUT] && balance ? JSBI.greaterThan(parsed[Field.INPUT].raw, balance.raw) : false;\n  var isInvalidRoute = route === null && value.length > 0;\n  var isInvalidTrade = route && parsed[independentField] ? !!!trade : false; // compute flag for whether maxing is allowed\n\n  var canMax = !((_tokens$Field$INPUT4 = tokens[Field.INPUT]) !== null && _tokens$Field$INPUT4 !== void 0 && _tokens$Field$INPUT4.equals(WETH[tokens[Field.INPUT].chainId])) && !isInvalidRoute && ((_formatted$Field$INPU = formatted[Field.INPUT]) === null || _formatted$Field$INPU === void 0 ? void 0 : _formatted$Field$INPU.length) === 0 && !!balance && JSBI.greaterThan(balance.raw, ZERO); // function to perform the swap\n\n  var _useState = useState(false),\n      swapping = _useState[0],\n      setSwapping = _useState[1];\n\n  var inputToken = useContract((_tokens$Field$INPUT5 = tokens[Field.INPUT]) === null || _tokens$Field$INPUT5 === void 0 ? void 0 : _tokens$Field$INPUT5.address, IERC20.abi, true);\n  var router = useContract(ROUTER_ADDRESS, IUniswapV2Router02ABI, true);\n\n  function swap() {\n    return _swap.apply(this, arguments);\n  }\n\n  function _swap() {\n    _swap = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {\n      var innerSwap, _innerSwap, deadline, approved, mockGas, permit, tryToManuallyApprove;\n\n      return _regeneratorRuntime.wrap(function _callee2$(_context4) {\n        while (1) {\n          switch (_context4.prev = _context4.next) {\n            case 0:\n              _innerSwap = function _innerSwap3() {\n                _innerSwap = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(deadline) {\n                  var mockGas,\n                      permit,\n                      routerFunctionNames,\n                      routerArguments,\n                      value,\n                      _ref11,\n                      routerFunctionName,\n                      permitAndCall,\n                      _iterator,\n                      _step,\n                      _loop,\n                      _ret,\n                      _iterator2,\n                      _step2,\n                      _loop2,\n                      _ret2,\n                      _args3 = arguments;\n\n                  return _regeneratorRuntime.wrap(function _callee$(_context3) {\n                    while (1) {\n                      switch (_context3.prev = _context3.next) {\n                        case 0:\n                          mockGas = _args3.length > 1 && _args3[1] !== undefined ? _args3[1] : false;\n                          permit = _args3.length > 2 ? _args3[2] : undefined;\n                          // eslint-disable-line @typescript-eslint/no-explicit-any\n                          value = 0;\n\n                          if ((trade === null || trade === void 0 ? void 0 : trade.tradeType) === TradeType.EXACT_INPUT) {\n                            if (tokens[Field.INPUT].equals(WETH[tokens[Field.INPUT].chainId])) {\n                              routerFunctionNames = ['swapExactETHForTokens', 'swapExactETHForTokensSupportingFeeOnTransferTokens'];\n                              routerArguments = [\"0x\".concat(parsed[Field.OUTPUT].raw.toString(16)), route.path.map(function (token) {\n                                return token.address;\n                              }), account, deadline];\n                              value = \"0x\".concat(parsed[Field.INPUT].raw.toString(16));\n                            } else if (tokens[Field.OUTPUT].equals(WETH[tokens[Field.OUTPUT].chainId])) {\n                              routerFunctionNames = ['swapExactTokensForETH', 'swapExactTokensForETHSupportingFeeOnTransferTokens'];\n                              routerArguments = [\"0x\".concat(parsed[Field.INPUT].raw.toString(16)), \"0x\".concat(parsed[Field.OUTPUT].raw.toString(16)), route.path.map(function (token) {\n                                return token.address;\n                              }), account, deadline];\n                            } else {\n                              routerFunctionNames = ['swapExactTokensForTokens', 'swapExactTokensForTokensSupportingFeeOnTransferTokens'];\n                              routerArguments = [\"0x\".concat(parsed[Field.INPUT].raw.toString(16)), \"0x\".concat(parsed[Field.OUTPUT].raw.toString(16)), route.path.map(function (token) {\n                                return token.address;\n                              }), account, deadline];\n                            }\n                          } else {\n                            if (tokens[Field.INPUT].equals(WETH[tokens[Field.INPUT].chainId])) {\n                              routerFunctionNames = ['swapETHForExactTokens'];\n                              routerArguments = [\"0x\".concat(parsed[Field.OUTPUT].raw.toString(16)), route.path.map(function (token) {\n                                return token.address;\n                              }), account, deadline];\n                              value = \"0x\".concat(parsed[Field.INPUT].raw.toString(16));\n                            } else if (tokens[Field.OUTPUT].equals(WETH[tokens[Field.OUTPUT].chainId])) {\n                              routerFunctionNames = ['swapTokensForExactETH'];\n                              routerArguments = [\"0x\".concat(parsed[Field.OUTPUT].raw.toString(16)), \"0x\".concat(parsed[Field.INPUT].raw.toString(16)), route.path.map(function (token) {\n                                return token.address;\n                              }), account, deadline];\n                            } else {\n                              routerFunctionNames = ['swapTokensForExactTokens'];\n                              routerArguments = [\"0x\".concat(parsed[Field.OUTPUT].raw.toString(16)), \"0x\".concat(parsed[Field.INPUT].raw.toString(16)), route.path.map(function (token) {\n                                return token.address;\n                              }), account, deadline];\n                            }\n                          } // we have an approve tx pending\n\n\n                          if (!mockGas) {\n                            _context3.next = 9;\n                            break;\n                          }\n\n                          // because we can't estimate gas, as it will fail b/c of the approve, we are forced to use the first function\n                          routerFunctionName = routerFunctionNames[0];\n                          _context3.next = 8;\n                          return (_ref11 = router)[routerFunctionName].apply(_ref11, _toConsumableArray(routerArguments).concat([{\n                            value: value,\n                            gasLimit: GAS_LIMIT_WHEN_MOCKING\n                          }]))[\"catch\"](function (error) {\n                            if ((error === null || error === void 0 ? void 0 : error.code) !== 4001) {\n                              console.log(\"\".concat(routerFunctionName, \" failed with a mocked gas limit.\"), error);\n                            }\n\n                            throw error;\n                          });\n\n                        case 8:\n                          return _context3.abrupt(\"return\", _context3.sent);\n\n                        case 9:\n                          if (!permit) {\n                            _context3.next = 32;\n                            break;\n                          }\n\n                          permitAndCall = new Contract(PERMIT_AND_CALL_ADDRESS, ['function permitAndCall(address token, uint256 value, bytes4 permitSelector, bytes calldata permitData, bytes4 routerFunctionSelector, bytes calldata routerFunctionData)'], library.getSigner(account).connectUnchecked()); // try to get a gas limit for each function name in turn\n\n                          _iterator = _createForOfIteratorHelper(routerFunctionNames);\n                          _context3.prev = 12;\n                          _loop = /*#__PURE__*/_regeneratorRuntime.mark(function _loop() {\n                            var _permitAndCall$estima;\n\n                            var routerFunctionName, routerFunctionFragment, routerFunctionSelector, permitAndCallArguments, gasLimit;\n                            return _regeneratorRuntime.wrap(function _loop$(_context) {\n                              while (1) {\n                                switch (_context.prev = _context.next) {\n                                  case 0:\n                                    routerFunctionName = _step.value;\n                                    routerFunctionFragment = router[\"interface\"].fragments.filter(function (_ref12) {\n                                      var name = _ref12.name;\n                                      return name === routerFunctionName;\n                                    })[0];\n                                    routerFunctionSelector = hexDataSlice(id(\"\".concat(routerFunctionName, \"(\").concat(routerFunctionFragment === null || routerFunctionFragment === void 0 ? void 0 : routerFunctionFragment.inputs.map(function (_ref13) {\n                                      var type = _ref13.type;\n                                      return type;\n                                    }).join(','), \")\")), 0, 4);\n                                    permitAndCallArguments = [tokens[Field.INPUT].address, \"0x\".concat(parsed[Field.INPUT].raw.toString(16)), permit.permitSelector, permit.permitData, routerFunctionSelector, defaultAbiCoder.encode(routerFunctionFragment.inputs, routerArguments)];\n                                    _context.next = 6;\n                                    return (_permitAndCall$estima = permitAndCall.estimateGas).permitAndCall.apply(_permitAndCall$estima, permitAndCallArguments.concat([{\n                                      value: value\n                                    }])).then(function (gasLimit) {\n                                      return gasLimit.mul(105).div(100);\n                                    })[\"catch\"](function (error) {\n                                      console.log(\"estimateGas failed for \".concat(routerFunctionName, \" via permitAndCall.\"), error);\n                                    });\n\n                                  case 6:\n                                    gasLimit = _context.sent;\n\n                                    if (!BigNumber.isBigNumber(gasLimit)) {\n                                      _context.next = 12;\n                                      break;\n                                    }\n\n                                    _context.next = 10;\n                                    return permitAndCall.permitAndCall.apply(permitAndCall, permitAndCallArguments.concat([{\n                                      value: value,\n                                      gasLimit: gasLimit\n                                    }]))[\"catch\"](function (error) {\n                                      if ((error === null || error === void 0 ? void 0 : error.code) !== 4001) {\n                                        console.log(\"\".concat(routerFunctionName, \" failed via permitAndCall.\"), error);\n                                      }\n\n                                      throw error;\n                                    });\n\n                                  case 10:\n                                    _context.t0 = _context.sent;\n                                    return _context.abrupt(\"return\", {\n                                      v: _context.t0\n                                    });\n\n                                  case 12:\n                                  case \"end\":\n                                    return _context.stop();\n                                }\n                              }\n                            }, _loop);\n                          });\n\n                          _iterator.s();\n\n                        case 15:\n                          if ((_step = _iterator.n()).done) {\n                            _context3.next = 22;\n                            break;\n                          }\n\n                          return _context3.delegateYield(_loop(), \"t0\", 17);\n\n                        case 17:\n                          _ret = _context3.t0;\n\n                          if (!(typeof _ret === \"object\")) {\n                            _context3.next = 20;\n                            break;\n                          }\n\n                          return _context3.abrupt(\"return\", _ret.v);\n\n                        case 20:\n                          _context3.next = 15;\n                          break;\n\n                        case 22:\n                          _context3.next = 27;\n                          break;\n\n                        case 24:\n                          _context3.prev = 24;\n                          _context3.t1 = _context3[\"catch\"](12);\n\n                          _iterator.e(_context3.t1);\n\n                        case 27:\n                          _context3.prev = 27;\n\n                          _iterator.f();\n\n                          return _context3.finish(27);\n\n                        case 30:\n                          // if we're here, it means all estimateGas calls failed\n                          console.log(routerFunctionNames.length === 1 ? \"If you're trying to swap a token that takes a transfer fee, you must specify an exact input amount.\" : \"If you're trying to swap a token that takes a transfer fee, ensure your slippage tolerance is higher than the fee.\");\n                          throw Error();\n\n                        case 32:\n                          // try to get a gas limit for each function name in turn\n                          _iterator2 = _createForOfIteratorHelper(routerFunctionNames);\n                          _context3.prev = 33;\n                          _loop2 = /*#__PURE__*/_regeneratorRuntime.mark(function _loop2() {\n                            var _estimateGas;\n\n                            var routerFunctionName, gasLimit, _ref14;\n\n                            return _regeneratorRuntime.wrap(function _loop2$(_context2) {\n                              while (1) {\n                                switch (_context2.prev = _context2.next) {\n                                  case 0:\n                                    routerFunctionName = _step2.value;\n                                    _context2.next = 3;\n                                    return (_estimateGas = router.estimateGas)[routerFunctionName].apply(_estimateGas, _toConsumableArray(routerArguments).concat([{\n                                      value: value\n                                    }])).then(function (gasLimit) {\n                                      return gasLimit.mul(105).div(100);\n                                    })[\"catch\"](function (error) {\n                                      console.log(\"estimateGas failed for \".concat(routerFunctionName, \".\"), error);\n                                    });\n\n                                  case 3:\n                                    gasLimit = _context2.sent;\n\n                                    if (!BigNumber.isBigNumber(gasLimit)) {\n                                      _context2.next = 9;\n                                      break;\n                                    }\n\n                                    _context2.next = 7;\n                                    return (_ref14 = router)[routerFunctionName].apply(_ref14, _toConsumableArray(routerArguments).concat([{\n                                      value: value,\n                                      gasLimit: gasLimit\n                                    }]))[\"catch\"](function (error) {\n                                      if ((error === null || error === void 0 ? void 0 : error.code) !== 4001) {\n                                        console.log(\"\".concat(routerFunctionName, \" failed.\"), error);\n                                      }\n\n                                      throw error;\n                                    });\n\n                                  case 7:\n                                    _context2.t0 = _context2.sent;\n                                    return _context2.abrupt(\"return\", {\n                                      v: _context2.t0\n                                    });\n\n                                  case 9:\n                                  case \"end\":\n                                    return _context2.stop();\n                                }\n                              }\n                            }, _loop2);\n                          });\n\n                          _iterator2.s();\n\n                        case 36:\n                          if ((_step2 = _iterator2.n()).done) {\n                            _context3.next = 43;\n                            break;\n                          }\n\n                          return _context3.delegateYield(_loop2(), \"t2\", 38);\n\n                        case 38:\n                          _ret2 = _context3.t2;\n\n                          if (!(typeof _ret2 === \"object\")) {\n                            _context3.next = 41;\n                            break;\n                          }\n\n                          return _context3.abrupt(\"return\", _ret2.v);\n\n                        case 41:\n                          _context3.next = 36;\n                          break;\n\n                        case 43:\n                          _context3.next = 48;\n                          break;\n\n                        case 45:\n                          _context3.prev = 45;\n                          _context3.t3 = _context3[\"catch\"](33);\n\n                          _iterator2.e(_context3.t3);\n\n                        case 48:\n                          _context3.prev = 48;\n\n                          _iterator2.f();\n\n                          return _context3.finish(48);\n\n                        case 51:\n                          // if we're here, it means all estimateGas calls failed\n                          console.log(routerFunctionNames.length === 1 ? \"If you're trying to swap a token that takes a transfer fee, you must specify an exact input amount.\" : \"If you're trying to swap a token that takes a transfer fee, ensure your slippage tolerance is higher than the fee.\");\n                          throw Error();\n\n                        case 53:\n                        case \"end\":\n                          return _context3.stop();\n                      }\n                    }\n                  }, _callee, null, [[12, 24, 27, 30], [33, 45, 48, 51]]);\n                }));\n                return _innerSwap.apply(this, arguments);\n              };\n\n              innerSwap = function _innerSwap2(_x) {\n                return _innerSwap.apply(this, arguments);\n              };\n\n              setSwapping(true);\n              deadline = Math.floor(Date.now() / 1000) + deadlineDelta;\n              approved = JSBI.greaterThanOrEqual(allowance.raw, parsed[Field.INPUT].raw);\n              mockGas = false;\n\n              if (approved) {\n                _context4.next = 20;\n                break;\n              }\n\n              tryToManuallyApprove = true; // attempt to gather a permit signature where possible\n\n              if (!canPermit(tokens[Field.INPUT])) {\n                _context4.next = 17;\n                break;\n              }\n\n              if (!(permitAndCallAllowance && JSBI.greaterThanOrEqual(permitAndCallAllowance.raw, parsed[Field.INPUT].raw))) {\n                _context4.next = 15;\n                break;\n              }\n\n              approved = true;\n              tryToManuallyApprove = false;\n              permit = {\n                permitSelector: '0x00000000',\n                permitData: '0x'\n              };\n              _context4.next = 17;\n              break;\n\n            case 15:\n              _context4.next = 17;\n              return gatherPermit(account, deadline, approveMax, tokens[Field.INPUT], library).then(function (gatheredPermit) {\n                approved = true;\n                tryToManuallyApprove = false;\n                permit = gatheredPermit;\n              })[\"catch\"](function (error) {\n                // if the error code is 4001 (EIP-1193 user rejected request), we don't want to try a manual approve\n                if ((error === null || error === void 0 ? void 0 : error.code) === 4001) {\n                  tryToManuallyApprove = false;\n                } else {\n                  console.log(\"permit failed.\", error);\n                }\n              });\n\n            case 17:\n              if (!tryToManuallyApprove) {\n                _context4.next = 20;\n                break;\n              }\n\n              _context4.next = 20;\n              return inputToken.approve(ROUTER_ADDRESS, \"0x\".concat((approveMax ? MAX_UINT256 : parsed[Field.INPUT].raw).toString(16))).then(function (_ref9) {\n                var hash = _ref9.hash;\n                addTransaction(chainId, hash);\n                approved = true;\n                mockGas = true;\n              })[\"catch\"](function (error) {\n                if ((error === null || error === void 0 ? void 0 : error.code) !== 4001) {\n                  console.log(\"approve failed.\", error);\n                }\n              });\n\n            case 20:\n              if (!approved) {\n                _context4.next = 24;\n                break;\n              }\n\n              return _context4.abrupt(\"return\", innerSwap(deadline, mockGas, permit).then(function (_ref10) {\n                var hash = _ref10.hash;\n                addTransaction(chainId, hash);\n                dispatch({\n                  type: ActionType.TYPE,\n                  payload: {\n                    field: independentField,\n                    value: ''\n                  }\n                });\n                setSwapping(false);\n              }) // we don't do anything with the error here, innerSwap is responsible for handling it\n              [\"catch\"](function () {\n                setSwapping(false);\n              }));\n\n            case 24:\n              setSwapping(false);\n\n            case 25:\n            case \"end\":\n              return _context4.stop();\n          }\n        }\n      }, _callee2);\n    }));\n    return _swap.apply(this, arguments);\n  }\n\n  return __jsx(Stack, {\n    direction: \"column\",\n    align: \"center\",\n    spacing: \"6rem\",\n    flexGrow: 1,\n    justifyContent: \"center\",\n    px: \"2.5rem\",\n    py: \"8rem\",\n    shouldWrapChildren: true\n  }, __jsx(Stack, {\n    direction: \"row\",\n    align: \"flex-start\",\n    spacing: \"1rem\",\n    flexWrap: \"wrap\",\n    shouldWrapChildren: true\n  }, __jsx(SwapText, null, \"I want to\"), !!!trade ? __jsx(Link, _extends({}, modifyUrlObjectForIPFS({\n    pathname: buy ? '/sell' : '/buy',\n    query: _objectSpread(_objectSpread({}, (_tokens$Field$INPUT6 = tokens[Field.INPUT]) !== null && _tokens$Field$INPUT6 !== void 0 && _tokens$Field$INPUT6.address ? _defineProperty({}, QueryParameters.INPUT, (_tokens$Field$INPUT7 = tokens[Field.INPUT]) === null || _tokens$Field$INPUT7 === void 0 ? void 0 : _tokens$Field$INPUT7.address) : {}), (_tokens$Field$OUTPUT = tokens[Field.OUTPUT]) !== null && _tokens$Field$OUTPUT !== void 0 && _tokens$Field$OUTPUT.address ? _defineProperty({}, QueryParameters.OUTPUT, (_tokens$Field$OUTPUT2 = tokens[Field.OUTPUT]) === null || _tokens$Field$OUTPUT2 === void 0 ? void 0 : _tokens$Field$OUTPUT2.address) : {})\n  }), {\n    passHref: true\n  }), __jsx(Button, {\n    as: \"a\",\n    variant: \"ghost\",\n    variantColor: buy ? 'green' : 'red',\n    p: \"0.5rem\",\n    mt: \"-0.2rem\",\n    fontSize: \"3xl\",\n    lineHeight: 1,\n    height: \"min-content\"\n  }, buy ? 'Buy' : 'Sell')) : __jsx(Button, {\n    variant: \"solid\",\n    variantColor: !warning ? buy ? 'green' : 'red' : 'yellow',\n    p: \"0.75rem\",\n    mt: \"-0.45rem\",\n    fontSize: \"3xl\",\n    lineHeight: 1,\n    height: \"min-content\",\n    leftIcon: !warning ? undefined : !danger ? 'warning-2' : 'not-allowed',\n    isDisabled: !account || isInvalidBalance || isInvalidTrade,\n    isLoading: swapping,\n    cursor: warning ? 'not-allowed' : 'pointer',\n    onClick: swap\n  }, buy ? 'Buy' : 'Sell'), trade && independentField === (buy ? Field.INPUT : Field.OUTPUT) ? __jsx(SwapText, null, buy ? 'at least' : 'at most') : null, __jsx(AmountInput, {\n    controlled: independentField === (buy ? Field.OUTPUT : Field.INPUT),\n    isDisabled: showUSD || swapping,\n    isInvalid: isInvalidTrade || !buy && isInvalidBalance,\n    value: showUSD && USDAmountsFormatted[buy ? Field.OUTPUT : Field.INPUT] ? \"$\".concat(USDAmountsFormatted[buy ? Field.OUTPUT : Field.INPUT]) : formatted[buy ? Field.OUTPUT : Field.INPUT],\n    onChange: function onChange(value) {\n      dispatch({\n        type: ActionType.TYPE,\n        payload: {\n          field: buy ? Field.OUTPUT : Field.INPUT,\n          value: value\n        }\n      });\n    }\n  }), !buy && canMax ? __jsx(Button, {\n    size: \"sm\",\n    mt: \"0.3rem\",\n    onClick: function onClick() {\n      dispatch({\n        type: ActionType.TYPE,\n        payload: {\n          field: Field.INPUT,\n          value: balance === null || balance === void 0 ? void 0 : balance.toExact()\n        }\n      });\n    }\n  }, \"Max\") : null, __jsx(TokenSelect, {\n    tokenAddress: tokenAddresses[buy ? Field.OUTPUT : Field.INPUT].address,\n    isInvalid: isInvalidRoute,\n    isDisabled: swapping,\n    onAddressSelect: function onAddressSelect(address) {\n      dispatch({\n        type: ActionType.SELECT_TOKEN,\n        payload: {\n          field: buy ? Field.OUTPUT : Field.INPUT,\n          address: address\n        }\n      });\n    }\n  }), __jsx(SwapText, null, buy ? 'with' : 'for', trade && independentField === (buy ? Field.OUTPUT : Field.INPUT) ? buy ? ' at most' : ' at least' : ''), __jsx(AmountInput, {\n    controlled: independentField === (buy ? Field.INPUT : Field.OUTPUT),\n    isDisabled: showUSD || swapping,\n    isInvalid: isInvalidTrade || buy && isInvalidBalance,\n    value: showUSD && USDAmountsFormatted[buy ? Field.INPUT : Field.OUTPUT] ? \"$\".concat(USDAmountsFormatted[buy ? Field.INPUT : Field.OUTPUT]) : formatted[buy ? Field.INPUT : Field.OUTPUT],\n    onChange: function onChange(value) {\n      dispatch({\n        type: ActionType.TYPE,\n        payload: {\n          field: buy ? Field.INPUT : Field.OUTPUT,\n          value: value\n        }\n      });\n    }\n  }), buy && canMax ? __jsx(Button, {\n    size: \"sm\",\n    mt: \"0.3rem\",\n    onClick: function onClick() {\n      dispatch({\n        type: ActionType.TYPE,\n        payload: {\n          field: Field.INPUT,\n          value: balance === null || balance === void 0 ? void 0 : balance.toExact()\n        }\n      });\n    }\n  }, \"Max\") : null, __jsx(TokenSelect, {\n    tokenAddress: tokenAddresses[buy ? Field.INPUT : Field.OUTPUT].address,\n    isInvalid: isInvalidRoute,\n    isDisabled: swapping,\n    onAddressSelect: function onAddressSelect(address) {\n      dispatch({\n        type: ActionType.SELECT_TOKEN,\n        payload: {\n          field: buy ? Field.INPUT : Field.OUTPUT,\n          address: address\n        }\n      });\n    }\n  }), __jsx(SwapText, {\n    fontSize: \"3xl\",\n    lineHeight: 1,\n    pt: \"0.3rem\"\n  }, \".\")), __jsx(TradeSummary, {\n    route: route,\n    trade: trade,\n    warning: warning,\n    danger: danger\n  }));\n}","map":null,"metadata":{},"sourceType":"module"}