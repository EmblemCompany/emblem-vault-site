{"ast":null,"code":"import _objectWithoutProperties from \"@babel/runtime/helpers/esm/objectWithoutProperties\";\nimport _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport _regeneratorRuntime from \"@babel/runtime/regenerator\";\nimport _asyncToGenerator from \"@babel/runtime/helpers/esm/asyncToGenerator\";\nvar _excluded = [\"permitSelector\", \"getPermitData\", \"domain\"];\n\nvar _permitGatherers;\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nimport { ChainId } from '@uniswap/sdk';\nimport { splitSignature, hexDataSlice } from '@ethersproject/bytes';\nimport { PERMIT_AND_CALL_ADDRESS, MAX_UINT256 } from './constants';\nimport { Contract } from '@ethersproject/contracts';\nimport { id } from '@ethersproject/hash';\nimport { defaultAbiCoder } from '@ethersproject/abi';\nvar EIP712Domain = [{\n  name: 'name',\n  type: 'string'\n}, {\n  name: 'version',\n  type: 'string'\n}, {\n  name: 'chainId',\n  type: 'uint256'\n}, {\n  name: 'verifyingContract',\n  type: 'address'\n}];\n\nvar DAIPermitGatherer = /*#__PURE__*/function () {\n  var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(address, deadline, _, token, library) {\n    var Permit, domain, DAI, nonce, message, inputs;\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            Permit = [{\n              name: 'holder',\n              type: 'address'\n            }, {\n              name: 'spender',\n              type: 'address'\n            }, {\n              name: 'nonce',\n              type: 'uint256'\n            }, {\n              name: 'expiry',\n              type: 'uint256'\n            }, {\n              name: 'allowed',\n              type: 'bool'\n            }];\n            domain = {\n              name: 'Dai Stablecoin',\n              version: '1'\n            };\n            DAI = new Contract(token.address, ['function nonces(address holder) view returns (uint256 nonce)'], library);\n            _context.next = 5;\n            return DAI.nonces(address);\n\n          case 5:\n            nonce = _context.sent;\n            _context.t0 = address;\n            _context.t1 = PERMIT_AND_CALL_ADDRESS;\n            _context.next = 10;\n            return Promise.resolve(nonce.toNumber())[\"catch\"](function () {\n              return nonce.toString();\n            });\n\n          case 10:\n            _context.t2 = _context.sent;\n            _context.t3 = deadline;\n            message = {\n              holder: _context.t0,\n              spender: _context.t1,\n              nonce: _context.t2,\n              expiry: _context.t3,\n              allowed: true\n            };\n            inputs = ['address', 'address', 'uint256', 'uint256', 'bool', 'uint8', 'bytes32', 'bytes32'];\n            return _context.abrupt(\"return\", {\n              types: {\n                EIP712Domain: EIP712Domain,\n                Permit: Permit\n              },\n              domain: domain,\n              message: message,\n              permitSelector: hexDataSlice(id(\"permit(\".concat(inputs.join(','), \")\")), 0, 4),\n              getPermitData: function getPermitData(_ref2) {\n                var v = _ref2.v,\n                    r = _ref2.r,\n                    s = _ref2.s;\n                return defaultAbiCoder.encode(inputs, [address, PERMIT_AND_CALL_ADDRESS, nonce, deadline, true, v, r, s]);\n              }\n            });\n\n          case 15:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n\n  return function DAIPermitGatherer(_x, _x2, _x3, _x4, _x5) {\n    return _ref.apply(this, arguments);\n  };\n}();\n\nvar USDCPermitGatherer = /*#__PURE__*/function () {\n  var _ref3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(address, deadline, _, token, library) {\n    var Permit, domain, USDC, nonce, value, message, inputs;\n    return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            Permit = [{\n              name: 'owner',\n              type: 'address'\n            }, {\n              name: 'spender',\n              type: 'address'\n            }, {\n              name: 'value',\n              type: 'uint256'\n            }, {\n              name: 'nonce',\n              type: 'uint256'\n            }, {\n              name: 'deadline',\n              type: 'uint256'\n            }];\n            domain = {\n              name: 'USD Coin',\n              version: '2'\n            };\n            USDC = new Contract(token.address, ['function nonces(address owner) view returns (uint256 nonce)'], library);\n            _context2.next = 5;\n            return USDC.nonces(address);\n\n          case 5:\n            nonce = _context2.sent;\n            value = \"0x\".concat(MAX_UINT256.toString(16));\n            _context2.t0 = address;\n            _context2.t1 = PERMIT_AND_CALL_ADDRESS;\n            _context2.t2 = value;\n            _context2.next = 12;\n            return Promise.resolve(nonce.toNumber())[\"catch\"](function () {\n              return nonce.toString();\n            });\n\n          case 12:\n            _context2.t3 = _context2.sent;\n            _context2.t4 = deadline;\n            message = {\n              owner: _context2.t0,\n              spender: _context2.t1,\n              value: _context2.t2,\n              nonce: _context2.t3,\n              deadline: _context2.t4\n            };\n            inputs = ['address', 'address', 'uint256', 'uint256', 'uint8', 'bytes32', 'bytes32'];\n            return _context2.abrupt(\"return\", {\n              types: {\n                EIP712Domain: EIP712Domain,\n                Permit: Permit\n              },\n              domain: domain,\n              message: message,\n              permitSelector: hexDataSlice(id(\"permit(\".concat(inputs.join(','), \")\")), 0, 4),\n              getPermitData: function getPermitData(_ref4) {\n                var v = _ref4.v,\n                    r = _ref4.r,\n                    s = _ref4.s;\n                return defaultAbiCoder.encode(inputs, [address, PERMIT_AND_CALL_ADDRESS, value, deadline, v, r, s]);\n              }\n            });\n\n          case 17:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee2);\n  }));\n\n  return function USDCPermitGatherer(_x6, _x7, _x8, _x9, _x10) {\n    return _ref3.apply(this, arguments);\n  };\n}();\n\nvar permitGatherers = (_permitGatherers = {}, _defineProperty(_permitGatherers, ChainId.MAINNET, {\n  '0x6B175474E89094C44Da98b954EedeAC495271d0F': DAIPermitGatherer,\n  '0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48': USDCPermitGatherer\n}), _defineProperty(_permitGatherers, ChainId.KOVAN, {\n  '0x4F96Fe3b7A6Cf9725f59d353F723c1bDb64CA6Aa': DAIPermitGatherer\n}), _permitGatherers);\nexport function canPermit(token) {\n  var _permitGatherers$toke;\n\n  return !token ? false : !!((_permitGatherers$toke = permitGatherers[token.chainId]) !== null && _permitGatherers$toke !== void 0 && _permitGatherers$toke[token.address]);\n}\nexport function gatherPermit(_x11, _x12, _x13, _x14, _x15) {\n  return _gatherPermit.apply(this, arguments);\n}\n\nfunction _gatherPermit() {\n  _gatherPermit = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(address, deadline, approveMax, token, library) {\n    var _yield$permitGatherer, permitSelector, getPermitData, domain, data, signature;\n\n    return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n      while (1) {\n        switch (_context3.prev = _context3.next) {\n          case 0:\n            _context3.next = 2;\n            return permitGatherers[token.chainId][token.address](address, deadline, approveMax, token, library);\n\n          case 2:\n            _yield$permitGatherer = _context3.sent;\n            permitSelector = _yield$permitGatherer.permitSelector;\n            getPermitData = _yield$permitGatherer.getPermitData;\n            domain = _yield$permitGatherer.domain;\n            data = _objectWithoutProperties(_yield$permitGatherer, _excluded);\n            _context3.next = 9;\n            return library.send('eth_signTypedData_v4', [address, JSON.stringify(_objectSpread(_objectSpread({}, data), {}, {\n              domain: _objectSpread(_objectSpread({}, domain), {}, {\n                chainId: token.chainId,\n                verifyingContract: token.address\n              }),\n              primaryType: 'Permit'\n            }))]).then(splitSignature);\n\n          case 9:\n            signature = _context3.sent;\n            return _context3.abrupt(\"return\", {\n              permitSelector: permitSelector,\n              permitData: getPermitData(signature)\n            });\n\n          case 11:\n          case \"end\":\n            return _context3.stop();\n        }\n      }\n    }, _callee3);\n  }));\n  return _gatherPermit.apply(this, arguments);\n}","map":null,"metadata":{},"sourceType":"module"}