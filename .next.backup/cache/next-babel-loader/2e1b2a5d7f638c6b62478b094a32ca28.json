{"ast":null,"code":"import React from \"react\";\nvar __jsx = React.createElement;\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport { useReducer, useState, useEffect } from 'react';\nimport { useRouter } from 'next/router';\nimport Link from 'next/link';\nimport { useWeb3React } from '@web3-react/core';\nimport { parseUnits } from '@ethersproject/units';\nimport { Contract } from '@ethersproject/contracts';\nimport { BigNumber } from '@ethersproject/bignumber';\nimport { TradeType, TokenAmount, JSBI, WETH, Percent } from '@uniswap/sdk';\nimport { hexDataSlice } from '@ethersproject/bytes';\nimport { id } from '@ethersproject/hash';\nimport { defaultAbiCoder } from '@ethersproject/abi';\nimport IERC20 from '@uniswap/v2-core/build/IERC20.json';\nimport { abi as IUniswapV2Router02ABI } from '@uniswap/v2-periphery/build/IUniswapV2Router02.json';\nimport { Stack, Button, Text } from '@chakra-ui/core';\nimport AmountInput from '../components/AmountInput';\nimport TokenSelect from '../components/TokenSelect';\nimport { useTokenByAddressAndAutomaticallyAdd } from '../tokens';\nimport { useRoute, useContract, useQueryParameters, useTrade, useUSDTokenPrice } from '../hooks';\nimport { useTokenBalance, useTokenAllowance, useETHBalance } from '../data';\nimport { ROUTER_ADDRESS, ZERO, MAX_UINT256, QueryParameters, PERMIT_AND_CALL_ADDRESS, GAS_LIMIT_WHEN_MOCKING } from '../constants';\nimport { useSlippage, useDeadline, useApproveMax, useTransactions, useFirstToken, useSecondToken, useShowUSD } from '../context';\nimport TradeSummary from '../components/TradeSummary';\nimport { canPermit, gatherPermit } from '../permits';\nimport { modifyUrlObjectForIPFS } from '../utils';\nvar Field;\n\n(function (Field) {\n  Field[Field[\"INPUT\"] = 0] = \"INPUT\";\n  Field[Field[\"OUTPUT\"] = 1] = \"OUTPUT\";\n})(Field || (Field = {}));\n\nfunction initializeSentenceState(partialState) {\n  var _partialState$Field$I, _partialState$Field$O;\n\n  return {\n    independentField: partialState.independentField,\n    value: '',\n    [Field.INPUT]: {\n      address: (_partialState$Field$I = partialState[Field.INPUT]) === null || _partialState$Field$I === void 0 ? void 0 : _partialState$Field$I.address\n    },\n    [Field.OUTPUT]: {\n      address: (_partialState$Field$O = partialState[Field.OUTPUT]) === null || _partialState$Field$O === void 0 ? void 0 : _partialState$Field$O.address\n    }\n  };\n}\n\nvar ActionType;\n\n(function (ActionType) {\n  ActionType[ActionType[\"SELECT_TOKEN\"] = 0] = \"SELECT_TOKEN\";\n  ActionType[ActionType[\"TYPE\"] = 1] = \"TYPE\";\n  ActionType[ActionType[\"RESET\"] = 2] = \"RESET\";\n})(ActionType || (ActionType = {}));\n\nfunction reducer(state, action) {\n  switch (action.type) {\n    case ActionType.SELECT_TOKEN:\n      {\n        const {\n          field,\n          address\n        } = action.payload;\n\n        if (!!address && address === state[field === Field.INPUT ? Field.OUTPUT : Field.INPUT].address) {\n          return _objectSpread(_objectSpread({}, state), {}, {\n            value: '',\n            [Field.INPUT]: state[Field.OUTPUT],\n            [Field.OUTPUT]: state[Field.INPUT]\n          });\n        } else {\n          return _objectSpread(_objectSpread({}, state), {}, {\n            [field]: {\n              address\n            }\n          });\n        }\n      }\n\n    case ActionType.TYPE:\n      {\n        const {\n          field,\n          value\n        } = action.payload;\n        return _objectSpread(_objectSpread({}, state), {}, {\n          independentField: field,\n          value\n        });\n      }\n\n    case ActionType.RESET:\n      {\n        const {\n          field\n        } = action.payload;\n        return initializeSentenceState({\n          independentField: field\n        });\n      }\n  }\n}\n\nfunction SwapText(_ref) {\n  let {\n    children\n  } = _ref,\n      rest = _objectWithoutProperties(_ref, [\"children\"]);\n\n  return __jsx(Text, _extends({\n    fontSize: \"3xl\",\n    lineHeight: 1,\n    py: \"0.3rem\"\n  }, rest), children);\n}\n\nexport default function Swap({\n  buy\n}) {\n  var _tokens$Field$INPUT, _tokens$Field$INPUT2, _ref2, _tokens$Field$INPUT3, _formatted$Field$INPU, _tokens$Field$INPUT4, _tokens$Field$INPUT5, _tokens$Field$INPUT6, _tokens$Field$OUTPUT, _tokens$Field$OUTPUT2;\n\n  const {\n    query,\n    pathname,\n    replace\n  } = useRouter();\n  const queryParameters = useQueryParameters();\n  const {\n    account,\n    chainId,\n    library\n  } = useWeb3React();\n  const [approveMax] = useApproveMax();\n  const [deadlineDelta] = useDeadline();\n  const [slippage] = useSlippage();\n  const [, {\n    addTransaction\n  }] = useTransactions(); // reducer state\n\n  const {\n    0: state,\n    1: dispatch\n  } = useReducer(reducer, {\n    independentField: buy ? Field.OUTPUT : Field.INPUT,\n    [Field.INPUT]: {\n      address: queryParameters[QueryParameters.INPUT]\n    },\n    [Field.OUTPUT]: {\n      address: queryParameters[QueryParameters.OUTPUT]\n    }\n  }, initializeSentenceState);\n\n  const {\n    independentField,\n    value\n  } = state,\n        tokenAddresses = _objectWithoutProperties(state, [\"independentField\", \"value\"]); // derived state\n\n\n  const dependentField = independentField === Field.INPUT ? Field.OUTPUT : Field.INPUT;\n  const tradeType = independentField === Field.INPUT ? TradeType.EXACT_INPUT : TradeType.EXACT_OUTPUT; // sdk tokens\n\n  const tokens = {\n    [Field.INPUT]: useTokenByAddressAndAutomaticallyAdd(tokenAddresses[Field.INPUT].address),\n    [Field.OUTPUT]: useTokenByAddressAndAutomaticallyAdd(tokenAddresses[Field.OUTPUT].address)\n  }; // keep global token state in sync\n\n  const [, setFirstToken] = useFirstToken();\n  const [, setSecondToken] = useSecondToken();\n  useEffect(() => {\n    setFirstToken(tokens[buy ? Field.OUTPUT : Field.INPUT]);\n    setSecondToken(tokens[buy ? Field.INPUT : Field.OUTPUT]);\n  }); // sdk route\n\n  const [naiveRoute, allPairs] = useRoute(tokens[Field.INPUT], tokens[Field.OUTPUT]); // parse user value\n\n  const parsed = {};\n\n  if (value !== '' && value !== '.' && tokens[independentField]) {\n    try {\n      var _tokens$independentFi;\n\n      const valueParsed = parseUnits(value, (_tokens$independentFi = tokens[independentField]) === null || _tokens$independentFi === void 0 ? void 0 : _tokens$independentFi.decimals).toString();\n\n      if (valueParsed !== '0') {\n        parsed[independentField] = new TokenAmount(tokens[independentField], valueParsed);\n      }\n    } catch {// should only fail if the user specifies too many decimal places of precision (or maybe exceed max uint?)\n    }\n  } // sdk trade\n\n\n  const trade = useTrade(tokens[Field.INPUT], tokens[Field.OUTPUT], allPairs, parsed[independentField], tradeType);\n  const route = trade ? trade.route : naiveRoute; // populate the parsed dependent field\n\n  if (trade) {\n    if (tradeType === TradeType.EXACT_INPUT) {\n      parsed[dependentField] = trade.minimumAmountOut(new Percent(`${slippage}`, `${10000}`));\n    } else {\n      parsed[dependentField] = trade.maximumAmountIn(new Percent(`${slippage}`, `${10000}`));\n    }\n  } // usd values\n\n\n  const [showUSD] = useShowUSD();\n  const USDPrices = {\n    [Field.INPUT]: useUSDTokenPrice(tokens[Field.INPUT]),\n    [Field.OUTPUT]: useUSDTokenPrice(tokens[Field.OUTPUT])\n  };\n  const USDAmountsFormatted = {\n    [Field.INPUT]: parsed[Field.INPUT] && USDPrices[Field.INPUT] ? parsed[Field.INPUT].multiply(USDPrices[Field.INPUT]).toFixed(2, {\n      groupSeparator: ','\n    }) : undefined,\n    [Field.OUTPUT]: parsed[Field.OUTPUT] && USDPrices[Field.OUTPUT] ? parsed[Field.OUTPUT].multiply(USDPrices[Field.OUTPUT]).toFixed(2, {\n      groupSeparator: ','\n    }) : undefined\n  }; // calculate the formatted values from the parsed\n\n  const formatted = {\n    [independentField]: value,\n    [dependentField]: parsed[dependentField] ? parsed[dependentField].toSignificant(4, {\n      groupSeparator: ','\n    }) : ''\n  }; // reset when the network changes\n\n  useEffect(() => {\n    if (typeof chainId === 'number') {\n      return () => {\n        dispatch({\n          type: ActionType.RESET,\n          payload: {\n            field: buy ? Field.OUTPUT : Field.INPUT\n          }\n        });\n      };\n    }\n  }, [chainId, buy]); // clear url params\n\n  useEffect(() => {\n    if (Object.keys(query).length > 0) {\n      const {\n        href,\n        as\n      } = modifyUrlObjectForIPFS(pathname);\n      replace(href, as, {\n        shallow: true\n      });\n    }\n  }); // get input allowance for validation purposes\n\n  const {\n    data: _allowance\n  } = useTokenAllowance(tokens[Field.INPUT], account, ROUTER_ADDRESS);\n  const allowance = ((_tokens$Field$INPUT = tokens[Field.INPUT]) === null || _tokens$Field$INPUT === void 0 ? void 0 : _tokens$Field$INPUT.equals(WETH[tokens[Field.INPUT].chainId])) ? new TokenAmount(WETH[tokens[Field.INPUT].chainId], MAX_UINT256) : _allowance; // get permitAndCall allowance if the input token supports permit\n\n  const {\n    data: permitAndCallAllowance\n  } = useTokenAllowance(canPermit(tokens[Field.INPUT]) ? tokens[Field.INPUT] : undefined, account, PERMIT_AND_CALL_ADDRESS); // get input balance for validation purposes\n\n  const ETHBalance = useETHBalance(account);\n\n  const _balance = useTokenBalance(tokens[Field.INPUT], account);\n\n  const balance = ((_tokens$Field$INPUT2 = tokens[Field.INPUT]) === null || _tokens$Field$INPUT2 === void 0 ? void 0 : _tokens$Field$INPUT2.equals(WETH[(_ref2 = tokens[Field.INPUT]) === null || _ref2 === void 0 ? void 0 : _ref2.chainId])) ? ETHBalance.data : _balance.data; // compute flags for warning states\n\n  const warning = !!trade && Number.parseFloat(trade.slippage.toSignificant(2)) >= 5;\n  const danger = !!trade && Number.parseFloat(trade.slippage.toSignificant(2)) >= 10; // compute validation flags\n\n  const isInvalidBalance = parsed[Field.INPUT] && balance ? JSBI.greaterThan(parsed[Field.INPUT].raw, balance.raw) : false;\n  const isInvalidRoute = route === null && value.length > 0;\n  const isInvalidTrade = route && parsed[independentField] ? !!!trade : false; // compute flag for whether maxing is allowed\n\n  const canMax = !((_tokens$Field$INPUT3 = tokens[Field.INPUT]) === null || _tokens$Field$INPUT3 === void 0 ? void 0 : _tokens$Field$INPUT3.equals(WETH[tokens[Field.INPUT].chainId])) && !isInvalidRoute && ((_formatted$Field$INPU = formatted[Field.INPUT]) === null || _formatted$Field$INPU === void 0 ? void 0 : _formatted$Field$INPU.length) === 0 && !!balance && JSBI.greaterThan(balance.raw, ZERO); // function to perform the swap\n\n  const {\n    0: swapping,\n    1: setSwapping\n  } = useState(false);\n  const inputToken = useContract((_tokens$Field$INPUT4 = tokens[Field.INPUT]) === null || _tokens$Field$INPUT4 === void 0 ? void 0 : _tokens$Field$INPUT4.address, IERC20.abi, true);\n  const router = useContract(ROUTER_ADDRESS, IUniswapV2Router02ABI, true);\n\n  async function swap() {\n    setSwapping(true);\n\n    async function innerSwap(deadline, mockGas = false, permit) {\n      let routerFunctionNames;\n      let routerArguments; // eslint-disable-line @typescript-eslint/no-explicit-any\n\n      let value = 0;\n\n      if ((trade === null || trade === void 0 ? void 0 : trade.tradeType) === TradeType.EXACT_INPUT) {\n        if (tokens[Field.INPUT].equals(WETH[tokens[Field.INPUT].chainId])) {\n          routerFunctionNames = ['swapExactETHForTokens', 'swapExactETHForTokensSupportingFeeOnTransferTokens'];\n          routerArguments = [`0x${parsed[Field.OUTPUT].raw.toString(16)}`, route.path.map(token => token.address), account, deadline];\n          value = `0x${parsed[Field.INPUT].raw.toString(16)}`;\n        } else if (tokens[Field.OUTPUT].equals(WETH[tokens[Field.OUTPUT].chainId])) {\n          routerFunctionNames = ['swapExactTokensForETH', 'swapExactTokensForETHSupportingFeeOnTransferTokens'];\n          routerArguments = [`0x${parsed[Field.INPUT].raw.toString(16)}`, `0x${parsed[Field.OUTPUT].raw.toString(16)}`, route.path.map(token => token.address), account, deadline];\n        } else {\n          routerFunctionNames = ['swapExactTokensForTokens', 'swapExactTokensForTokensSupportingFeeOnTransferTokens'];\n          routerArguments = [`0x${parsed[Field.INPUT].raw.toString(16)}`, `0x${parsed[Field.OUTPUT].raw.toString(16)}`, route.path.map(token => token.address), account, deadline];\n        }\n      } else {\n        if (tokens[Field.INPUT].equals(WETH[tokens[Field.INPUT].chainId])) {\n          routerFunctionNames = ['swapETHForExactTokens'];\n          routerArguments = [`0x${parsed[Field.OUTPUT].raw.toString(16)}`, route.path.map(token => token.address), account, deadline];\n          value = `0x${parsed[Field.INPUT].raw.toString(16)}`;\n        } else if (tokens[Field.OUTPUT].equals(WETH[tokens[Field.OUTPUT].chainId])) {\n          routerFunctionNames = ['swapTokensForExactETH'];\n          routerArguments = [`0x${parsed[Field.OUTPUT].raw.toString(16)}`, `0x${parsed[Field.INPUT].raw.toString(16)}`, route.path.map(token => token.address), account, deadline];\n        } else {\n          routerFunctionNames = ['swapTokensForExactTokens'];\n          routerArguments = [`0x${parsed[Field.OUTPUT].raw.toString(16)}`, `0x${parsed[Field.INPUT].raw.toString(16)}`, route.path.map(token => token.address), account, deadline];\n        }\n      } // we have an approve tx pending\n\n\n      if (mockGas) {\n        // because we can't estimate gas, as it will fail b/c of the approve, we are forced to use the first function\n        const routerFunctionName = routerFunctionNames[0];\n        return await router[routerFunctionName](...routerArguments, {\n          value,\n          gasLimit: GAS_LIMIT_WHEN_MOCKING\n        }).catch(error => {\n          if ((error === null || error === void 0 ? void 0 : error.code) !== 4001) {\n            console.log(`${routerFunctionName} failed with a mocked gas limit.`, error);\n          }\n\n          throw error;\n        });\n      } // we have permit data\n\n\n      if (permit) {\n        const permitAndCall = new Contract(PERMIT_AND_CALL_ADDRESS, ['function permitAndCall(address token, uint256 value, bytes4 permitSelector, bytes calldata permitData, bytes4 routerFunctionSelector, bytes calldata routerFunctionData)'], library.getSigner(account).connectUnchecked()); // try to get a gas limit for each function name in turn\n\n        for (const routerFunctionName of routerFunctionNames) {\n          const routerFunctionFragment = router.interface.fragments.filter(({\n            name\n          }) => name === routerFunctionName)[0];\n          const routerFunctionSelector = hexDataSlice(id(`${routerFunctionName}(${routerFunctionFragment === null || routerFunctionFragment === void 0 ? void 0 : routerFunctionFragment.inputs.map(({\n            type\n          }) => type).join(',')})`), 0, 4);\n          const permitAndCallArguments = [tokens[Field.INPUT].address, `0x${parsed[Field.INPUT].raw.toString(16)}`, permit.permitSelector, permit.permitData, routerFunctionSelector, defaultAbiCoder.encode(routerFunctionFragment.inputs, routerArguments)];\n          const gasLimit = await permitAndCall.estimateGas.permitAndCall(...permitAndCallArguments, {\n            value\n          }).then(gasLimit => gasLimit.mul(105).div(100)).catch(error => {\n            console.log(`estimateGas failed for ${routerFunctionName} via permitAndCall.`, error);\n          });\n\n          if (BigNumber.isBigNumber(gasLimit)) {\n            return await permitAndCall.permitAndCall(...permitAndCallArguments, {\n              value,\n              gasLimit\n            }).catch(error => {\n              if ((error === null || error === void 0 ? void 0 : error.code) !== 4001) {\n                console.log(`${routerFunctionName} failed via permitAndCall.`, error);\n              }\n\n              throw error;\n            });\n          }\n        } // if we're here, it means all estimateGas calls failed\n\n\n        console.log(routerFunctionNames.length === 1 ? \"If you're trying to swap a token that takes a transfer fee, you must specify an exact input amount.\" : \"If you're trying to swap a token that takes a transfer fee, ensure your slippage tolerance is higher than the fee.\");\n        throw Error();\n      } // try to get a gas limit for each function name in turn\n\n\n      for (const routerFunctionName of routerFunctionNames) {\n        const gasLimit = await router.estimateGas[routerFunctionName](...routerArguments, {\n          value\n        }).then(gasLimit => gasLimit.mul(105).div(100)).catch(error => {\n          console.log(`estimateGas failed for ${routerFunctionName}.`, error);\n        });\n\n        if (BigNumber.isBigNumber(gasLimit)) {\n          return await router[routerFunctionName](...routerArguments, {\n            value,\n            gasLimit\n          }).catch(error => {\n            if ((error === null || error === void 0 ? void 0 : error.code) !== 4001) {\n              console.log(`${routerFunctionName} failed.`, error);\n            }\n\n            throw error;\n          });\n        }\n      } // if we're here, it means all estimateGas calls failed\n\n\n      console.log(routerFunctionNames.length === 1 ? \"If you're trying to swap a token that takes a transfer fee, you must specify an exact input amount.\" : \"If you're trying to swap a token that takes a transfer fee, ensure your slippage tolerance is higher than the fee.\");\n      throw Error();\n    }\n\n    const deadline = Math.floor(Date.now() / 1000) + deadlineDelta;\n    let approved = JSBI.greaterThanOrEqual(allowance.raw, parsed[Field.INPUT].raw);\n    let mockGas = false;\n    let permit;\n\n    if (!approved) {\n      let tryToManuallyApprove = true; // attempt to gather a permit signature where possible\n\n      if (canPermit(tokens[Field.INPUT])) {\n        // in the slightly weird case where the user has already approved PermitAndCall, just fake the permit\n        if (permitAndCallAllowance && JSBI.greaterThanOrEqual(permitAndCallAllowance.raw, parsed[Field.INPUT].raw)) {\n          approved = true;\n          tryToManuallyApprove = false;\n          permit = {\n            permitSelector: '0x00000000',\n            permitData: '0x'\n          };\n        } else {\n          await gatherPermit(account, deadline, approveMax, tokens[Field.INPUT], library).then(gatheredPermit => {\n            approved = true;\n            tryToManuallyApprove = false;\n            permit = gatheredPermit;\n          }).catch(error => {\n            // if the error code is 4001 (EIP-1193 user rejected request), we don't want to try a manual approve\n            if ((error === null || error === void 0 ? void 0 : error.code) === 4001) {\n              tryToManuallyApprove = false;\n            } else {\n              console.log(`permit failed.`, error);\n            }\n          });\n        }\n      }\n\n      if (tryToManuallyApprove) {\n        await inputToken.approve(ROUTER_ADDRESS, `0x${(approveMax ? MAX_UINT256 : parsed[Field.INPUT].raw).toString(16)}`).then(({\n          hash\n        }) => {\n          addTransaction(chainId, hash);\n          approved = true;\n          mockGas = true;\n        }).catch(error => {\n          if ((error === null || error === void 0 ? void 0 : error.code) !== 4001) {\n            console.log(`approve failed.`, error);\n          }\n        });\n      }\n    }\n\n    if (approved) {\n      return innerSwap(deadline, mockGas, permit).then(({\n        hash\n      }) => {\n        addTransaction(chainId, hash);\n        dispatch({\n          type: ActionType.TYPE,\n          payload: {\n            field: independentField,\n            value: ''\n          }\n        });\n        setSwapping(false);\n      }) // we don't do anything with the error here, innerSwap is responsible for handling it\n      .catch(() => {\n        setSwapping(false);\n      });\n    } else {\n      setSwapping(false);\n    }\n  }\n\n  return __jsx(Stack, {\n    direction: \"column\",\n    align: \"center\",\n    spacing: \"6rem\",\n    flexGrow: 1,\n    justifyContent: \"center\",\n    px: \"2.5rem\",\n    py: \"8rem\",\n    shouldWrapChildren: true\n  }, __jsx(Stack, {\n    direction: \"row\",\n    align: \"flex-start\",\n    spacing: \"1rem\",\n    flexWrap: \"wrap\",\n    shouldWrapChildren: true\n  }, __jsx(SwapText, null, \"I want to\"), !!!trade ? __jsx(Link, _extends({}, modifyUrlObjectForIPFS({\n    pathname: buy ? '/sell' : '/buy',\n    query: _objectSpread(_objectSpread({}, ((_tokens$Field$INPUT5 = tokens[Field.INPUT]) === null || _tokens$Field$INPUT5 === void 0 ? void 0 : _tokens$Field$INPUT5.address) ? {\n      [QueryParameters.INPUT]: (_tokens$Field$INPUT6 = tokens[Field.INPUT]) === null || _tokens$Field$INPUT6 === void 0 ? void 0 : _tokens$Field$INPUT6.address\n    } : {}), ((_tokens$Field$OUTPUT = tokens[Field.OUTPUT]) === null || _tokens$Field$OUTPUT === void 0 ? void 0 : _tokens$Field$OUTPUT.address) ? {\n      [QueryParameters.OUTPUT]: (_tokens$Field$OUTPUT2 = tokens[Field.OUTPUT]) === null || _tokens$Field$OUTPUT2 === void 0 ? void 0 : _tokens$Field$OUTPUT2.address\n    } : {})\n  }), {\n    passHref: true\n  }), __jsx(Button, {\n    as: \"a\",\n    variant: \"ghost\",\n    variantColor: buy ? 'green' : 'red',\n    p: \"0.5rem\",\n    mt: \"-0.2rem\",\n    fontSize: \"3xl\",\n    lineHeight: 1,\n    height: \"min-content\"\n  }, buy ? 'Buy' : 'Sell')) : __jsx(Button, {\n    variant: \"solid\",\n    variantColor: !warning ? buy ? 'green' : 'red' : 'yellow',\n    p: \"0.75rem\",\n    mt: \"-0.45rem\",\n    fontSize: \"3xl\",\n    lineHeight: 1,\n    height: \"min-content\",\n    leftIcon: !warning ? undefined : !danger ? 'warning-2' : 'not-allowed',\n    isDisabled: !account || isInvalidBalance || isInvalidTrade,\n    isLoading: swapping,\n    cursor: warning ? 'not-allowed' : 'pointer',\n    onClick: swap\n  }, buy ? 'Buy' : 'Sell'), trade && independentField === (buy ? Field.INPUT : Field.OUTPUT) ? __jsx(SwapText, null, buy ? 'at least' : 'at most') : null, __jsx(AmountInput, {\n    controlled: independentField === (buy ? Field.OUTPUT : Field.INPUT),\n    isDisabled: showUSD || swapping,\n    isInvalid: isInvalidTrade || !buy && isInvalidBalance,\n    value: showUSD && USDAmountsFormatted[buy ? Field.OUTPUT : Field.INPUT] ? `$${USDAmountsFormatted[buy ? Field.OUTPUT : Field.INPUT]}` : formatted[buy ? Field.OUTPUT : Field.INPUT],\n    onChange: value => {\n      dispatch({\n        type: ActionType.TYPE,\n        payload: {\n          field: buy ? Field.OUTPUT : Field.INPUT,\n          value\n        }\n      });\n    }\n  }), !buy && canMax ? __jsx(Button, {\n    size: \"sm\",\n    mt: \"0.3rem\",\n    onClick: () => {\n      dispatch({\n        type: ActionType.TYPE,\n        payload: {\n          field: Field.INPUT,\n          value: balance === null || balance === void 0 ? void 0 : balance.toExact()\n        }\n      });\n    }\n  }, \"Max\") : null, __jsx(TokenSelect, {\n    tokenAddress: tokenAddresses[buy ? Field.OUTPUT : Field.INPUT].address,\n    isInvalid: isInvalidRoute,\n    isDisabled: swapping,\n    onAddressSelect: address => {\n      dispatch({\n        type: ActionType.SELECT_TOKEN,\n        payload: {\n          field: buy ? Field.OUTPUT : Field.INPUT,\n          address\n        }\n      });\n    }\n  }), __jsx(SwapText, null, buy ? 'with' : 'for', trade && independentField === (buy ? Field.OUTPUT : Field.INPUT) ? buy ? ' at most' : ' at least' : ''), __jsx(AmountInput, {\n    controlled: independentField === (buy ? Field.INPUT : Field.OUTPUT),\n    isDisabled: showUSD || swapping,\n    isInvalid: isInvalidTrade || buy && isInvalidBalance,\n    value: showUSD && USDAmountsFormatted[buy ? Field.INPUT : Field.OUTPUT] ? `$${USDAmountsFormatted[buy ? Field.INPUT : Field.OUTPUT]}` : formatted[buy ? Field.INPUT : Field.OUTPUT],\n    onChange: value => {\n      dispatch({\n        type: ActionType.TYPE,\n        payload: {\n          field: buy ? Field.INPUT : Field.OUTPUT,\n          value\n        }\n      });\n    }\n  }), buy && canMax ? __jsx(Button, {\n    size: \"sm\",\n    mt: \"0.3rem\",\n    onClick: () => {\n      dispatch({\n        type: ActionType.TYPE,\n        payload: {\n          field: Field.INPUT,\n          value: balance === null || balance === void 0 ? void 0 : balance.toExact()\n        }\n      });\n    }\n  }, \"Max\") : null, __jsx(TokenSelect, {\n    tokenAddress: tokenAddresses[buy ? Field.INPUT : Field.OUTPUT].address,\n    isInvalid: isInvalidRoute,\n    isDisabled: swapping,\n    onAddressSelect: address => {\n      dispatch({\n        type: ActionType.SELECT_TOKEN,\n        payload: {\n          field: buy ? Field.INPUT : Field.OUTPUT,\n          address\n        }\n      });\n    }\n  }), __jsx(SwapText, {\n    fontSize: \"3xl\",\n    lineHeight: 1,\n    pt: \"0.3rem\"\n  }, \".\")), __jsx(TradeSummary, {\n    route: route,\n    trade: trade,\n    warning: warning,\n    danger: danger\n  }));\n}","map":null,"metadata":{},"sourceType":"module"}