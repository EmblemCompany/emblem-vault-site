{"ast":null,"code":"function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\nimport { ChainId } from '@uniswap/sdk';\nimport { splitSignature, hexDataSlice } from '@ethersproject/bytes';\nimport { PERMIT_AND_CALL_ADDRESS, MAX_UINT256 } from './constants';\nimport { Contract } from '@ethersproject/contracts';\nimport { id } from '@ethersproject/hash';\nimport { defaultAbiCoder } from '@ethersproject/abi';\nconst EIP712Domain = [{\n  name: 'name',\n  type: 'string'\n}, {\n  name: 'version',\n  type: 'string'\n}, {\n  name: 'chainId',\n  type: 'uint256'\n}, {\n  name: 'verifyingContract',\n  type: 'address'\n}];\n\nconst DAIPermitGatherer = async (address, deadline, _, token, library) => {\n  const Permit = [{\n    name: 'holder',\n    type: 'address'\n  }, {\n    name: 'spender',\n    type: 'address'\n  }, {\n    name: 'nonce',\n    type: 'uint256'\n  }, {\n    name: 'expiry',\n    type: 'uint256'\n  }, {\n    name: 'allowed',\n    type: 'bool'\n  }];\n  const domain = {\n    name: 'Dai Stablecoin',\n    version: '1'\n  };\n  const DAI = new Contract(token.address, ['function nonces(address holder) view returns (uint256 nonce)'], library);\n  const nonce = await DAI.nonces(address);\n  const message = {\n    holder: address,\n    spender: PERMIT_AND_CALL_ADDRESS,\n    nonce: await Promise.resolve(nonce.toNumber()).catch(() => nonce.toString()),\n    expiry: deadline,\n    allowed: true\n  };\n  const inputs = ['address', 'address', 'uint256', 'uint256', 'bool', 'uint8', 'bytes32', 'bytes32'];\n  return {\n    types: {\n      EIP712Domain,\n      Permit\n    },\n    domain,\n    message,\n    permitSelector: hexDataSlice(id(`permit(${inputs.join(',')})`), 0, 4),\n    getPermitData: ({\n      v,\n      r,\n      s\n    }) => defaultAbiCoder.encode(inputs, [address, PERMIT_AND_CALL_ADDRESS, nonce, deadline, true, v, r, s])\n  };\n};\n\nconst USDCPermitGatherer = async (address, deadline, _, token, library) => {\n  const Permit = [{\n    name: 'owner',\n    type: 'address'\n  }, {\n    name: 'spender',\n    type: 'address'\n  }, {\n    name: 'value',\n    type: 'uint256'\n  }, {\n    name: 'nonce',\n    type: 'uint256'\n  }, {\n    name: 'deadline',\n    type: 'uint256'\n  }];\n  const domain = {\n    name: 'USD Coin',\n    version: '2'\n  };\n  const USDC = new Contract(token.address, ['function nonces(address owner) view returns (uint256 nonce)'], library);\n  const nonce = await USDC.nonces(address);\n  const value = `0x${MAX_UINT256.toString(16)}`;\n  const message = {\n    owner: address,\n    spender: PERMIT_AND_CALL_ADDRESS,\n    value,\n    nonce: await Promise.resolve(nonce.toNumber()).catch(() => nonce.toString()),\n    deadline\n  };\n  const inputs = ['address', 'address', 'uint256', 'uint256', 'uint8', 'bytes32', 'bytes32'];\n  return {\n    types: {\n      EIP712Domain,\n      Permit\n    },\n    domain,\n    message,\n    permitSelector: hexDataSlice(id(`permit(${inputs.join(',')})`), 0, 4),\n    getPermitData: ({\n      v,\n      r,\n      s\n    }) => defaultAbiCoder.encode(inputs, [address, PERMIT_AND_CALL_ADDRESS, value, deadline, v, r, s])\n  };\n};\n\nconst permitGatherers = {\n  [ChainId.MAINNET]: {\n    '0x6B175474E89094C44Da98b954EedeAC495271d0F': DAIPermitGatherer,\n    '0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48': USDCPermitGatherer\n  },\n  [ChainId.KOVAN]: {\n    '0x4F96Fe3b7A6Cf9725f59d353F723c1bDb64CA6Aa': DAIPermitGatherer\n  }\n};\nexport function canPermit(token) {\n  var _permitGatherers$toke;\n\n  return !token ? false : !!((_permitGatherers$toke = permitGatherers[token.chainId]) === null || _permitGatherers$toke === void 0 ? void 0 : _permitGatherers$toke[token.address]);\n}\nexport async function gatherPermit(address, deadline, approveMax, token, library) {\n  const _await$permitGatherer = await permitGatherers[token.chainId][token.address](address, deadline, approveMax, token, library),\n        {\n    permitSelector,\n    getPermitData,\n    domain\n  } = _await$permitGatherer,\n        data = _objectWithoutProperties(_await$permitGatherer, [\"permitSelector\", \"getPermitData\", \"domain\"]);\n\n  const signature = await library.send('eth_signTypedData_v4', [address, JSON.stringify(_objectSpread(_objectSpread({}, data), {}, {\n    domain: _objectSpread(_objectSpread({}, domain), {}, {\n      chainId: token.chainId,\n      verifyingContract: token.address\n    }),\n    primaryType: 'Permit'\n  }))]).then(splitSignature);\n  return {\n    permitSelector,\n    permitData: getPermitData(signature)\n  };\n}","map":{"version":3,"sources":["/Users/shannoncode/repo/Emblem.Currentwork/emblem-vault-site/permits.ts"],"names":["ChainId","splitSignature","hexDataSlice","PERMIT_AND_CALL_ADDRESS","MAX_UINT256","Contract","id","defaultAbiCoder","EIP712Domain","name","type","DAIPermitGatherer","address","deadline","_","token","library","Permit","domain","version","DAI","nonce","nonces","message","holder","spender","Promise","resolve","toNumber","catch","toString","expiry","allowed","inputs","types","permitSelector","join","getPermitData","v","r","s","encode","USDCPermitGatherer","USDC","value","owner","permitGatherers","MAINNET","KOVAN","canPermit","chainId","gatherPermit","approveMax","data","signature","send","JSON","stringify","verifyingContract","primaryType","then","permitData"],"mappings":"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","sourcesContent":["import { ChainId, Token } from '@uniswap/sdk'\nimport { Signature, splitSignature, hexDataSlice } from '@ethersproject/bytes'\nimport { PERMIT_AND_CALL_ADDRESS, MAX_UINT256 } from './constants'\nimport { Web3Provider } from '@ethersproject/providers'\nimport { Contract } from '@ethersproject/contracts'\nimport { BigNumber } from '@ethersproject/bignumber'\nimport { id } from '@ethersproject/hash'\nimport { defaultAbiCoder } from '@ethersproject/abi'\n\ninterface eth_signTypedData_v4 {\n  types: {\n    EIP712Domain: { name: string; type: string }[]\n    Permit: { name: string; type: string }[]\n  }\n  domain: {\n    name: string\n    version: string\n  }\n  message: {\n    [key: string]: any // eslint-disable-line @typescript-eslint/no-explicit-any\n  }\n}\n\nexport interface Permit {\n  permitSelector: string\n  permitData: string\n}\n\ninterface PermitGathererReturn extends eth_signTypedData_v4 {\n  permitSelector: Permit['permitSelector']\n  getPermitData: (signature: Signature) => Permit['permitData']\n}\n\ntype PermitGathererFunction = (\n  address: string,\n  deadline: number,\n  approveMax: boolean,\n  token: Token,\n  library: Web3Provider\n) => Promise<PermitGathererReturn>\n\nconst EIP712Domain = [\n  { name: 'name', type: 'string' },\n  { name: 'version', type: 'string' },\n  { name: 'chainId', type: 'uint256' },\n  { name: 'verifyingContract', type: 'address' },\n]\n\nconst DAIPermitGatherer: PermitGathererFunction = async (address, deadline, _, token, library) => {\n  const Permit = [\n    { name: 'holder', type: 'address' },\n    { name: 'spender', type: 'address' },\n    { name: 'nonce', type: 'uint256' },\n    { name: 'expiry', type: 'uint256' },\n    { name: 'allowed', type: 'bool' },\n  ]\n  const domain = {\n    name: 'Dai Stablecoin',\n    version: '1',\n  }\n  const DAI = new Contract(token.address, ['function nonces(address holder) view returns (uint256 nonce)'], library)\n  const nonce: BigNumber = await DAI.nonces(address)\n  const message = {\n    holder: address,\n    spender: PERMIT_AND_CALL_ADDRESS,\n    nonce: await Promise.resolve(nonce.toNumber()).catch(() => nonce.toString()),\n    expiry: deadline,\n    allowed: true,\n  }\n  const inputs = ['address', 'address', 'uint256', 'uint256', 'bool', 'uint8', 'bytes32', 'bytes32']\n  return {\n    types: {\n      EIP712Domain,\n      Permit,\n    },\n    domain,\n    message,\n    permitSelector: hexDataSlice(id(`permit(${inputs.join(',')})`), 0, 4),\n    getPermitData: ({ v, r, s }) =>\n      defaultAbiCoder.encode(inputs, [address, PERMIT_AND_CALL_ADDRESS, nonce, deadline, true, v, r, s]),\n  }\n}\n\nconst USDCPermitGatherer: PermitGathererFunction = async (address, deadline, _, token, library) => {\n  const Permit = [\n    { name: 'owner', type: 'address' },\n    { name: 'spender', type: 'address' },\n    { name: 'value', type: 'uint256' },\n    { name: 'nonce', type: 'uint256' },\n    { name: 'deadline', type: 'uint256' },\n  ]\n  const domain = {\n    name: 'USD Coin',\n    version: '2',\n  }\n  const USDC = new Contract(token.address, ['function nonces(address owner) view returns (uint256 nonce)'], library)\n  const nonce: BigNumber = await USDC.nonces(address)\n  const value = `0x${MAX_UINT256.toString(16)}`\n  const message = {\n    owner: address,\n    spender: PERMIT_AND_CALL_ADDRESS,\n    value,\n    nonce: await Promise.resolve(nonce.toNumber()).catch(() => nonce.toString()),\n    deadline,\n  }\n  const inputs = ['address', 'address', 'uint256', 'uint256', 'uint8', 'bytes32', 'bytes32']\n  return {\n    types: {\n      EIP712Domain,\n      Permit,\n    },\n    domain,\n    message,\n    permitSelector: hexDataSlice(id(`permit(${inputs.join(',')})`), 0, 4),\n    getPermitData: ({ v, r, s }) =>\n      defaultAbiCoder.encode(inputs, [address, PERMIT_AND_CALL_ADDRESS, value, deadline, v, r, s]),\n  }\n}\n\nconst permitGatherers: { [chainId: number]: { [tokenAddress: string]: PermitGathererFunction } } = {\n  [ChainId.MAINNET]: {\n    '0x6B175474E89094C44Da98b954EedeAC495271d0F': DAIPermitGatherer,\n    '0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48': USDCPermitGatherer,\n  },\n  [ChainId.KOVAN]: {\n    '0x4F96Fe3b7A6Cf9725f59d353F723c1bDb64CA6Aa': DAIPermitGatherer,\n  },\n}\n\nexport function canPermit(token?: Token): boolean {\n  return !token ? false : !!permitGatherers[token.chainId]?.[token.address]\n}\n\nexport async function gatherPermit(\n  address: string,\n  deadline: number,\n  approveMax: boolean,\n  token: Token,\n  library: Web3Provider\n): Promise<Permit> {\n  const { permitSelector, getPermitData, domain, ...data } = await permitGatherers[token.chainId][token.address](\n    address,\n    deadline,\n    approveMax,\n    token,\n    library\n  )\n\n  const signature = await library\n    .send('eth_signTypedData_v4', [\n      address,\n      JSON.stringify({\n        ...data,\n        domain: {\n          ...domain,\n          chainId: token.chainId,\n          verifyingContract: token.address,\n        },\n        primaryType: 'Permit',\n      }),\n    ])\n    .then(splitSignature)\n\n  return {\n    permitSelector,\n    permitData: getPermitData(signature),\n  }\n}\n"]},"metadata":{},"sourceType":"module"}