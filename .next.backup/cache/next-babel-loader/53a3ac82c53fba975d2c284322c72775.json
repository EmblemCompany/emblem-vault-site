{"ast":null,"code":"function ownKeys(object,enumerableOnly){var keys=Object.keys(object);if(Object.getOwnPropertySymbols){var symbols=Object.getOwnPropertySymbols(object);if(enumerableOnly){symbols=symbols.filter(function(sym){return Object.getOwnPropertyDescriptor(object,sym).enumerable;});}keys.push.apply(keys,symbols);}return keys;}function _objectSpread(target){for(var i=1;i<arguments.length;i++){var source=arguments[i]!=null?arguments[i]:{};if(i%2){ownKeys(Object(source),true).forEach(function(key){_defineProperty(target,key,source[key]);});}else if(Object.getOwnPropertyDescriptors){Object.defineProperties(target,Object.getOwnPropertyDescriptors(source));}else{ownKeys(Object(source)).forEach(function(key){Object.defineProperty(target,key,Object.getOwnPropertyDescriptor(source,key));});}}return target;}function _defineProperty(obj,key,value){if(key in obj){Object.defineProperty(obj,key,{value:value,enumerable:true,configurable:true,writable:true});}else{obj[key]=value;}return obj;}/*!\n * Doka Image Editor 7.8.0\n * (c) 2018-2021 PQINA Inc. - All Rights Reserved\n * License: https://pqina.nl/doka/license/\n */ /* eslint-disable */const backup='__doka_webapi__';var getNativeAPIRef=API=>window[backup]?window[backup][API]:window[API];var createProgressEvent=(loaded,lengthComputable=true)=>{// assigning 0 to 1 somehow doesn't work\nconst type='progress';const data={loaded:loaded*100,total:100,lengthComputable};try{return new(getNativeAPIRef('ProgressEvent'))(type,data);}catch(err){// IE11\nreturn _objectSpread({type},data);}};var noop=(...args)=>{};const FileReaderDataFormat={ArrayBuffer:'readAsArrayBuffer'};var readFile=(file,onprogress=noop,options={})=>new Promise((resolve,reject)=>{const{dataFormat=FileReaderDataFormat.ArrayBuffer}=options;const reader=new(getNativeAPIRef('FileReader'))();reader.onload=()=>resolve(reader.result);reader.onerror=reject;reader.onprogress=onprogress;reader[dataFormat](file);});const readExifOrientation=(view,offset)=>{// Missing 0x45786966 Marker? No Exif Header, stop here\nif(view.getUint32(offset+=2,false)!==0x45786966)return-1;// First 2bytes defines byte align of TIFF data.\n// If it is 0x4949=\"I I\", it means \"Intel\" type byte align\nconst intelByteAligned=view.getUint16(offset+=6,false)===0x4949;offset+=view.getUint32(offset+4,intelByteAligned);const tags=view.getUint16(offset,intelByteAligned);offset+=2;// find Orientation tag\nfor(let i=0;i<tags;i++){if(view.getUint16(offset+i*12,intelByteAligned)===0x0112)return view.getUint16(offset+i*12+8,intelByteAligned);}};const readData=data=>{const view=new DataView(data);// Every JPEG file starts from binary value '0xFFD8', so if it's not present, exit here\nif(view.getUint16(0,false)!=0xffd8)return null;const length=view.byteLength;let offset=2;let marker;while(offset<length){if(view.getUint16(offset+2,false)<=8)return-1;marker=view.getUint16(offset,false);offset+=2;// Exif Marker found\nif(marker===0xffe1)return readExifOrientation(view,offset);// Invalid marker, exit here\nelse if((marker&0xff00)!==0xff00)return null;// Next!\nelse offset+=view.getUint16(offset,false);}};var getImageOrientationFromFile=async(file,onprogress=noop)=>{onprogress(createProgressEvent(0));const result=await readFile(file.slice(0,256*1024));return readData(result)||1;};let result=null;var isBrowser=()=>{if(result===null)result=false&&typeof window.document!=='undefined';return result;};let result$1=null;var canOrientImages=()=>new Promise(resolve=>{if(result$1===null){// 2x1 pixel image 90CW rotated with orientation EXIF header\nconst testSrc='data:image/jpg;base64,/9j/4AAQSkZJRgABAQEASABIAAD/4QA6RXhpZgAATU0AKgAAAAgAAwESAAMAAAABAAYAAAEoAAMAAAABAAIAAAITAAMAAAABAAEAAAAAAAD/2wBDAP//////////////////////////////////////////////////////////////////////////////////////wAALCAABAAIBASIA/8QAJgABAAAAAAAAAAAAAAAAAAAAAxABAAAAAAAAAAAAAAAAAAAAAP/aAAgBAQAAPwBH/9k=';let testImage=isBrowser()?new Image():{};testImage.onload=()=>{// should correct orientation if is presented in landscape,\n// in which case the browser doesn't autocorrect\nresult$1=testImage.naturalWidth===1;testImage=undefined;resolve(result$1);};testImage.src=testSrc;return;}return resolve(result$1);});var canvasToImageData=canvas=>{const imageData=canvas.getContext('2d').getImageData(0,0,canvas.width,canvas.height);return imageData;};var h=(name,attributes,children=[])=>{const el=document.createElement(name);// @ts-ignore\nconst descriptors=Object.getOwnPropertyDescriptors(el.__proto__);for(const key in attributes){if(key==='style'){el.style.cssText=attributes[key];}else if(descriptors[key]&&descriptors[key].set||/textContent|innerHTML/.test(key)||typeof attributes[key]==='function'){el[key]=attributes[key];}else{el.setAttribute(key,attributes[key]);}}children.forEach(child=>el.appendChild(child));return el;};const MATRICES={1:()=>[1,0,0,1,0,0],2:width=>[-1,0,0,1,width,0],3:(width,height)=>[-1,0,0,-1,width,height],4:(width,height)=>[1,0,0,-1,0,height],5:()=>[0,1,1,0,0,0],6:(width,height)=>[0,1,-1,0,height,0],7:(width,height)=>[0,-1,-1,0,height,width],8:width=>[0,-1,1,0,0,width]};var getImageOrientationMatrix=(width,height,orientation=-1)=>{if(orientation===-1)orientation=1;return MATRICES[orientation](width,height);};var releaseCanvas=canvas=>{canvas.width=1;canvas.height=1;const ctx=canvas.getContext('2d');ctx&&ctx.clearRect(0,0,1,1);};var isImageData=obj=>'data'in obj;var imageDataToCanvas=async(imageData,orientation=1)=>{const[width,height]=(await canOrientImages())||orientation<5?[imageData.width,imageData.height]:[imageData.height,imageData.width];const canvas=h('canvas',{width,height});const ctx=canvas.getContext('2d');// transform image data ojects into in memory canvas elements so we can transform them (putImageData isn't affect by transforms)\nif(isImageData(imageData)&&!(await canOrientImages())&&orientation>1){const inMemoryCanvas=h('canvas',imageData);const ctx=inMemoryCanvas.getContext('2d');ctx.putImageData(imageData,0,0);imageData=inMemoryCanvas;}// get base transformation matrix\nif(!(await canOrientImages())&&orientation>1){ctx.transform.apply(ctx,getImageOrientationMatrix(imageData.width,imageData.height,orientation));}// can't test for instanceof ImageBitmap as Safari doesn't support it\n// if still imageData object by this point, we'll use put\nif(isImageData(imageData)){ctx.putImageData(imageData,0,0);}else{ctx.drawImage(imageData,0,0);}// if image data is of type canvas, clean it up\nif(imageData instanceof HTMLCanvasElement)releaseCanvas(imageData);return canvas;};var orientImageData=async(imageData,orientation=1)=>{if(orientation===1)return imageData;// correct image data for when the browser does not correctly read exif orientation headers\nif(!(await canOrientImages()))return canvasToImageData(await imageDataToCanvas(imageData,orientation));return imageData;};var imageToCanvas=(image,canvasMemoryLimit)=>{// if these are 0 it's possible that we're trying to convert an SVG that doesn't have width or height attributes\n// https://bugzilla.mozilla.org/show_bug.cgi?id=1328124\nlet canvasWidth=image.naturalWidth;let canvasHeight=image.naturalHeight;// determine if requires more memory than limit, if so limit target size\nconst requiredCanvasMemory=canvasWidth*canvasHeight;if(canvasMemoryLimit&&requiredCanvasMemory>canvasMemoryLimit){const canvasScalar=Math.sqrt(canvasMemoryLimit)/Math.sqrt(requiredCanvasMemory);canvasWidth=Math.floor(canvasWidth*canvasScalar);canvasHeight=Math.floor(canvasHeight*canvasScalar);}// create new canvas element\nconst canvas=h('canvas');canvas.width=canvasWidth;canvas.height=canvasHeight;const ctx=canvas.getContext('2d');ctx.drawImage(image,0,0,canvasWidth,canvasHeight);return canvas;};// turns image into canvas only after it's fully loaded\nvar imageToCanvasSafe=(image,canvasMemoryLimit)=>new Promise((resolve,reject)=>{const ready=()=>resolve(imageToCanvas(image,canvasMemoryLimit));if(image.complete&&image.width){// need to test for image.width, on ie11 it will be 0 for object urls\nready();}else{image.onload=ready;image.onerror=reject;}});var blobToCanvas=async(imageBlob,canvasMemoryLimit)=>{const imageElement=h('img',{src:URL.createObjectURL(imageBlob)});const canvas=await imageToCanvasSafe(imageElement,canvasMemoryLimit);URL.revokeObjectURL(imageElement.src);return canvas;};var canCreateImageBitmap=()=>'createImageBitmap'in window;var canCreateOffscreenCanvas=()=>'OffscreenCanvas'in window;var isSVGFile=blob=>/svg/.test(blob.type);var getUniqueId=()=>Math.random().toString(36).substr(2,9);var functionToBlob=fn=>new Blob(['(',typeof fn==='function'?fn.toString():fn,')()'],{type:'application/javascript'});const wrapFunction=fn=>`function () {self.onmessage = function (message) {(${fn.toString()}).apply(null, message.data.content.concat([function (err, response) {\n    response = response || {};\n    const transfer = 'data' in response ? [response.data.buffer] : 'width' in response ? [response] : [];\n    return self.postMessage({ id: message.data.id, content: response, error: err }, transfer);\n}]))}}`;const workerPool=new Map();var thread=(fn,args,transferList)=>new Promise((resolve,reject)=>{let workerKey=fn.toString();let pooledWorker=workerPool.get(workerKey);if(!pooledWorker){// create worker for this function\nconst workerFn=wrapFunction(fn);// create a new web worker\nconst url=URL.createObjectURL(functionToBlob(workerFn));const messages=new Map();const worker=new Worker(url);// create a pooled worker, this object will contain the worker and active messages\npooledWorker={url,worker,messages,terminate:()=>{pooledWorker.worker.terminate();URL.revokeObjectURL(url);}};// handle received messages\nworker.onmessage=function(e){// should receive message id and message\nconst{id,content,error}=e.data;// message route no longer valid\nif(!messages.has(id))return;// get related thread and resolve with returned content\nconst message=messages.get(id);// remove thread from threads cache\nmessages.delete(id);// resolve or reject message based on response from worker\nerror!=null?message.reject(error):message.resolve(content);};// pool this worker\nworkerPool.set(workerKey,pooledWorker);}// we need a way to remember this message so we generate a unique id and use that as a key for this request, that way we can link the response back to request in the pooledWorker.onmessage handler\nconst messageId=getUniqueId();pooledWorker.messages.set(messageId,{resolve,reject});// use pooled worker and await response\npooledWorker.worker.postMessage({id:messageId,content:args},transferList);});var blobToImageData=async(imageBlob,canvasMemoryLimit)=>{let imageData;// if can use OffscreenCanvas let's go for it as it will mean we can run this operation on a separate thread\nif(canCreateImageBitmap()&&!isSVGFile(imageBlob)&&canCreateOffscreenCanvas()){try{imageData=await thread((file,canvasMemoryLimit,done)=>{createImageBitmap(file).then(bitmap=>{let canvasWidth=bitmap.width;let canvasHeight=bitmap.height;// determine if requires more memory than limit, if so limit target size\nconst requiredCanvasMemory=canvasWidth*canvasHeight;if(canvasMemoryLimit&&requiredCanvasMemory>canvasMemoryLimit){const canvasScalar=Math.sqrt(canvasMemoryLimit)/Math.sqrt(requiredCanvasMemory);canvasWidth=Math.floor(canvasWidth*canvasScalar);canvasHeight=Math.floor(canvasHeight*canvasScalar);}const canvas=new OffscreenCanvas(canvasWidth,canvasHeight);const ctx=canvas.getContext('2d');ctx.drawImage(bitmap,0,0);const imageData=ctx.getImageData(0,0,canvas.width,canvas.height);done(null,imageData);}).catch(err=>{// fail silently\ndone(err);});},[imageBlob,canvasMemoryLimit]);}catch(err){// fails silently on purpose, we'll try to turn the blob into image data in the main thread\n// console.error(err);\n}}// use main thread to generate ImageData\nif(!imageData||!imageData.width){const canvas=await blobToCanvas(imageBlob,canvasMemoryLimit);imageData=canvasToImageData(canvas);releaseCanvas(canvas);}return imageData;};var canvasToBlob=(canvas,mimeType=undefined,quality=undefined)=>new Promise((resolve,reject)=>{try{canvas.toBlob(blob=>{resolve(blob);},mimeType,quality);}catch(err){reject(err);}});var imageDataToBlob=async(imageData,mimeType,quality)=>{try{const canvas=await imageDataToCanvas(imageData);const blob=await canvasToBlob(canvas,mimeType,quality);releaseCanvas(canvas);return blob;}catch(err){throw err;}};var blobReadSection=async(blob,slice=[0,blob.size],onprogress)=>await readFile(blob.slice(...slice),onprogress);var blobWriteSection=(blob,section,slice=[0,blob.size])=>{if(!section)return blob;return new Blob([section,blob.slice(...slice)],{type:blob.type});};var getExtensionFromMimeType=mimeType=>mimeType.match(/\\/([a-z]+)/)[1];var getFilenameWithoutExtension=name=>name.substr(0,name.lastIndexOf('.'))||name;var getExtensionFromFilename=filename=>filename.split('.').pop();const ImageExtensionsRegex=/avif|bmp|gif|jpg|jpeg|jpe|jif|jfif|png|svg|tiff|webp/;/*\nSupport image mime types\n- image/webp\n- image/gif\n- image/avif\n- image/jpeg\n- image/png\n- image/bmp\n- image/svg+xml\n*/var getMimeTypeFromExtension=ext=>{// empty string returned if extension not found\nif(!ImageExtensionsRegex.test(ext))return'';// return MimeType for this extension\nreturn'image/'+(/jfif|jif|jpe|jpg/.test(ext)?'jpeg':ext==='svg'?'svg+xml':ext);};var getMimeTypeFromFilename=name=>name&&getMimeTypeFromExtension(getExtensionFromFilename(name).toLowerCase());var matchFilenameToMimeType=(filename,mimeType)=>{// get the mime type that matches this extension\nconst fileMimeType=getMimeTypeFromFilename(filename);// test if type already matches current mime type, no need to change name\nif(fileMimeType===mimeType)return filename;// get the extension for this mimetype (gets all characters after the \"image/\" part)\nconst targetMimeTypeExtension=getExtensionFromMimeType(mimeType);return`${getFilenameWithoutExtension(filename)}.${targetMimeTypeExtension}`;};var blobToFile=(blob,filename,mimetype)=>{const lastModified=new Date().getTime();const blobHasMimeType=blob.type.length&&blob.type!=='null';const blobMimeType=blobHasMimeType?blob.type:mimetype;const name=matchFilenameToMimeType(filename,blobMimeType);try{return new(getNativeAPIRef('File'))([blob],name,{lastModified,type:blobHasMimeType?blob.type:blobMimeType});}catch(err){const file=blobHasMimeType?blob.slice():blob.slice(0,blob.size,blobMimeType);file.lastModified=lastModified;file.name=name;return file;}};var getAspectRatio=(w,h)=>w/h;var passthrough=v=>v;const PI=Math.PI;const HALF_PI=Math.PI/2;const QUART_PI=HALF_PI/2;var isRotatedSideways=a=>{const rotationLimited=Math.abs(a)%Math.PI;return rotationLimited>QUART_PI&&rotationLimited<Math.PI-QUART_PI;};//\n// generic\n//\nconst scale=(value,scalar,pivot)=>pivot+(value-pivot)*scalar;const ellipseCreateFromRect=rect=>({x:rect.x+rect.width*0.5,y:rect.y+rect.height*0.5,rx:rect.width*0.5,ry:rect.height*0.5});//\n// vector\n//\nconst vectorCreateEmpty=()=>vectorCreate(0,0);const vectorCreate=(x,y)=>({x,y});const vectorCreateFromSize=size=>vectorCreate(size.width,size.height);const vectorCreateFromPointerEvent=e=>vectorCreate(e.pageX,e.pageY);const vectorCreateFromPointerEventOffset=e=>vectorCreate(e.offsetX,e.offsetY);const vectorClone=v=>vectorCreate(v.x,v.y);const vectorInvert=v=>{v.x=-v.x;v.y=-v.y;return v;};const vectorPerpendicular=v=>{const x=v.x;v.x=-v.y;v.y=x;return v;};const vectorRotate=(v,radians,pivot=vectorCreateEmpty())=>{const cos=Math.cos(radians);const sin=Math.sin(radians);const tx=v.x-pivot.x;const ty=v.y-pivot.y;v.x=pivot.x+cos*tx-sin*ty;v.y=pivot.y+sin*tx+cos*ty;return v;};const vectorLength=v=>Math.sqrt(v.x*v.x+v.y*v.y);const vectorNormalize=v=>{const length=Math.sqrt(v.x*v.x+v.y*v.y);if(length===0)return vectorCreateEmpty();v.x/=length;v.y/=length;return v;};const vectorAngle=v=>Math.atan2(v.y,v.x);const vectorAngleBetween=(a,b)=>Math.atan2(b.y-a.y,b.x-a.x);const vectorEqual=(a,b)=>a.x===b.x&&a.y===b.y;const vectorApply=(v,fn)=>{v.x=fn(v.x);v.y=fn(v.y);return v;};const vectorAdd=(a,b)=>{a.x+=b.x;a.y+=b.y;return a;};const vectorSubtract=(a,b)=>{a.x-=b.x;a.y-=b.y;return a;};const vectorMultiply=(v,f)=>{v.x*=f;v.y*=f;return v;};const vectorDot=(a,b)=>a.x*b.x+a.y*b.y;const vectorDistanceSquared=(a,b=vectorCreateEmpty())=>{const x=a.x-b.x;const y=a.y-b.y;return x*x+y*y;};const vectorDistance=(a,b=vectorCreateEmpty())=>Math.sqrt(vectorDistanceSquared(a,b));const vectorCenter=v=>{let x=0;let y=0;v.forEach(v=>{x+=v.x;y+=v.y;});return vectorCreate(x/v.length,y/v.length);};const vectorsFlip=(points,flipX,flipY,cx,cy)=>{points.forEach(point=>{point.x=flipX?cx-(point.x-cx):point.x;point.y=flipY?cy-(point.y-cy):point.y;});return points;};const vectorsRotate=(points,angle,cx,cy)=>{const s=Math.sin(angle);const c=Math.cos(angle);points.forEach(p=>{p.x-=cx;p.y-=cy;const rx=p.x*c-p.y*s;const ry=p.x*s+p.y*c;p.x=cx+rx;p.y=cy+ry;});return points;};//\n// size\n//\nconst toSize=(width,height)=>({width,height});const sizeClone=size=>toSize(size.width,size.height);const sizeCreateFromAny=obj=>toSize(obj.width,obj.height);const sizeCreateFromRect=r=>toSize(r.width,r.height);const sizeCreateFromArray=a=>toSize(a[0],a[1]);const sizeCreate=(width,height)=>toSize(width,height);const sizeEqual=(a,b,format=passthrough)=>format(a.width)===format(b.width)&&format(a.height)===format(b.height);const sizeScale=(size,scalar)=>{size.width*=scalar;size.height*=scalar;return size;};const sizeCenter=size=>vectorCreate(size.width*0.5,size.height*0.5);const sizeRotate=(size,radians)=>{const cos=Math.cos(radians);const sin=Math.sin(radians);const w=cos*size.width+sin*size.height;const h=sin*size.width+cos*size.height;size.width=w;size.height=h;return size;};const sizeTurn=(size,radians)=>{const w=size.width;const h=size.height;if(isRotatedSideways(radians)){size.width=h;size.height=w;}return size;};const sizeContains=(a,b)=>a.width>=b.width&&a.height>=b.height;const sizeApply=(size,fn)=>{size.width=fn(size.width);size.height=fn(size.height);return size;};const sizeHypotenuse=size=>Math.sqrt(size.width*size.width+size.height*size.height);const sizeMin=(a,b)=>sizeCreate(Math.min(a.width,b.width),Math.min(a.height,b.height));//\n// line\n//\nconst lineCreate=(start,end)=>({start,end});const lineClone=line=>lineCreate(vectorClone(line.start),vectorClone(line.end));const lineExtend=(line,amount)=>{const v=vectorCreate(line.start.x-line.end.x,line.start.y-line.end.y);const vn=vectorNormalize(v);const vm=vectorMultiply(vn,amount);line.start.x+=vm.x;line.start.y+=vm.y;line.end.x-=vm.x;line.end.y-=vm.y;return line;};const lineMultiply=(line,amount)=>{const v=vectorCreate(line.start.x-line.end.x,line.start.y-line.end.y);const vn=vectorNormalize(v);const vm=vectorMultiply(vn,amount);line.end.x+=vm.x;line.end.y+=vm.y;return line;};//\n// rect\n//\nconst CornerSigns=[vectorCreate(-1,-1),vectorCreate(-1,1),vectorCreate(1,1),vectorCreate(1,-1)];const toRect=(x,y,width,height)=>({x,y,width,height});const rectClone=rect=>toRect(rect.x,rect.y,rect.width,rect.height);const rectCreateEmpty=()=>toRect(0,0,0,0);const rectCreateFromDimensions=(width,height)=>toRect(0,0,width,height);const rectCreateFromSize=size=>toRect(0,0,size.width,size.height);const rectCreateFromAny=obj=>toRect(obj.x||0,obj.y||0,obj.width||0,obj.height||0);const rectCreateFromPoints=(...args)=>{const pts=Array.isArray(args[0])?args[0]:args;let xMin=pts[0].x;let xMax=pts[0].x;let yMin=pts[0].y;let yMax=pts[0].y;pts.forEach(point=>{xMin=Math.min(xMin,point.x);xMax=Math.max(xMax,point.x);yMin=Math.min(yMin,point.y);yMax=Math.max(yMax,point.y);});return toRect(xMin,yMin,xMax-xMin,yMax-yMin);};const rectCreateFromEllipse=ellipse=>rectCreate(ellipse.x-ellipse.rx,ellipse.y-ellipse.ry,ellipse.rx*2,ellipse.ry*2);const rectCreateWithCenter=(center,size)=>toRect(center.x-size.width*0.5,center.y-size.height*0.5,size.width,size.height);const rectCreate=(x,y,width,height)=>toRect(x,y,width,height);const rectCenter=rect=>vectorCreate(rect.x+rect.width*0.5,rect.y+rect.height*0.5);const rectTranslate=(rect,t)=>{rect.x+=t.x;rect.y+=t.y;return rect;};const rectScale=(rect,scalar,pivot)=>{pivot=pivot||rectCenter(rect);rect.x=scalar*(rect.x-pivot.x)+pivot.x;rect.y=scalar*(rect.y-pivot.y)+pivot.y;rect.width=scalar*rect.width;rect.height=scalar*rect.height;return rect;};const rectMultiply=(rect,factor)=>{rect.x*=factor;rect.y*=factor;rect.width*=factor;rect.height*=factor;return rect;};const rectDivide=(rect,factor)=>{rect.x/=factor;rect.y/=factor;rect.width/=factor;rect.height/=factor;return rect;};const rectSubtract=(a,b)=>{a.x-=b.x;a.y-=b.y;a.width-=b.width;a.height-=b.height;return a;};const rectAdd=(a,b)=>{a.x+=b.x;a.y+=b.y;a.width+=b.width;a.height+=b.height;return a;};const rectEqual=(a,b,format=passthrough)=>format(a.x)===format(b.x)&&format(a.y)===format(b.y)&&format(a.width)===format(b.width)&&format(a.height)===format(b.height);const rectAspectRatio=rect=>getAspectRatio(rect.width,rect.height);const rectUpdate=(rect,x,y,width,height)=>{rect.x=x;rect.y=y;rect.width=width;rect.height=height;return rect;};const rectUpdateWithRect=(a,b)=>{a.x=b.x;a.y=b.y;a.width=b.width;a.height=b.height;return a;};const rectRotate=(rect,radians,pivot)=>{if(!pivot)pivot=rectCenter(rect);return rectGetCorners(rect).map(vertex=>vectorRotate(vertex,radians,pivot));};const rectCenterRect=(a,b)=>toRect(a.width*0.5-b.width*0.5,a.height*0.5-b.height*0.5,b.width,b.height);const rectContainsPoint=(rect,point)=>{if(point.x<rect.x)return false;if(point.y<rect.y)return false;if(point.x>rect.x+rect.width)return false;if(point.y>rect.y+rect.height)return false;return true;};const rectCoverRect=(rect,aspectRatio,offset=vectorCreateEmpty())=>{if(rect.width===0||rect.height===0)return rectCreateEmpty();const inputAspectRatio=rectAspectRatio(rect);if(!aspectRatio)aspectRatio=inputAspectRatio;let width=rect.width;let height=rect.height;if(aspectRatio>inputAspectRatio){// height remains the same, width is expanded\nwidth=height*aspectRatio;}else{// width remains the same, height is expanded\nheight=width/aspectRatio;}return toRect(offset.x+(rect.width-width)*0.5,offset.y+(rect.height-height)*0.5,width,height);};const rectContainRect=(rect,aspectRatio=rectAspectRatio(rect),offset=vectorCreateEmpty())=>{if(rect.width===0||rect.height===0)return rectCreateEmpty();let width=rect.width;let height=width/aspectRatio;if(height>rect.height){height=rect.height;width=height*aspectRatio;}return toRect(offset.x+(rect.width-width)*0.5,offset.y+(rect.height-height)*0.5,width,height);};const rectToBounds=rect=>[Math.min(rect.y,rect.y+rect.height),Math.max(rect.x,rect.x+rect.width),Math.max(rect.y,rect.y+rect.height),Math.min(rect.x,rect.x+rect.width)];const rectGetCorners=rect=>[vectorCreate(rect.x,rect.y),vectorCreate(rect.x+rect.width,rect.y),vectorCreate(rect.x+rect.width,rect.y+rect.height),vectorCreate(rect.x,rect.y+rect.height)];const rectApply=(rect,fn)=>{if(!rect)return;rect.x=fn(rect.x);rect.y=fn(rect.y);rect.width=fn(rect.width);rect.height=fn(rect.height);return rect;};const rectApplyPerspective=(rect,perspective,pivot=rectCenter(rect))=>rectGetCorners(rect).map((corner,index)=>{const sign=CornerSigns[index];return vectorCreate(scale(corner.x,1.0+sign.x*perspective.x,pivot.x),scale(corner.y,1.0+sign.y*perspective.y,pivot.y));});const rectNormalizeOffset=rect=>{rect.x=0;rect.y=0;return rect;};// https://stackoverflow.com/questions/9692448/how-can-you-find-the-centroid-of-a-concave-irregular-polygon-in-javascript\nconst quadCentroid=points=>{const pts=points.map(vectorClone);const first=pts[0];const last=pts[pts.length-1];if(first.x!=last.x||first.y!=last.y){pts.push(first);}let twicearea=0;let x=0;let y=0;let nPts=pts.length;let p1;let p2;let f;for(let i=0,j=nPts-1;i<nPts;j=i++){p1=pts[i];p2=pts[j];f=(p1.y-first.y)*(p2.x-first.x)-(p2.y-first.y)*(p1.x-first.x);twicearea+=f;x+=(p1.x+p2.x-2*first.x)*f;y+=(p1.y+p2.y-2*first.y)*f;}f=twicearea*3;return vectorCreate(x/f+first.x,y/f+first.y);};const lineLineIntersection=(a,b)=>_lineLineIntersection(a.start,a.end,b.start,b.end);const _lineLineIntersection=(a,b,c,d)=>{const uA=((d.x-c.x)*(a.y-c.y)-(d.y-c.y)*(a.x-c.x))/((d.y-c.y)*(b.x-a.x)-(d.x-c.x)*(b.y-a.y));const uB=((b.x-a.x)*(a.y-c.y)-(b.y-a.y)*(a.x-c.x))/((d.y-c.y)*(b.x-a.x)-(d.x-c.x)*(b.y-a.y));if(uA>=0&&uA<=1&&uB>=0&&uB<=1){return vectorCreate(a.x+uA*(b.x-a.x),a.y+uA*(b.y-a.y));}return undefined;};const linePointsIntersection=(line,points)=>{const vertices=[...points,points[0]];const l=vertices.length;const intersections=[];for(let i=0;i<l-1;i++){const intersection=_lineLineIntersection(line.start,line.end,vectorCreate(vertices[i].x,vertices[i].y),vectorCreate(vertices[i+1].x,vertices[i+1].y));if(!intersection)continue;intersections.push(intersection);}return intersections.length?intersections:undefined;};// First translate the polygon so that `point` is the origin. Then, for each\n// edge, get the angle between two vectors: 1) the edge vector and 2) the\n// vector of the first vertex of the edge. If all of the angles are the same\n// sign (which is negative since they will be counter-clockwise) then the\n// point is inside the polygon; otherwise, the point is outside.\nconst polyPointIntersectionConvex=(point,vertices)=>{let i,a,b,ax,ay,bx,by,edgex,edgey,x;const l=vertices.length;for(i=0;i<l;i++){a=vertices[i];b=vertices[i+1>l-1?0:i+1];ax=a.x-point.x;ay=a.y-point.y;bx=b.x-point.x;by=b.y-point.y;edgex=ax-bx;edgey=ay-by;x=edgex*ay-edgey*ax;// 0 is ON the edge, but we check for -0.00001 to fix floating point errors\nif(x<-0.00001)return false;}return true;};const quadLines=vertices=>{const arr=[];for(let i=0;i<vertices.length;i++){let next=i+1;if(next===vertices.length)next=0;arr.push(lineCreate(vectorClone(vertices[i]),vectorClone(vertices[next])));}return arr;};var getImageTransformedRect=(imageSize,imageRotation)=>{const imageRect=rectCreateFromSize(imageSize);const imageCenter=rectCenter(imageRect);const imageTransformedVertices=rectRotate(imageRect,imageRotation,imageCenter);return rectNormalizeOffset(rectCreateFromPoints(imageTransformedVertices));};var isElement=(v,name)=>v instanceof HTMLElement&&(name?new RegExp(`^${name}$`,'i').test(v.nodeName):true);var isFile=v=>v instanceof File;var isString=v=>typeof v==='string';var canvasToFile=async(canvas,mimeType,quality)=>{const blob=await canvasToBlob(canvas,mimeType,quality);return blobToFile(blob,'canvas');};var getFilenameFromURL=url=>url.split('/').pop().split(/\\?|\\#/).shift();let isSafari=null;var isSafari$1=()=>{if(isSafari===null)isSafari=isSafari=/^((?!chrome|android).)*safari/i.test(navigator.userAgent);return isSafari;};var getImageElementSize=imageElement=>new Promise((resolve,reject)=>{let shouldAutoRemove=false;// test if image is attached to DOM, if not attached, attach so measurement is correct on Safari\nif(!imageElement.parentNode&&isSafari$1()){shouldAutoRemove=true;// has width 0 and height 0 to prevent rendering very big SVGs (without width and height) that will for one frame overflow the window and show a scrollbar\nimageElement.style.cssText=`position:absolute;visibility:hidden;pointer-events:none;left:0;top:0;width:0;height:0;`;document.body.appendChild(imageElement);}// start testing size\nconst measure=()=>{const width=imageElement.naturalWidth;const height=imageElement.naturalHeight;const hasSize=width&&height;if(!hasSize)return;// clean up image if was attached for measuring\nif(shouldAutoRemove)imageElement.parentNode.removeChild(imageElement);clearInterval(intervalId);resolve({width,height});};imageElement.onerror=err=>{clearInterval(intervalId);reject(err);};const intervalId=setInterval(measure,1);measure();});var getImageSize=async image=>{// the image element we'll use to load the image\nlet imageElement=image;// if is not an image element, it must be a valid image source\nif(!imageElement.src){imageElement=new Image();imageElement.src=isString(image)?image:URL.createObjectURL(image);}let size;try{size=await getImageElementSize(imageElement);}catch(err){throw err;}finally{isFile(image)&&URL.revokeObjectURL(imageElement.src);}return size;};const awaitComplete=image=>new Promise((resolve,reject)=>{if(image.complete)return resolve(image);image.onload=()=>resolve(image);image.onerror=reject;});var imageToFile=async imageElement=>{try{const size=await getImageSize(imageElement);const image=await awaitComplete(imageElement);const canvas=document.createElement('canvas');canvas.width=size.width;canvas.height=size.height;const ctx=canvas.getContext('2d');ctx.drawImage(image,0,0);const blob=await canvasToBlob(canvas);return blobToFile(blob,getFilenameFromURL(image.src));}catch(err){throw err;}};var isDataURI=str=>/^data:/.test(str);var isUserAgent=test=>isBrowser()?RegExp(test).test(window.navigator.userAgent):undefined;let result$2=null;var isInternetExplorer=()=>{if(result$2===null)result$2=isUserAgent(/MSIE|Trident/);return result$2;};// IE11 does not support getting blobs with fetch, so we use this fallback method\nconst dataURIToBlob=dataURI=>{const parts=dataURI.split(',');const type=parts[0].substr(4);const byteString=atob(parts[1]);const l=byteString.length;const ab=new ArrayBuffer(byteString.length);const ia=new Uint8Array(ab);for(var i=0;i<l;i++){ia[i]=byteString.charCodeAt(i);}return new Blob([ab],{type:type});};var dataURIToFile=async(dataURI,filename='data-uri',onprogress=noop)=>{// basic loader, no size info\nonprogress(createProgressEvent(0));let blob;if(isInternetExplorer()){blob=dataURIToBlob(dataURI);onprogress(createProgressEvent(0.5));}else{const res=await fetch(dataURI);onprogress(createProgressEvent(0.33));blob=await res.blob();onprogress(createProgressEvent(0.66));}const file=blobToFile(blob,filename);onprogress(createProgressEvent(1));return file;};var getResponseHeader=(xhr,header,parse=header=>header)=>xhr.getAllResponseHeaders().indexOf(header)>=0?parse(xhr.getResponseHeader(header)):undefined;var getFilenameFromContentDisposition=header=>{if(!header)return null;const matches=header.split(/filename=|filename\\*=.+''/).splice(1).map(name=>name.trim().replace(/^[\"']|[;\"']{0,2}$/g,'')).filter(name=>name.length);return matches.length?decodeURI(matches[matches.length-1]):null;};const DokaErrorCode={URL_REQUEST:'URL_REQUEST',DOCTYPE_MISSING:'DOCTYPE_MISSING'};class DokaError extends Error{constructor(message,code,metadata){super(message);this.name='DokaError';this.code=code;this.metadata=metadata;}}var fetchFile=(url,onprogress)=>new Promise((resolve,reject)=>{const handleError=()=>reject(new DokaError('Error fetching image',DokaErrorCode.URL_REQUEST,xhr));const xhr=new XMLHttpRequest();xhr.onprogress=onprogress;xhr.onerror=handleError,xhr.onload=()=>{if(!xhr.response||xhr.status>=300||xhr.status<200)return handleError();// we store the response mime type so we can add it to the blob later on, if it's missing (happens on Safari 10)\nconst mimetype=getResponseHeader(xhr,'Content-Type');// try to get filename and any file instructions as well\nconst filename=getResponseHeader(xhr,'Content-Disposition',getFilenameFromContentDisposition)||getFilenameFromURL(url);// convert to actual file if possible\nresolve(blobToFile(xhr.response,filename,mimetype||getMimeTypeFromFilename(filename)));};xhr.open('GET',url);xhr.responseType='blob';xhr.send();});var urlToFile=(url,onprogress)=>{// use fetch to create blob from data uri\nif(isDataURI(url))return dataURIToFile(url,undefined,onprogress);// load file from url\nreturn fetchFile(url,onprogress);};var isBlob=v=>v instanceof Blob&&!(v instanceof File);var srcToFile=async(src,onprogress)=>{if(isFile(src)||isBlob(src))return src;else if(isString(src))return await urlToFile(src,onprogress);else if(isElement(src,'canvas'))return await canvasToFile(src);else if(isElement(src,'img'))return await imageToFile(src);else{throw new DokaError('Invalid image source','invalid-image-source');}};var orientImageSize=async(size,orientation=1)=>{// browser can handle image orientation\nif(await canOrientImages())return size;// no need to fix orientation\nif(orientation<5)return size;// correct image size\nreturn sizeCreate(size.height,size.width);};var arrayBufferReadImageHead=data=>{const view=new DataView(data);// Every JPEG file starts from binary value '0xFFD8', so if it's not present, exit here\nif(view.getUint16(0)!==0xffd8)return null;let offset=2;// Start at 2 as we skipped two bytes (FFD8)\nlet marker;let markerLength;while(offset<view.byteLength){marker=view.getUint16(offset,false);markerLength=view.getUint16(offset+2,false)+2;// Test if is APP and COM markers\nconst isData=marker>=0xffe0&&marker<=0xffef||marker===0xfffe;if(!isData)break;if(offset+markerLength>view.byteLength)break;offset+=markerLength;}return data.slice(0,offset);};const readExifOrientation$1=(view,offset)=>{// Missing 0x45786966 Marker? No Exif Header, stop here\nif(view.getUint32(offset+=2,false)!==0x45786966)return-1;// First 2bytes defines byte align of TIFF data.\n// If it is 0x4949=\"I I\", it means \"Intel\" type byte align\nconst intelByteAligned=view.getUint16(offset+=6,false)===0x4949;offset+=view.getUint32(offset+4,intelByteAligned);const tags=view.getUint16(offset,intelByteAligned);offset+=2;// find Orientation tag\nfor(let i=0;i<tags;i++){if(view.getUint16(offset+i*12,intelByteAligned)===0x0112)return view.getUint16(offset+i*12+8,intelByteAligned);}};var arrayBufferReadExifOrientationTag=data=>{if(!data)return;const view=new DataView(data);// Every JPEG file starts from binary value '0xFFD8', so if it's not present, exit here\nif(view.getUint16(0,false)!=0xffd8)return;const length=view.byteLength;let offset=2;let marker;while(offset<length){if(view.getUint16(offset+2,false)<=8)return;marker=view.getUint16(offset,false);offset+=2;// Exif Marker found\nif(marker===0xffe1)return readExifOrientation$1(view,offset);// Invalid marker, exit here\nelse if((marker&0xff00)!==0xff00)return;// Next!\nelse offset+=view.getUint16(offset,false);}};var arrayBufferWriteExifOrientationTag=(data,value=1)=>{if(!data)return false;const view=new DataView(data);// Every JPEG file starts from binary value '0xFFD8', so if it's not present, exit here\nif(view.getUint16(0)!==0xffd8)return false;let offset=2;// Start at 2 as we skipped two bytes (FFD8)\nlet marker;let markerLength;let orientationCorrected=false;while(offset<view.byteLength){marker=view.getUint16(offset,false);markerLength=view.getUint16(offset+2,false)+2;// Test if is APP and COM markers\nconst isData=marker>=0xffe0&&marker<=0xffef||marker===0xfffe;if(!isData)break;if(!orientationCorrected)orientationCorrected=writeExifOrientation(view,offset,value);if(offset+markerLength>view.byteLength)break;offset+=markerLength;}return orientationCorrected;};const writeExifOrientation=(view,offset,orientation)=>{// Missing 0x45786966 Marker? No Exif Header, stop here\nif(view.getUint32(offset+4,false)!==0x45786966)return;// next byte!\noffset+=4;// First 2bytes defines byte align of TIFF data.\n// If it is 0x4949=\"I I\", it means \"Intel\" type byte align\nconst intelByteAligned=view.getUint16(offset+=6,false)===0x4949;offset+=view.getUint32(offset+4,intelByteAligned);const tags=view.getUint16(offset,intelByteAligned);offset+=2;// find Orientation tag and overwrite with orientation value\nfor(let i=0;i<tags;i++){if(view.getUint16(offset+i*12,intelByteAligned)===0x0112){view.setUint16(offset+i*12+8,orientation,intelByteAligned);return true;}}return false;};var isJPEG=file=>/jpeg/.test(file.type);var isPlainObject=obj=>typeof obj=='object'&&obj.constructor==Object;var stringify=value=>!isPlainObject(value)?value:JSON.stringify(value);var post=(url,dataset,options)=>new Promise((resolve,reject)=>{const{token={},beforeSend=noop,onprogress=noop}=options;token.cancel=()=>request.abort();const request=new XMLHttpRequest();request.upload.onprogress=onprogress;request.onload=()=>request.status>=200&&request.status<300?resolve(request):reject(request);request.onerror=()=>reject(request);request.ontimeout=()=>reject(request);request.open('POST',encodeURI(url));beforeSend(request);request.send(dataset.reduce((formData,args)=>{// @ts-ignore\nformData.append(...args.map(stringify));return formData;},new FormData()));});var ctxRotate=(ctx,rotation=0,pivot)=>{if(rotation===0)return ctx;ctx.translate(pivot.x,pivot.y);ctx.rotate(rotation);ctx.translate(-pivot.x,-pivot.y);return ctx;};var ctxTranslate=(ctx,x,y)=>{ctx.translate(x,y);return ctx;};var ctxScale=(ctx,x,y)=>{ctx.scale(x,y);return ctx;};var cropImageData=async(imageData,options={})=>{const{flipX,flipY,rotation,crop}=options;const imageSize=sizeCreateFromAny(imageData);const shouldFlip=flipX||flipY;const shouldRotate=!!rotation;const cropDefined=crop&&(crop.x||crop.y||crop.width||crop.height);const cropCoversImage=cropDefined&&rectEqual(crop,rectCreateFromSize(imageSize));const shouldCrop=cropDefined&&!cropCoversImage;// skip!\nif(!shouldFlip&&!shouldRotate&&!shouldCrop)return imageData;// create drawing context\nlet imageDataOut;let image=h('canvas',{width:imageData.width,height:imageData.height});image.getContext('2d').putImageData(imageData,0,0);// flip image data\nif(shouldFlip){const ctx=h('canvas',{width:image.width,height:image.height}).getContext('2d');ctxScale(ctx,flipX?-1:1,flipY?-1:1);ctx.drawImage(image,flipX?-image.width:0,flipY?-image.height:0);ctx.restore();releaseCanvas(image);image=ctx.canvas;}// rotate image data\nif(shouldRotate){// if shouldRotate is true we also receive a crop rect\nconst outputSize=sizeApply(sizeCreateFromRect(rectCreateFromPoints(rectRotate(rectCreateFromAny(image),rotation))),Math.floor);const ctx=h('canvas',{width:crop.width,height:crop.height}).getContext('2d');ctxTranslate(ctx,-crop.x,-crop.y);ctxRotate(ctx,rotation,sizeCenter(outputSize));ctx.drawImage(image,(outputSize.width-image.width)*0.5,(outputSize.height-image.height)*0.5);ctx.restore();releaseCanvas(image);image=ctx.canvas;}// crop image data\nelse if(shouldCrop){const ctx=image.getContext('2d');imageDataOut=ctx.getImageData(crop.x,crop.y,crop.width,crop.height);releaseCanvas(image);return imageDataOut;}// done, return resulting image data\nconst ctx=image.getContext('2d');imageDataOut=ctx.getImageData(0,0,image.width,image.height);releaseCanvas(image);return imageDataOut;};var resizeTransform=(options,done)=>{const{imageData,width,height}=options;const originWidth=imageData.width;const originHeight=imageData.height;const targetWidth=Math.round(width);const targetHeight=Math.round(height);const inputData=imageData.data;const outputData=new Uint8ClampedArray(targetWidth*targetHeight*4);const ratioWidth=originWidth/targetWidth;const ratioHeight=originHeight/targetHeight;const ratioWidthHalf=Math.ceil(ratioWidth*0.5);const ratioHeightHalf=Math.ceil(ratioHeight*0.5);for(let j=0;j<targetHeight;j++){for(let i=0;i<targetWidth;i++){const x2=(i+j*targetWidth)*4;let weight=0;let weights=0;let weightsAlpha=0;let r=0;let g=0;let b=0;let a=0;const centerY=(j+0.5)*ratioHeight;for(let yy=Math.floor(j*ratioHeight);yy<(j+1)*ratioHeight;yy++){const dy=Math.abs(centerY-(yy+0.5))/ratioHeightHalf;const centerX=(i+0.5)*ratioWidth;const w0=dy*dy;for(let xx=Math.floor(i*ratioWidth);xx<(i+1)*ratioWidth;xx++){let dx=Math.abs(centerX-(xx+0.5))/ratioWidthHalf;const w=Math.sqrt(w0+dx*dx);if(w>=-1&&w<=1){weight=2*w*w*w-3*w*w+1;if(weight>0){dx=4*(xx+yy*originWidth);const ref=inputData[dx+3];a+=weight*ref;weightsAlpha+=weight;if(ref<255){weight=weight*ref/250;}r+=weight*inputData[dx];g+=weight*inputData[dx+1];b+=weight*inputData[dx+2];weights+=weight;}}}}outputData[x2]=r/weights;outputData[x2+1]=g/weights;outputData[x2+2]=b/weights;outputData[x2+3]=a/weightsAlpha;}}done(null,{data:outputData,width:targetWidth,height:targetHeight});};var imageDataObjectToImageData=obj=>{if(obj instanceof ImageData){return obj;}let imageData;try{imageData=new ImageData(obj.width,obj.height);}catch(err){// IE + Old EDGE (tested on 12)\nconst canvas=h('canvas');imageData=canvas.getContext('2d').createImageData(obj.width,obj.height);}imageData.data.set(obj.data);return imageData;};var resizeImageData=async(imageData,options={})=>{const{width,height,fit,upscale}=options;// no need to rescale\nif(!width&&!height)return imageData;let targetWidth=width;let targetHeight=height;if(!width){targetWidth=height;}else if(!height){targetHeight=width;}if(fit!=='force'){let scalarWidth=targetWidth/imageData.width;let scalarHeight=targetHeight/imageData.height;let scalar=1;if(fit==='cover'){scalar=Math.max(scalarWidth,scalarHeight);}else if(fit==='contain'){scalar=Math.min(scalarWidth,scalarHeight);}// if image is too small, exit here with original image\nif(scalar>1&&upscale===false)return imageData;targetWidth=Math.round(imageData.width*scalar);targetHeight=Math.round(imageData.height*scalar);}// no need to resize?\nif(imageData.width===targetWidth&&imageData.height===targetHeight)return imageData;// let's resize!\nimageData=await thread(resizeTransform,[{imageData:imageData,width:targetWidth,height:targetHeight}],[imageData.data.buffer]);// the resizer returns a plain object, not an actual image data object, lets create one\nreturn imageDataObjectToImageData(imageData);};var colorEffect=(options,done)=>{const{imageData,matrix}=options;if(!matrix)return done(null,imageData);const outputData=new Uint8ClampedArray(imageData.width*imageData.height*4);const data=imageData.data;const l=data.length;const m11=matrix[0];const m12=matrix[1];const m13=matrix[2];const m14=matrix[3];const m15=matrix[4];const m21=matrix[5];const m22=matrix[6];const m23=matrix[7];const m24=matrix[8];const m25=matrix[9];const m31=matrix[10];const m32=matrix[11];const m33=matrix[12];const m34=matrix[13];const m35=matrix[14];const m41=matrix[15];const m42=matrix[16];const m43=matrix[17];const m44=matrix[18];const m45=matrix[19];let index=0;let r=0.0;let g=0.0;let b=0.0;let a=0.0;let mr=0.0;let mg=0.0;let mb=0.0;let ma=0.0;let or=0.0;let og=0.0;let ob=0.0;for(;index<l;index+=4){r=data[index]/255;g=data[index+1]/255;b=data[index+2]/255;a=data[index+3]/255;mr=r*m11+g*m12+b*m13+a*m14+m15;mg=r*m21+g*m22+b*m23+a*m24+m25;mb=r*m31+g*m32+b*m33+a*m34+m35;ma=r*m41+g*m42+b*m43+a*m44+m45;or=Math.max(0,mr*ma)+(1.0-ma);og=Math.max(0,mg*ma)+(1.0-ma);ob=Math.max(0,mb*ma)+(1.0-ma);outputData[index]=Math.max(0.0,Math.min(1.0,or))*255;outputData[index+1]=Math.max(0.0,Math.min(1.0,og))*255;outputData[index+2]=Math.max(0.0,Math.min(1.0,ob))*255;outputData[index+3]=a*255;}done(null,{data:outputData,width:imageData.width,height:imageData.height});};var convolutionEffect=(options,done)=>{const{imageData,matrix}=options;if(!matrix)return done(null,imageData);// calculate kernel weight\nlet kernelWeight=matrix.reduce((prev,curr)=>prev+curr);// input info\nconst inputWidth=imageData.width;const inputHeight=imageData.height;const inputData=imageData.data;let i=0;let x=0;let y=0;const side=Math.round(Math.sqrt(matrix.length));const sideHalf=Math.floor(side/2);let r=0,g=0,b=0,a=0,cx=0,cy=0,scy=0,scx=0,srcOff=0,weight=0;const outputData=new Uint8ClampedArray(inputWidth*inputHeight*4);for(y=0;y<inputHeight;y++){for(x=0;x<inputWidth;x++){// calculate the weighed sum of the source image pixels that\n// fall under the convolution matrix\nr=0;g=0;b=0;a=0;for(cy=0;cy<side;cy++){for(cx=0;cx<side;cx++){scy=y+cy-sideHalf;scx=x+cx-sideHalf;if(scy<0||scy>=inputHeight||scx<0||scx>=inputWidth)continue;srcOff=(scy*inputWidth+scx)*4;weight=matrix[cy*side+cx];r+=inputData[srcOff]*weight;g+=inputData[srcOff+1]*weight;b+=inputData[srcOff+2]*weight;a+=inputData[srcOff+3]*weight;}}outputData[i]=r/kernelWeight;outputData[i+1]=g/kernelWeight;outputData[i+2]=b/kernelWeight;outputData[i+3]=a/kernelWeight;i+=4;}}done(null,{data:outputData,width:inputWidth,height:inputHeight});};var vignetteEffect=(options,done)=>{const{imageData,strength}=options;if(!strength)return done(null,imageData);const outputData=new Uint8ClampedArray(imageData.width*imageData.height*4);const inputWidth=imageData.width;const inputHeight=imageData.height;const data=imageData.data;const dist=(x,y)=>{dx=x-cx;dy=y-cy;return Math.sqrt(dx*dx+dy*dy);};let index=0;let x=0;let y=0;let cx=inputWidth*0.5;let cy=inputHeight*0.5;let dx;let dy;let f;let dm=dist(0,0);for(y=0;y<inputHeight;y++){for(x=0;x<inputWidth;x++){index=(x+y*inputWidth)*4;f=dist(x,y)*strength/dm;if(strength>0){outputData[index]=data[index]*(1-f);outputData[index+1]=data[index+1]*(1-f);outputData[index+2]=data[index+2]*(1-f);}else{outputData[index]=data[index]+f*-(255-data[index]);outputData[index+1]=data[index+1]+f*-(255-data[index+1]);outputData[index+2]=data[index+2]+f*-(255-data[index+2]);}outputData[index+3]=data[index+3];}}done(null,{data:outputData,width:imageData.width,height:imageData.height});};var noiseEffect=(options,done)=>{const{imageData,level,monochrome=false}=options;if(!level)return done(null,imageData);const outputData=new Uint8ClampedArray(imageData.width*imageData.height*4);const data=imageData.data;const l=data.length;let index=0;let r;let g;let b;let average;const rand=()=>(-1+Math.random()*2)*255*level;for(;index<l;index+=4){if(monochrome){average=rand();r=average;g=average;b=average;}else{r=rand();g=rand();b=rand();}outputData[index]=data[index]+r;outputData[index+1]=data[index+1]+g;outputData[index+2]=data[index+2]+b;outputData[index+3]=data[index+3];}done(null,{data:outputData,width:imageData.width,height:imageData.height});};var gammaEffect=(options,done)=>{const{imageData,level}=options;if(!level)return done(null,imageData);const outputData=new Uint8ClampedArray(imageData.width*imageData.height*4);const data=imageData.data;const l=data.length;let index=0;let r;let g;let b;for(;index<l;index+=4){r=data[index]/255;g=data[index+1]/255;b=data[index+2]/255;outputData[index]=Math.pow(r,level)*255;outputData[index+1]=Math.pow(g,level)*255;outputData[index+2]=Math.pow(b,level)*255;outputData[index+3]=data[index+3];}done(null,{data:outputData,width:imageData.width,height:imageData.height});};var isIdentityMatrix=matrix=>{/*\n    [\n        1, 0, 0, 0, 0\n        0, 1, 0, 0, 0\n        0, 0, 1, 0, 0\n        0, 0, 0, 1, 0\n    ]\n    */const l=matrix.length;let v;let s=l>=20?6:l>=16?5:3;for(let i=0;i<l;i++){v=matrix[i];if(v===1&&i%s!==0)return false;else if(v!==0&&v!==1)return false;}return true;};var filterImageData=async(imageData,options={})=>{const{colorMatrix,convolutionMatrix,gamma:gammaLevel,noise:noiseLevel,vignette:vignetteStrength}=options;// filters\nconst filters=[];// apply convolution matrix\nif(convolutionMatrix){filters.push([convolutionEffect,{matrix:convolutionMatrix.clarity}]);}// apply noise\nif(gammaLevel>0){filters.push([gammaEffect,{level:1.0/gammaLevel}]);}// apply color matrix\nif(colorMatrix&&!isIdentityMatrix(colorMatrix)){filters.push([colorEffect,{matrix:colorMatrix}]);}// apply noise\nif(noiseLevel>0||noiseLevel<0){filters.push([noiseEffect,{level:noiseLevel}]);}// apply vignette\nif(vignetteStrength>0||vignetteStrength<0){filters.push([vignetteEffect,{strength:vignetteStrength}]);}// no changes\nif(!filters.length)return imageData;// builds effect chain\nconst chain=(transforms,i)=>`(err, imageData) => {\n            (${transforms[i][0].toString()})(Object.assign({ imageData: imageData }, filterInstructions[${i}]), \n                ${transforms[i+1]?chain(transforms,i+1):'done'})\n        }`;const filterChain=`function (options, done) {\n        const filterInstructions = options.filterInstructions;\n        const imageData = options.imageData;\n        (${chain(filters,0)})(null, imageData)\n    }`;imageData=await thread(filterChain,[{imageData:imageData,filterInstructions:filters.map(t=>t[1])}],[imageData.data.buffer]);// the resizer returns a plain object, not an actual image data object, lets create one\nreturn imageDataObjectToImageData(imageData);};var isNumber=v=>typeof v==='number';var isEmoji=str=>isString(str)&&str.match(/(?:[\\u2700-\\u27bf]|(?:\\ud83c[\\udde6-\\uddff]){2}|[\\ud800-\\udbff][\\udc00-\\udfff]|[\\u0023-\\u0039]\\ufe0f?\\u20e3|\\u3299|\\u3297|\\u303d|\\u3030|\\u24c2|\\ud83c[\\udd70-\\udd71]|\\ud83c[\\udd7e-\\udd7f]|\\ud83c\\udd8e|\\ud83c[\\udd91-\\udd9a]|\\ud83c[\\udde6-\\uddff]|\\ud83c[\\ude01-\\ude02]|\\ud83c\\ude1a|\\ud83c\\ude2f|\\ud83c[\\ude32-\\ude3a]|\\ud83c[\\ude50-\\ude51]|\\u203c|\\u2049|[\\u25aa-\\u25ab]|\\u25b6|\\u25c0|[\\u25fb-\\u25fe]|\\u00a9|\\u00ae|\\u2122|\\u2139|\\ud83c\\udc04|[\\u2600-\\u26FF]|\\u2b05|\\u2b06|\\u2b07|\\u2b1b|\\u2b1c|\\u2b50|\\u2b55|\\u231a|\\u231b|\\u2328|\\u23cf|[\\u23e9-\\u23f3]|[\\u23f8-\\u23fa]|\\ud83c\\udccf|\\u2934|\\u2935|[\\u2190-\\u21ff])/g)!==null;var hasProp=(obj,key)=>obj.hasOwnProperty(key);var isObject=v=>typeof v==='object';const copy=val=>isObject(val)?deepCopy(val):val;const deepCopy=src=>{let dst;if(Array.isArray(src)){dst=[];src.forEach((val,i)=>{dst[i]=copy(val);});}else{dst={};Object.keys(src).forEach(key=>{const val=src[key];dst[key]=copy(val);});}return dst;};var isFunction=v=>typeof v==='function';var isArray=arr=>Array.isArray(arr);let result$3=null;var isMac=()=>{if(result$3===null)result$3=isBrowser()&&/^mac/i.test(navigator.platform);return result$3;};let result$4=null;var isIOS=()=>{if(result$4===null)// first part is for iPhones and iPads iOS 12 and below second part is for iPads with iOS 13 and up\nresult$4=isBrowser()&&(isUserAgent(/iPhone|iPad|iPod/)||isMac()&&navigator.maxTouchPoints>=1);return result$4;};var isApple=()=>isIOS()||isMac();var isWindows=()=>/^win/i.test(navigator.platform);// macos:   font-size: 123, x: 63.5, y: 110\n// windows: font-size: 112, x: 64, y: 103\n// android: font-size: 112, x: 64, y: 102\nlet x=64;let y=102;let fontSize=112;let hasSetValues=false;var getEmojiSVG=(emoji,alt)=>{if(!hasSetValues&&isBrowser()){if(isWindows())y=103;if(isApple()){x=63.5;y=110;fontSize=123;}hasSetValues=true;}return`<svg${alt?` aria-label=\"${alt}\"`:''} width=\"128\" height=\"128\" viewBox=\"0 0 128 128\" preserveAspectRatio=\"xMinYMin meet\" xmlns=\"http://www.w3.org/2000/svg\"><text x=\"${x}\" y=\"${y}\" alignment-baseline=\"text-top\" dominant-baseline=\"text-top\" text-anchor=\"middle\" font-size=\"${fontSize}px\">${emoji}</text></svg>`;};var SVGToDataURL=svg=>`data:image/svg+xml,${svg.replace('<','%3C').replace('>','%3E')}`;var isBinary=v=>v instanceof Blob;var toPercentage=(value,total)=>`${value/total*100}%`;var loadImage=(image,onsize=undefined)=>new Promise((resolve,reject)=>{// the image element we'll use to load the image\nlet imageElement=image;let sizeCalculated=false;const reportSize=()=>{if(sizeCalculated)return;sizeCalculated=true;isFunction(onsize)&&/* Use Promise.resolve to make async but place before resolve of parent promise */Promise.resolve().then(()=>onsize(sizeCreate(imageElement.naturalWidth,imageElement.naturalHeight)));};// if is not an image element, it must be a valid image source\nif(!imageElement.src){imageElement=new Image();imageElement.src=isString(image)?image:URL.createObjectURL(image);}if(imageElement.complete){reportSize();return resolve(imageElement);}// try to calculate size faster\nif(isFunction(onsize))getImageElementSize(imageElement).then(reportSize).catch(reject);imageElement.onload=()=>{reportSize();resolve(imageElement);};imageElement.onerror=reject;});var colorArrayToRGBA=color=>`rgba(${Math.round(color[0]*255)}, ${Math.round(color[1]*255)}, ${Math.round(color[2]*255)}, ${isNumber(color[3])?color[3]:1})`;const textPadding=20;// font offset\n// font size 16 -> 2, 4\n// font size 32 -> 4, 6\n// font size 64 -> 8, 12\n// font size 128 -> 16, 24\n// font size 256 -> 32, 48\nlet fontOffsetBrowser=undefined;const getBrowserFontOffset=fontSize=>{if(!fontOffsetBrowser){// size\nconst size=32;// let's calculate it\nconst ctx=createSimpleContext(size,size);updateTextContext(ctx,{fontSize:100,color:'#fff'});ctx.fillText('F',0,0);// get pixel data so we can find the white pixels\nconst data=ctx.getImageData(0,0,size,size).data;// find x offset\nlet p=0;let step=4;let to=data.length;let from=to-size*4;for(p=from;p<to;p+=step){if(data[p])break;}const x=(p-from)/step;// find y offset\nfrom=(size-1)*4;step=size*4;for(p=from;p<to;p+=step){if(data[p])break;}const y=(p-from)/step;fontOffsetBrowser=vectorCreate(x,y);// done with canvas\nreleaseCanvas(ctx.canvas);}return vectorCreate(-fontOffsetBrowser.x*fontSize*0.01,-fontOffsetBrowser.y*fontSize*0.01);};const createSimpleContext=(width=1,height=1)=>{const canvas=h('canvas');const ctx=canvas.getContext('2d');ctx.canvas.width=width;ctx.canvas.height=height;return ctx;};const updateTextContext=(ctx,options)=>{const{fontSize=16,fontFamily='sans-serif',fontWeight='normal',fontVariant='normal',fontStyle='normal',textAlign='left',color='#000'}=options;ctx.font=`${fontStyle} ${fontVariant} ${fontWeight} ${fontSize}px ${fontFamily}`;ctx.textBaseline='top';ctx.textAlign=textAlign;ctx.fillStyle=Array.isArray(color)?colorArrayToRGBA(color):color;};const createSimpleTextContext=options=>{const ctx=createSimpleContext();updateTextContext(ctx,options);return ctx;};const computeLineHeight=(fontSize,lineHeight)=>isFunction(lineHeight)?lineHeight(fontSize):lineHeight;const getMeasureVisibleWidth=measure=>Math.abs(measure.actualBoundingBoxLeft)+Math.abs(measure.actualBoundingBoxRight);const resizeContextToFitText=(ctx,text,options)=>{const{width,height}=measureTextContext(ctx,text,computeLineHeight(options.fontSize,options.lineHeight));ctx.canvas.width=Math.ceil(width);ctx.canvas.height=Math.ceil(height);return ctx;};const measureTextContext=(ctx,text,computedLineHeight)=>{const storedTextAlign=ctx.textAlign;ctx.textAlign='left';// calculate width\nconst lines=text.split('\\n');const width=lines.reduce((prev,curr)=>{const lineWidth=getMeasureVisibleWidth(ctx.measureText(curr));if(lineWidth>prev){prev=lineWidth;}return prev;},1);ctx.textAlign=storedTextAlign;// calculate height\nconst height=computedLineHeight*lines.length;return sizeCreate(Math.ceil(width),Math.ceil(height));};const TextSizeCache=new Map();const createTextSizeHash=(text,{fontSize,fontFamily,lineHeight,fontWeight,fontStyle,fontVariant})=>`${[text,fontSize,fontWeight,fontStyle,fontVariant,fontFamily].join('_')}_${isFunction(lineHeight)?lineHeight(fontSize):lineHeight}`;const textSize=(text,options)=>{const ctx=createSimpleTextContext(options);if(options.width)text=wrapText(ctx,text,options.width);const hash=createTextSizeHash(text,options);let size=TextSizeCache.get(hash);if(size)return _objectSpread({},size);size=measureTextContext(ctx,text,computeLineHeight(options.fontSize,options.lineHeight));TextSizeCache.set(hash,size);return _objectSpread({},size);};const wrapText=(ctx,text,lineWidth)=>{// exit if no text\nif(text.length===0)return'';const res=[];let lineBuffer='';let lineIndex=0;let measureWidth;const paragraphs=text.split('\\n\\n');// draw the current line\nconst pushLine=()=>{if(!lineBuffer.length)return;if(!res[lineIndex]){res[lineIndex]=[];}res[lineIndex].push(lineBuffer);// clear buffer\nlineBuffer='';};const fitChar=char=>{const testLine=lineBuffer+char;// measure width of entire line if adding these chars\nmeasureWidth=ctx.measureText(testLine).width;// fits on line?\nif(measureWidth<lineWidth){lineBuffer=testLine;}else{// doesn't fit but line buffer is empty, just print the character and move to next line\nif(!lineBuffer.length){lineBuffer=testLine;pushLine();}// fits, lets print current line and move char to next line\nelse{pushLine();lineBuffer=char;}lineIndex++;}};const fitWord=word=>{const testLine=lineBuffer.length?lineBuffer+' '+word:word;// measure width of entire line if adding these chars\nmeasureWidth=ctx.measureText(testLine).width;// fits on line?\nif(measureWidth<lineWidth){lineBuffer=testLine;}// wrap to next line\nelse{// if line buffer is empty, whole word doesn't fit, need to cut it up\nif(!lineBuffer.length){word.split('').forEach(fitChar);}// there are words in the buffer that do fit, let's draw the line and move this word to the next line\nelse{// draw current buffer\npushLine();lineIndex++;// retry to fit this word\nfitWord(word);}}};paragraphs.forEach(p=>{const lines=p.split('\\n');lines.forEach(l=>{l.split(' ').forEach(fitWord);// end of line reached, if we have words in our buffer\n// at this point we need to draw them and then move to the next line\nif(lineBuffer.length)pushLine();// forced new line\nlineIndex++;});// forced new line\nlineIndex++;});return res.map(line=>line.join(' ')).join('\\n');};const drawText=(ctx,text='',options={})=>{// exit if no text\nif(text.length===0)return ctx;const{x=0,y=0,lineWidth=0,textAlign,fontSize,lineHeight}=options;// determine where the browser will render the font and correct for browser differences\nconst browserFontOffset=vectorAdd(getBrowserFontOffset(fontSize),vectorCreate(fontSize/12,fontSize/3.75));const fontOffsetX=x+browserFontOffset.x;const fontOffsetY=y+browserFontOffset.y;const lineHeightComputed=isFunction(lineHeight)?lineHeight(fontSize):lineHeight;let offset=textAlign==='right'?lineWidth:textAlign==='center'?lineWidth*0.5:0;text.split('\\n').forEach((line,i)=>{ctx.fillText(line,fontOffsetX+offset,fontOffsetY+i*lineHeightComputed);});return ctx;};//#region shape generic\nconst shapeContain=(shape,parentRect)=>{const shapeAspectRatio=shape.width/shape.height;const containedShape=rectContainRect(parentRect,shapeAspectRatio);if(shape.width>containedShape.width||shape.height>containedShape.height){shape.width=containedShape.width;shape.height=containedShape.height;}return shape;};const shapeCenter=(shape,position)=>{shape.x=position.x-shape.width*0.5;shape.y=position.y-shape.height*0.5;return shape;};const shapeDeepCopy=shape=>{// don't attempt to clone background image element\n// TODO: MOVE IMAGE ELEMENT TO SOME INTERNAL CACHE\nconst shapeShallowCopy=_objectSpread({},shape);shapeShallowCopy.backgroundImageElement=undefined;const shapeDeepCopy=deepCopy(shapeShallowCopy);// we don't want a million image elements so we'll reference the original one\nif(shape.backgroundImageElement)shapeDeepCopy.backgroundImageElement=shape.backgroundImageElement;return shapeDeepCopy;};const getContextSize=(context,size={})=>{const contextAspectRatio=rectAspectRatio(context);let width;let height;if(size.width&&size.height)return sizeClone(size);if(size.width||size.height){width=parseFloat(size.width||Number.MAX_SAFE_INTEGER);height=parseFloat(size.height||Number.MAX_SAFE_INTEGER);const min=Math.min(width,height);if(isString(size.width)||isString(size.height)){width=`${min}%`;height=`${min*contextAspectRatio}%`;}else{width=min;height=min;}}else{const min=10;width=`${min}%`;height=`${min*contextAspectRatio}%`;}return{width,height};};const shapeCreateFromEmoji=(emoji,props={})=>{return _objectSpread(_objectSpread({width:undefined,height:undefined},props),{},{aspectRatio:1,backgroundImage:SVGToDataURL(getEmojiSVG(emoji))});};const shapeCreateFromImage=(src,oncomplete,props={})=>{const shape=_objectSpread(_objectSpread({// required/default image shape props\nwidth:undefined,height:undefined,aspectRatio:undefined,backgroundColor:[0,0,0,0]},props),{},{// set image\nbackgroundImage:isString(src)?src:URL.createObjectURL(src)});return shapeLoadResources(shape,oncomplete);};const shapeLoadResources=(shape,oncomplete=noop)=>{if(shape.backgroundImage){// done loading\nif(shape.isComplete){oncomplete(shape.isError,shape);return shape;}// is still loading\nif(shape.isLoading)return shape;// default state before loading\nshape.isComplete=false;shape.isError=false;shape.isLoading=true;// updates the size of the shape relative to the image\nconst updateShapeSize=imageSize=>{// if background size is not set the shape is not locked to the image aspect ratio\nif(shape.backgroundSize)return;// always locked to aspect ratio\nconst aspectRatio=imageSize.width/imageSize.height;// check if width has been defined, if so, we update height to match aspect ratio\nconst width=shape.width||imageSize.width;const height=width/aspectRatio;// set final dimensions\nshape.width=width;shape.height=height;shape.aspectRatio=imageSize.width/imageSize.height;};// now loading\nloadImage(shape.backgroundImage,updateShapeSize).then(image=>{shape.backgroundImageElement=image;}).catch(error=>{shape.isError=error;}).finally(()=>{shape.isLoading=false;shape.isComplete=true;oncomplete(shape.isError,shape);});}return shape;};const shapeCreateFromPreset=(preset,parentRect,oncomplete)=>{let shape;if(isString(preset)||isBinary(preset)){// if is emoji, create default markup,\nif(isEmoji(preset)){// create markup\nshape=shapeCreateFromEmoji(preset,getContextSize(parentRect));setTimeout(()=>oncomplete(undefined,shape),0);}// is URL, create default markup for image\nelse{shape=shapeCreateFromImage(preset,oncomplete,_objectSpread({},getContextSize(parentRect)));}}else{// is using src shortcut\nif(preset.src){// shape options\nconst shapeOptions=_objectSpread(_objectSpread({},preset.shape),getContextSize(parentRect,preset.shape||preset));// emoji markup\nif(isEmoji(preset.src)){shape=shapeCreateFromEmoji(preset.src,shapeOptions);setTimeout(()=>oncomplete(undefined,shape),0);}// is url\nelse if(isString(preset.src)){shape=shapeCreateFromImage(preset.src,oncomplete,shapeOptions);}}// should have markup defined\nelse if(preset.shape){shape=shapeDeepCopy(preset.shape);}}if(hasProp(shape,'backgroundImage')){// set transparent background if no background color defined\nif(!hasProp(shape,'backgroundColor')){shape.backgroundColor=[0,0,0,0];}// for image presets, disable styles by default\nif(!hasProp(shape,'disableStyle')){shape.disableStyle=true;}// by default don't allow flipping\nif(!hasProp(shape,'disableFlip')){shape.disableFlip=true;}}return parentRect?shapeComputeDisplay(shape,parentRect):shape;};const shapeLineGetStartPoint=line=>vectorCreate(line.x1,line.y1);const shapeLineGetEndPoint=line=>vectorCreate(line.x2,line.y2);const shapeTextUID=({text,textAlign,fontSize,fontFamily,lineHeight,fontWeight,fontStyle,fontVariant})=>`${[text,textAlign,fontSize,fontWeight,fontStyle,fontVariant,fontFamily].join('_')}_${isFunction(lineHeight)?lineHeight(fontSize):lineHeight}`;//#endregion\n//#region shape testing\n// shape types\nconst shapeIsText=shape=>hasProp(shape,'text');const shapeIsTextLine=shape=>shapeIsText(shape)&&!(shapeHasRelativeSize(shape)||hasProp(shape,'width'));const shapeIsTextBox=shape=>shapeIsText(shape)&&(shapeHasRelativeSize(shape)||hasProp(shape,'width'));const shapeIsRect=shape=>!shapeIsText(shape)&&shapeHasComputedSize(shape);const shapeIsEllipse=shape=>hasProp(shape,'rx');const shapeIsLine=shape=>hasProp(shape,'x1')&&!shapeIsTriangle(shape);const shapeIsTriangle=shape=>hasProp(shape,'x3');const shapeIsPath=shape=>hasProp(shape,'points');// shape state\nconst shapeIsTextEmpty=shape=>shapeIsText(shape)&&!shape.text.length;const shapeIsTextEditing=shape=>shapeIsText(shape)&&shape.isEditing;const shapeIsVisible=shape=>hasProp(shape,'opacity')?shape.opacity>0:true;const shapeIsSelected=shape=>shape.isSelected;const shapeIsDraft=shape=>shape.isDraft;const shapeHasSize=shape=>hasProp(shape,'width')&&hasProp(shape,'height');const shapeHasNumericStroke=shape=>isNumber(shape.strokeWidth)&&shape.strokeWidth>0;// only relevant if is bigger than 0\nconst shapeHasRelativePosition=shape=>{const hasRight=hasProp(shape,'right');const hasBottom=hasProp(shape,'bottom');return hasRight||hasBottom;};const shapeHasTexture=shape=>hasProp(shape,'backgroundImage')||hasProp(shape,'text');const shapeHasRelativeSize=shape=>(hasProp(shape,'x')||hasProp(shape,'left'))&&hasProp(shape,'right')||(hasProp(shape,'y')||hasProp(shape,'top'))&&hasProp(shape,'bottom');const shapeHasComputedSize=shape=>shapeHasSize(shape)||shapeHasRelativeSize(shape);// actions\nconst shapeSelect=shape=>{shape.isSelected=true;return shape;};const shapeMakeDraft=shape=>{shape.isDraft=true;return shape;};// rights\nconst shapeCanStyle=(shape,style)=>{if(shape.disableStyle===true)return false;if(isArray(shape.disableStyle)){return!shape.disableStyle.includes(style);}return true;};const shapeCanErase=shape=>shape.disableErase!==true;const shapeCanSelect=shape=>shape.disableSelect!==true&&!shapeIsPath(shape)&&!shapeIsTriangle(shape);const shapeCanRemove=shape=>shape.disableRemove!==true;const shapeCanDuplicate=shape=>shape.disableDuplicate!==true&&shapeCanMove(shape);const shapeCanReorder=shape=>shape.disableReorder!==true;const shapeCanFlip=shape=>{if(shape.disableFlip)return false;if(shapeIsDraft(shape)||shapeHasRelativePosition(shape))return false;return shapeHasTexture(shape);};const shapeCanInput=(shape,input)=>{if(!shapeIsText(shape))return false;if(shape.disableInput===true)return false;if(isFunction(shape.disableInput))return shape.disableInput(input!=null?input:shape.text);return input||true;};const shapeCanMove=shape=>shape.disableMove!==true&&!shapeIsDraft(shape)&&!shapeIsPath(shape)&&!shapeHasRelativePosition(shape);const shapeCanResize=shape=>shape.disableResize!==true&&!shapeIsDraft(shape)&&(shapeHasSize(shape)||shapeIsTextBox(shape)||shapeIsEllipse(shape)||shapeIsLine(shape))&&!shapeHasRelativePosition(shape)&&shapeCanMove(shape);const shapeCanRotate=shape=>shape.disableRotate!==true&&!shapeIsDraft(shape)&&(shapeHasSize(shape)||hasProp(shape,'text')||shapeIsEllipse(shape))&&!shapeHasRelativePosition(shape);//#endregion\n//#region shape formatting\nconst shapeDeleteRelativeProps=shape=>{delete shape.left;delete shape.right;delete shape.top;delete shape.bottom;return shape;};const shapeDeleteTransformProps=shape=>{delete shape.rotation;return shape;};const shapeFormatStroke=shape=>{shape.strokeWidth=shape.strokeWidth||1;shape.strokeColor=shape.strokeColor||[0,0,0];return shape;};const shapeFormatFill=shape=>{shape.backgroundColor=shape.backgroundColor?shape.backgroundColor:shape.strokeWidth||shape.backgroundImage?undefined:[0,0,0];return shape;};const autoLineHeight=fontSize=>fontSize*1.2;const shapeFormatText=shape=>{shape.fontSize=shape.fontSize||16;shape.fontFamily=shape.fontFamily||'sans-serif';shape.fontWeight=shape.fontWeight||'normal';shape.fontStyle=shape.fontStyle||'normal';shape.fontVariant=shape.fontVariant||'normal';shape.lineHeight=isNumber(shape.lineHeight)?shape.lineHeight:autoLineHeight;shape.color=shape.color||[0,0,0];return shapeIsTextLine(shape)?shapeFormatTextLine(shape):shapeFormatTextBox(shape);};const shapeFormatTextLine=shape=>{delete shape.textAlign;return shapeDeleteRelativeProps(shape);};const shapeFormatTextBox=shape=>{shape.textAlign=shape.textAlign||'left';return shape;};const shapeFormatRect=shape=>{shape.cornerRadius=shape.cornerRadius||0;shape.strokeWidth=shape.strokeWidth||0;shape.strokeColor=shape.strokeColor||[0,0,0];return shapeFormatFill(shape);};const shapeFormatTriangle=shape=>{shape.strokeWidth=shape.strokeWidth||0;shape.strokeColor=shape.strokeColor||[0,0,0];shapeFormatFill(shape);return shapeDeleteRelativeProps(shape);};const shapeFormatEllipse=shape=>{shape.strokeWidth=shape.strokeWidth||0;shape.strokeColor=shape.strokeColor||[0,0,0];return shapeFormatFill(shape);};const shapeFormatPath=shape=>{shapeFormatStroke(shape);shapeDeleteTransformProps(shape);return shapeDeleteRelativeProps(shape);};const shapeFormatLine=shape=>{shapeFormatStroke(shape);shape.lineStart=shape.lineStart||undefined;shape.lineEnd=shape.lineEnd||undefined;shapeDeleteTransformProps(shape);return shapeDeleteRelativeProps(shape);};const shapeFormatDefaults=shape=>{if(!isString(shape.id))shape.id=getUniqueId();if(!hasProp(shape,'rotation'))shape.rotation=0;if(!hasProp(shape,'opacity'))shape.opacity=1;if(!hasProp(shape,'disableErase'))shape.disableErase=true;};const shapeFormat=shape=>{shapeFormatDefaults(shape);if(shapeIsText(shape)){shapeFormatText(shape);}else if(shapeIsRect(shape)){shapeFormatRect(shape);}else if(shapeIsPath(shape)){shapeFormatPath(shape);}else if(shapeIsLine(shape)){shapeFormatLine(shape);}else if(shapeIsEllipse(shape)){shapeFormatEllipse(shape);}else if(shapeIsTriangle(shape)){shapeFormatTriangle(shape);}shapeLoadResources(shape);return shape;};const shapeGetDescription=shape=>{if(shapeIsText(shape)){return'text';}else if(shapeIsRect(shape)){return'rectangle';}else if(shapeIsPath(shape)){return'path';}else if(shapeIsLine(shape)){return'line';}else if(shapeIsEllipse(shape)){return'ellipse';}else if(shapeIsTriangle(shape)){return'triangle';}return;};//#endregion\nconst toPixelValue=(percentage,total)=>parseFloat(percentage)/100*total;//#region shape transforming\nconst shapeComputeValue=(shape,prop,{width,height})=>{if(!hasProp(shape,prop))return;let value=shape[prop];if(/points/.test(prop)){const arr=shape[prop];if(!isString(arr[0].x))return;shape[prop]=arr.map(p=>vectorCreate(toPixelValue(p.x,width),toPixelValue(p.y,height)));}else if(isString(value)){const f=parseFloat(value)/100;if(/^x|left|width|rx|fontSize|cornerRadius|strokeWidth/.test(prop))shape[prop]=width*f;else if(/^right/.test(prop))shape[prop]=width-width*f;else if(/^y|top|height|ry/.test(prop))shape[prop]=height*f;else if(/^bottom/.test(prop))shape[prop]=height-height*f;}};const displayProps=['width','height','left','top','right','bottom','x','y','rx','ry','points','fontSize','strokeWidth','lineHeight','x1','y1','x2','y2','x3','y3'];const shapeComputeDisplay=(shape,parentRect)=>{displayProps.forEach(prop=>shapeComputeValue(shape,prop,parentRect));shapeComputeRect(shape,parentRect);return shape;};const shapeGetPropPixelTotal=(prop,parentRect)=>{let total;if(/^x|width|rx|fontSize|strokeWidth|cornerRadius/.test(prop)){total=parentRect.width;}else if(/^y|height|ry/.test(prop)){total=parentRect.height;}return total;};const shapeUpdateProp=(shape,prop,value,parentRect)=>{if(!isString(shape[prop]))return shape[prop]=value;let total=shapeGetPropPixelTotal(prop,parentRect);shape[prop]=toPercentage(value,total);return shape;};const shapeGetPropPixelValue=(shape,prop,parentRect)=>{if(!isString(shape[prop]))return shape[prop];return toPixelValue(shape[prop],shapeGetPropPixelTotal(prop,parentRect));};const shapeGetPropsPixelValues=(shape,props,parentRect)=>{return props.reduce((prev,prop)=>{const value=shapeGetPropPixelValue(shape,prop,parentRect);prev[prop]=value;return prev;},{});};const shapeUpdateProps=(shape,props,parentRect)=>{Object.keys(props).forEach(key=>shapeUpdateProp(shape,key,props[key],parentRect));return shape;};const shapeComputeRect=(shape,parentRect)=>{if(hasProp(shape,'left'))shape.x=shape.left;if(hasProp(shape,'right')){const r=parentRect.width-shape.right;if(hasProp(shape,'left')){shape.x=shape.left;shape.width=Math.max(0,r-shape.left);}else if(hasProp(shape,'width')){shape.x=r-shape.width;}}if(hasProp(shape,'top'))shape.y=shape.top;if(hasProp(shape,'bottom')){const b=parentRect.height-shape.bottom;if(hasProp(shape,'top')){shape.y=shape.top;shape.height=Math.max(0,b-shape.top);}else if(hasProp(shape,'height')){shape.y=b-shape.height;}}return shape;};const shapeComputeTransform=(shape,translate,scale)=>{if(shapeIsPath(shape)){shape.points.filter(point=>isNumber(point.x)).forEach(point=>{point.x*=scale;point.y*=scale;point.x+=translate.x;point.y+=translate.y;});}if(shapeIsTriangle(shape)&&isNumber(shape.x1)){shape.x1*=scale;shape.y1*=scale;shape.x2*=scale;shape.y2*=scale;shape.x3*=scale;shape.y3*=scale;shape.x1+=translate.x;shape.y1+=translate.y;shape.x2+=translate.x;shape.y2+=translate.y;shape.x3+=translate.x;shape.y3+=translate.y;}if(shapeIsLine(shape)&&isNumber(shape.x1)){shape.x1*=scale;shape.y1*=scale;shape.x2*=scale;shape.y2*=scale;shape.x1+=translate.x;shape.y1+=translate.y;shape.x2+=translate.x;shape.y2+=translate.y;}if(isNumber(shape.x)&&isNumber(shape.y)){shape.x*=scale;shape.y*=scale;shape.x+=translate.x;shape.y+=translate.y;}if(isNumber(shape.width)&&isNumber(shape.height)){shape.width*=scale;shape.height*=scale;}if(isNumber(shape.rx)&&isNumber(shape.ry)){shape.rx*=scale;shape.ry*=scale;}if(shapeHasNumericStroke(shape)){shape.strokeWidth*=scale;}if(shapeIsText(shape)&&isNumber(shape.fontSize)){shape.fontSize*=scale;if(isNumber(shape.width))shape.width*=scale;}if(hasProp(shape,'cornerRadius')&&isNumber(shape.cornerRadius)){shape.cornerRadius*=scale;}return shape;};const shapeGetCenter=shape=>{if(shapeIsRect(shape)){return vectorCreate(shape.x+shape.width*0.5,shape.y+shape.height*0.5);}if(shapeIsEllipse(shape)){return vectorCreate(shape.x,shape.y);}if(shapeIsTextBox(shape)){const height=shape.height||textSize(shape.text,shape).height;return vectorCreate(shape.x+shape.width*0.5,shape.y+height*0.5);}if(shapeIsTextLine(shape)){const size=textSize(shape.text,shape);return vectorCreate(shape.x+size.width*0.5,shape.y+size.height*0.5);}if(shapeIsPath(shape)){return vectorCenter(shape.points);}if(shapeIsLine(shape)){return vectorCenter([shapeLineGetStartPoint(shape),shapeLineGetEndPoint(shape)]);}return undefined;};const shapeComputeLineEnd=(position,strokeWidth,color,style,direction)=>{let shape={};const isSolid=/solid/.test(style);const scaledSize=5*strokeWidth;const s=isSolid?scaledSize:scaledSize-1;const sh=isSolid?s*0.5:Math.ceil(s*0.5);const normal=vectorNormalize(direction);const offset=vectorMultiply(vectorClone(normal),sh);const anchor=vectorClone(position);const positionUpdated=vectorClone(position);if(/arrow/.test(style)){let x=position.x;let y=position.y;const tipOffset=vectorMultiply(vectorClone(normal),scaledSize);const inset=vectorCreate(x+tipOffset.x,y+tipOffset.y);vectorMultiply(tipOffset,0.55);if(isSolid){const arrowOffset=vectorMultiply(vectorClone(normal),sh*0.5);x-=arrowOffset.x;y-=arrowOffset.y;shape={points:[vectorCreate(x,y),vectorCreate(inset.x-tipOffset.y,inset.y+tipOffset.x),vectorCreate(inset.x+tipOffset.y,inset.y-tipOffset.x)],backgroundColor:color};// move back so arrow triangle overlaps with end of line (otherwise line sticks out of triangle tip)\npositionUpdated.x+=offset.x;positionUpdated.y+=offset.y;}else{// this prevents trouble with sharp line rendering in webgl\nconst p=vectorMultiply(vectorPerpendicular(vectorClone(normal)),0.5);const tipLeft=vectorCreate(x-p.x,y-p.y);const tipRight=vectorCreate(x+p.x,y+p.y);shape={points:[vectorCreate(inset.x+tipOffset.y,inset.y-tipOffset.x),tipLeft,vectorCreate(x,y),tipRight,vectorCreate(inset.x-tipOffset.y,inset.y+tipOffset.x)],strokeWidth:strokeWidth,strokeColor:color};}}else if(/circle/.test(style)){// adjust line point offset\npositionUpdated.x+=offset.x;positionUpdated.y+=offset.y;// add line cap\nshape={x:anchor.x,y:anchor.y,rx:sh,ry:sh,backgroundColor:isSolid?color:undefined,strokeWidth:isSolid?undefined:strokeWidth,strokeColor:isSolid?undefined:color};}else if(/square/.test(style)){// adjust line point offset\npositionUpdated.x+=offset.x;positionUpdated.y+=offset.y;shape={x:anchor.x-sh,y:anchor.y-sh,width:sh*2,height:sh*2,rotation:vectorAngle(normal),backgroundColor:isSolid?color:undefined,strokeWidth:isSolid?undefined:strokeWidth,strokeColor:isSolid?undefined:color};}else if(style==='bar'){shape={points:[vectorCreate(anchor.x-offset.y,anchor.y+offset.x),vectorCreate(anchor.x+offset.y,anchor.y-offset.x)],strokeWidth:strokeWidth,strokeColor:color};}return{position:positionUpdated,shape};};//#endregion\nvar ctxRoundRect=(ctx,x,y,width,height,radius)=>{if(width<2*radius)radius=width/2;if(height<2*radius)radius=height/2;ctx.beginPath();ctx.moveTo(x+radius,y);ctx.arcTo(x+width,y,x+width,y+height,radius);ctx.arcTo(x+width,y+height,x,y+height,radius);ctx.arcTo(x,y+height,x,y,radius);ctx.arcTo(x,y,x+width,y,radius);ctx.closePath();return ctx;};const defineRectShape=(ctx,shape)=>{shape.cornerRadius>0?ctxRoundRect(ctx,shape.x,shape.y,shape.width,shape.height,shape.cornerRadius):ctx.rect(shape.x,shape.y,shape.width,shape.height);return ctx;};const fillRectShape=(ctx,shape)=>{shape.backgroundColor&&ctx.fill();return ctx;};const strokeRectShape=(ctx,shape)=>{shape.strokeWidth&&ctx.stroke();return ctx;};var drawRect=async(ctx,shape)=>new Promise((resolve,reject)=>{ctx.lineWidth=shape.strokeWidth?shape.strokeWidth:1;// 1 is default value for lineWidth prop\nctx.strokeStyle=shape.strokeColor?colorArrayToRGBA(shape.strokeColor):'none';ctx.fillStyle=shape.backgroundColor?colorArrayToRGBA(shape.backgroundColor):'none';ctx.globalAlpha=shape.opacity;if(shape.backgroundImage){shapeLoadResources(shape,(error,shape)=>{if(error)return reject(error);let sX=0;let sY=0;let sWidth=shape.backgroundImageElement.naturalWidth;let sHeight=shape.backgroundImageElement.naturalHeight;let dX=shape.x;let dY=shape.y;let dWidth=shape.width;let dHeight=shape.height;if(shape.backgroundSize==='contain'){const rect=rectContainRect(shape,sWidth/sHeight);dWidth=rect.width;dHeight=rect.height;dX+=rect.x;dY+=rect.y;}else if(shape.backgroundSize==='cover'){const rect=rectContainRect(rectCreate(0,0,sWidth,sHeight),dWidth/dHeight);sWidth=rect.width;sHeight=rect.height;sX=rect.x;sY=rect.y;}defineRectShape(ctx,shape);fillRectShape(ctx,shape);ctx.save();ctx.clip();ctx.drawImage(shape.backgroundImageElement,sX,sY,sWidth,sHeight,dX,dY,dWidth,dHeight);ctx.restore();strokeRectShape(ctx,shape);resolve([]);});}else{defineRectShape(ctx,shape);fillRectShape(ctx,shape);strokeRectShape(ctx,shape);resolve([]);}});var drawEllipse=async(ctx,shape)=>new Promise((resolve,reject)=>{ctx.lineWidth=shape.strokeWidth||1;// 1 is default value for lineWidth prop\nctx.strokeStyle=shape.strokeColor?colorArrayToRGBA(shape.strokeColor):'none';ctx.fillStyle=shape.backgroundColor?colorArrayToRGBA(shape.backgroundColor):'none';ctx.globalAlpha=shape.opacity;ctx.ellipse(shape.x,shape.y,shape.rx,shape.ry,0,0,Math.PI*2);shape.backgroundColor&&ctx.fill();if(shape.backgroundImage){shapeLoadResources(shape,(error,image)=>{if(error)return reject(error);ctx.drawImage(image.backgroundImageElement,shape.x,shape.y,shape.width,shape.height);shape.strokeWidth&&ctx.stroke();resolve([]);});}else{shape.strokeWidth&&ctx.stroke();}resolve([]);});var drawText$1=async(ctx,shape)=>{const size=shape.width&&shape.height?sizeCreateFromAny(shape):textSize(shape.text,shape);const rect={x:shape.x,y:shape.y,width:shape.width||size.width,height:size.height};drawRect(ctx,_objectSpread(_objectSpread({},shape),rect));updateTextContext(ctx,shape);let tx=0;if(shape.textAlign=='center'){tx=-textPadding*0.5;}else if(shape.textAlign==='right'){tx=-textPadding;}ctx.rect(shape.x+tx,shape.y,shape.width+textPadding*2,shape.height);ctx.save();ctx.clip();drawText(ctx,shape.width?wrapText(ctx,shape.text,shape.width):shape.text,{x:shape.x,y:shape.y,fontSize:shape.fontSize,textAlign:shape.textAlign,lineHeight:shape.lineHeight,lineWidth:shape.width});ctx.restore();return[];};var drawLine=async(ctx,shape)=>new Promise(async(resolve,reject)=>{ctx.lineWidth=shape.strokeWidth||1;// 1 is default value for lineWidth prop\nctx.strokeStyle=shape.strokeColor?colorArrayToRGBA(shape.strokeColor):'none';ctx.globalAlpha=shape.opacity;let lineStartPosition=shapeLineGetStartPoint(shape);let lineEndPosition=shapeLineGetEndPoint(shape);const lineStartDescription=shape.lineStart&&shapeComputeLineEnd(lineStartPosition,shape.strokeWidth,shape.strokeColor,shape.lineStart,vectorCreate(lineEndPosition.x-lineStartPosition.x,lineEndPosition.y-lineStartPosition.y));const lineEndDescription=shape.lineEnd&&shapeComputeLineEnd(lineEndPosition,shape.strokeWidth,shape.strokeColor,shape.lineEnd,vectorCreate(lineStartPosition.x-lineEndPosition.x,lineStartPosition.y-lineEndPosition.y));// update start and end position of line if required to draw caps\nlineStartPosition=lineStartDescription?lineStartDescription.position:lineStartPosition;lineEndPosition=lineEndDescription?lineEndDescription.position:lineEndPosition;// draw line\nctx.moveTo(lineStartPosition.x,lineStartPosition.y);ctx.lineTo(lineEndPosition.x,lineEndPosition.y);shape.strokeWidth&&ctx.stroke();// draw other shapes\nresolve([lineStartDescription&&lineStartDescription.shape,lineEndDescription&&lineEndDescription.shape].filter(Boolean));});var drawPath=async(ctx,shape)=>new Promise((resolve,reject)=>{ctx.lineWidth=shape.strokeWidth||1;// 1 is default value for lineWidth prop\nctx.strokeStyle=shape.strokeColor?colorArrayToRGBA(shape.strokeColor):'none';ctx.fillStyle=shape.backgroundColor?colorArrayToRGBA(shape.backgroundColor):'none';ctx.globalAlpha=shape.opacity;// draw line\nconst{points}=shape;ctx.moveTo(points[0].x,points[0].y);const l=points.length;for(let i=1;i<l;i++){ctx.lineTo(points[i].x,points[i].y);}shape.strokeWidth&&ctx.stroke();shape.backgroundColor&&ctx.fill();resolve([]);});var ctxFlip=(ctx,flipX,flipY,pivot)=>{if(!flipX&&!flipY)return ctx;ctx.translate(pivot.x,pivot.y);ctx.scale(flipX?-1:1,flipY?-1:1);ctx.translate(-pivot.x,-pivot.y);return ctx;};const drawShape=async(ctx,shape)=>{// center, needed for transforms\nconst center=shapeGetCenter(shape);// rotate context\nctxRotate(ctx,shape.rotation,center);// flip context\nctxFlip(ctx,shape.flipX,shape.flipY,center);let fn;if(shapeIsRect(shape)){fn=drawRect;}else if(shapeIsEllipse(shape)){fn=drawEllipse;}else if(shapeIsLine(shape)){fn=drawLine;}else if(shapeIsPath(shape)){fn=drawPath;}else if(shapeIsText(shape)){fn=drawText$1;}// get shapes\nreturn[shape,...(await drawShapes(ctx,await fn(ctx,shape)))];};var drawShapes=async(ctx,shapes)=>{let drawnShapes=[];for(const shape of shapes){ctx.save();// clears previous shape's path\nctx.beginPath();// wait for shape to draw before drawing next shape\ndrawnShapes=[...drawnShapes,...(await drawShape(ctx,shape))];ctx.restore();}return drawnShapes;};var drawImageData=async(imageData,options={})=>{const{shapes=[],context=imageData,transform=noop}=options;// no shapes to draw\nif(!shapes.length)return imageData;// output\nlet imageDataOut;// create drawing context\nconst canvas=h('canvas');canvas.width=imageData.width;canvas.height=imageData.height;const ctx=canvas.getContext('2d');ctx.putImageData(imageData,0,0);// compute the position of all shapes\nconst computedShapes=shapes.map(shapeDeepCopy).map(shape=>shapeComputeDisplay(shape,{x:0,y:0,width:context.width,height:context.height}));// compute transforms for all shapes\ntransform(ctx);// draw shapes to canvas\nawait drawShapes(ctx,computedShapes);imageDataOut=ctx.getImageData(0,0,canvas.width,canvas.height);releaseCanvas(canvas);return imageDataOut;};var fillImageData=async(imageData,options={})=>{const{backgroundColor}=options;// no background color set or is fully transparent background color\nif(!backgroundColor||backgroundColor&&backgroundColor[3]===0)return imageData;// fill\nlet imageDataOut;let image=h('canvas');image.width=imageData.width;image.height=imageData.height;const ctx=image.getContext('2d');ctx.putImageData(imageData,0,0);// fill behind image\nctx.globalCompositeOperation='destination-over';ctx.fillStyle=colorArrayToRGBA(backgroundColor);ctx.fillRect(0,0,image.width,image.height);imageDataOut=ctx.getImageData(0,0,image.width,image.height);releaseCanvas(image);return imageDataOut;};var dotColorMatrix=(a,b)=>{const res=new Array(20);// R\nres[0]=a[0]*b[0]+a[1]*b[5]+a[2]*b[10]+a[3]*b[15];res[1]=a[0]*b[1]+a[1]*b[6]+a[2]*b[11]+a[3]*b[16];res[2]=a[0]*b[2]+a[1]*b[7]+a[2]*b[12]+a[3]*b[17];res[3]=a[0]*b[3]+a[1]*b[8]+a[2]*b[13]+a[3]*b[18];res[4]=a[0]*b[4]+a[1]*b[9]+a[2]*b[14]+a[3]*b[19]+a[4];// G\nres[5]=a[5]*b[0]+a[6]*b[5]+a[7]*b[10]+a[8]*b[15];res[6]=a[5]*b[1]+a[6]*b[6]+a[7]*b[11]+a[8]*b[16];res[7]=a[5]*b[2]+a[6]*b[7]+a[7]*b[12]+a[8]*b[17];res[8]=a[5]*b[3]+a[6]*b[8]+a[7]*b[13]+a[8]*b[18];res[9]=a[5]*b[4]+a[6]*b[9]+a[7]*b[14]+a[8]*b[19]+a[9];// B\nres[10]=a[10]*b[0]+a[11]*b[5]+a[12]*b[10]+a[13]*b[15];res[11]=a[10]*b[1]+a[11]*b[6]+a[12]*b[11]+a[13]*b[16];res[12]=a[10]*b[2]+a[11]*b[7]+a[12]*b[12]+a[13]*b[17];res[13]=a[10]*b[3]+a[11]*b[8]+a[12]*b[13]+a[13]*b[18];res[14]=a[10]*b[4]+a[11]*b[9]+a[12]*b[14]+a[13]*b[19]+a[14];// A\nres[15]=a[15]*b[0]+a[16]*b[5]+a[17]*b[10]+a[18]*b[15];res[16]=a[15]*b[1]+a[16]*b[6]+a[17]*b[11]+a[18]*b[16];res[17]=a[15]*b[2]+a[16]*b[7]+a[17]*b[12]+a[18]*b[17];res[18]=a[15]*b[3]+a[16]*b[8]+a[17]*b[13]+a[18]*b[18];res[19]=a[15]*b[4]+a[16]*b[9]+a[17]*b[14]+a[18]*b[19]+a[19];return res;};var getColorMatrixFromColorMatrices=colorMatrices=>colorMatrices.length?colorMatrices.reduce((previous,current)=>dotColorMatrix([...previous],current),colorMatrices.shift()):[];// connect function in process chain\nconst connect=(fn,getter=(...args)=>args,setter)=>async(state,options,onprogress)=>{// will hold function result\nlet res;// at this point we don't know if the length of this task can be computed\nonprogress(createProgressEvent(0,false));// try to run the function\nlet progressUpdated=false;try{res=await fn(...getter(state,options,event=>{progressUpdated=true;onprogress(event);}));}catch(err){throw err;}// a setter isn't required\nsetter&&setter(state,res);// if progress was updated, we expect the connected function to fire the 1/1 event, else we fire it here\nif(!progressUpdated)onprogress(createProgressEvent(1,false));return state;};//\n// Reader/Writer Presets\n//\nconst AnyToFile=({srcProp='src',destProp='dest'}={})=>[connect(srcToFile,(state,options,onprogress)=>[state[srcProp],onprogress],(state,file)=>state[destProp]=file),'any-to-file'];const BlobReadImageSize=({srcProp='src',destProp='size'}={})=>[connect(getImageSize,(state,options)=>[state[srcProp]],(state,size)=>state[destProp]=size),'read-image-size'];const ImageSizeMatchOrientation=({srcSize='size',srcOrientation='orientation',destSize='size'}={})=>[connect(orientImageSize,state=>[state[srcSize],state[srcOrientation]],(state,size)=>state[destSize]=size),'image-size-match-orientation'];const BlobReadImageHead=({srcProp='src',destProp='head'}={})=>[connect((blob,slice)=>isJPEG(blob)?blobReadSection(blob,slice):undefined,// 64 * 1024 should be enough bytes to find orientation header in next step\n// Exif metadata are restricted in size to 64 kB in JPEG images because according to the specification this information must be contained within a single JPEG APP1 segment.\nstate=>[state[srcProp],[0,64*1024],onprogress],(state,head)=>state[destProp]=head),'read-image-head'];const ImageHeadReadExifOrientationTag=({srcProp='head',destProp='orientation'}={})=>[connect(arrayBufferReadExifOrientationTag,state=>[state[srcProp]],(state,orientation)=>state[destProp]=orientation),'read-exif-orientation-tag'];const ImageHeadClearExifOrientationTag=({srcProp='head'}={})=>[connect(arrayBufferWriteExifOrientationTag,state=>[state[srcProp],1]),'clear-exif-orientation-tag'];const ApplyCanvasScalar=({srcImageSize='size',srcCanvasSize='imageData',srcImageState='imageState',destImageSize='size',destScalar='scalar'}={})=>[connect((naturalSize,canvasSize,imageState)=>{// calculate canvas scalar\nconst scalar=Math.min(canvasSize.width/naturalSize.width,canvasSize.height/naturalSize.height);// done because not scaling\nif(scalar!==1){const{crop,annotation,decoration}=imageState;// origin to scale to\nconst origin=vectorCreateEmpty();// scale select.crop\nif(crop)imageState.crop=rectScale(crop,scalar,origin);// scale annotation\nconst translate=vectorCreateEmpty();imageState.annotation=annotation.map(shape=>shapeComputeTransform(shape,translate,scalar));// scale decoration\nimageState.decoration=decoration.map(shape=>shapeComputeTransform(shape,translate,scalar));}return[scalar,sizeCreateFromAny(canvasSize)];},state=>[state[srcImageSize],state[srcCanvasSize],state[srcImageState]],(state,[scalar,imageSize])=>{state[destScalar]=scalar;state[destImageSize]=imageSize;}),'calculate-canvas-scalar'];const BlobToImageData=({srcProp='src',destProp='imageData',canvasMemoryLimit=undefined})=>[connect(blobToImageData,state=>[state[srcProp],canvasMemoryLimit],(state,imageData)=>state[destProp]=imageData),'blob-to-image-data'];const ImageDataMatchOrientation=({srcImageData='imageData',srcOrientation='orientation'}={})=>[connect(orientImageData,state=>[state[srcImageData],state[srcOrientation]],(state,imageData)=>state.imageData=imageData),'image-data-match-orientation'];const ImageDataFill=({srcImageData='imageData',srcImageState='imageState'}={})=>[connect(fillImageData,state=>[state[srcImageData],{backgroundColor:state[srcImageState].backgroundColor}],(state,imageData)=>state.imageData=imageData),'image-data-fill'];const ImageDataCrop=({srcImageData='imageData',srcImageState='imageState'}={})=>[connect(cropImageData,state=>[state[srcImageData],{crop:state[srcImageState].crop,rotation:state[srcImageState].rotation,flipX:state[srcImageState].flipX,flipY:state[srcImageState].flipY}],(state,imageData)=>state.imageData=imageData),'image-data-crop'];const ImageDataResize=({resize={width:undefined,height:undefined,fit:undefined,upscale:undefined},srcProp='imageData',srcImageState='imageState',destImageScaledSize='imageScaledSize'})=>[connect(resizeImageData,state=>[state[srcProp],{width:Math.min(resize.width||Number.MAX_SAFE_INTEGER,state[srcImageState].targetSize&&state[srcImageState].targetSize.width||Number.MAX_SAFE_INTEGER),height:Math.min(resize.height||Number.MAX_SAFE_INTEGER,state[srcImageState].targetSize&&state[srcImageState].targetSize.height||Number.MAX_SAFE_INTEGER),fit:resize.fit||'contain',upscale:resize.upscale||false}],(state,imageData)=>{if(!sizeEqual(state.imageData,imageData))state[destImageScaledSize]=sizeCreateFromAny(imageData);state.imageData=imageData;}),'image-data-resize'];const ImageDataFilter=({srcImageData='imageData',srcImageState='imageState',destImageData='imageData'}={})=>[connect(filterImageData,state=>{const{colorMatrix}=state[srcImageState];const colorMatrices=colorMatrix&&Object.keys(colorMatrix).map(name=>colorMatrix[name]).filter(Boolean);return[state[srcImageData],{colorMatrix:colorMatrices&&getColorMatrixFromColorMatrices(colorMatrices),convolutionMatrix:state[srcImageState].convolutionMatrix,gamma:state[srcImageState].gamma,noise:state[srcImageState].noise,vignette:state[srcImageState].vignette}];},(state,imageData)=>state[destImageData]=imageData),'image-data-filter'];const ImageDataAnnotate=({srcImageData='imageData',srcSize='size',srcImageState='imageState',destImageData='imageData',destImageScaledSize='imageScaledSize'}={})=>[connect(drawImageData,state=>[state[srcImageData],{shapes:state[srcImageState].annotation,context:state[srcSize],transform:ctx=>{const imageSize=state[srcSize];const{crop=rectCreateFromSize(imageSize),rotation=0,flipX,flipY}=state[srcImageState];const rotatedRect=getImageTransformedRect(imageSize,rotation);const rotatedSize={width:rotatedRect.width,height:rotatedRect.height};// calculate image scalar so we can scale annotations accordingly\nconst scaledSize=state[destImageScaledSize];const scalar=scaledSize?Math.min(scaledSize.width/crop.width,scaledSize.height/crop.height):1;// calculate center\nconst dx=imageSize.width*0.5-rotatedSize.width*0.5;const dy=imageSize.height*0.5-rotatedSize.height*0.5;const center=sizeCenter(imageSize);// image scalar\nctx.scale(scalar,scalar);// offset\nctx.translate(-dx,-dy);ctx.translate(-crop.x,-crop.y);// rotation\nctx.translate(center.x,center.y);ctx.rotate(rotation);ctx.translate(-center.x,-center.y);// flipping\nctx.scale(flipX?-1:1,flipY?-1:1);ctx.translate(flipX?-imageSize.width:0,flipY?-imageSize.height:0);// annotations are clipped clip to image\nctx.rect(0,0,imageSize.width,imageSize.height);ctx.clip();}}],(state,imageData)=>state[destImageData]=imageData),'image-data-annotate'];const ImageDataDecorate=({srcImageData='imageData',srcImageState='imageState',destImageData='imageData',destImageScaledSize='imageScaledSize'}={})=>[connect(drawImageData,state=>[state[srcImageData],{shapes:state[srcImageState].decoration,context:state[srcImageState].crop,transform:ctx=>{// calculate image scalar so we can scale decoration accordingly\nconst{crop}=state.imageState;const scaledSize=state[destImageScaledSize];const scalar=scaledSize?Math.min(scaledSize.width/crop.width,scaledSize.height/crop.height):1;ctx.scale(scalar,scalar);}}],(state,imageData)=>state[destImageData]=imageData),'image-data-decorate'];const ImageDataToBlob=({mimeType=undefined,quality=undefined,srcImageData='imageData',srcFile='src',destBlob='blob'}={})=>[connect(imageDataToBlob,state=>[state[srcImageData],mimeType||getMimeTypeFromFilename(state[srcFile].name)||state[srcFile].type,quality],(state,blob)=>state[destBlob]=blob),'image-data-to-blob'];const BlobWriteImageHead=(srcBlob='blob',srcHead='head',destBlob='blob')=>[connect((blob,head)=>isJPEG(blob)&&head?blobWriteSection(blob,arrayBufferReadImageHead(head),// location and size of the JPEG header\n[20]):blob,state=>[state[srcBlob],state[srcHead]],(state,blob)=>state[destBlob]=blob),'blob-write-image-head'];const BlobToFile=({renameFile=undefined,srcBlob='blob',srcFile='src',destFile='dest',defaultFilename=undefined}={})=>[connect(blobToFile,state=>[state[srcBlob],renameFile?renameFile(state[srcFile]):state[srcFile].name||`${defaultFilename}.${getExtensionFromMimeType(state[srcBlob].type)}`],(state,file)=>state[destFile]=file),'blob-to-file'];const Store=({url='./',dataset=state=>[['dest',state.dest,state.dest.name],['imageState',state.imageState]],destStore='store'})=>[connect(// upload function\nasync(dataset,onprogress)=>{try{return await post(url,dataset,{onprogress});}catch(err){throw err;}},// get state values\n(state,options,onprogress)=>[dataset(state),onprogress],// set state values\n(state,xhr)=>state[destStore]=xhr// logs XHR request returned by `post`\n),'store'];const PropFilter=allowlist=>[connect(state=>{// if no allowlist suppleid or is empty array we don't filter\nif(!allowlist||!allowlist.length)return state;// else we only allow the props defined in the list and delete non matching props\nObject.keys(state).forEach(key=>{if(allowlist.includes(key))return;delete state[key];});return state;}),'prop-filter'];// Generic image reader, suitable for most use cases\nconst createDefaultImageReader=(options={})=>{const{orientImage=true,outputProps=['src','dest','size'],preprocessImageFile}=options;return[// can read most source files and turn them into blobs\nAnyToFile(),// TODO: test if supported mime/type\n// called when file created, can be used to read unrecognized files\npreprocessImageFile&&[connect(preprocessImageFile,(state,options,onprogress)=>[state.dest,options,onprogress],(state,file)=>state.dest=file),'preprocess-image-file'],// quickly read size (only reads first part of image)\nBlobReadImageSize({srcProp:'dest'}),// fix image orientation\norientImage&&BlobReadImageHead({srcProp:'dest'}),orientImage&&ImageHeadReadExifOrientationTag(),orientImage&&ImageSizeMatchOrientation(),// remove unwanted props\nPropFilter(outputProps)].filter(Boolean);};// Generic image writer, suitable for most use cases\nconst createDefaultImageWriter=(options={})=>{const{canvasMemoryLimit=isIOS()?4096*4096:Infinity,orientImage=true,copyImageHead=true,mimeType=undefined,quality=undefined,renameFile=undefined,targetSize=undefined,store=undefined,outputProps=['src','dest','imageState','store'],preprocessImageState,postprocessImageData}=options;return[// get orientation info (if is jpeg)\n(orientImage||copyImageHead)&&BlobReadImageHead(),orientImage&&ImageHeadReadExifOrientationTag(),// get image size\nBlobReadImageSize(),// allow preproccesing of image state for example to replace placeholders\npreprocessImageState&&[connect(preprocessImageState,(state,options,onprogress)=>[state.imageState,options,onprogress],(state,imageState)=>state.imageState=imageState),'preprocess-image-state'],// get image data\nBlobToImageData({canvasMemoryLimit}),// get canvas scalar for when scaled down\nApplyCanvasScalar(),// fix image orientation\norientImage&&ImageSizeMatchOrientation(),orientImage&&ImageDataMatchOrientation(),// apply image state\nImageDataCrop(),ImageDataResize({resize:targetSize}),ImageDataFilter(),ImageDataFill(),ImageDataAnnotate(),ImageDataDecorate(),// run post processing on image data, for example to apply circular crop\npostprocessImageData&&[connect(postprocessImageData,(state,options,onprogress)=>[state.imageData,options,onprogress],(state,imageData)=>state.imageData=imageData),'postprocess-image-data'],// convert to file\nImageDataToBlob({mimeType,quality}),// we overwite the exif orientation tag so the image is oriented correctly\norientImage&&ImageHeadClearExifOrientationTag(),// we write the new image head to the target blob\ncopyImageHead&&BlobWriteImageHead(),// turn the image blob into a file, will also rename the file\nBlobToFile({defaultFilename:'image',renameFile}),// upload or process data\nstore&&(isString(store)?// a basic store to post to\nStore({url:store}):// see if is fully custom or store config\nisFunction(store)?// fully custom store function\n[store,'store']:// a store configuration object\nStore(store)),// remove unwanted props\nPropFilter(outputProps)].filter(Boolean);};function noop$1(){}const identity=x=>x;function assign(tar,src){// @ts-ignore\nfor(const k in src)tar[k]=src[k];return tar;}function run(fn){return fn();}function blank_object(){return Object.create(null);}function run_all(fns){fns.forEach(run);}function is_function(thing){return typeof thing==='function';}function safe_not_equal(a,b){return a!=a?b==b:a!==b||a&&typeof a==='object'||typeof a==='function';}function is_empty(obj){return Object.keys(obj).length===0;}function subscribe(store,...callbacks){if(store==null){return noop$1;}const unsub=store.subscribe(...callbacks);return unsub.unsubscribe?()=>unsub.unsubscribe():unsub;}function get_store_value(store){let value;subscribe(store,_=>value=_)();return value;}function component_subscribe(component,store,callback){component.$$.on_destroy.push(subscribe(store,callback));}function create_slot(definition,ctx,$$scope,fn){if(definition){const slot_ctx=get_slot_context(definition,ctx,$$scope,fn);return definition[0](slot_ctx);}}function get_slot_context(definition,ctx,$$scope,fn){return definition[1]&&fn?assign($$scope.ctx.slice(),definition[1](fn(ctx))):$$scope.ctx;}function get_slot_changes(definition,$$scope,dirty,fn){if(definition[2]&&fn){const lets=definition[2](fn(dirty));if($$scope.dirty===undefined){return lets;}if(typeof lets==='object'){const merged=[];const len=Math.max($$scope.dirty.length,lets.length);for(let i=0;i<len;i+=1){merged[i]=$$scope.dirty[i]|lets[i];}return merged;}return $$scope.dirty|lets;}return $$scope.dirty;}function update_slot(slot,slot_definition,ctx,$$scope,dirty,get_slot_changes_fn,get_slot_context_fn){const slot_changes=get_slot_changes(slot_definition,$$scope,dirty,get_slot_changes_fn);if(slot_changes){const slot_context=get_slot_context(slot_definition,ctx,$$scope,get_slot_context_fn);slot.p(slot_context,slot_changes);}}function exclude_internal_props(props){const result={};for(const k in props)if(k[0]!=='$')result[k]=props[k];return result;}function set_store_value(store,ret,value=ret){store.set(value);return ret;}function action_destroyer(action_result){return action_result&&is_function(action_result.destroy)?action_result.destroy:noop$1;}const is_client=false;let now=is_client?()=>window.performance.now():()=>Date.now();let raf=is_client?cb=>requestAnimationFrame(cb):noop$1;const tasks=new Set();function run_tasks(now){tasks.forEach(task=>{if(!task.c(now)){tasks.delete(task);task.f();}});if(tasks.size!==0)raf(run_tasks);}/**\n * Creates a new task that runs on each raf frame\n * until it returns a falsy value or is aborted\n */function loop(callback){let task;if(tasks.size===0)raf(run_tasks);return{promise:new Promise(fulfill=>{tasks.add(task={c:callback,f:fulfill});}),abort(){tasks.delete(task);}};}function append(target,node){target.appendChild(node);}function insert(target,node,anchor){target.insertBefore(node,anchor||null);}function detach(node){node.parentNode.removeChild(node);}function element(name){return document.createElement(name);}function svg_element(name){return document.createElementNS('http://www.w3.org/2000/svg',name);}function text(data){return document.createTextNode(data);}function space(){return text(' ');}function empty(){return text('');}function listen(node,event,handler,options){node.addEventListener(event,handler,options);return()=>node.removeEventListener(event,handler,options);}function prevent_default(fn){return function(event){event.preventDefault();// @ts-ignore\nreturn fn.call(this,event);};}function stop_propagation(fn){return function(event){event.stopPropagation();// @ts-ignore\nreturn fn.call(this,event);};}function attr(node,attribute,value){if(value==null)node.removeAttribute(attribute);else if(node.getAttribute(attribute)!==value)node.setAttribute(attribute,value);}function set_attributes(node,attributes){// @ts-ignore\nconst descriptors=Object.getOwnPropertyDescriptors(node.__proto__);for(const key in attributes){if(attributes[key]==null){node.removeAttribute(key);}else if(key==='style'){node.style.cssText=attributes[key];}else if(key==='__value'){node.value=node[key]=attributes[key];}else if(descriptors[key]&&descriptors[key].set){node[key]=attributes[key];}else{attr(node,key,attributes[key]);}}}function children(element){return Array.from(element.childNodes);}function set_data(text,data){data=''+data;if(text.wholeText!==data)text.data=data;}function set_input_value(input,value){input.value=value==null?'':value;}function set_style(node,key,value,important){node.style.setProperty(key,value,important?'important':'');}function custom_event(type,detail){const e=document.createEvent('CustomEvent');e.initCustomEvent(type,false,false,detail);return e;}const active_docs=new Set();let active=0;// https://github.com/darkskyapp/string-hash/blob/master/index.js\nfunction hash(str){let hash=5381;let i=str.length;while(i--)hash=(hash<<5)-hash^str.charCodeAt(i);return hash>>>0;}function create_rule(node,a,b,duration,delay,ease,fn,uid=0){const step=16.666/duration;let keyframes='{\\n';for(let p=0;p<=1;p+=step){const t=a+(b-a)*ease(p);keyframes+=p*100+`%{${fn(t,1-t)}}\\n`;}const rule=keyframes+`100% {${fn(b,1-b)}}\\n}`;const name=`__svelte_${hash(rule)}_${uid}`;const doc=node.ownerDocument;active_docs.add(doc);const stylesheet=doc.__svelte_stylesheet||(doc.__svelte_stylesheet=doc.head.appendChild(element('style')).sheet);const current_rules=doc.__svelte_rules||(doc.__svelte_rules={});if(!current_rules[name]){current_rules[name]=true;stylesheet.insertRule(`@keyframes ${name} ${rule}`,stylesheet.cssRules.length);}const animation=node.style.animation||'';node.style.animation=`${animation?`${animation}, `:''}${name} ${duration}ms linear ${delay}ms 1 both`;active+=1;return name;}function delete_rule(node,name){const previous=(node.style.animation||'').split(', ');const next=previous.filter(name?anim=>anim.indexOf(name)<0// remove specific animation\n:anim=>anim.indexOf('__svelte')===-1// remove all Svelte animations\n);const deleted=previous.length-next.length;if(deleted){node.style.animation=next.join(', ');active-=deleted;if(!active)clear_rules();}}function clear_rules(){raf(()=>{if(active)return;active_docs.forEach(doc=>{const stylesheet=doc.__svelte_stylesheet;let i=stylesheet.cssRules.length;while(i--)stylesheet.deleteRule(i);doc.__svelte_rules={};});active_docs.clear();});}let current_component;function set_current_component(component){current_component=component;}function get_current_component(){if(!current_component)throw new Error('Function called outside component initialization');return current_component;}function onMount(fn){get_current_component().$$.on_mount.push(fn);}function afterUpdate(fn){get_current_component().$$.after_update.push(fn);}function onDestroy(fn){get_current_component().$$.on_destroy.push(fn);}function createEventDispatcher(){const component=get_current_component();return(type,detail)=>{const callbacks=component.$$.callbacks[type];if(callbacks){// TODO are there situations where events could be dispatched\n// in a server (non-DOM) environment?\nconst event=custom_event(type,detail);callbacks.slice().forEach(fn=>{fn.call(component,event);});}};}function setContext(key,context){get_current_component().$$.context.set(key,context);}function getContext(key){return get_current_component().$$.context.get(key);}// TODO figure out if we still want to support\n// shorthand events, or if we want to implement\n// a real bubbling mechanism\nfunction bubble(component,event){const callbacks=component.$$.callbacks[event.type];if(callbacks){callbacks.slice().forEach(fn=>fn(event));}}const dirty_components=[];const binding_callbacks=[];const render_callbacks=[];const flush_callbacks=[];const resolved_promise=Promise.resolve();let update_scheduled=false;function schedule_update(){if(!update_scheduled){update_scheduled=true;resolved_promise.then(flush);}}function add_render_callback(fn){render_callbacks.push(fn);}function add_flush_callback(fn){flush_callbacks.push(fn);}let flushing=false;const seen_callbacks=new Set();function flush(){if(flushing)return;flushing=true;do{// first, call beforeUpdate functions\n// and update components\nfor(let i=0;i<dirty_components.length;i+=1){const component=dirty_components[i];set_current_component(component);update(component.$$);}set_current_component(null);dirty_components.length=0;while(binding_callbacks.length)binding_callbacks.pop()();// then, once components are updated, call\n// afterUpdate functions. This may cause\n// subsequent updates...\nfor(let i=0;i<render_callbacks.length;i+=1){const callback=render_callbacks[i];if(!seen_callbacks.has(callback)){// ...so guard against infinite loops\nseen_callbacks.add(callback);callback();}}render_callbacks.length=0;}while(dirty_components.length);while(flush_callbacks.length){flush_callbacks.pop()();}update_scheduled=false;flushing=false;seen_callbacks.clear();}function update($$){if($$.fragment!==null){$$.update();run_all($$.before_update);const dirty=$$.dirty;$$.dirty=[-1];$$.fragment&&$$.fragment.p($$.ctx,dirty);$$.after_update.forEach(add_render_callback);}}let promise;function wait(){if(!promise){promise=Promise.resolve();promise.then(()=>{promise=null;});}return promise;}function dispatch(node,direction,kind){node.dispatchEvent(custom_event(`${direction?'intro':'outro'}${kind}`));}const outroing=new Set();let outros;function group_outros(){outros={r:0,c:[],p:outros// parent group\n};}function check_outros(){if(!outros.r){run_all(outros.c);}outros=outros.p;}function transition_in(block,local){if(block&&block.i){outroing.delete(block);block.i(local);}}function transition_out(block,local,detach,callback){if(block&&block.o){if(outroing.has(block))return;outroing.add(block);outros.c.push(()=>{outroing.delete(block);if(callback){if(detach)block.d(1);callback();}});block.o(local);}}const null_transition={duration:0};function create_bidirectional_transition(node,fn,params,intro){let config=fn(node,params);let t=intro?0:1;let running_program=null;let pending_program=null;let animation_name=null;function clear_animation(){if(animation_name)delete_rule(node,animation_name);}function init(program,duration){const d=program.b-t;duration*=Math.abs(d);return{a:t,b:program.b,d,duration,start:program.start,end:program.start+duration,group:program.group};}function go(b){const{delay=0,duration=300,easing=identity,tick=noop$1,css}=config||null_transition;const program={start:now()+delay,b};if(!b){// @ts-ignore todo: improve typings\nprogram.group=outros;outros.r+=1;}if(running_program||pending_program){pending_program=program;}else{// if this is an intro, and there's a delay, we need to do\n// an initial tick and/or apply CSS animation immediately\nif(css){clear_animation();animation_name=create_rule(node,t,b,duration,delay,easing,css);}if(b)tick(0,1);running_program=init(program,duration);add_render_callback(()=>dispatch(node,b,'start'));loop(now=>{if(pending_program&&now>pending_program.start){running_program=init(pending_program,duration);pending_program=null;dispatch(node,running_program.b,'start');if(css){clear_animation();animation_name=create_rule(node,t,running_program.b,running_program.duration,0,easing,config.css);}}if(running_program){if(now>=running_program.end){tick(t=running_program.b,1-t);dispatch(node,running_program.b,'end');if(!pending_program){// we're done\nif(running_program.b){// intro — we can tidy up immediately\nclear_animation();}else{// outro — needs to be coordinated\nif(! --running_program.group.r)run_all(running_program.group.c);}}running_program=null;}else if(now>=running_program.start){const p=now-running_program.start;t=running_program.a+running_program.d*easing(p/running_program.duration);tick(t,1-t);}}return!!(running_program||pending_program);});}}return{run(b){if(is_function(config)){wait().then(()=>{// @ts-ignore\nconfig=config();go(b);});}else{go(b);}},end(){clear_animation();running_program=pending_program=null;}};}const globals=false?window:typeof globalThis!=='undefined'?globalThis:global;function destroy_block(block,lookup){block.d(1);lookup.delete(block.key);}function outro_and_destroy_block(block,lookup){transition_out(block,1,1,()=>{lookup.delete(block.key);});}function update_keyed_each(old_blocks,dirty,get_key,dynamic,ctx,list,lookup,node,destroy,create_each_block,next,get_context){let o=old_blocks.length;let n=list.length;let i=o;const old_indexes={};while(i--)old_indexes[old_blocks[i].key]=i;const new_blocks=[];const new_lookup=new Map();const deltas=new Map();i=n;while(i--){const child_ctx=get_context(ctx,list,i);const key=get_key(child_ctx);let block=lookup.get(key);if(!block){block=create_each_block(key,child_ctx);block.c();}else if(dynamic){block.p(child_ctx,dirty);}new_lookup.set(key,new_blocks[i]=block);if(key in old_indexes)deltas.set(key,Math.abs(i-old_indexes[key]));}const will_move=new Set();const did_move=new Set();function insert(block){transition_in(block,1);block.m(node,next);lookup.set(block.key,block);next=block.first;n--;}while(o&&n){const new_block=new_blocks[n-1];const old_block=old_blocks[o-1];const new_key=new_block.key;const old_key=old_block.key;if(new_block===old_block){// do nothing\nnext=new_block.first;o--;n--;}else if(!new_lookup.has(old_key)){// remove old block\ndestroy(old_block,lookup);o--;}else if(!lookup.has(new_key)||will_move.has(new_key)){insert(new_block);}else if(did_move.has(old_key)){o--;}else if(deltas.get(new_key)>deltas.get(old_key)){did_move.add(new_key);insert(new_block);}else{will_move.add(old_key);o--;}}while(o--){const old_block=old_blocks[o];if(!new_lookup.has(old_block.key))destroy(old_block,lookup);}while(n)insert(new_blocks[n-1]);return new_blocks;}function get_spread_update(levels,updates){const update={};const to_null_out={};const accounted_for={$$scope:1};let i=levels.length;while(i--){const o=levels[i];const n=updates[i];if(n){for(const key in o){if(!(key in n))to_null_out[key]=1;}for(const key in n){if(!accounted_for[key]){update[key]=n[key];accounted_for[key]=1;}}levels[i]=n;}else{for(const key in o){accounted_for[key]=1;}}}for(const key in to_null_out){if(!(key in update))update[key]=undefined;}return update;}function get_spread_object(spread_props){return typeof spread_props==='object'&&spread_props!==null?spread_props:{};}function bind(component,name,callback){const index=component.$$.props[name];if(index!==undefined){component.$$.bound[index]=callback;callback(component.$$.ctx[index]);}}function create_component(block){block&&block.c();}function mount_component(component,target,anchor){const{fragment,on_mount,on_destroy,after_update}=component.$$;fragment&&fragment.m(target,anchor);// onMount happens before the initial afterUpdate\nadd_render_callback(()=>{const new_on_destroy=on_mount.map(run).filter(is_function);if(on_destroy){on_destroy.push(...new_on_destroy);}else{// Edge case - component was destroyed immediately,\n// most likely as a result of a binding initialising\nrun_all(new_on_destroy);}component.$$.on_mount=[];});after_update.forEach(add_render_callback);}function destroy_component(component,detaching){const $$=component.$$;if($$.fragment!==null){run_all($$.on_destroy);$$.fragment&&$$.fragment.d(detaching);// TODO null out other refs, including component.$$ (but need to\n// preserve final state?)\n$$.on_destroy=$$.fragment=null;$$.ctx=[];}}function make_dirty(component,i){if(component.$$.dirty[0]===-1){dirty_components.push(component);schedule_update();component.$$.dirty.fill(0);}component.$$.dirty[i/31|0]|=1<<i%31;}function init(component,options,instance,create_fragment,not_equal,props,dirty=[-1]){const parent_component=current_component;set_current_component(component);const prop_values=options.props||{};const $$=component.$$={fragment:null,ctx:null,// state\nprops,update:noop$1,not_equal,bound:blank_object(),// lifecycle\non_mount:[],on_destroy:[],before_update:[],after_update:[],context:new Map(parent_component?parent_component.$$.context:[]),// everything else\ncallbacks:blank_object(),dirty,skip_bound:false};let ready=false;$$.ctx=instance?instance(component,prop_values,(i,ret,...rest)=>{const value=rest.length?rest[0]:ret;if($$.ctx&&not_equal($$.ctx[i],$$.ctx[i]=value)){if(!$$.skip_bound&&$$.bound[i])$$.bound[i](value);if(ready)make_dirty(component,i);}return ret;}):[];$$.update();ready=true;run_all($$.before_update);// `false` as a special case of no DOM component\n$$.fragment=create_fragment?create_fragment($$.ctx):false;if(options.target){if(options.hydrate){const nodes=children(options.target);// eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n$$.fragment&&$$.fragment.l(nodes);nodes.forEach(detach);}else{// eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n$$.fragment&&$$.fragment.c();}if(options.intro)transition_in(component.$$.fragment);mount_component(component,options.target,options.anchor);flush();}set_current_component(parent_component);}class SvelteComponent{$destroy(){destroy_component(this,1);this.$destroy=noop$1;}$on(type,callback){const callbacks=this.$$.callbacks[type]||(this.$$.callbacks[type]=[]);callbacks.push(callback);return()=>{const index=callbacks.indexOf(callback);if(index!==-1)callbacks.splice(index,1);};}$set($$props){if(this.$$set&&!is_empty($$props)){this.$$.skip_bound=true;this.$$set($$props);this.$$.skip_bound=false;}}}const subscriber_queue=[];/**\n * Creates a `Readable` store that allows reading by subscription.\n * @param value initial value\n * @param {StartStopNotifier}start start and stop notifications for subscriptions\n */function readable(value,start){return{subscribe:writable(value,start).subscribe};}/**\n * Create a `Writable` store that allows both updating and reading by subscription.\n * @param {*=}value initial value\n * @param {StartStopNotifier=}start start and stop notifications for subscriptions\n */function writable(value,start=noop$1){let stop;const subscribers=[];function set(new_value){if(safe_not_equal(value,new_value)){value=new_value;if(stop){// store is ready\nconst run_queue=!subscriber_queue.length;for(let i=0;i<subscribers.length;i+=1){const s=subscribers[i];s[1]();subscriber_queue.push(s,value);}if(run_queue){for(let i=0;i<subscriber_queue.length;i+=2){subscriber_queue[i][0](subscriber_queue[i+1]);}subscriber_queue.length=0;}}}}function update(fn){set(fn(value));}function subscribe(run,invalidate=noop$1){const subscriber=[run,invalidate];subscribers.push(subscriber);if(subscribers.length===1){stop=start(set)||noop$1;}run(value);return()=>{const index=subscribers.indexOf(subscriber);if(index!==-1){subscribers.splice(index,1);}if(subscribers.length===0){stop();stop=null;}};}return{set,update,subscribe};}function derived(stores,fn,initial_value){const single=!Array.isArray(stores);const stores_array=single?[stores]:stores;const auto=fn.length<2;return readable(initial_value,set=>{let inited=false;const values=[];let pending=0;let cleanup=noop$1;const sync=()=>{if(pending){return;}cleanup();const result=fn(single?values[0]:values,set);if(auto){set(result);}else{cleanup=is_function(result)?result:noop$1;}};const unsubscribers=stores_array.map((store,i)=>subscribe(store,value=>{values[i]=value;pending&=~(1<<i);if(inited){sync();}},()=>{pending|=1<<i;}));inited=true;sync();return function stop(){run_all(unsubscribers);cleanup();};});}var mergeObjects=objects=>objects.reduce((prev,curr)=>Object.assign(prev,curr),{});// @ts-ignore\nconst UPDATE_VALUE=updateValue=>({updateValue});const DEFAULT_VALUE=defaultValue=>({defaultValue});const CUSTOM_STORE=fn=>({store:fn});// @ts-ignore\nconst DERIVED_STORE=fn=>({store:(defaultValue,stores)=>derived(...fn(stores))});const UNIQUE_DERIVED_STORE=fn=>({store:(defaultValue,stores)=>{const[selectedStores,update,isEqual=()=>false]=fn(stores);let isFirst=true;let currentValue;return derived(selectedStores,(storeValues,set)=>{update(storeValues,value=>{if(!isFirst&&isEqual(currentValue,value))return;currentValue=value;isFirst=false;set(value);});});}});const MAP_STORE=fn=>({store:(defaultValue,stores)=>{const[valueMapper,paramStores={}]=fn(stores);let storedItems=[];let $paramStores={};const mapValue=item=>valueMapper(item,$paramStores);// set default properties for each shape\nconst setValue=items=>{// was empty, still empty\nif(!storedItems.length&&!items.length)return;// update value\nstoredItems=items;updateValue();};const updateValue=()=>{const mappedItems=storedItems.map(mapValue);storedItems=mappedItems;set(mappedItems);};Object.keys(paramStores).forEach(name=>{const store=paramStores[name];store.subscribe(value=>{$paramStores[name]=value;if(!value)return;updateValue();});});const{subscribe,set}=writable(defaultValue);return{set:setValue,update:fn=>setValue(fn(null)),subscribe};}});const createStore=(accessors,stores,options)=>{const{store=defaultValue=>writable(defaultValue),defaultValue=noop,// should be a function returning the default value\nupdateValue=undefined}=options;// create our private store\nconst storeInstance=store(defaultValue(),stores,accessors);const{subscribe,update=noop}=storeInstance;// update = noop because not all stores can be updated\n// on update private store\nlet unsub;const onUpdate=cb=>{let ignoreFirstCallback=true;if(unsub)unsub();unsub=subscribe(value=>{// need to ignore first callback because that returns current value\nif(ignoreFirstCallback)return ignoreFirstCallback=false;// now we have the newly assigned value\ncb(value);unsub();unsub=undefined;});};// create the value updater function, needs access to stores so can read all store values\nconst updateStoreValue=updateValue?updateValue(accessors):passthrough;// set and validate value\nstoreInstance.set=nextValue=>update(previousValue=>updateStoreValue(nextValue,previousValue,onUpdate));// set default value for external reference\nstoreInstance.defaultValue=defaultValue;// expose store api\nreturn storeInstance;};var createStores=props=>{const stores={};const accessors={};props.forEach(([name,...options])=>{const opts=mergeObjects(options);const store=stores[name]=createStore(accessors,stores,opts);const property={get:()=>get_store_value(store),set:store.set};Object.defineProperty(accessors,name,property);});return{stores,accessors};};var props=[// io\n['src'],['imageReader'],['imageWriter'],// current images\n['images',DEFAULT_VALUE(()=>[])]];var pubsub=()=>{let subs=[];return{sub:(event,callback)=>{subs.push({event,callback});return()=>subs=subs.filter(subscriber=>subscriber.event!==event||subscriber.callback!==callback);},pub:(event,value)=>{subs.filter(sub=>sub.event===event).forEach(sub=>sub.callback(value));}};};var capitalizeFirstLetter=str=>str.charAt(0).toUpperCase()+str.slice(1);var defineMethods=(object,api)=>{Object.keys(api).forEach(name=>{const descriptor=isFunction(api[name])?{value:api[name],writable:false}:api[name];Object.defineProperty(object,name,descriptor);});};var fixPrecision=(value,precision=12)=>parseFloat(value.toFixed(precision));const scalar=10000;var offsetRectToFitPolygon=(rect,poly)=>{const polyLines=quadLines(poly);const offset=vectorCreateEmpty();const rectVertexes=rectGetCorners(rect);// we can fit it\nrectVertexes.forEach(vertex=>{// we update each corner by adding the current offset\nvectorAdd(vertex,offset);// test if point lies in polygon, if so, all is fine and we can exit\nif(polyPointIntersectionConvex(vertex,poly))return;polyLines.forEach(line=>{// get angle of edge and draw a ray from the corner perpendicular to the edge\nconst a=Math.atan2(line.start.y-line.end.y,line.start.x-line.end.x);const x=Math.sin(Math.PI-a)*scalar;const y=Math.cos(Math.PI-a)*scalar;const ray=vectorCreate(vertex.x+x,vertex.y+y);// extend the poly line so even if we overshoot the polygon we hit it\nconst lineExtended=lineExtend(lineClone(line),scalar);// get the resulting intersection (there's always an intersection)\nconst intersection=lineLineIntersection(lineCreate(vertex,ray),lineExtended);// no intersection, no need to do anything\nif(!intersection)return;// update offset to move towards image\nvectorAdd(offset,vectorSubtract(vectorClone(intersection),vertex));});});// test if any vertexes still fall outside of poly, if so, we can't fit the rect\nconst rectOffset=rectClone(rect);vectorAdd(rectOffset,offset);const rectOffsetVertices=rectGetCorners(rectOffset);const fits=rectOffsetVertices.every(vertex=>polyPointIntersectionConvex(vertex,poly));if(fits){rectUpdateWithRect(rect,rectOffset);return true;}return false;};var limitCropRectToImage=(rect,poly)=>{// get crop rect polygon vertexes\nconst rectVertexes=rectGetCorners(rect);// if we end up here it doesn't fit, we might need to adjust\nconst polyLines=quadLines(poly)// extend the poly lines a tiny bit so we\n// don't shoot rays between line gaps at corners\n// this caused one intersection to be missing resulting\n// in error while manipulating crop edges\n// (rotate image 90degrees -> drag bottom edge) (2021-04-09)\n.map(line=>lineExtend(line,5));const rectCenterPosition=rectCenter(rect);const intersections=[];rectVertexes.forEach(rectVertex=>{const ray=lineMultiply(lineCreate(vectorClone(rectCenterPosition),vectorClone(rectVertex)),1000000);let intersectionFound=false;polyLines.map(lineClone).forEach(line=>{const intersection=lineLineIntersection(ray,line);if(!intersection||intersectionFound)return;intersections.push(intersection);intersectionFound=true;});});// top left -> bottom right\nconst tlbr=vectorDistance(intersections[0],intersections[2]);// top right -> bottom left\nconst trbl=vectorDistance(intersections[1],intersections[3]);// calculate smallest rectangle we can make, use that\nconst rectLimitedVertices=tlbr<trbl?[intersections[0],intersections[2]]:[intersections[1],intersections[3]];const rectLimitedToImage=rectCreateFromPoints(rectLimitedVertices);// only use our fitted crop rectangle if it's smaller than our current rectangle,\n// this would mean that our current rectangle couldn't be moved to make it fit\nif(rectLimitedToImage.width<rect.width){// need to center on previous rect\nrectUpdateWithRect(rect,rectLimitedToImage);return true;}return false;};var getImagePolygon=(image,imageRotation,imagePerspective={x:0,y:0})=>{const imageRect=rectCreateFromSize(image);const imageCenter=rectCenter(imageRect);const imagePoly=rectApplyPerspective(imageRect,imagePerspective,imageCenter).map(imageVertex=>vectorRotate(imageVertex,imageRotation,imageCenter));// get image poly bounds, we need this to offset the poly vertices from 0,0\nconst imagePolyBounds=rectCreateFromPoints(imagePoly);// get image polygon vertexes\nreturn imagePoly.map(imageVertex=>vectorSubtract(imageVertex,imagePolyBounds));};var getMaxSizeInRect=(size,rotation=0,aspectRatio=rectAspectRatio(size))=>{let width;let height;if(rotation!==0){const innerAngle=Math.atan2(1,aspectRatio);const rotationSigned=Math.sign(rotation)*rotation;const rotationSignedMod=rotationSigned%Math.PI;const rotationSignedModHalf=rotationSigned%HALF_PI;// determine if is turned on side\nlet hyp;let r;if(rotationSignedMod>QUART_PI&&rotationSignedMod<HALF_PI+QUART_PI){r=rotationSignedModHalf>QUART_PI?rotationSigned:HALF_PI-rotationSignedModHalf;}else{r=rotationSignedModHalf>QUART_PI?HALF_PI-rotationSignedModHalf:rotationSigned;}hyp=Math.min(Math.abs(size.height/Math.sin(innerAngle+r)),Math.abs(size.width/Math.cos(innerAngle-r)));width=Math.cos(innerAngle)*hyp;height=width/aspectRatio;}else{width=size.width;height=width/aspectRatio;if(height>size.height){height=size.height;width=height*aspectRatio;}}return sizeCreate(width,height);};var limitRectToImage=(rect,imageSize,imageRotation=0,imagePerspective=vectorCreateEmpty(),minSize)=>{// rotation and/or perspective, let's use the \"advanced\" collision detection method\nif(isNumber(imageRotation)&&imageRotation!==0||imagePerspective.x||imagePerspective.y){const inputAspectRatio=rectAspectRatio(rect);// test if crop can fit image, if it can, offset the crop so it fits\nconst imagePolygon=getImagePolygon(imageSize,imageRotation,imagePerspective);const maxSizeInRect=getMaxSizeInRect(imageSize,imageRotation,inputAspectRatio);const canFit=rect.width<maxSizeInRect.width&&rect.height<maxSizeInRect.height;if(!canFit){const dx=rect.width*0.5-maxSizeInRect.width*0.5;const dy=rect.height*0.5-maxSizeInRect.height*0.5;// adjust crop rect to max size\nif(rect.width>maxSizeInRect.width){rect.width=maxSizeInRect.width;rect.x+=dx;}if(rect.height>maxSizeInRect.height){rect.height=maxSizeInRect.height;rect.y+=dy;}// test if has exceeded min size, if so we need to limit the size and recalculate the other edge\n/*\n                        -\\\n                       /  ---\\\n                      h2      ---\\\n                     /            ---\\\n                    +--------w---------+\\\n                   /|                  | ---\\\n                  / |                  |     ---\\\n                 /  |                  |         ---\\\n                /   |                  |             --\n               h1   |                  |             /\n              /     |                  |            /\n             /      |                  |           /\n            -\\      |                  |          /\n              ---\\  |                  |         /\n                  --+------------------+        /\n                      ---\\                     /\n                          --\\                 /\n                             ---\\            /\n                                 ---\\       /\n                                     ---\\  /\n                                         --\n            */}offsetRectToFitPolygon(rect,imagePolygon);const wasLimited=limitCropRectToImage(rect,imagePolygon);// this makes sure that after limiting the size, the crop rect is moved to a position that is inside the image\nif(wasLimited)offsetRectToFitPolygon(rect,imagePolygon);}// no rotation, no perspective, use simple bounds method\nelse{// remember intended aspect ratio so we can try and recreate it\nlet intendedAspectRatio=rectAspectRatio(rect);// limit to image size first, can never exceed that\nrect.width=Math.min(rect.width,imageSize.width);rect.height=Math.min(rect.height,imageSize.height);// reposition rect so it's always inside image bounds\nrect.x=Math.max(rect.x,0);if(rect.x+rect.width>imageSize.width){rect.x-=rect.x+rect.width-imageSize.width;}rect.y=Math.max(rect.y,0);if(rect.y+rect.height>imageSize.height){rect.y-=rect.y+rect.height-imageSize.height;}// we get the center of the current rect so we can center the contained rect to it\nconst intendedCenter=rectCenter(rect);// make sure still adheres to aspect ratio\nconst containedRect=rectContainRect(rect,intendedAspectRatio);containedRect.width=Math.max(minSize.width,containedRect.width);containedRect.height=Math.max(minSize.height,containedRect.height);containedRect.x=intendedCenter.x-containedRect.width*0.5;containedRect.y=intendedCenter.y-containedRect.height*0.5;rectUpdateWithRect(rect,containedRect);}};var applyCropRectAction=(cropRectPrevious,cropRectNext,imageSize,imageRotation,imagePerspective,cropLimitToImageBounds,cropMinSize,cropMaxSize)=>{// clone\nconst minSize=sizeClone(cropMinSize);// set upper bounds to crop max size\nconst maxSize=sizeClone(cropMaxSize);// limit max size (more important that min size is respected so first limit max size)\nconst maxScalar=fixPrecision(Math.max(cropRectNext.width/maxSize.width,cropRectNext.height/maxSize.height));const minScalar=fixPrecision(Math.min(cropRectNext.width/minSize.width,cropRectNext.height/minSize.height));// clone for resulting crop rect\nconst cropRectOut=rectClone(cropRectNext);//\n// if exceeds min or max scale correct next crop rectangle to conform to bounds\n//\nif(minScalar<1||maxScalar>1){// center of both previous and next crop rects\nconst previousCropRectCenter=rectCenter(cropRectPrevious);const nextCropRectCenter=rectCenter(cropRectNext);// calculate scales\nconst scalar=minScalar<1?minScalar:maxScalar;const cx=(nextCropRectCenter.x+previousCropRectCenter.x)/2;const cy=(nextCropRectCenter.y+previousCropRectCenter.y)/2;const cw=cropRectOut.width/scalar;const ch=cropRectOut.height/scalar;rectUpdate(cropRectOut,cx-cw*0.5,cy-ch*0.5,cw,ch);}// no need to limit to bounds, let's go!\nif(!cropLimitToImageBounds)return{crop:cropRectOut};//\n// make sure the crop is made inside the bounds of the image\n//\nlimitRectToImage(cropRectOut,imageSize,imageRotation,imagePerspective,minSize);return{crop:cropRectOut};};var getBaseCropRect=(imageSize,transformedCropRect,imageRotation,imagePerspective={x:0,y:0})=>{const imageRect=rectCreateFromSize(imageSize);const imageCenter=rectCenter(imageRect);const imageTransformedVertices=rectRotate(imageRect,imageRotation,imageCenter);// get the rotated image bounds center (offset isn't relevant as crop is relative to top left image position)\nconst imageRotatedBoundsCenter=rectCenter(rectNormalizeOffset(rectCreateFromPoints(imageTransformedVertices)));// get the center of the crop inside the rotated image\nconst cropCenterInTransformedImage=rectCenter(transformedCropRect);// invert the rotation of the crop center around the rotated image center\nconst deRotatedCropCenter=vectorRotate(cropCenterInTransformedImage,-imageRotation,imageRotatedBoundsCenter);// calculate crop distance from rotated image center\nconst cropFromCenterOfTransformedImage=vectorSubtract(deRotatedCropCenter,imageRotatedBoundsCenter);// calculate original crop offset (from untransformed image)\nconst originalCropCenterOffset=vectorApply(vectorAdd(imageCenter,cropFromCenterOfTransformedImage),fixPrecision);return rectCreate(originalCropCenterOffset.x-transformedCropRect.width*0.5,originalCropCenterOffset.y-transformedCropRect.height*0.5,transformedCropRect.width,transformedCropRect.height);};var clamp=(value,min,max)=>Math.max(min,Math.min(value,max));var applyRotationAction=(imageRotationPrevious,imageRotation,imageRotationRange,cropRect,imageSize,imagePerspective,cropLimitToImageBounds,cropRectOrigin,cropMinSize,cropMaxSize)=>{// clone\nconst minSize=sizeClone(cropMinSize);// set upper bounds to crop max size if image is bigger than max size,\n// else if should limit to image bounds use image size as limit\nlet maxSize=sizeClone(cropMaxSize);if(cropLimitToImageBounds){maxSize.width=Math.min(cropMaxSize.width,imageSize.width);maxSize.height=Math.min(cropMaxSize.height,imageSize.height);}let didAttemptDoubleTurn=false;const rotate=(rotationPrevious,rotation)=>{// get the base crop rect (position of crop rect in untransformed image)\n// if we have the base crop rect we can apply the new rotation to it\nconst cropRectBase=getBaseCropRect(imageSize,cropRect,rotationPrevious,null);// calculate transforms based on new rotation and base crop rect\nconst imageRect=rectCreateFromSize(imageSize);const imageCenter=rectCenter(imageRect);const imageTransformedCorners=rectApplyPerspective(imageRect,imagePerspective,imageCenter);// need this to correct for perspective centroid displacement\nconst perspectiveOffset=vectorSubtract(vectorClone(imageCenter),quadCentroid(imageTransformedCorners));// rotate around center of image\nconst cropCenter=vectorRotate(rectCenter(cropRectBase),rotation,imageCenter);const rotateCropOffset=vectorSubtract(vectorClone(imageCenter),cropCenter);// get center of image bounds and move to correct position\nimageTransformedCorners.forEach(imageVertex=>vectorRotate(imageVertex,rotation,imageCenter));const imageBoundsRect=rectCreateFromPoints(imageTransformedCorners);const imageCentroid=quadCentroid(imageTransformedCorners);const cropOffset=vectorAdd(vectorSubtract(vectorSubtract(imageCentroid,rotateCropOffset),imageBoundsRect),perspectiveOffset);// create output cropRect\nconst cropRectOut=rectCreate(cropOffset.x-cropRectBase.width*0.5,cropOffset.y-cropRectBase.height*0.5,cropRectBase.width,cropRectBase.height);// if has size target, scale croprect to target size\nif(cropRectOrigin){rectScale(cropRectOut,cropRectOrigin.width/cropRectOut.width);}// if should limit to image bounds\nif(cropLimitToImageBounds){const imagePoly=getImagePolygon(imageSize,rotation,imagePerspective);// offsetRectToFitPolygon(cropRectOut, imagePoly);\n// commenting this fixes poly sliding problem when adjusting rotation\nlimitCropRectToImage(cropRectOut,imagePoly);}//#region if exceeds min or max adjust rotation to conform to bounds\nconst minScalar=fixPrecision(Math.min(cropRectOut.width/minSize.width,cropRectOut.height/minSize.height),8);const maxScalar=fixPrecision(Math.max(cropRectOut.width/maxSize.width,cropRectOut.height/maxSize.height),8);if(minScalar<1||maxScalar>1){// determine if is full image turn\nconst isTurn=fixPrecision(Math.abs(rotation-rotationPrevious))===fixPrecision(Math.PI/2);// try another turn if is turning image\nif(isTurn&&!didAttemptDoubleTurn){didAttemptDoubleTurn=true;return rotate(imageRotationPrevious,imageRotationPrevious+Math.sign(rotation-rotationPrevious)*Math.PI);}}//#endregion\nreturn{rotation,crop:rectApply(cropRectOut,v=>fixPrecision(v,8))};};// amount of turns applied, we need this to correctly determine the allowed rotation range\nconst imageTurns=Math.sign(imageRotation)*Math.round(Math.abs(imageRotation)/HALF_PI)*HALF_PI;const imageRotationClamped=clamp(imageRotation,imageTurns+imageRotationRange[0],imageTurns+imageRotationRange[1]);// set new crop position\nreturn rotate(imageRotationPrevious,imageRotationClamped);};const ORDERED_STATE_PROPS=[// requirements\n'cropLimitToImage','cropMinSize','cropMaxSize','cropAspectRatio',// selection -> flip -> rotate -> perspective -> crop\n'flipX','flipY','rotation','crop',// 'perspectiveX',\n// 'perspectiveY',\n// effects\n'colorMatrix','convolutionMatrix','gamma','vignette',// 'noise',\n// shapes\n'annotation','decoration',// other\n'backgroundColor','targetSize'];const clone=value=>{if(isArray(value)){return value.map(clone);}else if(isObject(value)){return _objectSpread({},value);}return value;};/* TODO: keep this state outside of the shape array? */const excludedShapeProps=['isDraft','isFormatted','isComplete','isError','isLoading','isEditing','isSelected'];/* note this method doesn't actually test if the value is fully serializable it simlpy excludes known prop values that can't be serialized */const isSerializeAble=value=>{// isFunction(value) ||\nreturn!isElement(value);};const filterShapeState=shapes=>shapes.map(shape=>Object.keys(shape).reduce((copy,prop)=>{if(excludedShapeProps.includes(prop)||!isSerializeAble(shape[prop]))return copy;copy[prop]=shape[prop];return copy;},{}));var stateStore=(defaultValue,stores,accessors)=>{const observedStores=ORDERED_STATE_PROPS.map(key=>stores[key]);// can only subscribe, setting is done directly through store accessors\n// @ts-ignore\nconst{subscribe}=derived(observedStores,(values,set)=>{const state=ORDERED_STATE_PROPS.reduce((prev,curr,i)=>{prev[curr]=clone(values[i]);return prev;},{});// round crop if defined\nstate.crop&&rectApply(state.crop,Math.round);// remove state props from decoration and annotation\nstate.annotation=state.annotation&&filterShapeState(state.annotation);state.decoration=state.decoration&&filterShapeState(state.decoration);set(state);});const setState=state=>{// requires at least some state to be supplied\nif(!state)return;// make sure crop origin is reset\naccessors.cropOrigin=undefined;// apply new values\nORDERED_STATE_PROPS// remove keys that weren't set\n.filter(key=>state.hasOwnProperty(key))// apply each key in order\n.forEach(key=>{accessors[key]=clone(state[key]);});};return{set:setState,update:fn=>setState(fn(null)),subscribe};};var toNumericAspectRatio=v=>{if(!v)return undefined;if(/:/.test(v)){const[w,h]=v.split(':');return w/h;}return parseFloat(v);};var arrayEqual=(a,b)=>{if(a.length!==b.length)return false;for(let i=0;i<a.length;i++){if(a[i]!==b[i])return false;}return true;};let result$5=null;var isAndroid=()=>{if(result$5===null)result$5=isUserAgent(/Android/);return result$5;};let result$6=null;var isFirefox=()=>{if(result$6===null)result$6=isUserAgent(/Firefox/);return result$6;};let result$7=null;var isEdge=()=>{if(result$7===null)result$7=isUserAgent(/Edge/);return result$7;};let vendor;var getBrowserVendor=()=>{if(vendor)return vendor;vendor=isIOS()?'ios':isAndroid()?'android':isFirefox()?'firefox':isInternetExplorer()?'ie':isEdge()?'edge':'chrome';return vendor;};// https://github.com/jhildenbiddle/canvas-size#test-results\nlet maxCanvasSze;var getMaxCanvasSize=()=>{if(!maxCanvasSze){const sizes={android:[32767,32767,10836],ios:[4194303,8388607,16777216],chrome:[32767,32767,268435456],firefox:[32767,32767,124992400],edge:[16384,16384,268435456],ie:[16384,16384,67108864]};maxCanvasSze=sizes[getBrowserVendor()]||sizes['chrome'];}const[width,height,density]=maxCanvasSze;return{width,height,density};};var padColorArray=(color=[0,0,0,0],opacity=1.0)=>color.length===4?color:[...color,opacity];//\n// constants\n//\nconst MIN_ROTATION=-QUART_PI;const MAX_ROTATION=QUART_PI;//\n// helper methods\n//\nconst isCropCentered=(crop,imageSize,imageRotation)=>{const cropCenter=vectorApply(rectCenter(crop),v=>fixPrecision(v,8));const imageRect=rectCreateFromSize(imageSize);const imageCenter=rectCenter(imageRect);const imageRotatedVertices=rectRotate(imageRect,imageRotation,imageCenter);const imageBoundsCenter=vectorApply(sizeCenter(rectCreateFromPoints(imageRotatedVertices)),v=>fixPrecision(v,8));const dx=Math.abs(imageBoundsCenter.x-cropCenter.x);const dy=Math.abs(imageBoundsCenter.y-cropCenter.y);return dx<1&&dy<1;};const isCropMaxSize=(cropRect,imageSize,rotation)=>{const maxSize=getMaxSizeInRect(imageSize,rotation,rectAspectRatio(cropRect));return sizeEqual(sizeApply(maxSize,Math.round),sizeApply(sizeClone(cropRect),Math.round));};//\n// updater methods\n//\nconst updateCropRect=props=>(cropNext,cropPrevious=cropNext)=>{// wait for image to load\nconst{loadState,size,cropMinSize,cropMaxSize,cropLimitToImage,rotation,perspective}=props;// image hasn't loaded yet, use supplied crop rect\nif(!cropNext||!loadState||!loadState.beforeComplete)return cropNext;// apply the action\nconst res=applyCropRectAction(cropPrevious,cropNext,size,rotation,perspective,cropLimitToImage,cropMinSize,cropMaxSize);const cropOut=rectApply(res.crop,v=>fixPrecision(v,8));return cropOut;};const updateCropAspectRatio=props=>aspectRatioNext=>{const{loadState,crop,size,rotation}=props;const aspectRatio=toNumericAspectRatio(aspectRatioNext);// no aspect ratio means custom aspect ratio so set to undefined\nif(!aspectRatio)return undefined;// can't update crop if not defined yet\nif(!loadState||!loadState.beforeComplete)return aspectRatio;// if crop centered scale up\nif(isCropCentered(crop,size,rotation)){const imageSize=sizeTurn(sizeClone(size),rotation);props.crop=rectApply(rectContainRect(rectCreateFromSize(imageSize),aspectRatioNext),fixPrecision);}else{const cropSize={width:crop.height*aspectRatio,height:crop.height};const tx=(crop.width-cropSize.width)*0.5;const ty=(crop.height-cropSize.height)*0.5;props.crop=rectApply(rectCreate(crop.x+tx,crop.y+ty,cropSize.width,cropSize.height),fixPrecision);}return aspectRatio;};const updateCropLimitToImage=props=>(limitToImageNext,limitToImagePrevious,onUpdate)=>{// if was not limiting previously and now set limiting make sure crop fits bounds\nif(!limitToImagePrevious&&limitToImageNext){onUpdate(()=>props.crop=rectClone(props.crop));}return limitToImageNext;};const updateRotation=props=>(rotationNext,rotationPrevious,onUpdate)=>{// when image rotation is updated we need to adjust the\n// cropRect offset so rotation happens from cropRect center\n// no change\nif(rotationNext===rotationPrevious)return rotationNext;// get relevant data from store state\nconst{loadState,size,rotationRange,cropMinSize,cropMaxSize,crop,perspective,cropLimitToImage,cropOrigin}=props;// image not ready, exit!\nif(!loadState||!loadState.beforeComplete)return rotationNext;// remember if current crop was at max size and centered, if so, resulting crop should also be at max size\nconst cropWasAtMaxSize=isCropMaxSize(crop,size,rotationPrevious);const cropWasCentered=isCropCentered(crop,size,rotationPrevious);// get new state\nconst res=applyRotationAction(rotationPrevious,rotationNext,rotationRange,crop,size,perspective,cropLimitToImage,cropOrigin,cropMinSize,cropMaxSize);// if is centered, and initial crop was at max size expand crop to max size\nif(cropWasAtMaxSize&&cropWasCentered){const rect=getMaxSizeInRect(size,rotationNext,rectAspectRatio(res.crop));// move top left corner\nres.crop.x+=res.crop.width*0.5;res.crop.y+=res.crop.height*0.5;res.crop.x-=rect.width*0.5;res.crop.y-=rect.height*0.5;// update size to max size\nres.crop.width=rect.width;res.crop.height=rect.height;}// return validated rotation value, then, after we assign that value, we update the crop rect\n// we may only call onUpdate if a change was made\nonUpdate(()=>{props.crop=rectApply(res.crop,v=>fixPrecision(v,8));});// return result rotation (might have been rotated twice to fit crop rectangle)\nreturn res.rotation;};// updates the range of valid rotation input\nconst updateRotationRange=(imageSize,imageIsRotatedSideways,cropMinSize,cropSize)=>{/*\n    - 'a' is angle between diagonal and image height\n    - 'b' is angle between diagonal and crop height\n    - 'c' is angle between diagonal and image width\n    - resulting range is then a - b\n    +----------/\\------------------------+\n    |         / \\ \\                      |\n    |        /   \\  \\                    |\n    |       /     \\   \\                  |\n    |       \\      \\    \\                |\n    |         \\     \\     \\              |\n    |           \\    \\      \\            |\n    |             \\   \\       /          |\n    |               \\  \\     /           |\n    |                 \\ \\   /            |\n    |                   \\\\a/b            |\n    +---------------------\\--------------+\n    */const scalar=Math.max(cropMinSize.width/cropSize.width,cropMinSize.height/cropSize.height);const minSize=sizeCreate(cropSize.width*scalar,cropSize.height*scalar);// the hypotenus is the length of the diagonal of the min crop size\nconst requiredSpace=sizeHypotenuse(minSize);// minimum space available in horizontal / vertical direction\nconst availableSpace=Math.min(imageSize.width,imageSize.height);// if there's enough space available, we can return the max range\nif(requiredSpace<availableSpace)return[MIN_ROTATION,MAX_ROTATION];// if the image is turned we need to swap the width and height\nconst imageWidth=imageIsRotatedSideways?imageSize.height:imageSize.width;const imageHeight=imageIsRotatedSideways?imageSize.width:imageSize.height;// subtracting the angle between the hypotenuse and the crop itself\nconst a=Math.acos(minSize.height/requiredSpace);const b=Math.acos(imageHeight/requiredSpace);const c=Math.asin(imageWidth/requiredSpace);const rangeHorizontal=a-b;const rangeVertical=c-a;// range is not a number, it means we can rotate as much as we want\nif(Number.isNaN(rangeHorizontal)&&Number.isNaN(rangeVertical))return[MIN_ROTATION,MAX_ROTATION];// get minimum range\nconst range=Number.isNaN(rangeHorizontal)?rangeVertical:Number.isNaN(rangeVertical)?rangeHorizontal:Math.min(rangeHorizontal,rangeVertical);// if not, limit range to min and max rotation\nconst rangeMin=Math.max(-range,MIN_ROTATION);const rangeMax=Math.min(range,MAX_ROTATION);return[rangeMin,rangeMax];};// updates the range of valid crop rectangle input\nconst updateCropRange=(imageSize,rotation,cropAspectRatio,cropMinSize,cropMaxSize,cropLimitToImage)=>{// ! rotation doesn't affect min size, only max size\n// set lower bounds to crop min size\nlet minSize=sizeClone(cropMinSize);// set upper bounds to crop max size\nlet maxSize=sizeClone(cropMaxSize);// now we got basic bounds, let's see if we should limit to the image bounds, else we done\nif(!cropLimitToImage)return[minSize,maxSize];return[minSize,sizeApply(getMaxSizeInRect(imageSize,rotation,cropAspectRatio),Math.round)];};const prepareShape=(shape,options)=>{// only auto-format once\nif(!shape.isFormatted){shape=shapeFormat(shape);shape.isFormatted=true;}// we need to make sure shape is still correctly positioned relative to parent\n// draft cannot be relative\n// if context changed\n// if has left top right or bottom\nif(!shape.isDraft&&shapeHasRelativeSize(shape)&&(!shape.context||!rectEqual(options.context,shape.context))){shape=shapeComputeRect(shape,options.context);shape.context=_objectSpread({},options.context);}return shape;};var imageProps=[// image info received from read\n['file'],['size'],// loading and processing state\n['loadState'],['processState'],// derived info\n['aspectRatio',DERIVED_STORE(({size})=>[size,$size=>$size?rectAspectRatio($size):undefined])],// image modifications\n['perspectiveX',DEFAULT_VALUE(()=>0)],['perspectiveY',DEFAULT_VALUE(()=>0)],['perspective',DERIVED_STORE(({perspectiveX,perspectiveY})=>[[perspectiveX,perspectiveY],([x,y])=>({x,y})])],['rotation',DEFAULT_VALUE(()=>0),UPDATE_VALUE(updateRotation)],['flipX',DEFAULT_VALUE(()=>false)],['flipY',DEFAULT_VALUE(()=>false)],['flip',DERIVED_STORE(({flipX,flipY})=>[[flipX,flipY],([x,y])=>({x,y})])],['isRotatedSideways',UNIQUE_DERIVED_STORE(({rotation})=>[[rotation],([$rotation],set)=>set(isRotatedSideways($rotation)),(prevValue,nextValue)=>prevValue!==nextValue])],['crop',UPDATE_VALUE(updateCropRect)],['cropAspectRatio',UPDATE_VALUE(updateCropAspectRatio)],['cropOrigin'],['cropMinSize',DEFAULT_VALUE(()=>({width:1,height:1}))],['cropMaxSize',DEFAULT_VALUE(()=>sizeClone(getMaxCanvasSize()))],['cropLimitToImage',DEFAULT_VALUE(()=>true),UPDATE_VALUE(updateCropLimitToImage)],['cropSize',UNIQUE_DERIVED_STORE(({crop})=>[[crop],([$crop],set)=>{if(!$crop)return;set(sizeCreate($crop.width,$crop.height));},// if is same as previous size, don't trigger update (happens when updating only the crop offset)\n(prevValue,nextValue)=>sizeEqual(prevValue,nextValue)])],['cropRectAspectRatio',DERIVED_STORE(({cropSize})=>[[cropSize],([$cropSize],set)=>{if(!$cropSize)return;set(fixPrecision(rectAspectRatio($cropSize),5));}])],['cropRange',UNIQUE_DERIVED_STORE(({size,rotation,cropRectAspectRatio,cropMinSize,cropMaxSize,cropLimitToImage})=>[[size,rotation,cropRectAspectRatio,cropMinSize,cropMaxSize,cropLimitToImage],([$size,$rotation,$cropRectAspectRatio,$cropMinSize,$cropMaxSize,$cropLimitToImage],set)=>{// wait for image size\nif(!$size)return;const range=updateCropRange($size,$rotation,$cropRectAspectRatio,$cropMinSize,$cropMaxSize,$cropLimitToImage);set(range);},// if is same range as previous range, don't trigger update\n(prevRange,nextRange)=>arrayEqual(prevRange,nextRange)])],['rotationRange',UNIQUE_DERIVED_STORE(({size,isRotatedSideways,cropMinSize,cropSize})=>[[size,isRotatedSideways,cropMinSize,cropSize],([$size,$isRotatedSideways,$cropMinSize,$cropSize],set)=>{// wait for image size\nif(!$size||!$cropSize)return;const range=updateRotationRange($size,$isRotatedSideways,$cropMinSize,$cropSize);set(range);},// if is same range as previous range, don't trigger update\n(prevRange,nextRange)=>arrayEqual(prevRange,nextRange)])],// canvas\n['backgroundColor',UPDATE_VALUE(()=>color=>padColorArray(color))],// size\n['targetSize'],// effects\n['colorMatrix'],['convolutionMatrix'],['gamma'],['noise'],['vignette'],// annotations live in image space\n['annotation',MAP_STORE(({size})=>[prepareShape,{context:size}]),DEFAULT_VALUE(()=>[])],// decorations live in crop space\n['decoration',MAP_STORE(({crop})=>[prepareShape,{context:crop}]),DEFAULT_VALUE(()=>[])],// state of image, used to restore a previous state or request the current state\n['state',CUSTOM_STORE(stateStore)]];var process=async(value,chainTasks,chainOptions={},processOptions)=>{// options relevant to the process method itself\nconst{ontaskstart,ontaskprogress,ontaskend,token}=processOptions;// has been cancelled\nlet cancelled=false;// set cancel handler method\ntoken.cancel=()=>{// cancel called from outside of the process method\ncancelled=true;};// step through chain\nfor(const[index,task]of chainTasks.entries()){// exit when cancelled\nif(cancelled)return;// get the task function and the id so we can notify the callee of the task that is being started\nconst[fn,id]=task;// start task\nontaskstart(index,id);try{value=await fn(value,_objectSpread({},chainOptions),event=>ontaskprogress(index,id,event));}catch(err){// stop processing more items in the chain\ncancelled=true;// pass error back to parent\nthrow err;}ontaskend(index,id);}return value;};// TODO: find better location for minSize / file load validation\nvar createImage=({minSize={width:1,height:1}}={})=>{// create default store\nconst{stores,accessors}=createStores(imageProps);// pub/sub\nconst{pub,sub}=pubsub();// processing handler\nconst createProcessingHandler=(stateProp,eventKey)=>{const getStore=()=>accessors[stateProp]||{};const setStore=obj=>accessors[stateProp]=_objectSpread(_objectSpread(_objectSpread({},getStore()),obj),{},{timeStamp:Date.now()});const hasError=()=>getStore().error;const handleError=error=>{if(hasError())return;setStore({error:error});pub(`${eventKey}error`,_objectSpread({},getStore()));};return{start(){pub(`${eventKey}start`);},onabort(){pub(`${eventKey}abort`);},ontaskstart(index,id){if(hasError())return;setStore({index,task:id,taskProgress:undefined,taskLengthComputable:undefined});pub(`${eventKey}taskstart`,_objectSpread({},getStore()));},ontaskprogress(index,id,event){if(hasError())return;setStore({index,task:id,taskProgress:event.loaded/event.total,taskLengthComputable:event.lengthComputable});pub(`${eventKey}taskprogress`,_objectSpread({},getStore()));pub(`${eventKey}progress`,_objectSpread({},getStore()));},ontaskend(index,id){if(hasError())return;setStore({index,task:id});pub(`${eventKey}taskend`,_objectSpread({},getStore()));},ontaskerror(error){handleError(error);},error(error){handleError(error);},beforeComplete(data){if(hasError())return;setStore({beforeComplete:true});pub(`before${eventKey}`,data);},complete(data){if(hasError())return;setStore({complete:true});pub(eventKey,data);}};};//#region read image\nconst read=(src,{reader})=>{// exit if no reader supplied\nif(!reader)return;// reset file data to undefined as we're loading a new image\nObject.assign(accessors,{file:undefined,size:undefined,loadState:undefined});// our cancel token so we can abort load if needed, cancel will be set by process\nlet imageReadToken={cancel:noop};let imageReadCancelled=false;const imageReadHandler=createProcessingHandler('loadState','load');const processOptions=_objectSpread({token:imageReadToken},imageReadHandler);const readerState={src,size:undefined,dest:undefined};const readerOptions={};// start reading image\n(async()=>{try{imageReadHandler.start();const output=await process(readerState,reader,readerOptions,processOptions);// was cancelled\nif(imageReadCancelled)return imageReadHandler.onabort();// get shortcuts for validation\nconst{size,dest}=output||{};// if we don't have a size\nif(!size||!size.width||!size.height)throw new DokaError('Image size missing','IMAGE_SIZE_MISSING',output);// size of image is too small\nif(size.width<minSize.width||size.height<minSize.height)throw new DokaError('Image too small','IMAGE_TOO_SMALL',_objectSpread(_objectSpread({},output),{},{minWidth:minSize.width,minHeight:minSize.height}));// update internal data\nObject.assign(accessors,{size:size,file:dest});// set base crop rect if not already has crop defined\nif(!accessors.crop){accessors.crop=rectContainRect(rectCreateFromSize(size),accessors.cropAspectRatio);}// apply current image state in correct order,\n// there's a difference between the actions `rotate -> crop` and `crop -> rotate`\n// this makes sure the initial state is always `rotate -> crop`\naccessors.state=accessors.state;// before load complete\nimageReadHandler.beforeComplete(output);// done loading image\nimageReadHandler.complete(output);}catch(err){imageReadHandler.error(err);}finally{imageReadToken=undefined;}})();// call to abort load\nreturn()=>{imageReadCancelled=true;imageReadToken&&imageReadToken.cancel();};};//#endregion\n//#region write image\nconst write=writer=>{// not ready to start processing\nif(!accessors.loadState.complete)return;// reset process state to undefined\naccessors.processState=undefined;const imageWriteHandler=createProcessingHandler('processState','process');const writerState={src:accessors.file,imageState:accessors.state,dest:undefined};// willProcessImageState\nif(!writer){imageWriteHandler.start();imageWriteHandler.complete(writerState);return;}// we need this token to be a blet to cancel the processing operation\nlet imageWriteToken={cancel:noop};const writerOptions={};const processOptions=_objectSpread({token:imageWriteToken},imageWriteHandler);// start writing image\n(async()=>{imageWriteHandler.start();try{const output=await process(writerState,writer,writerOptions,processOptions);imageWriteHandler.complete(output);}catch(err){imageWriteHandler.error(err);}finally{imageWriteToken=undefined;}})();// call to abort processing\nreturn()=>imageWriteToken&&imageWriteToken.cancel();};//#endregion\n//#region api\ndefineMethods(accessors,{read,write,on:sub});//#endregion\n// expose store API\nreturn{accessors,stores};};// @ts-ignore\nconst editorEventsToBubble=['loadstart','loadabort','loaderror','loadprogress','load','processstart','processabort','processerror','processprogress','process'];const imagePrivateProps=['flip','cropOrigin','isRotatedSideways','perspective','perspectiveX','perspectiveY','cropRange'];const editorPrivateProps=['images'];const getImagePropGroupedName=prop=>`image${capitalizeFirstLetter(prop)}`;const getEditorProps=()=>{const imageProperties=getImagePublicPropNames(imageProps).map(getImagePropGroupedName);const editorProperties=props.map(([prop])=>prop).filter(prop=>!editorPrivateProps.includes(prop));return imageProperties.concat(editorProperties);};const getImagePublicPropNames=imageProps=>imageProps.map(([prop])=>prop).filter(prop=>!imagePrivateProps.includes(prop));var createImageEditor=()=>{// create default stores\nconst{stores,accessors}=createStores(props);// set up pub/sub for the app layer\nconst{sub,pub}=pubsub();const bubble=name=>value=>pub(name,value);// helper method\nconst getImageObjSafe=()=>accessors.images?accessors.images[0]:{};// create shortcuts to image props : `crop` -> `imageCrop`\nlet initialImageProps={};getImagePublicPropNames(imageProps).forEach(prop=>{Object.defineProperty(accessors,getImagePropGroupedName(prop),{get:()=>{const image=getImageObjSafe();if(!image)return;return image.accessors[prop];},set:value=>{const image=getImageObjSafe();if(!image){initialImageProps[prop]=value;return;}image.accessors[prop]=value;}});});// handling loading an image if a src is set\nconst unsubSrc=stores.src.subscribe(src=>{// no image set, means clear active image\nif(!src)return accessors.images=[];// exit here if we don't have an imageReader we'll wait for an imageReader to be defined\nif(!accessors.imageReader)return;// this is the first image so let's use `loadSrc` so we can also apply initial props\nif(!accessors.images.length)return loadSrc(src);loadImage(src).catch(()=>{// fail silently, is handled with 'loaderror' event\n});});const unsubReader=stores.imageReader.subscribe(reader=>{// can't do anything without an image reader\nif(!reader)return;// an image has already been loaded no need to load images that were set earlier\nif(accessors.images.length)return;// no image to load, we'll wait for images to be set to the `src` prop\nif(!accessors.src)return;// src is waiting to be loaded so let's pick it up,\n// push it back a tick so we know initialImageProps are set\nloadSrc(accessors.src).catch(()=>{// fail silently, is handled with 'loaderror' event\n});});// loads the initial source, differs from loadImage as this method picks up any set image props\nconst loadSrc=src=>Promise.resolve().then(()=>loadImage(src,initialImageProps));// internal helper method to get active image\nconst getImage=()=>accessors.images&&accessors.images[0];//#endregion\n//#region public method (note that these are also called from UI, name of method is name of dispatched event in UI)\n// load image, resolve when image is loaded\nlet imageLoadAbort;const loadImage=(src,options={})=>new Promise((resolve,reject)=>{// get current image\nlet image=getImage();// determine min defined image size (is crop min size)\nconst minImageSize=options.cropMinSize||image&&image.accessors.cropMinSize;// if already has image, remove existing image\nif(image)removeImage();// access image props and stores\nimage=createImage({minSize:minImageSize});editorEventsToBubble.map(event=>image.accessors.on(event,bubble(event)));// done, clean up listeners\nconst done=()=>{initialImageProps={};unsubReject();unsubResolve();};const unsubReject=image.accessors.on('loaderror',error=>{done();reject(error);});image.accessors.on('beforeload',()=>{// normalize all prefixed options (from imageRotation -> rotation)\nconst normalizedOptions=getImagePublicPropNames(imageProps).reduce((prev,prop)=>{// test if already has image prop (rotation)\nif(prop in options){prev[prop]=options[prop];return prev;}// test if has prefixed image prop (imageRotation)\nelse{const groupedPropName=getImagePropGroupedName(prop);if(groupedPropName in options){prev[prop]=options[groupedPropName];}}return prev;},{});// if set as initial props we apply in most logical order\n['cropLimitToImage','crop','cropAspectRatio','rotation'].forEach(prop=>{if(!(prop in normalizedOptions))return;// asign to `image`\nimage.accessors[prop]=normalizedOptions[prop];// remove from normalizedOptions\ndelete normalizedOptions[prop];});// assign remaining options to `image`\nObject.assign(image.accessors,normalizedOptions);});const unsubResolve=image.accessors.on('load',output=>{imageLoadAbort=undefined;done();resolve(output);});// set new image\naccessors.images=[image];// assign passed options to editor accessors, we ignore 'src'\nif(options.imageReader)accessors.imageReader=options.imageReader;if(options.imageWriter)accessors.imageWriter=options.imageWriter;// start reading image\nimageLoadAbort=image.accessors.read(src,{reader:accessors.imageReader});});// start processing a loaded image, resolve when image is processed\nlet imageProcessAbort;const processImage=(src,options)=>{return new Promise(async(resolve,reject)=>{// if src supplied, first load src, then process\nsrc&&(await loadImage(src,options));// get current active image\nconst image=getImage();// needs image for processing\nif(!image)return reject('no image');// done, clean up listeners\nconst done=()=>{imageProcessAbort=undefined;unsubReject();unsubResolve();};const unsubReject=image.accessors.on('processerror',error=>{done();reject(error);});const unsubResolve=image.accessors.on('process',output=>{done();resolve(output);});imageProcessAbort=image.accessors.write(accessors.imageWriter);});};const abortProcessImage=()=>{const image=getImage();if(!image)return;if(imageProcessAbort)imageProcessAbort();image.accessors.processState=undefined;};// used internally (triggered by 'x' button when error loading image in UI)\nconst abortLoadImage=()=>{accessors.images=[];};// edit image, loads an image and resolve when image is processed\nconst editImage=(src,options)=>new Promise((resolve,reject)=>{loadImage(src,options).then(()=>{// access image props and stores\nconst{images}=accessors;const image=images[0];// done, clean up listeners\nconst done=()=>{unsubReject();unsubResolve();};const unsubReject=image.accessors.on('processerror',error=>{done();reject(error);});const unsubResolve=image.accessors.on('process',output=>{done();resolve(output);});}).catch(reject);});const removeImage=()=>{// no images, nothing to remove\nconst image=getImage();if(!image)return;// try to abort image load\nif(imageLoadAbort)imageLoadAbort();image.accessors.loadState=undefined;// clear images\naccessors.images=[];};//#endregion\nObject.defineProperty(accessors,'stores',{get:()=>stores});//#region API\ndefineMethods(accessors,{on:sub,loadImage,abortLoadImage,editImage,removeImage,processImage,abortProcessImage,destroy:()=>{unsubSrc();unsubReader();}});return accessors;//#endregion\n};var getComponentExportedProps=Component=>{const descriptors=Object.getOwnPropertyDescriptors(Component.prototype);return Object.keys(descriptors).filter(key=>!!descriptors[key]['get']);};function circOut(t){return Math.sqrt(1- --t*t);}function is_date(obj){return Object.prototype.toString.call(obj)==='[object Date]';}function get_interpolator(a,b){if(a===b||a!==a)return()=>a;const type=typeof a;if(type!==typeof b||Array.isArray(a)!==Array.isArray(b)){throw new Error('Cannot interpolate values of different type');}if(Array.isArray(a)){const arr=b.map((bi,i)=>{return get_interpolator(a[i],bi);});return t=>arr.map(fn=>fn(t));}if(type==='object'){if(!a||!b)throw new Error('Object cannot be null');if(is_date(a)&&is_date(b)){a=a.getTime();b=b.getTime();const delta=b-a;return t=>new Date(a+t*delta);}const keys=Object.keys(b);const interpolators={};keys.forEach(key=>{interpolators[key]=get_interpolator(a[key],b[key]);});return t=>{const result={};keys.forEach(key=>{result[key]=interpolators[key](t);});return result;};}if(type==='number'){const delta=b-a;return t=>a+t*delta;}throw new Error(`Cannot interpolate ${type} values`);}function tweened(value,defaults={}){const store=writable(value);let task;let target_value=value;function set(new_value,opts){if(value==null){store.set(value=new_value);return Promise.resolve();}target_value=new_value;let previous_task=task;let started=false;let{delay=0,duration=400,easing=identity,interpolate=get_interpolator}=assign(assign({},defaults),opts);if(duration===0){if(previous_task){previous_task.abort();previous_task=null;}store.set(value=target_value);return Promise.resolve();}const start=now()+delay;let fn;task=loop(now=>{if(now<start)return true;if(!started){fn=interpolate(value,new_value);if(typeof duration==='function')duration=duration(value,new_value);started=true;}if(previous_task){previous_task.abort();previous_task=null;}const elapsed=now-start;if(elapsed>duration){store.set(value=new_value);return false;}// @ts-ignore\nstore.set(value=fn(easing(elapsed/duration)));return true;});return task.promise;}return{set,update:(fn,opts)=>set(fn(target_value,value),opts),subscribe:store.subscribe};}function tick_spring(ctx,last_value,current_value,target_value){if(typeof current_value==='number'){// @ts-ignore\nconst delta=target_value-current_value;// @ts-ignore\nconst velocity=(current_value-last_value)/(ctx.dt||1/60);// guard div by 0\nconst spring=ctx.opts.stiffness*delta;const damper=ctx.opts.damping*velocity;const acceleration=(spring-damper)*ctx.inv_mass;const d=(velocity+acceleration)*ctx.dt;if(Math.abs(d)<ctx.opts.precision&&Math.abs(delta)<ctx.opts.precision){return target_value;// settled\n}else{ctx.settled=false;// signal loop to keep ticking\n// @ts-ignore\nreturn current_value+d;}}else if(isArray(current_value)){// @ts-ignore\nreturn current_value.map((_,i)=>tick_spring(ctx,last_value[i],current_value[i],target_value[i]));}else if(typeof current_value==='object'){const next_value={};// @ts-ignore\nfor(const k in current_value){// @ts-ignore\nnext_value[k]=tick_spring(ctx,last_value[k],current_value[k],target_value[k]);}// @ts-ignore\nreturn next_value;}else{throw new Error(`Cannot spring ${typeof current_value} values`);}}function spring(value,opts={}){const store=writable(value);const{stiffness=0.15,damping=0.8,precision=0.01}=opts;let last_time;let task;let current_token;let last_value=value;let target_value=value;let inv_mass=1;let inv_mass_recovery_rate=0;let cancel_task=false;function set(new_value,opts={}){target_value=new_value;const token=current_token={};if(value==null||opts.hard||spring.stiffness>=1&&spring.damping>=1){cancel_task=true;// cancel any running animation\nlast_time=null;last_value=new_value;store.set(value=target_value);return Promise.resolve();}else if(opts.soft){const rate=opts.soft===true?0.5:+opts.soft;inv_mass_recovery_rate=1/(rate*60);inv_mass=0;// infinite mass, unaffected by spring forces\n}if(!task){last_time=null;cancel_task=false;const ctx={inv_mass:undefined,opts:spring,settled:true,dt:undefined};task=loop(now=>{if(last_time===null)last_time=now;if(cancel_task){cancel_task=false;task=null;return false;}inv_mass=Math.min(inv_mass+inv_mass_recovery_rate,1);// altered so doesn't create a new object\nctx.inv_mass=inv_mass;ctx.opts=spring;ctx.settled=true;// tick_spring may signal false\nctx.dt=(now-last_time)*60/1000;const next_value=tick_spring(ctx,last_value,value,target_value);last_time=now;last_value=value;store.set(value=next_value);if(ctx.settled)task=null;return!ctx.settled;});}return new Promise(fulfil=>{task.promise.then(()=>{if(token===current_token)fulfil();});});}const spring={set,update:(fn,opts)=>set(fn(target_value,value),opts),subscribe:store.subscribe,stiffness,damping,precision};return spring;}var prefersReducedMotion=readable(false,set=>{const mql=window.matchMedia('(prefers-reduced-motion:reduce)');set(mql.matches);mql.onchange=()=>set(mql.matches);});var hasResizeObserver=()=>'ResizeObserver'in window;//\nconst rectNext=rectCreateEmpty();const updateNodeRect=(node,x,y,width,height)=>{if(!node.rect)node.rect=rectCreateEmpty();const rect=node.rect;rectUpdate(rectNext,x,y,width,height);if(rectEqual(rect,rectNext))return;rectUpdateWithRect(rect,rectNext);node.dispatchEvent(new CustomEvent('measure',{detail:rect}));};// measures the element\nconst r=Math.round;const measureViewRect=node=>{const clientRect=node.getBoundingClientRect();updateNodeRect(node,r(clientRect.x),r(clientRect.y),r(clientRect.width),r(clientRect.height));};const measureOffset=node=>updateNodeRect(node,node.offsetLeft,node.offsetTop,node.offsetWidth,node.offsetHeight);// holds all the elements to measure using requestAnimationFrame\nconst elements=[];// draw loop\nlet frame=null;function tick(){if(!elements.length){frame=null;return;}elements.forEach(node=>node.measure(node));frame=requestAnimationFrame(tick);}let observer;// ResizeObserver API not known by TypeScript\nvar measurable=(node,options={})=>{const{observePosition=false,observeViewRect=false,once=false,disabled=false}=options;// exit\nif(disabled)return;// use resize observe if available\nif(hasResizeObserver()&&!observePosition&&!observeViewRect){// we only create one observer, it will observe all registered elements\nif(!observer){// @ts-ignore: [2020-02-20] ResizeObserver API not known by TypeScript\nobserver=new ResizeObserver(entries=>{entries.forEach(entry=>measureOffset(entry.target));});}// start observing this node\nobserver.observe(node);// measure our node for the first time\nmeasureOffset(node);// if should only measure once, remove now\nif(once)observer.unobserve(node);// and we done, need to return a clean up method for when our node is destroyed\nreturn{destroy(){// already unobserved this node\nif(once)return;observer.unobserve(node);// TODO: test if all nodes have been removed, if so, remove observer\n}};}// set measure function\nnode.measure=observeViewRect?measureViewRect:measureOffset;// add so the element is measured\nelements.push(node);// start measuring on next frame, we set up a single measure loop,\n// the loop will check if there's still elements that need to be measured,\n// else it will stop running\nif(!frame)frame=requestAnimationFrame(tick);// measure this element now\nnode.measure(node);// remove method\nreturn{destroy(){const index=elements.indexOf(node);elements.splice(index,1);}};};var focusvisible=element=>{let isKeyboardInteraction=false;const handlePointerdown=()=>{isKeyboardInteraction=false;};const handleKeydown=()=>{isKeyboardInteraction=true;};const handleKeyup=()=>{isKeyboardInteraction=false;};const handleFocus=e=>{if(!isKeyboardInteraction)return;e.target.dataset.focusVisible='';};const handleBlur=e=>{delete e.target.dataset.focusVisible;};const map={pointerdown:handlePointerdown,keydown:handleKeydown,keyup:handleKeyup,focus:handleFocus,blur:handleBlur};Object.keys(map).forEach(event=>element.addEventListener(event,map[event],true));return{destroy(){Object.keys(map).forEach(event=>element.removeEventListener(event,map[event],true));}};};var isImage=file=>/^image/.test(file.type);const getFilesFromEvent=e=>{const{items,files}=e.dataTransfer;if(items){return Array.from(items).filter(item=>item.kind==='file').map(item=>item.getAsFile());}return Array.from(files)||[];};var dropable=node=>{const handleDragOver=e=>{// need to be prevent default to allow drop\ne.preventDefault();};const handleDrop=e=>{e.preventDefault();e.stopPropagation();// prevents parents from catching this drop\nnode.dispatchEvent(new CustomEvent('dropfiles',{detail:{event:e,files:getFilesFromEvent(e).filter(file=>isImage(file))}}));};node.addEventListener('drop',handleDrop);node.addEventListener('dragover',handleDragOver);// remove method\nreturn{destroy(){node.removeEventListener('drop',handleDrop);node.removeEventListener('dragover',handleDragOver);}};};let result$8=null;var supportsWebGL2=()=>{if(result$8===null){if('WebGL2RenderingContext'in window){let canvas;try{canvas=h('canvas');result$8=!!canvas.getContext('webgl2');}catch(err){result$8=false;}canvas&&releaseCanvas(canvas);}else{result$8=false;}}return result$8;};var isPowerOf2=value=>(value&value-1)===0;var stringReplace=(str,entries={},prefix='',postfix='')=>{return Object.keys(entries).filter(key=>!isObject(entries[key])).reduce((prev,curr)=>{return prev.replace(new RegExp(prefix+curr+postfix),entries[curr]);},str);};var SHADER_FRAG_HEAD=\"#version 300 es\\nprecision highp float;\\n\\nout vec4 fragColor;\";// eslint-disable-line\nvar SHADER_FRAG_INIT=\"\\nfloat a=1.0;vec4 fillColor=uColor;vec4 textureColor=texture(uTexture,vTexCoord);textureColor*=(1.0-step(1.0,vTexCoord.y))*step(0.0,vTexCoord.y)*(1.0-step(1.0,vTexCoord.x))*step(0.0,vTexCoord.x);\";// eslint-disable-line\nvar SHADER_FRAG_MASK=\"\\nuniform float uMaskFeather[8];uniform float uMaskBounds[4];uniform float uMaskOpacity;float mask(float x,float y,float bounds[4],float opacity){return 1.0-(1.0-(smoothstep(bounds[3],bounds[3]+1.0,x)*(1.0-smoothstep(bounds[1]-1.0,bounds[1],x))*(1.0-step(bounds[0],y))*step(bounds[2],y)))*(1.0-opacity);}\";// eslint-disable-line\nvar SHADER_FRAG_MASK_APPLY=\"\\nfloat m=mask(gl_FragCoord.x,gl_FragCoord.y,uMaskBounds,uMaskOpacity);\";// eslint-disable-line\nvar SHADER_FRAG_MASK_FEATHER_APPLY=\"\\nfloat leftFeatherOpacity=step(uMaskFeather[1],gl_FragCoord.x)*uMaskFeather[0]+((1.0-uMaskFeather[0])*smoothstep(uMaskFeather[1],uMaskFeather[3],gl_FragCoord.x));float rightFeatherOpacity=(1.0-step(uMaskFeather[7],gl_FragCoord.x))*uMaskFeather[4]+((1.0-uMaskFeather[4])*smoothstep(uMaskFeather[7],uMaskFeather[5],gl_FragCoord.x));a*=leftFeatherOpacity*rightFeatherOpacity;\";// eslint-disable-line\nvar SHADER_FRAG_RECT_AA=\"\\nvec2 scaledPoint=vec2(vRectCoord.x*uSize.x,vRectCoord.y*uSize.y);a*=smoothstep(0.0,1.0,uSize.x-scaledPoint.x);a*=smoothstep(0.0,1.0,uSize.y-scaledPoint.y);a*=smoothstep(0.0,1.0,scaledPoint.x);a*=smoothstep(0.0,1.0,scaledPoint.y);\";// eslint-disable-line\nvar SHADER_FRAG_CORNER_RADIUS=\"\\nvec2 s=(uSize-2.0)*.5;vec2 r=(vRectCoord*uSize);vec2 p=r-(uSize*.5);float cornerRadius=uCornerRadius[0];bool left=r.x<s.x;bool top=r.y<s.x;if(!left&&top){cornerRadius=uCornerRadius[1];}if(!left&&!top){cornerRadius=uCornerRadius[3];}if(left&&!top){cornerRadius=uCornerRadius[2];}a*=1.0-clamp(length(max(abs(p)-(s-cornerRadius),0.0))-cornerRadius,0.0,1.0);\";// eslint-disable-line\nvar SHADER_FRAG_SHAPE_BLEND_COLOR=\"\\nfillColor.a*=a;fillColor.rgb*=fillColor.a;fillColor.rgb*=m;fillColor.rgb+=(1.0-m)*(uCanvasColor.rgb*fillColor.a);textureColor*=uTextureOpacity;textureColor.a*=a;textureColor.rgb*=m*a;textureColor.rgb+=(1.0-m)*(uCanvasColor.rgb*textureColor.a);fragColor=textureColor+(fillColor*(1.0-textureColor.a));\";// eslint-disable-line\nvar SHADER_FRAG_TEXTURE_COLORIZE=\"\\nif(uTextureColor.a!=0.0&&textureColor.a>0.0){vec3 colorFlattened=textureColor.rgb/textureColor.a;if(colorFlattened.r>.999999&&colorFlattened.g==0.0&&colorFlattened.b>.999999){textureColor.rgb=uTextureColor.rgb*textureColor.a;}textureColor*=uTextureColor.a;}\";// eslint-disable-line\nvar SHADER_VERT_HEAD=\"#version 300 es\\n\\nin vec4 aPosition;uniform mat4 uMatrix;\";// eslint-disable-line\nvar SHADER_VERT_MULTIPLY_MATRUX=\"\\ngl_Position=uMatrix*vec4(aPosition.x,aPosition.y,0,1);\";// eslint-disable-line\nvar SHADER_VERT_TEXTURE=\"\\nin vec2 aTexCoord;out vec2 vTexCoord;\";// eslint-disable-line\nconst SHADER_VERT_SNIPPETS={head:SHADER_VERT_HEAD,text:SHADER_VERT_TEXTURE,matrix:SHADER_VERT_MULTIPLY_MATRUX};const SHADER_FRAG_SNIPPETS={head:SHADER_FRAG_HEAD,mask:SHADER_FRAG_MASK,init:SHADER_FRAG_INIT,colorize:SHADER_FRAG_TEXTURE_COLORIZE,maskapply:SHADER_FRAG_MASK_APPLY,maskfeatherapply:SHADER_FRAG_MASK_FEATHER_APPLY,edgeaa:SHADER_FRAG_RECT_AA,cornerradius:SHADER_FRAG_CORNER_RADIUS,fragcolor:SHADER_FRAG_SHAPE_BLEND_COLOR};const transpileShader=(gl,src,type)=>{src=stringReplace(src,type===gl.VERTEX_SHADER?SHADER_VERT_SNIPPETS:SHADER_FRAG_SNIPPETS,'##').trim();// ready if supports webgl\nif(supportsWebGL2())return src;src=src.replace(/#version.+/gm,'').trim();src=src.replace(/^\\/\\/\\#/gm,'#');if(type===gl.VERTEX_SHADER){src=src.replace(/in /gm,'attribute ').replace(/out /g,'varying ');}if(type===gl.FRAGMENT_SHADER){src=src.replace(/in /gm,'varying ').replace(/out.*?;/gm,'').replace(/texture\\(/g,'texture2D(').replace(/fragColor/g,'gl_FragColor');}return`${src}`;};const compileShader=(gl,src,type)=>{const shader=gl.createShader(type);const transpiledSrc=transpileShader(gl,src,type);gl.shaderSource(shader,transpiledSrc);gl.compileShader(shader);if(!gl.getShaderParameter(shader,gl.COMPILE_STATUS)){console.error(gl.getShaderInfoLog(shader));}return shader;};const createShader=(gl,vertexShader,fragmentShader,attribs,uniforms)=>{const program=gl.createProgram();gl.attachShader(program,compileShader(gl,vertexShader,gl.VERTEX_SHADER));gl.attachShader(program,compileShader(gl,fragmentShader,gl.FRAGMENT_SHADER));gl.linkProgram(program);const locations={};attribs.forEach(name=>{locations[name]=gl.getAttribLocation(program,name);});uniforms.forEach(name=>{locations[name]=gl.getUniformLocation(program,name);});return{program,locations};};const canMipMap=source=>{if(supportsWebGL2())return true;return isPowerOf2(source.width)&&isPowerOf2(source.height);};const applyTextureProperties=(gl,source)=>{gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_MIN_FILTER,canMipMap(source)?gl.LINEAR_MIPMAP_LINEAR:gl.LINEAR);gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_MAG_FILTER,gl.LINEAR);gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_WRAP_S,gl.CLAMP_TO_EDGE);gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_WRAP_T,gl.CLAMP_TO_EDGE);if(canMipMap(source)){gl.generateMipmap(gl.TEXTURE_2D);}};const createTexture=(gl,source)=>{const texture=gl.createTexture();gl.bindTexture(gl.TEXTURE_2D,texture);gl.texImage2D(gl.TEXTURE_2D,0,gl.RGBA,gl.RGBA,gl.UNSIGNED_BYTE,source);applyTextureProperties(gl,source);gl.bindTexture(gl.TEXTURE_2D,null);return texture;};const applyOpacity=(color,opacity=1)=>color?[color[0],color[1],color[2],isNumber(color[3])?opacity*color[3]:opacity]:[0,0,0,0];const mat4Create=()=>{const mat=new Float32Array(16);mat[0]=1;mat[5]=1;mat[10]=1;mat[15]=1;return mat;};const mat4Perspective=(mat,fovy,aspect,near,far)=>{const f=1.0/Math.tan(fovy/2);const nf=1/(near-far);mat[0]=f/aspect;mat[1]=0;mat[2]=0;mat[3]=0;mat[4]=0;mat[5]=f;mat[6]=0;mat[7]=0;mat[8]=0;mat[9]=0;mat[10]=(far+near)*nf;mat[11]=-1;mat[12]=0;mat[13]=0;mat[14]=2*far*near*nf;mat[15]=0;};const mat4Ortho=(mat,left,right,bottom,top,near,far)=>{const lr=1/(left-right);const bt=1/(bottom-top);const nf=1/(near-far);mat[0]=-2*lr;mat[1]=0;mat[2]=0;mat[3]=0;mat[4]=0;mat[5]=-2*bt;mat[6]=0;mat[7]=0;mat[8]=0;mat[9]=0;mat[10]=2*nf;mat[11]=0;mat[12]=(left+right)*lr;mat[13]=(top+bottom)*bt;mat[14]=(far+near)*nf;mat[15]=1;};const mat4Translate=(mat,x,y,z)=>{mat[12]=mat[0]*x+mat[4]*y+mat[8]*z+mat[12];mat[13]=mat[1]*x+mat[5]*y+mat[9]*z+mat[13];mat[14]=mat[2]*x+mat[6]*y+mat[10]*z+mat[14];mat[15]=mat[3]*x+mat[7]*y+mat[11]*z+mat[15];};const mat4Scale=(mat,s)=>{mat[0]=mat[0]*s;mat[1]=mat[1]*s;mat[2]=mat[2]*s;mat[3]=mat[3]*s;mat[4]=mat[4]*s;mat[5]=mat[5]*s;mat[6]=mat[6]*s;mat[7]=mat[7]*s;mat[8]=mat[8]*s;mat[9]=mat[9]*s;mat[10]=mat[10]*s;mat[11]=mat[11]*s;};const mat4ScaleX=(mat,s)=>{mat[0]=mat[0]*s;mat[1]=mat[1]*s;mat[2]=mat[2]*s;mat[3]=mat[3]*s;};const mat4ScaleY=(mat,s)=>{mat[4]=mat[4]*s;mat[5]=mat[5]*s;mat[6]=mat[6]*s;mat[7]=mat[7]*s;};const mat4RotateX=(mat,rad)=>{const s=Math.sin(rad);const c=Math.cos(rad);const a10=mat[4];const a11=mat[5];const a12=mat[6];const a13=mat[7];const a20=mat[8];const a21=mat[9];const a22=mat[10];const a23=mat[11];mat[4]=a10*c+a20*s;mat[5]=a11*c+a21*s;mat[6]=a12*c+a22*s;mat[7]=a13*c+a23*s;mat[8]=a20*c-a10*s;mat[9]=a21*c-a11*s;mat[10]=a22*c-a12*s;mat[11]=a23*c-a13*s;};const mat4RotateY=(mat,rad)=>{const s=Math.sin(rad);const c=Math.cos(rad);const a00=mat[0];const a01=mat[1];const a02=mat[2];const a03=mat[3];const a20=mat[8];const a21=mat[9];const a22=mat[10];const a23=mat[11];mat[0]=a00*c-a20*s;mat[1]=a01*c-a21*s;mat[2]=a02*c-a22*s;mat[3]=a03*c-a23*s;mat[8]=a00*s+a20*c;mat[9]=a01*s+a21*c;mat[10]=a02*s+a22*c;mat[11]=a03*s+a23*c;};const mat4RotateZ=(mat,rad)=>{const s=Math.sin(rad);const c=Math.cos(rad);const a00=mat[0];const a01=mat[1];const a02=mat[2];const a03=mat[3];const a10=mat[4];const a11=mat[5];const a12=mat[6];const a13=mat[7];mat[0]=a00*c+a10*s;mat[1]=a01*c+a11*s;mat[2]=a02*c+a12*s;mat[3]=a03*c+a13*s;mat[4]=a10*c-a00*s;mat[5]=a11*c-a01*s;mat[6]=a12*c-a02*s;mat[7]=a13*c-a03*s;};var degToRad=degrees=>degrees*Math.PI/180;var previewFragmentShader=\"\\n##head\\nin vec2 vTexCoord;uniform sampler2D uTexture;uniform sampler2D uTextureMarkup;uniform vec2 uTextureSize;uniform float uOpacity;uniform vec4 uFillColor;uniform vec4 uOverlayColor;uniform mat4 uColorMatrix;uniform vec4 uColorOffset;uniform float uClarityKernel[9];uniform float uClarityKernelWeight;uniform float uColorGamma;uniform float uColorVignette;uniform float uMaskClip;uniform float uMaskOpacity;uniform float uMaskBounds[4];uniform float uMaskCornerRadius[4];uniform float uMaskFeather[8];vec4 applyGamma(vec4 c,float g){c.r=pow(c.r,g);c.g=pow(c.g,g);c.b=pow(c.b,g);return c;}vec4 applyColorMatrix(vec4 c,mat4 m,vec4 o){vec4 cM=(c*m)+o;cM*=cM.a;return cM;}vec4 applyConvolutionMatrix(vec4 c,float k0,float k1,float k2,float k3,float k4,float k5,float k6,float k7,float k8,float w){if(w<=0.0)return c;vec2 pixel=vec2(1)/uTextureSize;vec4 colorSum=texture(uTexture,vTexCoord+pixel*vec2(-1.0,-1.0))*k0+texture(uTexture,vTexCoord+pixel*vec2(0.0,-1.0))*k1+texture(uTexture,vTexCoord+pixel*vec2(1.0,-1.0))*k2+texture(uTexture,vTexCoord+pixel*vec2(-1.0,0.0))*k3+texture(uTexture,vTexCoord+pixel*vec2(0.0,0.0))*k4+texture(uTexture,vTexCoord+pixel*vec2(1.0,0.0))*k5+texture(uTexture,vTexCoord+pixel*vec2(-1.0,1.0))*k6+texture(uTexture,vTexCoord+pixel*vec2(0.0,1.0))*k7+texture(uTexture,vTexCoord+pixel*vec2(1.0,1.0))*k8;vec4 color=vec4((colorSum/w).rgb,c.a);color.rgb=clamp(color.rgb,0.0,1.0);return color;}vec4 applyVignette(vec4 c,vec2 pos,vec2 center,float v){float d=distance(pos,center)/length(center);float f=1.0-(d*abs(v));if(v>0.0){c.rgb*=f;}else if(v<0.0){c.rgb+=(1.0-f)*(1.0-c.rgb);}return c;}vec4 blendPremultipliedAlpha(vec4 back,vec4 front){return front+(back*(1.0-front.a));}void main(){float x=gl_FragCoord.x;float y=gl_FragCoord.y;float a=1.0;float maskTop=uMaskBounds[0];float maskRight=uMaskBounds[1];float maskBottom=uMaskBounds[2];float maskLeft=uMaskBounds[3];float leftFeatherOpacity=step(uMaskFeather[1],x)*uMaskFeather[0]+((1.0-uMaskFeather[0])*smoothstep(uMaskFeather[1],uMaskFeather[3],x));float rightFeatherOpacity=(1.0-step(uMaskFeather[7],x))*uMaskFeather[4]+((1.0-uMaskFeather[4])*smoothstep(uMaskFeather[7],uMaskFeather[5],x));a*=leftFeatherOpacity*rightFeatherOpacity;float overlayColorAlpha=(smoothstep(maskLeft,maskLeft+1.0,x)*(1.0-smoothstep(maskRight-1.0,maskRight,x))*(1.0-step(maskTop,y))*step(maskBottom,y));if(uOverlayColor.a==0.0){a*=overlayColorAlpha;}vec2 offset=vec2(maskLeft,maskBottom);vec2 size=vec2(maskRight-maskLeft,maskTop-maskBottom)*.5;vec2 center=offset.xy+size.xy;int pixelX=int(step(center.x,x));int pixelY=int(step(y,center.y));float cornerRadius=0.0;if(pixelX==0&&pixelY==0)cornerRadius=uMaskCornerRadius[0];if(pixelX==1&&pixelY==0)cornerRadius=uMaskCornerRadius[1];if(pixelX==0&&pixelY==1)cornerRadius=uMaskCornerRadius[2];if(pixelX==1&&pixelY==1)cornerRadius=uMaskCornerRadius[3];float cornerOffset=sign(cornerRadius)*length(max(abs(gl_FragCoord.xy-size-offset)-size+cornerRadius,0.0))-cornerRadius;float cornerOpacity=1.0-smoothstep(0.0,1.0,cornerOffset);a*=cornerOpacity;vec2 scaledPoint=vec2(vTexCoord.x*uTextureSize.x,vTexCoord.y*uTextureSize.y);a*=smoothstep(0.0,1.0,uTextureSize.x-scaledPoint.x);a*=smoothstep(0.0,1.0,uTextureSize.y-scaledPoint.y);a*=smoothstep(0.0,1.0,scaledPoint.x);a*=smoothstep(0.0,1.0,scaledPoint.y);vec4 color=texture(uTexture,vTexCoord);color=applyConvolutionMatrix(color,uClarityKernel[0],uClarityKernel[1],uClarityKernel[2],uClarityKernel[3],uClarityKernel[4],uClarityKernel[5],uClarityKernel[6],uClarityKernel[7],uClarityKernel[8],uClarityKernelWeight);color=applyGamma(color,uColorGamma);color=applyColorMatrix(color,uColorMatrix,uColorOffset);color=blendPremultipliedAlpha(uFillColor,color);color*=a;color=blendPremultipliedAlpha(color,texture(uTextureMarkup,vTexCoord));if(uColorVignette!=0.0){vec2 pos=gl_FragCoord.xy-offset;color=applyVignette(color,pos,center-offset,uColorVignette);}vec4 overlayColor=uOverlayColor*(1.0-overlayColorAlpha);overlayColor.rgb*=overlayColor.a;color=blendPremultipliedAlpha(color,overlayColor);if(uOverlayColor.a>0.0&&color.a<1.0&&uFillColor.a>0.0){color=blendPremultipliedAlpha(uFillColor,overlayColor);}color*=uOpacity;fragColor=color;}\";// eslint-disable-line\nvar previewVertexShader=\"\\n##head\\n##text\\nvoid main(){vTexCoord=aTexCoord;gl_Position=uMatrix*aPosition;}\";// eslint-disable-line\nvar pathVertexShader=\"#version 300 es\\n\\nin vec4 aPosition;in vec2 aNormal;in float aMiter;out vec2 vNormal;out float vMiter;uniform float uWidth;uniform mat4 uMatrix;void main(){vMiter=aMiter;vNormal=aNormal;float w=uWidth;gl_Position=uMatrix*vec4(aPosition.x+(aNormal.x*w*.5*aMiter),aPosition.y+(aNormal.y*w*.5*aMiter),0,1);}\";// eslint-disable-line\nvar pathFragmentShader=\"\\n##head\\n##mask\\nin vec2 vNormal;in float vMiter;uniform float uWidth;uniform vec4 uColor;uniform vec4 uCanvasColor;void main(){vec4 fillColor=uColor;float w=(uWidth-1.0)*.5;float d=1.0-abs(vMiter);float m=mask(gl_FragCoord.x,gl_FragCoord.y,uMaskBounds,uMaskOpacity);fillColor.a*=clamp(smoothstep(0.25,1.0,d*w),0.0,1.0);fillColor.rgb*=fillColor.a;fillColor.rgb*=m;fillColor.rgb+=(1.0-m)*(uCanvasColor.rgb*fillColor.a);fragColor=fillColor;}\";// eslint-disable-line\nvar rectVertexShader=\"\\n##head\\n##text\\nin vec2 aRectCoord;out vec2 vRectCoord;void main(){vTexCoord=aTexCoord;vRectCoord=aRectCoord;\\n##matrix\\n}\";// eslint-disable-line\nvar rectFragmentShader=\"\\n##head\\n##mask\\nin vec2 vTexCoord;in vec2 vRectCoord;uniform sampler2D uTexture;uniform vec4 uTextureColor;uniform float uTextureOpacity;uniform vec4 uColor;uniform float uCornerRadius[4];uniform vec2 uSize;uniform vec2 uPosition;uniform vec4 uCanvasColor;void main(){\\n##init\\n##colorize\\n##edgeaa\\n##cornerradius\\n##maskfeatherapply\\n##maskapply\\n##fragcolor\\n}\";// eslint-disable-line\nvar ellipseVertexShader=\"\\n##head\\n##text\\nvoid main(){vTexCoord=vec2(aTexCoord.x*2.0-1.0,aTexCoord.y*2.0-1.0);\\n##matrix\\n}\";// eslint-disable-line\nvar ellipseFragmentShader=\"\\n##head\\n##mask\\nin vec2 vTexCoord;uniform sampler2D uTexture;uniform float uTextureOpacity;uniform vec2 uRadius;uniform vec4 uColor;uniform int uInverted;uniform vec4 uCanvasColor;void main(){\\n##init\\nfloat ar=uRadius.x/uRadius.y;vec2 rAA=vec2(uRadius.x-1.0,uRadius.y-(1.0/ar));vec2 scaledPointSq=vec2((vTexCoord.x*uRadius.x)*(vTexCoord.x*uRadius.x),(vTexCoord.y*uRadius.y)*(vTexCoord.y*uRadius.y));float p=(scaledPointSq.x/(uRadius.x*uRadius.x))+(scaledPointSq.y/(uRadius.y*uRadius.y));float pAA=(scaledPointSq.x/(rAA.x*rAA.x))+(scaledPointSq.y/(rAA.y*rAA.y));a=smoothstep(1.0,p/pAA,p);if(uInverted==1)a=1.0-a;\\n##maskapply\\n##fragcolor\\n}\";// eslint-disable-line\nvar triangleVertexShader=\"\\n##head\\nvoid main(){\\n##matrix\\n}\";// eslint-disable-line\nvar triangleFragmentShader=\"\\n##head\\n##mask\\nuniform vec4 uColor;uniform vec4 uCanvasColor;void main(){vec4 fillColor=uColor;\\n##maskapply\\nfillColor.rgb*=fillColor.a;fillColor.rgb*=m;fillColor.rgb+=(1.0-m)*(uCanvasColor.rgb*fillColor.a);fragColor=fillColor;}\";// eslint-disable-line\nconst createPathSegment=(vertices,index,a,b,c)=>{let ab;let bc;ab=vectorNormalize(vectorCreate(b.x-a.x,b.y-a.y));bc=vectorNormalize(vectorCreate(c.x-b.x,c.y-b.y));const tangent=vectorNormalize(vectorCreate(ab.x+bc.x,ab.y+bc.y));const miter=vectorCreate(-tangent.y,tangent.x);const normal=vectorCreate(-ab.y,ab.x);// TODO: The Math.min is a \"dirty\" hack to prevent miter spikes, should bevel line edges\n// const dist = Math.min(1, 1 / vectorDot(miter, normal));\nconst miterLength=1/vectorDot(miter,normal);vertices[index]=b.x;vertices[index+1]=b.y;vertices[index+2]=miter.x;vertices[index+3]=miter.y;vertices[index+4]=-miterLength;vertices[index+5]=b.x;vertices[index+6]=b.y;vertices[index+7]=miter.x;vertices[index+8]=miter.y;vertices[index+9]=miterLength;};const createPathVertices=(points,close)=>{let a,b,c,i=0;const l=points.length;const stride=10;const vertices=new Float32Array((close?l+1:l)*stride);const first=points[0];const last=points[l-1];for(i=0;i<l;i++){a=points[i-1];b=points[i];c=points[i+1];// if previous point not available use inverse vector to next point\nif(!a)a=close?last:vectorCreate(b.x+(b.x-c.x),b.y+(b.y-c.y));// if next point not available use inverse vector from previous point\nif(!c)c=close?first:vectorCreate(b.x+(b.x-a.x),b.y+(b.y-a.y));createPathSegment(vertices,i*stride,a,b,c);}if(close)createPathSegment(vertices,l*stride,last,first,points[1]);return vertices;};const rectPointsToVertices=points=>{// [tl, tr, br, bl]\n// B   D\n// | \\ |\n// A  C\nconst vertices=new Float32Array(8);vertices[0]=points[3].x;vertices[1]=points[3].y;vertices[2]=points[0].x;vertices[3]=points[0].y;vertices[4]=points[2].x;vertices[5]=points[2].y;vertices[6]=points[1].x;vertices[7]=points[1].y;return vertices;};const trianglePointToVertices=points=>{const vertices=new Float32Array(6);vertices[0]=points[0].x;vertices[1]=points[0].y;vertices[2]=points[1].x;vertices[3]=points[1].y;vertices[4]=points[2].x;vertices[5]=points[2].y;return vertices;};const createRectPoints=(rect,rotation=0,flipX,flipY)=>{const corners=rectGetCorners(rect);const cx=rect.x+rect.width*0.5;const cy=rect.y+rect.height*0.5;if(flipX||flipY)vectorsFlip(corners,flipX,flipY,cx,cy);if(rotation!==0)vectorsRotate(corners,rotation,cx,cy);return corners;};const createEllipseOutline=(x,y,width,height,rotation,flipX,flipY)=>{const points=[];// decide how much points we need to describe the circle\nconst size=Math.abs(width)+Math.abs(height);const precision=Math.max(20,Math.round(size/6));const w=width*0.5;const h=height*0.5;const cx=x+w;const cy=y+h;for(let i=0;i<precision;i++){points.push(vectorCreate(cx+w*Math.cos(i*(Math.PI*2)/precision),cy+h*Math.sin(i*(Math.PI*2)/precision)));}if(flipX||flipY)vectorsFlip(points,flipX,flipY,cx,cy);if(rotation)vectorsRotate(points,rotation,cx,cy);return points;};const createRectOutline=(x,y,width,height,rotation,cornerRadius,flipX,flipY)=>{const points=[];if(cornerRadius.every(v=>v===0)){points.push(vectorCreate(x,y),// top left corner\nvectorCreate(x+width,y),// top right corner\nvectorCreate(x+width,y+height),// bottom right corner\nvectorCreate(x,y+height)// bottom left corner\n);}else{const[tl,tr,bl,br]=cornerRadius;const l=x;const r=x+width;const t=y;const b=y+height;// start at end of top left corner\npoints.push(vectorCreate(l+tl,t));pushRectCornerPoints(points,r-tr,t+tr,tr,-1);// move to bottom right corner\npoints.push(vectorCreate(r,t+tr));pushRectCornerPoints(points,r-br,b-br,br,0);// move to bottom left corner\npoints.push(vectorCreate(r-br,b));pushRectCornerPoints(points,l+bl,b-bl,bl,1);// move to top left corner\npoints.push(vectorCreate(l,b-bl));pushRectCornerPoints(points,l+tl,t+tl,tl,2);}if(flipX||flipY)vectorsFlip(points,flipX,flipY,x+width*0.5,y+height*0.5);if(rotation)vectorsRotate(points,rotation,x+width*0.5,y+height*0.5);return points;};const pushRectCornerPoints=(points,x,y,radius,offset)=>{const precision=Math.min(20,Math.max(4,Math.round(radius/2)));let p=0;let s=0;let rx=0;let ry=0;let i=0;for(;i<precision;i++){p=i/precision;s=offset*HALF_PI+p*HALF_PI;rx=radius*Math.cos(s);ry=radius*Math.sin(s);points.push(vectorCreate(x+rx,y+ry));}};var getWebGLContext=(canvas,attrs)=>canvas.getContext('webgl2',attrs)||canvas.getContext('webgl',attrs)||canvas.getContext('experimental-webgl',attrs);// prettier-ignore\n// B   D\n// | \\ |\n// A  C\nconst rectUV=new Float32Array([0.0,1.0,0.0,0.0,1.0,1.0,1.0,0.0]);var createGLImageDrawer=(canvas,imageData,imageSize,pixelDensity)=>{let viewSize={width:0,height:0};let viewSizeVisual={width:0,height:0};let viewAspectRatio;let viewPixelDensity;let viewZ;let markupMatrixCanvas;let markupMatrixFrameBuffer;let markupMatrix;let imagePositions;let maskTop;let maskRight;let maskBottom;let maskLeft;let maskOpacity;let maskBounds;let canvasColor=[0,0,0];//#region texture handling\n// offset +   0 : white\n// offset +   1 : transparent\n// offset +   2 : preview markup\n// offset +   3 : preview\n// offset + >=4 : markup\nconst TEXTURE_WHITE_INDEX=0;const TEXTURE_TRANSPARENT_INDEX=1;const TEXTURE_PREVIEW_MARKUP_INDEX=2;const TEXTURE_PREVIEW_INDEX=3;const TEXTURE_OFFSET=4;const textures=[];const setTextureObject=(index,texture,source=undefined)=>{const storedTexture=textures[index];if(storedTexture)gl.deleteTexture(storedTexture.texture);textures[index]={texture,source,textureAspectRatio:source?getAspectRatio(source.width,source.height):undefined};return index;};const getTextureSize=index=>{const source=textures[index].source;return source&&{width:source.width,height:source.height};};const getAvailableTextureIndex=()=>{const index=textures.findIndex(value=>value===undefined);return index<TEXTURE_OFFSET?textures.length:index;};const addTextureObject=(texture,source=undefined)=>setTextureObject(getAvailableTextureIndex(),texture,source);const addTexture=source=>addTextureObject(createTexture(gl,source),source);const setTexture=(index,source)=>{setTextureObject(index,createTexture(gl,source),source);};const reserveTexture=index=>{textures[index]={};};const removeTexture=index=>{const item=textures[index];gl.deleteTexture(item.texture);if(item.source instanceof HTMLCanvasElement)releaseCanvas(item.source);textures[index]=undefined;};//#endregion\n// resize view\nconst resize=(width,height,pixelDensity)=>{// density\nviewPixelDensity=pixelDensity;// visual size\nviewSizeVisual.width=width;viewSizeVisual.height=height;// size\nviewSize.width=width*pixelDensity;viewSize.height=height*pixelDensity;// calculate the aspect ratio, we use this to determine quad size\nviewAspectRatio=getAspectRatio(viewSize.width,viewSize.height);// sync dimensions with image data\ncanvas.width=viewSize.width;canvas.height=viewSize.height;// redefine matrices\nmarkupMatrixCanvas=mat4Create();mat4Ortho(markupMatrixCanvas,0,viewSize.width,viewSize.height,0,-1,1);markupMatrixFrameBuffer=mat4Create();const w=imageData.width*pixelDensity;const h=imageData.height*pixelDensity;mat4Ortho(markupMatrixFrameBuffer,0,w,h,0,-1,1);mat4Translate(markupMatrixFrameBuffer,0,h,0);mat4ScaleX(markupMatrixFrameBuffer,1);mat4ScaleY(markupMatrixFrameBuffer,-1);// update preview markup texture\ngl.bindTexture(gl.TEXTURE_2D,textures[TEXTURE_PREVIEW_MARKUP_INDEX].texture);gl.texImage2D(gl.TEXTURE_2D,0,gl.RGBA,imageData.width,imageData.height,0,gl.RGBA,gl.UNSIGNED_BYTE,null);// set the filtering, we don't need mips\ngl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_MIN_FILTER,gl.LINEAR);gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_WRAP_S,gl.CLAMP_TO_EDGE);gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_WRAP_T,gl.CLAMP_TO_EDGE);gl.bindFramebuffer(gl.FRAMEBUFFER,fb);gl.framebufferTexture2D(gl.FRAMEBUFFER,gl.COLOR_ATTACHMENT0,gl.TEXTURE_2D,textures[TEXTURE_PREVIEW_MARKUP_INDEX].texture,0);// update image texture\nconst imageWidth=imageSize.width*pixelDensity;const imageHeight=imageSize.height*pixelDensity;const l=imageWidth*-0.5;const t=imageHeight*0.5;const r=imageWidth*0.5;const b=imageHeight*-0.5;// prettier-ignore\n// B   D\n// | \\ |\n// A  C\nimagePositions=new Float32Array([l,b,0,l,t,0,r,b,0,r,t,0]);gl.bindBuffer(gl.ARRAY_BUFFER,imagePositionsBuffer);gl.bufferData(gl.ARRAY_BUFFER,imagePositions,gl.STATIC_DRAW);// move image backwards so it's presented in actual pixel size\nviewZ=// 1. we calculate the z offset required to have the\n//    image height match the view height\n/*        /|\n                     / |\n                    /  | height / 2\n                   /   |\n            f / 2 /__z_|\n                  \\    |\n                   \\   |\n                    \\  |\n                     \\ |\n                      \\|\n            */imageSize.height/2/FOV_TAN_HALF*(// 2. we want to render the image at the actual height, viewsize / height gets us results in a 1:1 presentation\nviewSize.height/imageSize.height)*// 3. z has to be negative, therefor multiply by -1\n-1;};// fov is fixed\nconst FOV=degToRad(30);const FOV_TAN_HALF=Math.tan(FOV/2);// get gl drawing context\nconst gl=getWebGLContext(canvas,{antialias:false,alpha:false,premultipliedAlpha:true});// no drawing context received, exit\nif(!gl)return;// enable derivatives\ngl.getExtension('OES_standard_derivatives');// toggle gl settings\ngl.disable(gl.DEPTH_TEST);// set blend mode, we need it for alpha blending\ngl.enable(gl.BLEND);/*\n    https://webglfundamentals.org/webgl/lessons/webgl-and-alpha.html\n    most if not all Canvas 2D implementations work with pre-multiplied alpha.\n    That means when you transfer them to WebGL and UNPACK_PREMULTIPLY_ALPHA_WEBGL\n    is false WebGL will convert them back to un-premultipiled.\n    With pre-multiplied alpha on, [1, .5, .5, 0] does not exist, it's always [0, 0, 0, 0]\n    */gl.blendFunc(gl.ONE,gl.ONE_MINUS_SRC_ALPHA);gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL,true);// something to look into:\n// gl.UNPACK_COLORSPACE_CONVERSION_WEBGL\n// create white base shape texture\nconst whiteTexture=gl.createTexture();gl.bindTexture(gl.TEXTURE_2D,whiteTexture);gl.texImage2D(gl.TEXTURE_2D,0,gl.RGBA,1,// width\n1,// height\n0,gl.RGBA,gl.UNSIGNED_BYTE,new Uint8Array([255,255,255,255])// white background\n);setTextureObject(TEXTURE_WHITE_INDEX,whiteTexture);const transparentTexture=gl.createTexture();gl.bindTexture(gl.TEXTURE_2D,transparentTexture);gl.texImage2D(gl.TEXTURE_2D,0,gl.RGBA,1,// width\n1,// height\n0,gl.RGBA,gl.UNSIGNED_BYTE,new Uint8Array([0,0,0,0])// transparent background\n);setTextureObject(TEXTURE_TRANSPARENT_INDEX,transparentTexture);// create image markup texture and framebuffer\nconst imageMarkupTexture=gl.createTexture();setTextureObject(TEXTURE_PREVIEW_MARKUP_INDEX,imageMarkupTexture);const fb=gl.createFramebuffer();// #region image\n// create preview texture\nsetTexture(TEXTURE_PREVIEW_INDEX,imageData);const imagePositionsBuffer=gl.createBuffer();const texturePositionsBuffer=gl.createBuffer();gl.bindBuffer(gl.ARRAY_BUFFER,texturePositionsBuffer);gl.bufferData(gl.ARRAY_BUFFER,rectUV,gl.STATIC_DRAW);// prettier-ignore\n// B   D\n// | \\ |\n// A  C\nconst imageCoordinateCount=4;// create default pixel drawing program, supports what we need\nconst previewShader=createShader(gl,previewVertexShader,previewFragmentShader,['aPosition','aTexCoord'],['uMatrix','uTexture','uTextureMarkup','uTextureSize','uColorGamma','uColorVignette','uColorOffset','uColorMatrix','uClarityKernel','uClarityKernelWeight','uOpacity','uMaskOpacity','uMaskBounds','uMaskCornerRadius','uMaskFeather','uFillColor','uOverlayColor']);// tell canvas context to use program\ngl.useProgram(previewShader.program);// transform vars\nlet matrix;const drawPreviewImage=(originX,originY,translateX,translateY,rotateX,rotateY,rotateZ,scale,colorMatrix,opacity=1,clarity,gamma=1,vignette=0,maskFeather=[1,0,1,0,1,viewSizeVisual.width,1,viewSizeVisual.width],maskCornerRadius=[0,0,0,0],imageBackgroundColor=[0,0,0,0],imageOverlayColor=[0,0,0,0],enableMarkup=true)=>{const{program,locations}=previewShader;// convert to pixel density\ntranslateX*=viewPixelDensity;translateY*=viewPixelDensity;originX*=viewPixelDensity;originY*=viewPixelDensity;// apply\nmatrix=mat4Create();mat4Perspective(matrix,FOV,viewAspectRatio,1,-viewZ*2);// move image\nmat4Translate(matrix,translateX,-translateY,viewZ);// set rotation origin in view\nmat4Translate(matrix,originX,-originY,0);// rotate image\nmat4RotateZ(matrix,-rotateZ);// resize\nmat4Scale(matrix,scale);// reset rotation origin\nmat4Translate(matrix,-originX,originY,0);// flip\nmat4RotateY(matrix,rotateY);mat4RotateX(matrix,rotateX);//\n// tell context to draw preview\n//\ngl.useProgram(program);gl.enableVertexAttribArray(locations.aPosition);gl.enableVertexAttribArray(locations.aTexCoord);// set up texture\nconst previewTexture=textures[TEXTURE_PREVIEW_INDEX];gl.uniform1i(locations.uTexture,TEXTURE_PREVIEW_INDEX);gl.uniform2f(locations.uTextureSize,imageData.width,imageData.height);gl.activeTexture(gl.TEXTURE0+TEXTURE_PREVIEW_INDEX);gl.bindTexture(gl.TEXTURE_2D,previewTexture.texture);// set up markup texture\nconst textureIndex=enableMarkup?TEXTURE_PREVIEW_MARKUP_INDEX:TEXTURE_TRANSPARENT_INDEX;const markupTexture=textures[textureIndex];gl.uniform1i(locations.uTextureMarkup,textureIndex);gl.activeTexture(gl.TEXTURE0+textureIndex);gl.bindTexture(gl.TEXTURE_2D,markupTexture.texture);// set up buffers\ngl.bindBuffer(gl.ARRAY_BUFFER,imagePositionsBuffer);gl.vertexAttribPointer(locations.aPosition,3,gl.FLOAT,false,0,0);gl.bindBuffer(gl.ARRAY_BUFFER,texturePositionsBuffer);gl.vertexAttribPointer(locations.aTexCoord,2,gl.FLOAT,false,0,0);// update matrix\ngl.uniformMatrix4fv(locations.uMatrix,false,matrix);// overlay color\ngl.uniform4fv(locations.uOverlayColor,imageOverlayColor);gl.uniform4fv(locations.uFillColor,imageBackgroundColor);// convolution\nlet clarityWeight;if(!clarity){clarity=[0,0,0,0,1,0,0,0,0];clarityWeight=-1;}else{clarityWeight=clarity.reduce((prev,curr)=>prev+curr,0);clarityWeight=clarityWeight<=0?1:clarityWeight;}gl.uniform1fv(locations.uClarityKernel,clarity);gl.uniform1f(locations.uClarityKernelWeight,clarityWeight);gl.uniform1f(locations.uColorGamma,1.0/gamma);gl.uniform1f(locations.uColorVignette,vignette);// set color matrix values\ngl.uniform4f(locations.uColorOffset,colorMatrix[4],colorMatrix[9],colorMatrix[14],colorMatrix[19]);gl.uniformMatrix4fv(locations.uColorMatrix,false,[colorMatrix[0],colorMatrix[1],colorMatrix[2],colorMatrix[3],colorMatrix[5],colorMatrix[6],colorMatrix[7],colorMatrix[8],colorMatrix[10],colorMatrix[11],colorMatrix[12],colorMatrix[13],colorMatrix[15],colorMatrix[16],colorMatrix[17],colorMatrix[18]]);// opacity level\ngl.uniform1f(locations.uOpacity,opacity);// mask\ngl.uniform1f(locations.uMaskOpacity,maskOpacity);gl.uniform1fv(locations.uMaskBounds,maskBounds);gl.uniform1fv(locations.uMaskCornerRadius,maskCornerRadius.map(v=>v*pixelDensity));gl.uniform1fv(locations.uMaskFeather,maskFeather.map((v,i)=>i%2===0?v:v*pixelDensity));gl.drawArrays(gl.TRIANGLE_STRIP,0,imageCoordinateCount);gl.disableVertexAttribArray(locations.aPosition);gl.disableVertexAttribArray(locations.aTexCoord);};//#endregion\n// #region path\nconst pathShader=createShader(gl,pathVertexShader,pathFragmentShader,['aPosition','aNormal','aMiter'],['uColor','uCanvasColor','uMatrix','uWidth','uMaskBounds','uMaskOpacity']);const pathBuffer=gl.createBuffer();const strokePath=(points,width,color,close)=>{const{program,locations}=pathShader;gl.useProgram(program);gl.enableVertexAttribArray(locations.aPosition);gl.enableVertexAttribArray(locations.aNormal);gl.enableVertexAttribArray(locations.aMiter);const vertices=createPathVertices(points,close);const stride=Float32Array.BYTES_PER_ELEMENT*5;const normalOffset=Float32Array.BYTES_PER_ELEMENT*2;// at position 2\nconst miterOffset=Float32Array.BYTES_PER_ELEMENT*4;// at position 4\ngl.uniform1f(locations.uWidth,width+2.0);gl.uniform4fv(locations.uColor,color);gl.uniformMatrix4fv(locations.uMatrix,false,markupMatrix);gl.uniform4f(locations.uCanvasColor,canvasColor[0],canvasColor[1],canvasColor[2],1);gl.uniform1fv(locations.uMaskBounds,maskBounds);gl.uniform1f(locations.uMaskOpacity,maskOpacity);gl.bindBuffer(gl.ARRAY_BUFFER,pathBuffer);gl.bufferData(gl.ARRAY_BUFFER,vertices,gl.STATIC_DRAW);gl.vertexAttribPointer(locations.aPosition,2,gl.FLOAT,false,stride,0);gl.vertexAttribPointer(locations.aNormal,2,gl.FLOAT,false,stride,normalOffset);gl.vertexAttribPointer(locations.aMiter,1,gl.FLOAT,false,stride,miterOffset);gl.drawArrays(gl.TRIANGLE_STRIP,0,vertices.length/5);gl.disableVertexAttribArray(locations.aPosition);gl.disableVertexAttribArray(locations.aNormal);gl.disableVertexAttribArray(locations.aMiter);};//#endregion\n// #region triangle\nconst triangleShader=createShader(gl,triangleVertexShader,triangleFragmentShader,['aPosition'],['uColor','uCanvasColor','uMatrix','uMaskBounds','uMaskOpacity']);const triangleBuffer=gl.createBuffer();const fillTriangle=(vertices,backgroundColor)=>{const{program,locations}=triangleShader;gl.useProgram(program);gl.enableVertexAttribArray(locations.aPosition);gl.uniform4fv(locations.uColor,backgroundColor);gl.uniformMatrix4fv(locations.uMatrix,false,markupMatrix);gl.uniform1fv(locations.uMaskBounds,maskBounds);gl.uniform1f(locations.uMaskOpacity,maskOpacity);gl.uniform4f(locations.uCanvasColor,canvasColor[0],canvasColor[1],canvasColor[2],1);gl.bindBuffer(gl.ARRAY_BUFFER,triangleBuffer);gl.bufferData(gl.ARRAY_BUFFER,vertices,gl.STATIC_DRAW);gl.vertexAttribPointer(locations.aPosition,2,gl.FLOAT,false,0,0);gl.drawArrays(gl.TRIANGLE_STRIP,0,vertices.length/2);gl.disableVertexAttribArray(locations.aPosition);return vertices;};//#endregion\n// #region rect\nconst rectShaderAttributes=['aPosition','aTexCoord','aRectCoord'];const rectShaderUniforms=['uTexture','uColor','uMatrix','uCanvasColor','uTextureColor','uTextureOpacity','uPosition','uSize','uMaskBounds','uMaskOpacity','uMaskFeather','uCornerRadius'];const rectShader=createShader(gl,rectVertexShader,rectFragmentShader,rectShaderAttributes,rectShaderUniforms);const rectBuffer=gl.createBuffer();const rectTextureBuffer=gl.createBuffer();const rectCornerBuffer=gl.createBuffer();const rectTextureColorFilter=[0,0,0,0];const fillRect=(vertices,width,height,cornerRadius,backgroundColor,backgroundImage,opacity=1.0,colorFilter=rectTextureColorFilter,uv=rectUV,maskFeather=[1,0,1,0,1,Math.max(viewSize.width,imageData.width),1,Math.max(viewSize.width,imageData.width)])=>{const{program,locations}=rectShader;gl.useProgram(program);gl.enableVertexAttribArray(locations.aPosition);gl.enableVertexAttribArray(locations.aTexCoord);gl.enableVertexAttribArray(locations.aRectCoord);gl.uniform4fv(locations.uColor,backgroundColor);gl.uniform4fv(locations.uTextureColor,colorFilter);gl.uniform1f(locations.uTextureOpacity,opacity);gl.uniform2fv(locations.uSize,[width,height]);gl.uniform2fv(locations.uPosition,[vertices[2],vertices[3]]);gl.uniform1fv(locations.uCornerRadius,cornerRadius);gl.uniform4f(locations.uCanvasColor,canvasColor[0],canvasColor[1],canvasColor[2],1);// mask\ngl.uniform1fv(locations.uMaskFeather,maskFeather.map((v,i)=>i%2===0?v:v*pixelDensity));gl.uniform1fv(locations.uMaskBounds,maskBounds);gl.uniform1f(locations.uMaskOpacity,maskOpacity);gl.uniformMatrix4fv(locations.uMatrix,false,markupMatrix);const textureIndex=textures[backgroundImage]&&textures[backgroundImage].texture?backgroundImage:TEXTURE_TRANSPARENT_INDEX;gl.uniform1i(locations.uTexture,textureIndex);gl.activeTexture(gl.TEXTURE0+textureIndex);gl.bindTexture(gl.TEXTURE_2D,textures[textureIndex].texture);gl.bindBuffer(gl.ARRAY_BUFFER,rectTextureBuffer);gl.bufferData(gl.ARRAY_BUFFER,uv,gl.STATIC_DRAW);gl.vertexAttribPointer(locations.aTexCoord,2,gl.FLOAT,false,0,0);// we use these coordinates combined with the size of the rect to interpolate and alias edges\ngl.bindBuffer(gl.ARRAY_BUFFER,rectCornerBuffer);gl.bufferData(gl.ARRAY_BUFFER,rectUV,gl.STATIC_DRAW);gl.vertexAttribPointer(locations.aRectCoord,2,gl.FLOAT,false,0,0);gl.bindBuffer(gl.ARRAY_BUFFER,rectBuffer);gl.bufferData(gl.ARRAY_BUFFER,vertices,gl.STATIC_DRAW);gl.vertexAttribPointer(locations.aPosition,2,gl.FLOAT,false,0,0);gl.drawArrays(gl.TRIANGLE_STRIP,0,vertices.length/2);gl.disableVertexAttribArray(locations.aPosition);gl.disableVertexAttribArray(locations.aTexCoord);gl.disableVertexAttribArray(locations.aRectCoord);return vertices;};//#endregion\n// #region ellipse\nconst ellipseShader=createShader(gl,ellipseVertexShader,ellipseFragmentShader,['aPosition','aTexCoord'],['uTexture','uTextureOpacity','uColor','uCanvasColor','uMatrix','uRadius','uInverted','uMaskBounds','uMaskOpacity']);const ellipseBuffer=gl.createBuffer();const ellipseTextureBuffer=gl.createBuffer();const fillEllipse=(vertices,width,height,backgroundColor,backgroundImage=TEXTURE_TRANSPARENT_INDEX,opacity=1.0,inverted=false)=>{const{program,locations}=ellipseShader;gl.useProgram(program);gl.enableVertexAttribArray(locations.aPosition);gl.enableVertexAttribArray(locations.aTexCoord);gl.uniform2fv(locations.uRadius,[width*0.5,height*0.5]);gl.uniform1i(locations.uInverted,inverted?1:0);gl.uniform4fv(locations.uColor,backgroundColor);gl.uniformMatrix4fv(locations.uMatrix,false,markupMatrix);gl.uniform4f(locations.uCanvasColor,canvasColor[0],canvasColor[1],canvasColor[2],1);gl.uniform1fv(locations.uMaskBounds,maskBounds);gl.uniform1f(locations.uMaskOpacity,maskOpacity);gl.uniform1i(locations.uTexture,backgroundImage);gl.uniform1f(locations.uTextureOpacity,opacity);gl.activeTexture(gl.TEXTURE0+backgroundImage);gl.bindTexture(gl.TEXTURE_2D,textures[backgroundImage].texture);gl.bindBuffer(gl.ARRAY_BUFFER,ellipseTextureBuffer);gl.bufferData(gl.ARRAY_BUFFER,rectUV,gl.STATIC_DRAW);gl.vertexAttribPointer(locations.aTexCoord,2,gl.FLOAT,false,0,0);gl.bindBuffer(gl.ARRAY_BUFFER,ellipseBuffer);gl.bufferData(gl.ARRAY_BUFFER,vertices,gl.STATIC_DRAW);gl.vertexAttribPointer(locations.aPosition,2,gl.FLOAT,false,0,0);gl.drawArrays(gl.TRIANGLE_STRIP,0,vertices.length/2);gl.disableVertexAttribArray(locations.aPosition);gl.disableVertexAttribArray(locations.aTexCoord);};//#endregion\n//\n// draw calls\n//\nconst drawPath=(points,strokeWidth,strokeColor,opacity)=>{// is no line\nif(points.length<2)return;strokePath(points.map(p=>({x:p.x*pixelDensity,y:p.y*pixelDensity})),strokeWidth*pixelDensity,applyOpacity(strokeColor,opacity),false);};const drawTriangle=(points,rotation=0,flipX=false,flipY=false,backgroundColor,opacity)=>{if(!backgroundColor)return;const clonedPoints=points.map(p=>({x:p.x*pixelDensity,y:p.y*pixelDensity}));const center=quadCentroid(clonedPoints);if(flipX||flipY)vectorsFlip(clonedPoints,flipX,flipY,center.x,center.y);vectorsRotate(clonedPoints,rotation,center.x,center.y);const vertices=trianglePointToVertices(clonedPoints);fillTriangle(vertices,applyOpacity(backgroundColor,opacity));};const getBackgroundUV=(width,height,backgroundSize,backgroundPosition)=>{if(!backgroundSize&&!backgroundPosition)return rectUV;let x=backgroundPosition.x/backgroundSize.width;let y=backgroundPosition.y/backgroundSize.height;let w=width/backgroundSize.width/pixelDensity;let h=height/backgroundSize.height/pixelDensity;w-=x;h-=y;// prettier-ignore\n// B   D\n// | \\ |\n// A  C\n// bottom left\nconst ax=-x;const ay=h;// top left\nconst bx=-x;const by=-y;// bottom right\nconst cx=w;const cy=h;// top right\nconst dx=w;const dy=-y;return new Float32Array([ax,ay,bx,by,cx,cy,dx,dy]);};const limitCornerRadius=(r,size)=>Math.floor(clamp(r,0,Math.min((size.width-1)*0.5,(size.height-1)*0.5)));const drawRect=(rect,rotation=0,flipX=false,flipY=false,cornerRadius,backgroundColor,backgroundImage,backgroundSize=undefined,backgroundPosition=undefined,strokeWidth,strokeColor,opacity,maskFeather=undefined,colorize)=>{// clone first\nlet rectOut=rectMultiply(rectClone(rect),pixelDensity);// has radius, doesn't matter for coordinates\nconst cornerRadiusOut=cornerRadius.map(r=>limitCornerRadius(r||0,rect)).map(r=>r*viewPixelDensity);// should fill\nif(backgroundColor||backgroundImage){// adjust for edge anti-aliasing, if we don't do this the\n// visible rectangle will be 1 pixel smaller than the actual rectangle\nconst rectFill=rectClone(rectOut);rectFill.x-=0.5;rectFill.y-=0.5;rectFill.width+=1.0;rectFill.height+=1.0;const points=createRectPoints(rectFill,rotation,flipX,flipY);const vertices=rectPointsToVertices(points);let color;if(colorize){color=applyOpacity(colorize);// as 0 transparancy is used to test if the colorize filter should be applied we set it to 0.001\nif(color[3]===0)color[3]=0.001;}fillRect(vertices,rectFill.width,rectFill.height,cornerRadiusOut,applyOpacity(backgroundColor,opacity),backgroundImage,opacity,color,getBackgroundUV(rectFill.width,rectFill.height,backgroundSize,backgroundPosition),maskFeather);}// should draw outline\nif(strokeWidth){// fixes issue where stroke would render weirdly\nstrokeWidth=Math.min(strokeWidth,rectOut.width,rectOut.height);strokePath(// rect out is already multiplied by pixel density\ncreateRectOutline(rectOut.x,rectOut.y,rectOut.width,rectOut.height,rotation,cornerRadiusOut,flipX,flipY),strokeWidth*pixelDensity,applyOpacity(strokeColor,opacity),true);}};const drawEllipse=(center,rx,ry,rotation,flipX,flipY,backgroundColor,backgroundImage,strokeWidth,strokeColor,opacity,inverted)=>{let rectOut=rectMultiply(rectCreate(center.x-rx,center.y-ry,rx*2,ry*2),pixelDensity);if(backgroundColor||backgroundImage){// adjust for edge anti-aliasing, if we don't do this the\n// visible rectangle will be 1 pixel smaller than the actual rectangle\nconst rectFill=rectClone(rectOut);rectFill.x-=0.5;rectFill.y-=0.5;rectFill.width+=1.0;rectFill.height+=1.0;const points=createRectPoints(rectFill,rotation,flipX,flipY);const vertices=rectPointsToVertices(points);fillEllipse(vertices,rectFill.width,rectFill.height,applyOpacity(backgroundColor,opacity),backgroundImage,opacity,inverted);}if(strokeWidth)strokePath(// rect out is already multiplied by pixeldensity\ncreateEllipseOutline(rectOut.x,rectOut.y,rectOut.width,rectOut.height,rotation,flipX,flipY),strokeWidth*pixelDensity,applyOpacity(strokeColor,opacity),true);};//#endregion\nreturn{// draw api\ndrawPath,drawTriangle,drawRect,drawEllipse,drawPreviewImage,setCanvasColor(color){canvasColor=color;},drawToCanvas(){gl.bindFramebuffer(gl.FRAMEBUFFER,null);// switch transform matrix\nmarkupMatrix=markupMatrixCanvas;// tell webgl about the viewport\ngl.viewport(0,0,gl.drawingBufferWidth,gl.drawingBufferHeight);// black (or other color depending on background)\ngl.colorMask(true,true,true,false);gl.clearColor(canvasColor[0],canvasColor[1],canvasColor[2],1);// gl.clearColor(0.25, 0.25, 0.25, 1); // for debugging\ngl.clear(gl.COLOR_BUFFER_BIT);},drawToFramebuffer(){// is twice as big as the loaded image\ngl.bindFramebuffer(gl.FRAMEBUFFER,fb);// switch transform matrix\nmarkupMatrix=markupMatrixFrameBuffer;// tell webgl about the \"viewport\"\ngl.viewport(0,0,imageData.width,imageData.height);// always transparent\ngl.colorMask(true,true,true,true);gl.clearColor(0,0,0,0);gl.clear(gl.COLOR_BUFFER_BIT);},// texture management\naddTexture,setTexture,reserveTexture,removeTexture,getTextureSize,getAvailableTextureIndex,// set mask\nenableMask(rect,opacity){const maskX=rect.x*viewPixelDensity;const maskY=rect.y*viewPixelDensity;const maskWidth=rect.width*viewPixelDensity;const maskHeight=rect.height*viewPixelDensity;maskLeft=maskX;maskRight=maskLeft+maskWidth;maskTop=viewSize.height-maskY;maskBottom=viewSize.height-(maskY+maskHeight);maskOpacity=1.0-opacity;maskBounds=[maskTop,maskRight,maskBottom,maskLeft];},disableMask(){maskLeft=0;maskRight=viewSize.width;maskTop=viewSize.height;maskBottom=0;maskOpacity=1;maskBounds=[maskTop,maskRight,maskBottom,maskLeft];},// canvas\nresize,release(){canvas.width=1;canvas.height=1;}};};/* src/core/ui/components/Canvas.svelte generated by Svelte v3.29.4 */function create_fragment(ctx){let div;let canvas_1;let measurable_action;let mounted;let dispose;return{c(){div=element(\"div\");canvas_1=element(\"canvas\");attr(div,\"class\",\"DokaCanvas\");},m(target,anchor){insert(target,div,anchor);append(div,canvas_1);/*canvas_1_binding*/ctx[15](canvas_1);if(!mounted){dispose=[listen(canvas_1,\"measure\",/*handleSizeChange*/ctx[4]),action_destroyer(measurable_action=measurable.call(null,canvas_1))];mounted=true;}},p:noop$1,i:noop$1,o:noop$1,d(detaching){if(detaching)detach(div);/*canvas_1_binding*/ctx[15](null);mounted=false;run_all(dispose);}};}function instance($$self,$$props,$$invalidate){let $imageMain;let $background;let $mask;const dispatch=createEventDispatcher();// fallback matrix\nconst COLOR_MATRIX_IDENTITY=[1,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,1,0];let{animate}=$$props;let{imageData}=$$props;let{imageSize}=$$props;let{imageProps}=$$props;let{imagePreviews=[]}=$$props;let{maskRect}=$$props;let{pixelRatio=1}=$$props;let{willRender=passthrough}=$$props;let{loadImageData=passthrough}=$$props;let{backgroundColor}=$$props;//\n// springyness for main preview\n//\nconst updateSpring=(spring,value)=>spring.set(value,{hard:!animate});const blendWithCanvasBackground=(back,front)=>{const[bR,bG,bB]=back;const[fR,fG,fB,fA]=front;return[fR*fA+bR*(1-fA),fG*fA+bG*(1-fA),fB*fA+bB*(1-fA),1];};const SPRING_PROPS={precision:0.0001};const SPRING_PROPS_FRACTION={precision:SPRING_PROPS.precision*0.01};const background=tweened(undefined,{duration:250});component_subscribe($$self,background,value=>$$invalidate(22,$background=value));const translation=spring(undefined,SPRING_PROPS);const rotation=spring(undefined,SPRING_PROPS_FRACTION);const origin=spring(undefined,SPRING_PROPS);const perspective=spring(undefined,SPRING_PROPS_FRACTION);const scale=spring(undefined,SPRING_PROPS_FRACTION);const gamma=spring(undefined,SPRING_PROPS_FRACTION);const vignette=spring(undefined,SPRING_PROPS_FRACTION);const colorMatrix=spring([...COLOR_MATRIX_IDENTITY],SPRING_PROPS);const clarity=writable(undefined);const opacity=spring(0,SPRING_PROPS_FRACTION);const maskOpacity=spring(1,SPRING_PROPS_FRACTION);const mask=writable();component_subscribe($$self,mask,value=>$$invalidate(24,$mask=value));const imageBackgroundColor=writable();const imageMain=derived([origin,translation,perspective,rotation,scale,opacity,colorMatrix,mask,maskOpacity,clarity,gamma,vignette,imageBackgroundColor,background],([$origin,$translation,$perspective,$rotation,$scale,$opacity,$colorMatrix,$mask,$maskOpacity,$clarity,$gamma,$vignette,$imageBackgroundColor,$background],set)=>{if(!imageProps||!$background)return set(undefined);const maskOpacityClamped=clamp($maskOpacity,0,1);set({origin:$origin,translation:$translation,perspective:$perspective,rotation:$rotation,scale:$scale,colorMatrix:$colorMatrix,opacity:clamp($opacity,0,1),clarity:$clarity,gamma:$gamma,vignette:$vignette,mask:$mask,maskOpacity:maskOpacityClamped,overlayColor:[$background[0],$background[1],$background[2],maskOpacityClamped],backgroundColor:$imageBackgroundColor});});component_subscribe($$self,imageMain,value=>$$invalidate(21,$imageMain=value));//\n// rendering\n//\nlet canvas;let webGLImageDrawer=null;let width=null;let height=null;const drawPreviewImage=({origin,translation,rotation,scale,colorMatrix,opacity,clarity,gamma,vignette,offset,maskFeather,maskCornerRadius,backgroundColor,overlayColor,enableShapes})=>{let tx=translation.x;let ty=translation.y;if(offset){tx+=offset.x-width*0.5;ty+=offset.y-height*0.5;}// calculate opaque backgroundColor if is background color is transparent and visible\nif(backgroundColor[3]<1&&backgroundColor[3]>0){backgroundColor=blendWithCanvasBackground($background,backgroundColor);}webGLImageDrawer.drawPreviewImage(origin.x,origin.y,tx,ty,rotation.x,rotation.y,rotation.z,scale,colorMatrix||COLOR_MATRIX_IDENTITY,opacity,clarity,gamma,vignette,maskFeather,maskCornerRadius,backgroundColor,overlayColor,enableShapes);};// shape texture cache\nconst TextureUnits=new Map([]);const getShapeImageTexture=({backgroundImage})=>{// get texture unit assigned to this image\nlet texture=TextureUnits.get(backgroundImage);// texture already available, we done\nif(texture)return texture;// reserve texture unit\ntexture=webGLImageDrawer.getAvailableTextureIndex();webGLImageDrawer.reserveTexture(texture);// this background is now available in this texture unit\nTextureUnits.set(backgroundImage,texture);// load the new background image data\nloadImageData(backgroundImage).then(imageData=>{// create new texture\nwebGLImageDrawer.setTexture(texture,imageData);// need to redraw because texture is now available\nrequestAnimationFrame(drawUpdate);}).catch(err=>{console.error(err);});return texture;};const TEXT_MEASURE_CONTEXT=createSimpleContext();const getShapeTextTexture=shape=>{let{text,textAlign,fontFamily,fontSize,fontWeight,fontVariant,fontStyle,lineHeight,width}=shape;// we need this context to correctly wrap text\nupdateTextContext(TEXT_MEASURE_CONTEXT,{fontSize,fontFamily,fontWeight,fontVariant,fontStyle,textAlign});// wrap the text\nconst textString=width?wrapText(TEXT_MEASURE_CONTEXT,text,width):text;// create UID for this texture so we can cache it and fetch it later on\nconst textUID=shapeTextUID(_objectSpread(_objectSpread({},shape),{},{text:textString}));// get texture unit assigned to this specific text shape\nlet texture=TextureUnits.get(textUID);if(texture)return texture;// we need to create a new texture\nconst ctx=createSimpleContext();updateTextContext(ctx,{fontSize,fontFamily,fontWeight,fontVariant,fontStyle,textAlign});// calculate canvas height\nresizeContextToFitText(ctx,textString,{fontSize,fontFamily,fontWeight,fontVariant,fontStyle,textAlign,lineHeight});const contextMinWidth=ctx.canvas.width;// scale context to account for italic styles\nctx.canvas.width+=textPadding;// context resized, we now need to re-apply style\nupdateTextContext(ctx,{fontSize,fontFamily,fontWeight,fontVariant,fontStyle,textAlign,color:[1,0,1]// color we'll replace in the shader\n});// if so, draw text and update texture\ndrawText(ctx,textString,{fontSize,textAlign,lineHeight,lineWidth:contextMinWidth});// TODO: Create power of 2 texture and update texture instead of delete -> replace\n// add this texture\ntexture=webGLImageDrawer.addTexture(ctx.canvas);// Store reference to the texture\nTextureUnits.set(textUID,texture);return texture;};const getShapeTexture=shape=>{let texture;// let's create textures for backgrounds and texts\nif(shape.backgroundImage){texture=getShapeImageTexture(shape);}else if(isString(shape.text)){if(shape.width&&shape.width<1||shape.height&&shape.height<1)return undefined;texture=getShapeTextTexture(shape);}return texture;};const drawShapes=(shapes=[])=>shapes.map(shape=>{let texture=getShapeTexture(shape);if(isArray(shape.points)){// is triangle\nif(shape.points.length===3&&shape.backgroundColor){webGLImageDrawer.drawTriangle(shape.points,shape.rotation,shape.flipX,shape.flipY,shape.backgroundColor,shape.strokeWidth,shape.strokeColor,shape.opacity);}else// is normal path\n{webGLImageDrawer.drawPath(shape.points,shape.strokeWidth,shape.strokeColor,shape.opacity);}}else// is ellipse \nif(isNumber(shape.rx)){webGLImageDrawer.drawEllipse(shape,shape.rx,shape.ry,shape.rotation,shape.flipX,shape.flipY,shape.backgroundColor,texture,shape.strokeWidth,shape.strokeColor,shape.opacity,shape.inverted);}else// is rect\nif(isString(shape.text)&&texture||shape.width){const textureSize=texture&&webGLImageDrawer.getTextureSize(texture);let colorize=undefined;let shapeRect;let shapeCornerRadius=[shape.cornerRadius,shape.cornerRadius,shape.cornerRadius,shape.cornerRadius];if(shape.width){shapeRect=shape;}else{shapeRect=_objectSpread({x:shape.x,y:shape.y},textureSize);}let backgroundSize;let backgroundPosition;if(textureSize){// background should be scaled\nif(shape.backgroundImage&&shape.backgroundSize){// always respect texture aspect ratio\nconst textureAspectRatio=getAspectRatio(textureSize.width,textureSize.height);// adjust position of background\nif(shape.backgroundSize===\"contain\"){const rect=rectContainRect(shape,textureAspectRatio,shapeRect);backgroundSize=sizeCreateFromRect(rect);backgroundPosition=vectorCreate((shape.width-backgroundSize.width)*0.5,(shape.height-backgroundSize.height)*0.5);}else if(shape.backgroundSize===\"cover\"){const rect=rectCoverRect(shape,textureAspectRatio,shapeRect);backgroundSize=sizeCreateFromRect(rect);backgroundPosition=vectorCreate(rect.x,rect.y);backgroundPosition=vectorCreate((shape.width-backgroundSize.width)*0.5,(shape.height-backgroundSize.height)*0.5);}}else// is text, \"background\" should be texture size and be positioned based on alignment\nif(shape.text&&shape.width){// position texture based on text alignment\nbackgroundSize=textureSize;backgroundPosition=vectorCreate(0,0);// auto height\nif(!shape.height)shape.height=textureSize.height;// textPadding so text doesn't clip on left and right edges\nshape.x-=textPadding;shape.width+=textPadding*2;if(shape.textAlign===\"left\"){backgroundPosition.x=textPadding;}if(shape.textAlign===\"center\"){backgroundPosition.x=textPadding*0.5+(shape.width-textureSize.width)*0.5;}if(shape.textAlign===\"right\"){backgroundPosition.x=shape.width-textureSize.width;}}else if(shape.text){backgroundPosition=vectorCreate(0,0);backgroundSize={width:shapeRect.width,height:shapeRect.height};// texture is slightly larger because of text padding, need to compensate for this in single line mode\nshapeRect.width-=textPadding;}if(shape.text)colorize=shape.color;}webGLImageDrawer.drawRect(shapeRect,shape.rotation,shape.flipX,shape.flipY,shapeCornerRadius,shape.backgroundColor,texture,backgroundSize,backgroundPosition,shape.strokeWidth,shape.strokeColor,shape.opacity,undefined,colorize);}return texture?[shape.id,texture]:undefined;}).filter(Boolean);// redraws state\nconst redraw=()=>{// allow dev to inject more shapes\nconst canvas=willRender({opacity:$imageMain.opacity,// opacity of main image, can be used to change opacity of other elements\nrotation:$imageMain.rotation,scale:$imageMain.scale,size:canvasSize,backgroundColor:[...$background]});canvas.backgroundColor=[...$background];canvas.image=$imageMain;canvas.imageMask=$imageMain.mask;canvas.imageMaskOpacity=$imageMain.maskOpacity;canvas.imagePreviews=imagePreviews;// no need to draw to framebuffer is no annotations\nconst hasAnnotations=canvas.annotationShapes.length>0;// if image has background color\nconst hasImageBackgroundColor=$imageMain.backgroundColor[3]>0;// if the overlay is transparent so we can see the canvas\nconst hasTransparentOverlay=$imageMain.maskOpacity<1;// array of textures used in this draw call\nconst usedTextures=[];// set canvas background color to image background color if is defined\nif(hasTransparentOverlay&&hasImageBackgroundColor){const backR=canvas.backgroundColor[0];const backG=canvas.backgroundColor[1];const backB=canvas.backgroundColor[2];const frontA=1-$imageMain.maskOpacity;const frontR=$imageMain.backgroundColor[0]*frontA;const frontG=$imageMain.backgroundColor[1]*frontA;const frontB=$imageMain.backgroundColor[2]*frontA;const fA=1-frontA;canvas.backgroundColor=[frontR+backR*fA,frontG+backG*fA,frontB+backB*fA,1];}webGLImageDrawer.setCanvasColor(canvas.backgroundColor);// if has annotations draw annotation shapes to framebuffer\n// TODO: only run this if annotations have changed\nif(hasAnnotations){webGLImageDrawer.disableMask();webGLImageDrawer.drawToFramebuffer();usedTextures.push(...drawShapes(canvas.annotationShapes));}// switch to canvas drawing for other elements\nwebGLImageDrawer.drawToCanvas();webGLImageDrawer.enableMask(canvas.imageMask,canvas.imageMaskOpacity);// draw a colored rectangle behind main preview image\nif(hasImageBackgroundColor){webGLImageDrawer.drawRect($mask,0,false,false,[0,0,0,0],blendWithCanvasBackground($background,$imageMain.backgroundColor));}// draw main preview image\ncanvas.image.enableShapes=hasAnnotations;drawPreviewImage(canvas.image);// TODO: move vignette here (draw with colorized circular gradient texture instead of in shader)\n// draw decorations shapes relative to crop\nusedTextures.push(...drawShapes(canvas.decorationShapes));// crop mask not used for interface\nwebGLImageDrawer.disableMask();// draw custom interface shapes\nusedTextures.push(...drawShapes(canvas.interfaceShapes));canvas.imagePreviews.forEach(image=>{webGLImageDrawer.enableMask(image.mask,image.maskOpacity);// draw background fill\nif(hasImageBackgroundColor){webGLImageDrawer.drawRect(image.mask,0,false,false,image.maskCornerRadius,$imageMain.backgroundColor,undefined,undefined,undefined,undefined,undefined,image.opacity,image.maskFeather);}drawPreviewImage(_objectSpread(_objectSpread({},image),{},{backgroundColor:$imageMain.backgroundColor,overlayColor:[0,0,0,0],enableShapes:false}));});webGLImageDrawer.disableMask();// determine which textures can be dropped\nTextureUnits.forEach((registeredTextureUnit,key,map)=>{const isUsed=!!usedTextures.find(([id,usedTextureUnit])=>usedTextureUnit===registeredTextureUnit);// stil used, no need to release\nif(isUsed)return;// remove this texture\nTextureUnits.delete(key);webGLImageDrawer.removeTexture(registeredTextureUnit);});};//\n// events\n//\n// auto update when size changes\nconst handleSizeChange=e=>{$$invalidate(17,width=e.detail.width);$$invalidate(18,height=e.detail.height);dispatch(\"measure\",{width,height});};//\n// hooks\n//\n// after DOM has been altered, draw to canvas\nafterUpdate(()=>drawUpdate());// hook up canvas and image\nonMount(()=>$$invalidate(16,webGLImageDrawer=createGLImageDrawer(canvas,imageData,imageSize,pixelRatio)));// clean up canvas\nonDestroy(()=>{// if canvas wasn't created we don't need to release it\nif(!webGLImageDrawer)return;// done drawing\nwebGLImageDrawer.release();// force release canvas for Safari\nreleaseCanvas(TEXT_MEASURE_CONTEXT.canvas);});function canvas_1_binding($$value){binding_callbacks[$$value?\"unshift\":\"push\"](()=>{canvas=$$value;$$invalidate(0,canvas);});}$$self.$$set=$$props=>{if(\"animate\"in $$props)$$invalidate(5,animate=$$props.animate);if(\"imageData\"in $$props)$$invalidate(6,imageData=$$props.imageData);if(\"imageSize\"in $$props)$$invalidate(7,imageSize=$$props.imageSize);if(\"imageProps\"in $$props)$$invalidate(8,imageProps=$$props.imageProps);if(\"imagePreviews\"in $$props)$$invalidate(9,imagePreviews=$$props.imagePreviews);if(\"maskRect\"in $$props)$$invalidate(10,maskRect=$$props.maskRect);if(\"pixelRatio\"in $$props)$$invalidate(11,pixelRatio=$$props.pixelRatio);if(\"willRender\"in $$props)$$invalidate(12,willRender=$$props.willRender);if(\"loadImageData\"in $$props)$$invalidate(13,loadImageData=$$props.loadImageData);if(\"backgroundColor\"in $$props)$$invalidate(14,backgroundColor=$$props.backgroundColor);};let canvasSize;let canDraw;let drawUpdate;$$self.$$.update=()=>{if($$self.$$.dirty[0]&/*backgroundColor*/16384){// canvas style\nbackgroundColor&&updateSpring(background,backgroundColor);}if($$self.$$.dirty[0]&/*imageProps*/256){// image transforms\nimageProps&&updateSpring(origin,imageProps.origin);}if($$self.$$.dirty[0]&/*imageProps*/256){imageProps&&updateSpring(translation,imageProps.translation);}if($$self.$$.dirty[0]&/*imageProps*/256){imageProps&&updateSpring(perspective,imageProps.perspective);}if($$self.$$.dirty[0]&/*imageProps*/256){imageProps&&updateSpring(rotation,imageProps.rotation);}if($$self.$$.dirty[0]&/*imageProps*/256){imageProps&&updateSpring(scale,imageProps.scale);}if($$self.$$.dirty[0]&/*imageProps*/256){imageProps&&updateSpring(colorMatrix,imageProps.colorMatrix||[...COLOR_MATRIX_IDENTITY]);}if($$self.$$.dirty[0]&/*imageProps*/256){imageProps&&updateSpring(vignette,imageProps.vignette||0);}if($$self.$$.dirty[0]&/*imageProps*/256){imageProps&&updateSpring(gamma,imageProps.gamma||1);}if($$self.$$.dirty[0]&/*imageProps*/256){imageProps&&clarity.set(imageProps.convolutionMatrix&&imageProps.convolutionMatrix.clarity||undefined);}if($$self.$$.dirty[0]&/*imageProps*/256){// image ui style\nimageProps&&updateSpring(opacity,1);}if($$self.$$.dirty[0]&/*imageProps*/256){imageProps&&updateSpring(maskOpacity,isNumber(imageProps.maskOpacity)?imageProps.maskOpacity:1);}if($$self.$$.dirty[0]&/*maskRect*/1024){maskRect&&mask.set(maskRect);}if($$self.$$.dirty[0]&/*imageProps*/256){imageProps&&imageBackgroundColor.set(imageProps.backgroundColor);}if($$self.$$.dirty[0]&/*width, height*/393216){// canvas size\ncanvasSize={width,height};}if($$self.$$.dirty[0]&/*webGLImageDrawer, width, height, $imageMain*/2555904){// can draw view\n$$invalidate(20,canDraw=webGLImageDrawer&&width&&height&&$imageMain);}if($$self.$$.dirty[0]&/*width, height, webGLImageDrawer, pixelRatio*/460800){// observe width and height changes and resize the canvas proportionally\nwidth&&height&&webGLImageDrawer&&webGLImageDrawer.resize(width,height,pixelRatio);}if($$self.$$.dirty[0]&/*canDraw*/1048576){// switch to draw method when can draw\ndrawUpdate=canDraw?redraw:noop;}};return[canvas,background,mask,imageMain,handleSizeChange,animate,imageData,imageSize,imageProps,imagePreviews,maskRect,pixelRatio,willRender,loadImageData,backgroundColor,canvas_1_binding];}class Canvas extends SvelteComponent{constructor(options){super();init(this,options,instance,create_fragment,safe_not_equal,{animate:5,imageData:6,imageSize:7,imageProps:8,imagePreviews:9,maskRect:10,pixelRatio:11,willRender:12,loadImageData:13,backgroundColor:14},[-1,-1]);}}var arrayJoin=(arr,filter=Boolean,str=' ')=>arr.filter(filter).join(str);/* src/core/ui/components/TabList.svelte generated by Svelte v3.29.4 */const get_default_slot_changes=dirty=>({tab:dirty&/*tabNodes*/8});const get_default_slot_context=ctx=>({tab:/*tab*/ctx[16]});function get_each_context(ctx,list,i){const child_ctx=ctx.slice();child_ctx[16]=list[i];return child_ctx;}// (72:4) {#each tabNodes as tab (tab.id) }\nfunction create_each_block(key_1,ctx){let li;let button;let button_aria_controls_value;let button_id_value;let button_aria_selected_value;let button_disabled_value;let t;let current;let mounted;let dispose;const default_slot_template=/*#slots*/ctx[10].default;const default_slot=create_slot(default_slot_template,ctx,/*$$scope*/ctx[9],get_default_slot_context);function keydown_handler(...args){return(/*keydown_handler*/ctx[11](/*tab*/ctx[16],...args));}function click_handler(...args){return(/*click_handler*/ctx[12](/*tab*/ctx[16],...args));}return{key:key_1,first:null,c(){li=element(\"li\");button=element(\"button\");if(default_slot)default_slot.c();t=space();attr(button,\"role\",\"tab\");attr(button,\"aria-controls\",button_aria_controls_value=/*tab*/ctx[16].href);attr(button,\"id\",button_id_value=/*tab*/ctx[16].tabId);attr(button,\"aria-selected\",button_aria_selected_value=/*tab*/ctx[16].selected);button.disabled=button_disabled_value=/*tab*/ctx[16].disabled;this.first=li;},m(target,anchor){insert(target,li,anchor);append(li,button);if(default_slot){default_slot.m(button,null);}append(li,t);current=true;if(!mounted){dispose=[listen(button,\"keydown\",keydown_handler),listen(button,\"click\",click_handler)];mounted=true;}},p(new_ctx,dirty){ctx=new_ctx;if(default_slot){if(default_slot.p&&dirty&/*$$scope, tabNodes*/520){update_slot(default_slot,default_slot_template,ctx,/*$$scope*/ctx[9],dirty,get_default_slot_changes,get_default_slot_context);}}if(!current||dirty&/*tabNodes*/8&&button_aria_controls_value!==(button_aria_controls_value=/*tab*/ctx[16].href)){attr(button,\"aria-controls\",button_aria_controls_value);}if(!current||dirty&/*tabNodes*/8&&button_id_value!==(button_id_value=/*tab*/ctx[16].tabId)){attr(button,\"id\",button_id_value);}if(!current||dirty&/*tabNodes*/8&&button_aria_selected_value!==(button_aria_selected_value=/*tab*/ctx[16].selected)){attr(button,\"aria-selected\",button_aria_selected_value);}if(!current||dirty&/*tabNodes*/8&&button_disabled_value!==(button_disabled_value=/*tab*/ctx[16].disabled)){button.disabled=button_disabled_value;}},i(local){if(current)return;transition_in(default_slot,local);current=true;},o(local){transition_out(default_slot,local);current=false;},d(detaching){if(detaching)detach(li);if(default_slot)default_slot.d(detaching);mounted=false;run_all(dispose);}};}function create_fragment$1(ctx){let ul;let each_blocks=[];let each_1_lookup=new Map();let ul_class_value;let current;let each_value=/*tabNodes*/ctx[3];const get_key=ctx=>/*tab*/ctx[16].id;for(let i=0;i<each_value.length;i+=1){let child_ctx=get_each_context(ctx,each_value,i);let key=get_key(child_ctx);each_1_lookup.set(key,each_blocks[i]=create_each_block(key,child_ctx));}return{c(){ul=element(\"ul\");for(let i=0;i<each_blocks.length;i+=1){each_blocks[i].c();}attr(ul,\"class\",ul_class_value=arrayJoin([\"DokaTabList\",/*klass*/ctx[0]]));attr(ul,\"role\",\"tablist\");attr(ul,\"data-layout\",/*layout*/ctx[1]);},m(target,anchor){insert(target,ul,anchor);for(let i=0;i<each_blocks.length;i+=1){each_blocks[i].m(ul,null);}/*ul_binding*/ctx[13](ul);current=true;},p(ctx,[dirty]){if(dirty&/*tabNodes, handleKeyTab, handleClickTab, $$scope*/568){const each_value=/*tabNodes*/ctx[3];group_outros();each_blocks=update_keyed_each(each_blocks,dirty,get_key,1,ctx,each_value,each_1_lookup,ul,outro_and_destroy_block,create_each_block,null,get_each_context);check_outros();}if(!current||dirty&/*klass*/1&&ul_class_value!==(ul_class_value=arrayJoin([\"DokaTabList\",/*klass*/ctx[0]]))){attr(ul,\"class\",ul_class_value);}if(!current||dirty&/*layout*/2){attr(ul,\"data-layout\",/*layout*/ctx[1]);}},i(local){if(current)return;for(let i=0;i<each_value.length;i+=1){transition_in(each_blocks[i]);}current=true;},o(local){for(let i=0;i<each_blocks.length;i+=1){transition_out(each_blocks[i]);}current=false;},d(detaching){if(detaching)detach(ul);for(let i=0;i<each_blocks.length;i+=1){each_blocks[i].d();}/*ul_binding*/ctx[13](null);}};}function instance$1($$self,$$props,$$invalidate){let{$$slots:slots={},$$scope}=$$props;let root;let{class:klass=undefined}=$$props;let{name}=$$props;let{selected}=$$props;let{tabs=[]}=$$props;let{layout=undefined}=$$props;const dispatch=createEventDispatcher();const focusTab=index=>{const tab=root.querySelectorAll(\"button[role=\\\"tab\\\"]\")[index];if(!tab)return;tab.focus();};const handleClickTab=(e,id)=>{e.preventDefault();e.stopPropagation();dispatch(\"select\",id);};const handleKeyTab=({key},id)=>{if(!/arrow/i.test(key))return;const index=tabs.findIndex(tab=>tab.id===id);// next\nif(/right|down/i.test(key))return focusTab(index<tabs.length-1?index+1:0);// prev\nif(/left|up/i.test(key))return focusTab(index>0?index-1:tabs.length-1);};const keydown_handler=(tab,e)=>handleKeyTab(e,tab.id);const click_handler=(tab,e)=>handleClickTab(e,tab.id);function ul_binding($$value){binding_callbacks[$$value?\"unshift\":\"push\"](()=>{root=$$value;$$invalidate(2,root);});}$$self.$$set=$$props=>{if(\"class\"in $$props)$$invalidate(0,klass=$$props.class);if(\"name\"in $$props)$$invalidate(6,name=$$props.name);if(\"selected\"in $$props)$$invalidate(7,selected=$$props.selected);if(\"tabs\"in $$props)$$invalidate(8,tabs=$$props.tabs);if(\"layout\"in $$props)$$invalidate(1,layout=$$props.layout);if(\"$$scope\"in $$props)$$invalidate(9,$$scope=$$props.$$scope);};let tabNodes;$$self.$$.update=()=>{if($$self.$$.dirty&/*tabs, selected, name*/448){$$invalidate(3,tabNodes=tabs.map(tab=>{const isActive=tab.id===selected;return _objectSpread(_objectSpread({},tab),{},{tabId:`doka-tab-${name}-${tab.id}`,href:`#doka-${name}-${tab.id}`,selected:isActive});}));}};return[klass,layout,root,tabNodes,handleClickTab,handleKeyTab,name,selected,tabs,$$scope,slots,keydown_handler,click_handler,ul_binding];}class TabList extends SvelteComponent{constructor(options){super();init(this,options,instance$1,create_fragment$1,safe_not_equal,{class:0,name:6,selected:7,tabs:8,layout:1});}}/* src/core/ui/components/TabPanels.svelte generated by Svelte v3.29.4 */const get_default_slot_changes$1=dirty=>({panel:dirty&/*panelNodes*/16,panelIsActive:dirty&/*panelNodes*/16});const get_default_slot_context$1=ctx=>({panel:/*id*/ctx[11],panelIsActive:!/*hidden*/ctx[15]});function get_each_context$1(ctx,list,i){const child_ctx=ctx.slice();child_ctx[11]=list[i].id;child_ctx[12]=list[i].panelId;child_ctx[13]=list[i].tabindex;child_ctx[14]=list[i].labelledBy;child_ctx[15]=list[i].hidden;child_ctx[3]=list[i].visible;return child_ctx;}// (61:4) {#each panelNodes as { id, panelId, tabindex, labelledBy, hidden, visible }\nfunction create_each_block$1(key_1,ctx){let div;let t;let div_class_value;let div_hidden_value;let div_id_value;let div_tabindex_value;let div_aria_labelledby_value;let div_data_inert_value;let current;const default_slot_template=/*#slots*/ctx[9].default;const default_slot=create_slot(default_slot_template,ctx,/*$$scope*/ctx[8],get_default_slot_context$1);return{key:key_1,first:null,c(){div=element(\"div\");if(default_slot)default_slot.c();t=space();attr(div,\"class\",div_class_value=arrayJoin([\"DokaTabPanel\",/*panelClass*/ctx[1]]));div.hidden=div_hidden_value=/*hidden*/ctx[15];attr(div,\"id\",div_id_value=/*panelId*/ctx[12]);attr(div,\"tabindex\",div_tabindex_value=/*tabindex*/ctx[13]);attr(div,\"aria-labelledby\",div_aria_labelledby_value=/*labelledBy*/ctx[14]);attr(div,\"data-inert\",div_data_inert_value=!/*visible*/ctx[3]);this.first=div;},m(target,anchor){insert(target,div,anchor);if(default_slot){default_slot.m(div,null);}append(div,t);current=true;},p(ctx,dirty){if(default_slot){if(default_slot.p&&dirty&/*$$scope, panelNodes*/272){update_slot(default_slot,default_slot_template,ctx,/*$$scope*/ctx[8],dirty,get_default_slot_changes$1,get_default_slot_context$1);}}if(!current||dirty&/*panelClass*/2&&div_class_value!==(div_class_value=arrayJoin([\"DokaTabPanel\",/*panelClass*/ctx[1]]))){attr(div,\"class\",div_class_value);}if(!current||dirty&/*panelNodes*/16&&div_hidden_value!==(div_hidden_value=/*hidden*/ctx[15])){div.hidden=div_hidden_value;}if(!current||dirty&/*panelNodes*/16&&div_id_value!==(div_id_value=/*panelId*/ctx[12])){attr(div,\"id\",div_id_value);}if(!current||dirty&/*panelNodes*/16&&div_tabindex_value!==(div_tabindex_value=/*tabindex*/ctx[13])){attr(div,\"tabindex\",div_tabindex_value);}if(!current||dirty&/*panelNodes*/16&&div_aria_labelledby_value!==(div_aria_labelledby_value=/*labelledBy*/ctx[14])){attr(div,\"aria-labelledby\",div_aria_labelledby_value);}if(!current||dirty&/*panelNodes*/16&&div_data_inert_value!==(div_data_inert_value=!/*visible*/ctx[3])){attr(div,\"data-inert\",div_data_inert_value);}},i(local){if(current)return;transition_in(default_slot,local);current=true;},o(local){transition_out(default_slot,local);current=false;},d(detaching){if(detaching)detach(div);if(default_slot)default_slot.d(detaching);}};}function create_fragment$2(ctx){let div;let each_blocks=[];let each_1_lookup=new Map();let div_class_value;let measurable_action;let current;let mounted;let dispose;let each_value=/*panelNodes*/ctx[4];const get_key=ctx=>/*id*/ctx[11];for(let i=0;i<each_value.length;i+=1){let child_ctx=get_each_context$1(ctx,each_value,i);let key=get_key(child_ctx);each_1_lookup.set(key,each_blocks[i]=create_each_block$1(key,child_ctx));}return{c(){div=element(\"div\");for(let i=0;i<each_blocks.length;i+=1){each_blocks[i].c();}attr(div,\"class\",div_class_value=arrayJoin([\"DokaTabPanels\",/*klass*/ctx[0]]));attr(div,\"style\",/*style*/ctx[2]);},m(target,anchor){insert(target,div,anchor);for(let i=0;i<each_blocks.length;i+=1){each_blocks[i].m(div,null);}current=true;if(!mounted){dispose=[listen(div,\"measure\",/*measure_handler*/ctx[10]),action_destroyer(measurable_action=measurable.call(null,div))];mounted=true;}},p(ctx,[dirty]){if(dirty&/*arrayJoin, panelClass, panelNodes, $$scope*/274){const each_value=/*panelNodes*/ctx[4];group_outros();each_blocks=update_keyed_each(each_blocks,dirty,get_key,1,ctx,each_value,each_1_lookup,div,outro_and_destroy_block,create_each_block$1,null,get_each_context$1);check_outros();}if(!current||dirty&/*klass*/1&&div_class_value!==(div_class_value=arrayJoin([\"DokaTabPanels\",/*klass*/ctx[0]]))){attr(div,\"class\",div_class_value);}if(!current||dirty&/*style*/4){attr(div,\"style\",/*style*/ctx[2]);}},i(local){if(current)return;for(let i=0;i<each_value.length;i+=1){transition_in(each_blocks[i]);}current=true;},o(local){for(let i=0;i<each_blocks.length;i+=1){transition_out(each_blocks[i]);}current=false;},d(detaching){if(detaching)detach(div);for(let i=0;i<each_blocks.length;i+=1){each_blocks[i].d();}mounted=false;run_all(dispose);}};}function instance$2($$self,$$props,$$invalidate){let{$$slots:slots={},$$scope}=$$props;let{class:klass=undefined}=$$props;let{name}=$$props;let{selected}=$$props;let{visible=undefined}=$$props;let{panelClass=undefined}=$$props;let{panels=[]}=$$props;let{style=undefined}=$$props;function measure_handler(event){bubble($$self,event);}$$self.$$set=$$props=>{if(\"class\"in $$props)$$invalidate(0,klass=$$props.class);if(\"name\"in $$props)$$invalidate(5,name=$$props.name);if(\"selected\"in $$props)$$invalidate(6,selected=$$props.selected);if(\"visible\"in $$props)$$invalidate(3,visible=$$props.visible);if(\"panelClass\"in $$props)$$invalidate(1,panelClass=$$props.panelClass);if(\"panels\"in $$props)$$invalidate(7,panels=$$props.panels);if(\"style\"in $$props)$$invalidate(2,style=$$props.style);if(\"$$scope\"in $$props)$$invalidate(8,$$scope=$$props.$$scope);};let panelNodes;$$self.$$.update=()=>{if($$self.$$.dirty&/*panels, selected, visible, name*/232){$$invalidate(4,panelNodes=panels.map(id=>{const isActive=id===selected;const isVisible=visible?visible.indexOf(id)!==-1:true;return{id,panelId:`doka-${name}_${id}`,labelledBy:`doka-tab-${name}_${id}`,hidden:!isActive,visible:isVisible,tabindex:isActive?0:-1};}));}};return[klass,panelClass,style,visible,panelNodes,name,selected,panels,$$scope,slots,measure_handler];}class TabPanels extends SvelteComponent{constructor(options){super();init(this,options,instance$2,create_fragment$2,safe_not_equal,{class:0,name:5,selected:6,visible:3,panelClass:1,panels:7,style:2});}}/* src/core/ui/components/Panel.svelte generated by Svelte v3.29.4 */function create_fragment$3(ctx){let div;let switch_instance;let updating_name;let div_class_value;let current;const switch_instance_spread_levels=[/*componentProps*/ctx[7]];function switch_instance_name_binding(value){/*switch_instance_name_binding*/ctx[17].call(null,value);}var switch_value=/*componentView*/ctx[11];function switch_props(ctx){let switch_instance_props={};for(let i=0;i<switch_instance_spread_levels.length;i+=1){switch_instance_props=assign(switch_instance_props,switch_instance_spread_levels[i]);}if(/*panelName*/ctx[3]!==void 0){switch_instance_props.name=/*panelName*/ctx[3];}return{props:switch_instance_props};}if(switch_value){switch_instance=new switch_value(switch_props(ctx));binding_callbacks.push(()=>bind(switch_instance,\"name\",switch_instance_name_binding));/*switch_instance_binding*/ctx[18](switch_instance);switch_instance.$on(\"measure\",/*measure_handler*/ctx[19]);}return{c(){div=element(\"div\");if(switch_instance)create_component(switch_instance.$$.fragment);attr(div,\"data-util\",/*panelName*/ctx[3]);attr(div,\"class\",div_class_value=arrayJoin([\"DokaPanel\",/*klass*/ctx[1]]));attr(div,\"style\",/*style*/ctx[6]);},m(target,anchor){insert(target,div,anchor);if(switch_instance){mount_component(switch_instance,div,null);}current=true;},p(ctx,[dirty]){const switch_instance_changes=dirty&/*componentProps*/128?get_spread_update(switch_instance_spread_levels,[get_spread_object(/*componentProps*/ctx[7])]):{};if(!updating_name&&dirty&/*panelName*/8){updating_name=true;switch_instance_changes.name=/*panelName*/ctx[3];add_flush_callback(()=>updating_name=false);}if(switch_value!==(switch_value=/*componentView*/ctx[11])){if(switch_instance){group_outros();const old_component=switch_instance;transition_out(old_component.$$.fragment,1,0,()=>{destroy_component(old_component,1);});check_outros();}if(switch_value){switch_instance=new switch_value(switch_props(ctx));binding_callbacks.push(()=>bind(switch_instance,\"name\",switch_instance_name_binding));/*switch_instance_binding*/ctx[18](switch_instance);switch_instance.$on(\"measure\",/*measure_handler*/ctx[19]);create_component(switch_instance.$$.fragment);transition_in(switch_instance.$$.fragment,1);mount_component(switch_instance,div,null);}else{switch_instance=null;}}else if(switch_value){switch_instance.$set(switch_instance_changes);}if(!current||dirty&/*panelName*/8){attr(div,\"data-util\",/*panelName*/ctx[3]);}if(!current||dirty&/*klass*/2&&div_class_value!==(div_class_value=arrayJoin([\"DokaPanel\",/*klass*/ctx[1]]))){attr(div,\"class\",div_class_value);}if(!current||dirty&/*style*/64){attr(div,\"style\",/*style*/ctx[6]);}},i(local){if(current)return;if(switch_instance)transition_in(switch_instance.$$.fragment,local);current=true;},o(local){if(switch_instance)transition_out(switch_instance.$$.fragment,local);current=false;},d(detaching){if(detaching)detach(div);/*switch_instance_binding*/ctx[18](null);if(switch_instance)destroy_component(switch_instance);}};}function instance$3($$self,$$props,$$invalidate){let $opacityClamped;let $isActivePrivateStore;const dispatch=createEventDispatcher();let{isActive=true}=$$props;let{stores}=$$props;let{content}=$$props;let{component}=$$props;let{locale}=$$props;let{class:klass=undefined}=$$props;// we remember the view rect in this variable\nlet rect;const opacity=spring(0);const opacityClamped=derived(opacity,$opacity=>clamp($opacity,0,1));component_subscribe($$self,opacityClamped,value=>$$invalidate(22,$opacityClamped=value));// throw hide / show events\nlet isHidden=!isActive;// create active store so can be used in derived stores\nconst isActivePrivateStore=writable(isActive);component_subscribe($$self,isActivePrivateStore,value=>$$invalidate(23,$isActivePrivateStore=value));const stateProps={isActive:derived(isActivePrivateStore,$isActivePrivateStore=>$isActivePrivateStore),isActiveFraction:derived(opacityClamped,$opacityClamped=>$opacityClamped),isVisible:derived(opacityClamped,$opacityClamped=>$opacityClamped>0)};// build the component props\nconst componentView=content.view;const componentExportedProps=getComponentExportedProps(componentView);const componentComputedProps=Object.keys(content.props||{}).reduce((computedProps,key)=>{if(!componentExportedProps.includes(key))return computedProps;computedProps[key]=content.props[key];return computedProps;},{});const componentComputedStateProps=Object.keys(stateProps).reduce((computedStateProps,key)=>{if(!componentExportedProps.includes(key))return computedStateProps;computedStateProps[key]=stateProps[key];return computedStateProps;},{});// class used on panel element\nlet panelName;// we use the `hasBeenMounted` bool to block rect updates until the entire panel is ready\nlet hasBeenMounted=false;let preMountRect;let mountRectTimeout;onMount(()=>{$$invalidate(4,hasBeenMounted=true);// this fixes a weird issue where the measure event isn't fired \n// when no components active in subview\nclearTimeout(mountRectTimeout);mountRectTimeout=setTimeout(()=>{if(rect||!preMountRect)return;dispatch(\"measure\",_objectSpread({},preMountRect));},0);});function switch_instance_name_binding(value){panelName=value;$$invalidate(3,panelName);}function switch_instance_binding($$value){binding_callbacks[$$value?\"unshift\":\"push\"](()=>{component=$$value;$$invalidate(0,component);});}const measure_handler=e=>{$$invalidate(5,preMountRect=_objectSpread({},e.detail));if(!hasBeenMounted)return;$$invalidate(2,rect=e.detail);dispatch(\"measure\",_objectSpread({},rect));};$$self.$$set=$$props=>{if(\"isActive\"in $$props)$$invalidate(12,isActive=$$props.isActive);if(\"stores\"in $$props)$$invalidate(13,stores=$$props.stores);if(\"content\"in $$props)$$invalidate(14,content=$$props.content);if(\"component\"in $$props)$$invalidate(0,component=$$props.component);if(\"locale\"in $$props)$$invalidate(15,locale=$$props.locale);if(\"class\"in $$props)$$invalidate(1,klass=$$props.class);};let style;let componentProps;$$self.$$.update=()=>{if($$self.$$.dirty&/*rect, isActive, component*/4101){// when the view rect changes and the panel is in active state or became active, dispatch measure event\nif(rect&&isActive&&component)dispatch(\"measure\",rect);}if($$self.$$.dirty&/*isActive*/4096){opacity.set(isActive?1:0);}if($$self.$$.dirty&/*$opacityClamped, isHidden*/5242880){if($opacityClamped<=0&&!isHidden){$$invalidate(20,isHidden=true);dispatch(\"hide\");}else if($opacityClamped>0&&isHidden){$$invalidate(20,isHidden=false);dispatch(\"show\");}}if($$self.$$.dirty&/*$opacityClamped*/4194304){dispatch(\"fade\",$opacityClamped);}if($$self.$$.dirty&/*$opacityClamped*/4194304){// only set opacity prop if is below 0\n$$invalidate(6,style=$opacityClamped<1?`opacity: ${$opacityClamped}`:undefined);}if($$self.$$.dirty&/*isActive*/4096){set_store_value(isActivePrivateStore,$isActivePrivateStore=isActive,$isActivePrivateStore);}if($$self.$$.dirty&/*stores, locale*/40960){$$invalidate(7,componentProps=_objectSpread(_objectSpread(_objectSpread({},componentComputedProps),componentComputedStateProps),{},{stores,locale}));}};return[component,klass,rect,panelName,hasBeenMounted,preMountRect,style,componentProps,dispatch,opacityClamped,isActivePrivateStore,componentView,isActive,stores,content,locale,opacity,switch_instance_name_binding,switch_instance_binding,measure_handler];}class Panel extends SvelteComponent{constructor(options){super();init(this,options,instance$3,create_fragment$3,safe_not_equal,{isActive:12,stores:13,content:14,component:0,locale:15,class:1,opacity:16});}get opacity(){return this.$$.ctx[16];}}/* src/core/ui/components/Icon.svelte generated by Svelte v3.29.4 */function create_fragment$4(ctx){let svg;let svg_viewBox_value;let current;const default_slot_template=/*#slots*/ctx[5].default;const default_slot=create_slot(default_slot_template,ctx,/*$$scope*/ctx[4],null);return{c(){svg=svg_element(\"svg\");if(default_slot)default_slot.c();attr(svg,\"class\",/*klass*/ctx[3]);attr(svg,\"style\",/*style*/ctx[2]);attr(svg,\"width\",/*width*/ctx[0]);attr(svg,\"height\",/*height*/ctx[1]);attr(svg,\"viewBox\",svg_viewBox_value=\"0 0 \"+/*width*/ctx[0]+\"\\n    \"+/*height*/ctx[1]);attr(svg,\"xmlns\",\"http://www.w3.org/2000/svg\");attr(svg,\"aria-hidden\",\"true\");attr(svg,\"focusable\",\"false\");attr(svg,\"stroke-linecap\",\"round\");attr(svg,\"stroke-linejoin\",\"round\");},m(target,anchor){insert(target,svg,anchor);if(default_slot){default_slot.m(svg,null);}current=true;},p(ctx,[dirty]){if(default_slot){if(default_slot.p&&dirty&/*$$scope*/16){update_slot(default_slot,default_slot_template,ctx,/*$$scope*/ctx[4],dirty,null,null);}}if(!current||dirty&/*klass*/8){attr(svg,\"class\",/*klass*/ctx[3]);}if(!current||dirty&/*style*/4){attr(svg,\"style\",/*style*/ctx[2]);}if(!current||dirty&/*width*/1){attr(svg,\"width\",/*width*/ctx[0]);}if(!current||dirty&/*height*/2){attr(svg,\"height\",/*height*/ctx[1]);}if(!current||dirty&/*width, height*/3&&svg_viewBox_value!==(svg_viewBox_value=\"0 0 \"+/*width*/ctx[0]+\"\\n    \"+/*height*/ctx[1])){attr(svg,\"viewBox\",svg_viewBox_value);}},i(local){if(current)return;transition_in(default_slot,local);current=true;},o(local){transition_out(default_slot,local);current=false;},d(detaching){if(detaching)detach(svg);if(default_slot)default_slot.d(detaching);}};}function instance$4($$self,$$props,$$invalidate){let{$$slots:slots={},$$scope}=$$props;let{width=24}=$$props;let{height=24}=$$props;let{style=undefined}=$$props;let{class:klass=undefined}=$$props;$$self.$$set=$$props=>{if(\"width\"in $$props)$$invalidate(0,width=$$props.width);if(\"height\"in $$props)$$invalidate(1,height=$$props.height);if(\"style\"in $$props)$$invalidate(2,style=$$props.style);if(\"class\"in $$props)$$invalidate(3,klass=$$props.class);if(\"$$scope\"in $$props)$$invalidate(4,$$scope=$$props.$$scope);};return[width,height,style,klass,$$scope,slots];}class Icon extends SvelteComponent{constructor(options){super();init(this,options,instance$4,create_fragment$4,safe_not_equal,{width:0,height:1,style:2,class:3});}}var isEventTarget=(e,element)=>element===e.target||element.contains(e.target);/* src/core/ui/components/Button.svelte generated by Svelte v3.29.4 */function create_if_block_1(ctx){let icon_1;let current;icon_1=new Icon({props:{class:\"DokaButtonIcon\",$$slots:{default:[create_default_slot]},$$scope:{ctx}}});return{c(){create_component(icon_1.$$.fragment);},m(target,anchor){mount_component(icon_1,target,anchor);current=true;},p(ctx,dirty){const icon_1_changes={};if(dirty&/*$$scope, icon*/1048578){icon_1_changes.$$scope={dirty,ctx};}icon_1.$set(icon_1_changes);},i(local){if(current)return;transition_in(icon_1.$$.fragment,local);current=true;},o(local){transition_out(icon_1.$$.fragment,local);current=false;},d(detaching){destroy_component(icon_1,detaching);}};}// (40:16) <Icon class=\"DokaButtonIcon\">\nfunction create_default_slot(ctx){let g;return{c(){g=svg_element(\"g\");},m(target,anchor){insert(target,g,anchor);g.innerHTML=/*icon*/ctx[1];},p(ctx,dirty){if(dirty&/*icon*/2)g.innerHTML=/*icon*/ctx[1];},d(detaching){if(detaching)detach(g);}};}// (46:12) {#if label}\nfunction create_if_block(ctx){let span;let t;return{c(){span=element(\"span\");t=text(/*label*/ctx[0]);attr(span,\"class\",/*elLabelClass*/ctx[11]);},m(target,anchor){insert(target,span,anchor);append(span,t);},p(ctx,dirty){if(dirty&/*label*/1)set_data(t,/*label*/ctx[0]);if(dirty&/*elLabelClass*/2048){attr(span,\"class\",/*elLabelClass*/ctx[11]);}},d(detaching){if(detaching)detach(span);}};}// (37:10)          \nfunction fallback_block(ctx){let span;let t;let current;let if_block0=/*icon*/ctx[1]&&create_if_block_1(ctx);let if_block1=/*label*/ctx[0]&&create_if_block(ctx);return{c(){span=element(\"span\");if(if_block0)if_block0.c();t=space();if(if_block1)if_block1.c();attr(span,\"class\",/*elButtonInnerClass*/ctx[9]);},m(target,anchor){insert(target,span,anchor);if(if_block0)if_block0.m(span,null);append(span,t);if(if_block1)if_block1.m(span,null);current=true;},p(ctx,dirty){if(/*icon*/ctx[1]){if(if_block0){if_block0.p(ctx,dirty);if(dirty&/*icon*/2){transition_in(if_block0,1);}}else{if_block0=create_if_block_1(ctx);if_block0.c();transition_in(if_block0,1);if_block0.m(span,t);}}else if(if_block0){group_outros();transition_out(if_block0,1,1,()=>{if_block0=null;});check_outros();}if(/*label*/ctx[0]){if(if_block1){if_block1.p(ctx,dirty);}else{if_block1=create_if_block(ctx);if_block1.c();if_block1.m(span,null);}}else if(if_block1){if_block1.d(1);if_block1=null;}if(!current||dirty&/*elButtonInnerClass*/512){attr(span,\"class\",/*elButtonInnerClass*/ctx[9]);}},i(local){if(current)return;transition_in(if_block0);current=true;},o(local){transition_out(if_block0);current=false;},d(detaching){if(detaching)detach(span);if(if_block0)if_block0.d();if(if_block1)if_block1.d();}};}function create_fragment$5(ctx){let button;let action_action;let current;let mounted;let dispose;const default_slot_template=/*#slots*/ctx[18].default;const default_slot=create_slot(default_slot_template,ctx,/*$$scope*/ctx[20],null);const default_slot_or_fallback=default_slot||fallback_block(ctx);return{c(){button=element(\"button\");if(default_slot_or_fallback)default_slot_or_fallback.c();attr(button,\"type\",/*type*/ctx[4]);attr(button,\"style\",/*style*/ctx[2]);button.disabled=/*disabled*/ctx[3];attr(button,\"class\",/*elButtonClass*/ctx[10]);attr(button,\"title\",/*label*/ctx[0]);},m(target,anchor){insert(target,button,anchor);if(default_slot_or_fallback){default_slot_or_fallback.m(button,null);}/*button_binding*/ctx[19](button);current=true;if(!mounted){dispose=[listen(button,\"keydown\",function(){if(is_function(/*onkeydown*/ctx[6]))/*onkeydown*/ctx[6].apply(this,arguments);}),listen(button,\"click\",function(){if(is_function(/*onclick*/ctx[5]))/*onclick*/ctx[5].apply(this,arguments);}),action_destroyer(action_action=/*action*/ctx[7].call(null,button))];mounted=true;}},p(new_ctx,[dirty]){ctx=new_ctx;if(default_slot){if(default_slot.p&&dirty&/*$$scope*/1048576){update_slot(default_slot,default_slot_template,ctx,/*$$scope*/ctx[20],dirty,null,null);}}else{if(default_slot_or_fallback&&default_slot_or_fallback.p&&dirty&/*elButtonInnerClass, elLabelClass, label, icon*/2563){default_slot_or_fallback.p(ctx,dirty);}}if(!current||dirty&/*type*/16){attr(button,\"type\",/*type*/ctx[4]);}if(!current||dirty&/*style*/4){attr(button,\"style\",/*style*/ctx[2]);}if(!current||dirty&/*disabled*/8){button.disabled=/*disabled*/ctx[3];}if(!current||dirty&/*elButtonClass*/1024){attr(button,\"class\",/*elButtonClass*/ctx[10]);}if(!current||dirty&/*label*/1){attr(button,\"title\",/*label*/ctx[0]);}},i(local){if(current)return;transition_in(default_slot_or_fallback,local);current=true;},o(local){transition_out(default_slot_or_fallback,local);current=false;},d(detaching){if(detaching)detach(button);if(default_slot_or_fallback)default_slot_or_fallback.d(detaching);/*button_binding*/ctx[19](null);mounted=false;run_all(dispose);}};}function instance$5($$self,$$props,$$invalidate){let{$$slots:slots={},$$scope}=$$props;let{class:klass=undefined}=$$props;let{label=undefined}=$$props;let{labelClass=undefined}=$$props;let{innerClass=undefined}=$$props;let{hideLabel=false}=$$props;let{icon=undefined}=$$props;let{style=undefined}=$$props;let{disabled=undefined}=$$props;let{type=\"button\"}=$$props;let{onclick=undefined}=$$props;let{onkeydown=undefined}=$$props;let{action=()=>{}}=$$props;let root;const isEventTarget$1=e=>isEventTarget(e,root);const getElement=()=>root;function button_binding($$value){binding_callbacks[$$value?\"unshift\":\"push\"](()=>{root=$$value;$$invalidate(8,root);});}$$self.$$set=$$props=>{if(\"class\"in $$props)$$invalidate(12,klass=$$props.class);if(\"label\"in $$props)$$invalidate(0,label=$$props.label);if(\"labelClass\"in $$props)$$invalidate(13,labelClass=$$props.labelClass);if(\"innerClass\"in $$props)$$invalidate(14,innerClass=$$props.innerClass);if(\"hideLabel\"in $$props)$$invalidate(15,hideLabel=$$props.hideLabel);if(\"icon\"in $$props)$$invalidate(1,icon=$$props.icon);if(\"style\"in $$props)$$invalidate(2,style=$$props.style);if(\"disabled\"in $$props)$$invalidate(3,disabled=$$props.disabled);if(\"type\"in $$props)$$invalidate(4,type=$$props.type);if(\"onclick\"in $$props)$$invalidate(5,onclick=$$props.onclick);if(\"onkeydown\"in $$props)$$invalidate(6,onkeydown=$$props.onkeydown);if(\"action\"in $$props)$$invalidate(7,action=$$props.action);if(\"$$scope\"in $$props)$$invalidate(20,$$scope=$$props.$$scope);};let elButtonInnerClass;let elButtonClass;let elLabelClass;$$self.$$.update=()=>{if($$self.$$.dirty&/*innerClass*/16384){$$invalidate(9,elButtonInnerClass=arrayJoin([\"DokaButtonInner\",innerClass]));}if($$self.$$.dirty&/*hideLabel, klass*/36864){$$invalidate(10,elButtonClass=arrayJoin([\"DokaButton\",hideLabel&&\"DokaButtonIconOnly\",klass]));}if($$self.$$.dirty&/*hideLabel, labelClass*/40960){$$invalidate(11,elLabelClass=arrayJoin([hideLabel?\"implicit\":\"DokaButtonLabel\",labelClass]));}};return[label,icon,style,disabled,type,onclick,onkeydown,action,root,elButtonInnerClass,elButtonClass,elLabelClass,klass,labelClass,innerClass,hideLabel,isEventTarget$1,getElement,slots,button_binding,$$scope];}class Button extends SvelteComponent{constructor(options){super();init(this,options,instance$5,create_fragment$5,safe_not_equal,{class:12,label:0,labelClass:13,innerClass:14,hideLabel:15,icon:1,style:2,disabled:3,type:4,onclick:5,onkeydown:6,action:7,isEventTarget:16,getElement:17});}get isEventTarget(){return this.$$.ctx[16];}get getElement(){return this.$$.ctx[17];}}var arrayRemove=(array,predicate)=>{const index=array.findIndex(predicate);if(index>=0)return array.splice(index,1);return undefined;};// svelte\n// constants\nconst INERTIA_THRESHOLD=0.25;// when force of velocity exceeds this value we drift\nconst INERTIA_DISTANCE_MULTIPLIER=50;const INERTIA_DURATION_MULTIPLIER=80;const TAP_DURATION_MAX=300;const TAP_DISTANCE_MAX=64;const DOUBLE_TAP_DURATION_MAX=700;const DOUBLE_TAP_DISTANCE_MAX=128;const isContextMenuAction=e=>isNumber(e.button)&&e.button!==0;const getPinchScalar=(offset,current)=>{return(current-offset)/offset;};var interactable=(node,options={})=>{// set defaults\nconst{inertia=false,matchTarget=false,pinch=false,getEventPosition=e=>vectorCreate(e.clientX,e.clientY)}=options;//\n// helpers\n//\nfunction dispatch(type,detail){node.dispatchEvent(new CustomEvent(type,{detail}));}function resetInertia(){if(inertiaTweenUnsubscribe)inertiaTweenUnsubscribe();inertiaTweenUnsubscribe=undefined;}//#region pointer registry\nconst pointers=[];const addPointer=e=>{const pointer={timeStamp:e.timeStamp,timeStampInitial:e.timeStamp,position:getEventPosition(e),origin:getEventPosition(e),velocity:vectorCreateEmpty(),translation:vectorCreateEmpty(),interactionState:undefined,event:e};pointers.push(pointer);pointer.interactionState=getInteractionState(pointers);};const removePointer=e=>{const pointer=arrayRemove(pointers,pointer=>pointer.event.pointerId===e.pointerId);if(pointer)return pointer[0];};const getPointerIndex=e=>pointers.findIndex(pointer=>pointer.event.pointerId===e.pointerId);const flattenPointerOrigin=pointer=>{pointer.origin.x=pointer.position.x;pointer.origin.y=pointer.position.y;pointer.translation.x=0;pointer.translation.y=0;};const updatePointer=e=>{const pointer=getPointer(e);if(!pointer)return;const{timeStamp}=e;// position\nconst eventPosition=getEventPosition(e);// duration between previous interaction and new interaction, an interaction duration cannot be faster than 1 millisecond\nconst interactionDuration=Math.max(1,timeStamp-pointer.timeStamp);// calculate velocity\npointer.velocity.x=(eventPosition.x-pointer.position.x)/interactionDuration;pointer.velocity.y=(eventPosition.y-pointer.position.y)/interactionDuration;// update the translation\npointer.translation.x=eventPosition.x-pointer.origin.x;pointer.translation.y=eventPosition.y-pointer.origin.y;// set new state\npointer.timeStamp=timeStamp;pointer.position.x=eventPosition.x;pointer.position.y=eventPosition.y;pointer.event=e;};const getPointer=e=>{const i=getPointerIndex(e);if(i<0)return;return pointers[i];};const isSingleTouching=()=>pointers.length===1;const isMultiTouching=()=>pointers.length===2;const getDistance=(pointers,position)=>{const distanceTotal=pointers.reduce((prev,curr)=>{prev+=vectorDistance(position,curr.position);return prev;},0);return distanceTotal/pointers.length;};const getInteractionState=pointers=>{const center=vectorCenter(pointers.map(pointer=>pointer.position));const distance=getDistance(pointers,center);return{center,distance,velocity:vectorCenter(pointers.map(pointer=>pointer.velocity)),translation:vectorCenter(pointers.map(pointer=>pointer.translation))};};//#endregion\nlet inertiaTween;let inertiaTweenUnsubscribe;let pinchOffset;let currentTranslation;let currentScale;let isGesture;let lastTapTimeStamp=0;let lastTapPosition=undefined;// start handling interactions\nnode.addEventListener('pointerdown',handlePointerdown);function handlePointerdown(e){// ignore more than two pointers for now\nif(isMultiTouching())return;// not interested in context menu\nif(isContextMenuAction(e))return;// target should equal node, if it doesn't user might have clicked one of the nodes children\nif(matchTarget&&e.target!==node)return;// stop any previous inertia tweens\nresetInertia();// register this pointer\naddPointer(e);// if is first pointer we need to init the drag gesture\nif(isSingleTouching()){// handle pointer events\ndocument.documentElement.addEventListener('pointermove',handlePointermove);document.documentElement.addEventListener('pointerup',handlePointerup);document.documentElement.addEventListener('pointercancel',handlePointerup);// clear vars\nisGesture=false;currentScale=0;currentTranslation=vectorCreateEmpty();pinchOffset=undefined;dispatch('interactionstart',{origin:vectorClone(getPointer(e).origin)});}else if(pinch){isGesture=true;pinchOffset=vectorDistance(pointers[0].position,pointers[1].position);currentTranslation.x+=pointers[0].translation.x;currentTranslation.y+=pointers[0].translation.y;flattenPointerOrigin(pointers[0]);}}//\n// pointer move can only be a primary event (other pointers are not handled)\n//\nfunction handlePointermove(e){// prevent selection of text (Safari)\ne.preventDefault();// update pointer state\nupdatePointer(e);let scalar=currentScale;let translation=vectorClone(pointers[0].translation);if(pinch&&isMultiTouching()){// current offset\ntranslation.x+=pointers[1].translation.x;translation.y+=pointers[1].translation.y;// current pinch distance\nconst pinchCurrent=vectorDistance(pointers[0].position,pointers[1].position);// to find out scalar we calculate the difference between the pinch offset and the new pinch\nscalar+=getPinchScalar(pinchOffset,pinchCurrent);}translation.x+=currentTranslation.x;translation.y+=currentTranslation.y;dispatch('interactionupdate',{translation,scalar:pinch?scalar:undefined});}//\n// pointer up can only be a primary event (other pointers are not handled)\n//\nfunction handlePointerup(e){// remove pointer from active pointers array\nconst removedPointer=removePointer(e);// store current size\nif(pinch&&isSingleTouching()){// calculate current scale\nconst pinchCurrent=vectorDistance(pointers[0].position,removedPointer.position);currentScale=(currentScale||0)+getPinchScalar(pinchOffset,pinchCurrent);currentTranslation.x+=pointers[0].translation.x+removedPointer.translation.x;currentTranslation.y+=pointers[0].translation.y+removedPointer.translation.y;flattenPointerOrigin(pointers[0]);}// check if this was a tap\nlet isTap=false;let isDoubleTap=false;if(!isGesture){const interactionEnd=performance.now();const interactionDuration=interactionEnd-removedPointer.timeStampInitial;const interactionDistanceSquared=vectorDistanceSquared(removedPointer.translation);isTap=interactionDistanceSquared<TAP_DISTANCE_MAX&&interactionDuration<TAP_DURATION_MAX;isDoubleTap=!!(lastTapPosition&&isTap&&interactionEnd-lastTapTimeStamp<DOUBLE_TAP_DURATION_MAX&&vectorDistanceSquared(lastTapPosition,removedPointer.position)<DOUBLE_TAP_DISTANCE_MAX);if(isTap){lastTapPosition=vectorClone(removedPointer.position);lastTapTimeStamp=interactionEnd;}}// we wait till last multi-touch interaction is finished, all pointers need to be de-registered before proceeding\nif(pointers.length>0)return;// stop listening\ndocument.documentElement.removeEventListener('pointermove',handlePointermove);document.documentElement.removeEventListener('pointerup',handlePointerup);document.documentElement.removeEventListener('pointercancel',handlePointerup);const translation=vectorClone(removedPointer.translation);const velocity=vectorClone(removedPointer.velocity);// allows cancelling inertia from release handler\nlet inertiaPrevented=false;// user has released interaction\ndispatch('interactionrelease',{isTap,isDoubleTap,translation,scalar:currentScale,preventInertia:()=>inertiaPrevented=true});// stop intantly if not a lot of force applied\nconst force=vectorDistance(velocity);if(inertiaPrevented||!inertia||force<INERTIA_THRESHOLD){return handleEnd(translation,{isTap,isDoubleTap});}// drift\ninertiaTween=tweened(vectorClone(translation),{easing:circOut,duration:force*INERTIA_DURATION_MULTIPLIER});inertiaTween.set({x:translation.x+velocity.x*INERTIA_DISTANCE_MULTIPLIER,y:translation.y+velocity.y*INERTIA_DISTANCE_MULTIPLIER}).then(()=>{// if has unsubscribed (tween was reset)\nif(!inertiaTweenUnsubscribe)return;// go!\nhandleEnd(get_store_value(inertiaTween),{isTap,isDoubleTap});});inertiaTweenUnsubscribe=inertiaTween.subscribe(handleInertiaUpdate);}function handleInertiaUpdate(inertiaTranslation){// if is same as previous position, ignore\nif(!inertiaTranslation)return;// || vectorEqual(inertiaTranslation, translation)) return;\n// this will handle drift interactions\ndispatch('interactionupdate',{translation:inertiaTranslation,scalar:pinch?currentScale:undefined});}function handleEnd(translation,tapState){resetInertia();dispatch('interactionend',_objectSpread(_objectSpread({},tapState),{},{translation,scalar:pinch?currentScale:undefined}));}return{destroy(){resetInertia();node.removeEventListener('pointerdown',handlePointerdown);}};};var nudgeable=(element,options={})=>{// if added as action on non focusable element you should add tabindex=0 attribute\nconst{direction=undefined,shiftMultiplier=10,bubbles=false,stopKeydownPropagation=true}=options;const isHorizontalDirection=direction==='horizontal';const isVerticalDirection=direction==='vertical';const handleKeydown=e=>{const{key}=e;const isShift=e.shiftKey;const isHorizontalAction=/up|down/i.test(key);const isVerticalAction=/left|right/i.test(key);// no directional key\nif(!isHorizontalAction&&!isVerticalAction)return;// is horizontal but up or down pressed\nif(isHorizontalDirection&&isVerticalAction)return;// is vertical but left or right pressed\nif(isVerticalDirection&&isHorizontalAction)return;// if holding shift move by a factor 10\nconst multiplier=isShift?shiftMultiplier:1;if(stopKeydownPropagation)e.stopPropagation();element.dispatchEvent(new CustomEvent('nudge',{bubbles,detail:vectorCreate((/left/i.test(key)?-1:/right/i.test(key)?1:0)*multiplier,(/up/i.test(key)?-1:/down/i.test(key)?1:0)*multiplier)}));};element.addEventListener('keydown',handleKeydown);return{destroy(){element.removeEventListener('keydown',handleKeydown);}};};function elastify(translation,dist){return dist*Math.sign(translation)*Math.log10(1+Math.abs(translation)/dist);}const elastifyRects=(a,b,dist)=>{if(!b)return rectClone(a);const left=a.x+elastify(b.x-a.x,dist);const right=a.x+a.width+elastify(b.x+b.width-(a.x+a.width),dist);const top=a.y+elastify(b.y-a.y,dist);const bottom=a.y+a.height+elastify(b.y+b.height-(a.y+a.height),dist);return{x:left,y:top,width:right-left,height:bottom-top};};var unitToPixels=(value,element)=>{if(!value)return;if(/em/.test(value))return parseInt(value,10)*16;if(/px/.test(value))return parseInt(value,10);};var getWheelDelta=e=>{let d=e.detail||0;// @ts-ignore\nif(e.wheelDelta||e.wheelDeltaY)d=(-e.wheelDelta||-e.wheelDeltaY)/120;if(!d)d=e.deltaY;return d;};/* src/core/ui/components/Scrollable.svelte generated by Svelte v3.29.4 */function create_fragment$6(ctx){let div1;let div0;let interactable_action;let measurable_action;let div1_class_value;let measurable_action_1;let nudgeable_action;let current;let mounted;let dispose;const default_slot_template=/*#slots*/ctx[29].default;const default_slot=create_slot(default_slot_template,ctx,/*$$scope*/ctx[28],null);return{c(){div1=element(\"div\");div0=element(\"div\");if(default_slot)default_slot.c();attr(div0,\"style\",/*childStyle*/ctx[6]);attr(div1,\"class\",div1_class_value=arrayJoin([\"DokaScrollable\",/*klass*/ctx[0]]));attr(div1,\"style\",/*overflowStyle*/ctx[4]);attr(div1,\"data-direction\",/*scrollDirection*/ctx[1]);attr(div1,\"data-state\",/*containerState*/ctx[5]);},m(target,anchor){insert(target,div1,anchor);append(div1,div0);if(default_slot){default_slot.m(div0,null);}/*div1_binding*/ctx[31](div1);current=true;if(!mounted){dispose=[listen(div0,\"interactionstart\",/*handleDragStart*/ctx[9]),listen(div0,\"interactionupdate\",/*handleDragMove*/ctx[11]),listen(div0,\"interactionend\",/*handleDragEnd*/ctx[12]),listen(div0,\"interactionrelease\",/*handleDragRelease*/ctx[10]),action_destroyer(interactable_action=interactable.call(null,div0,{inertia:true})),listen(div0,\"measure\",/*measure_handler*/ctx[30]),action_destroyer(measurable_action=measurable.call(null,div0)),listen(div1,\"wheel\",/*handleWheel*/ctx[14]),listen(div1,\"scroll\",/*handleScroll*/ctx[16]),listen(div1,\"focusin\",/*handleFocus*/ctx[15]),listen(div1,\"nudge\",/*handleNudge*/ctx[17]),listen(div1,\"measure\",/*handleResizeScrollContainer*/ctx[13]),action_destroyer(measurable_action_1=measurable.call(null,div1,{observePosition:true})),action_destroyer(nudgeable_action=nudgeable.call(null,div1,{direction:/*scrollDirection*/ctx[1]===\"x\"?\"horizontal\":\"vertical\",stopKeydownPropagation:false}))];mounted=true;}},p(ctx,dirty){if(default_slot){if(default_slot.p&&dirty[0]&/*$$scope*/268435456){update_slot(default_slot,default_slot_template,ctx,/*$$scope*/ctx[28],dirty,null,null);}}if(!current||dirty[0]&/*childStyle*/64){attr(div0,\"style\",/*childStyle*/ctx[6]);}if(!current||dirty[0]&/*klass*/1&&div1_class_value!==(div1_class_value=arrayJoin([\"DokaScrollable\",/*klass*/ctx[0]]))){attr(div1,\"class\",div1_class_value);}if(!current||dirty[0]&/*overflowStyle*/16){attr(div1,\"style\",/*overflowStyle*/ctx[4]);}if(!current||dirty[0]&/*scrollDirection*/2){attr(div1,\"data-direction\",/*scrollDirection*/ctx[1]);}if(!current||dirty[0]&/*containerState*/32){attr(div1,\"data-state\",/*containerState*/ctx[5]);}if(nudgeable_action&&is_function(nudgeable_action.update)&&dirty[0]&/*scrollDirection*/2)nudgeable_action.update.call(null,{direction:/*scrollDirection*/ctx[1]===\"x\"?\"horizontal\":\"vertical\",stopKeydownPropagation:false});},i(local){if(current)return;transition_in(default_slot,local);current=true;},o(local){transition_out(default_slot,local);current=false;},d(detaching){if(detaching)detach(div1);if(default_slot)default_slot.d(detaching);/*div1_binding*/ctx[31](null);mounted=false;run_all(dispose);}};}function instance$6($$self,$$props,$$invalidate){let $scrollOffset;let $keysPressedStore;let{$$slots:slots={},$$scope}=$$props;const dispatch=createEventDispatcher();const keysPressedStore=getContext(\"keysPressed\");component_subscribe($$self,keysPressedStore,value=>$$invalidate(46,$keysPressedStore=value));let scrollState=\"idle\";let scrollOrigin;let scrollRect;let scrollContainerRect;let scrollReleased;let scrollOffset=spring(0);component_subscribe($$self,scrollOffset,value=>$$invalidate(44,$scrollOffset=value));let{class:klass=undefined}=$$props;let{scrollBlockInteractionDist=5}=$$props;let{scrollStep=10}=$$props;// the distance multiplier for each mouse scroll interaction (delta)\nlet{scrollFocusMargin=64}=$$props;// the margin used around elements to decided where to move the focus so elements are positioned into view with some spacing around them, this allows peaking at next/previous elements\nlet{scrollDirection=\"x\"}=$$props;let{scrollAutoCancel=false}=$$props;let{elasticity=0}=$$props;let{onscroll=noop}=$$props;let{maskFeatherSize=undefined}=$$props;let{maskFeatherStartOpacity=undefined}=$$props;let{maskFeatherEndOpacity=undefined}=$$props;let{scroll=undefined}=$$props;// logic\nlet container;let overflowStyle=\"\";// is scroll in reset state\nlet scrollAtRest=true;// triggers onscroll callback\nscrollOffset.subscribe(value=>{const pos=vectorCreateEmpty();pos[scrollDirection]=value;onscroll(pos);});const limitOffsetToContainer=offset=>Math.max(Math.min(0,offset),scrollContainerRect[size]-scrollRect[size]);let scrollFirstMove;let scrollCancelled;let scrollTranslationPrev;const isHorizontalTranslation=translation=>{const velocity=vectorApply(vectorCreate(translation.x-scrollTranslationPrev.x,translation.y-scrollTranslationPrev.y),Math.abs);scrollTranslationPrev=vectorClone(translation);const speed=vectorDistanceSquared(velocity);const diff=velocity.x-velocity.y;return!(speed>1&&diff<-0.5);};const handleDragStart=()=>{// not overflowing so no need to handle\nif(!overflows)return;scrollCancelled=false;scrollFirstMove=true;scrollTranslationPrev=vectorCreate(0,0);scrollReleased=false;$$invalidate(32,scrollState=\"idle\");scrollOrigin=get_store_value(scrollOffset);};const handleDragRelease=({detail})=>{if(!overflows)return;scrollReleased=true;$$invalidate(32,scrollState=\"idle\");};const handleDragMove=({detail})=>{if(!overflows)return;if(scrollCancelled)return;// fixes problem with single move event fired when clicking\nif(scrollFirstMove){scrollFirstMove=false;if(vectorDistanceSquared(detail.translation)<0.1)return;}if(scrollAutoCancel&&scrollDirection===\"x\"&&!isHorizontalTranslation(detail.translation)){scrollCancelled=true;return;}setScrollOffset(scrollOrigin+detail.translation[scrollDirection],{elastic:true});};const handleDragEnd=({detail})=>{if(!overflows)return;if(scrollCancelled)return;const offset=scrollOrigin+detail.translation[scrollDirection];const offsetLimited=limitOffsetToContainer(offset);scrollAtRest=false;scrollOffset.set(offsetLimited).then(res=>{if(!scrollReleased)return;scrollAtRest=true;});};const handleResizeScrollContainer=({detail})=>{$$invalidate(34,scrollContainerRect=detail);dispatch(\"measure\",{x:detail.x,y:detail.y,width:detail.width,height:detail.height});};const setScrollOffset=(offset,options={})=>{const{elastic=false,animate=false}=options;// prevents clicks on child elements if the container is being scrolled\nif(Math.abs(offset)>scrollBlockInteractionDist&&scrollState===\"idle\"&&!scrollReleased){$$invalidate(32,scrollState=\"scrolling\");}const offsetLimited=limitOffsetToContainer(offset);const offsetVisual=elastic&&elasticity&&!scrollReleased?offsetLimited+elastify(offset-offsetLimited,elasticity):offsetLimited;let snapToPosition=true;if(animate){snapToPosition=false;}else if(!scrollAtRest){snapToPosition=!scrollReleased;}scrollAtRest=false;scrollOffset.set(offsetVisual,{hard:snapToPosition}).then(res=>{if(!scrollReleased)return;scrollAtRest=true;});};const handleWheel=e=>{// don't do anything if isn't overflowing\nif(!overflows)return;// scroll down -> move to right/down\n// scroll up -> move to left/up\n// don't run default actions, prevent other actions from running\ne.preventDefault();e.stopPropagation();// apply wheel delta to offset\nconst delta=getWheelDelta(e);const offset=get_store_value(scrollOffset);setScrollOffset(offset+delta*scrollStep,{animate:true});};const handleFocus=e=>{// don't do anything if isn't overflowing\nif(!overflows)return;// ignore this handler if is dragging\nif(!scrollReleased&&!$keysPressedStore.length)return;let target=e.target;// when a target is marked as implicit we use its parent elemetn\nif(e.target.classList.contains(\"implicit\"))target=target.parentNode;// get bounds\nconst start=target[scrollDirection===\"x\"?\"offsetLeft\":\"offsetTop\"];//.offsetLeft;\nconst space=target[scrollDirection===\"x\"?\"offsetWidth\":\"offsetHeight\"];//.offsetWidth;\nconst end=start+space;// we need to know the current offset of the scroll so we can determine if the target is in view\nconst currentScrollOffset=get_store_value(scrollOffset);// the margin around elements to keep in mind when focussing items\nconst margin=scrollFocusMargin+maskFeatherSize;if(currentScrollOffset+start<margin){setScrollOffset(-start+margin);}else if(currentScrollOffset+end>scrollContainerRect[size]-margin){setScrollOffset(scrollContainerRect[size]-end-margin,{animate:true});}};const handleScroll=()=>{// the scroll handler corrects auto browser scroll, \n// is triggered when browser tries to focus an \n// element outside of the scrollcontiner\n$$invalidate(3,container[scrollDirection===\"x\"?\"scrollLeft\":\"scrollTop\"]=0,container);};const handleNudge=({detail})=>{const delta=-2*detail[scrollDirection];const offset=get_store_value(scrollOffset);setScrollOffset(offset+delta*scrollStep,{animate:true});};const measure_handler=e=>$$invalidate(2,scrollRect=e.detail);function div1_binding($$value){binding_callbacks[$$value?\"unshift\":\"push\"](()=>{container=$$value;$$invalidate(3,container);});}$$self.$$set=$$props=>{if(\"class\"in $$props)$$invalidate(0,klass=$$props.class);if(\"scrollBlockInteractionDist\"in $$props)$$invalidate(21,scrollBlockInteractionDist=$$props.scrollBlockInteractionDist);if(\"scrollStep\"in $$props)$$invalidate(22,scrollStep=$$props.scrollStep);if(\"scrollFocusMargin\"in $$props)$$invalidate(23,scrollFocusMargin=$$props.scrollFocusMargin);if(\"scrollDirection\"in $$props)$$invalidate(1,scrollDirection=$$props.scrollDirection);if(\"scrollAutoCancel\"in $$props)$$invalidate(24,scrollAutoCancel=$$props.scrollAutoCancel);if(\"elasticity\"in $$props)$$invalidate(25,elasticity=$$props.elasticity);if(\"onscroll\"in $$props)$$invalidate(26,onscroll=$$props.onscroll);if(\"maskFeatherSize\"in $$props)$$invalidate(18,maskFeatherSize=$$props.maskFeatherSize);if(\"maskFeatherStartOpacity\"in $$props)$$invalidate(19,maskFeatherStartOpacity=$$props.maskFeatherStartOpacity);if(\"maskFeatherEndOpacity\"in $$props)$$invalidate(20,maskFeatherEndOpacity=$$props.maskFeatherEndOpacity);if(\"scroll\"in $$props)$$invalidate(27,scroll=$$props.scroll);if(\"$$scope\"in $$props)$$invalidate(28,$$scope=$$props.$$scope);};let size;let axis;let containerStyle;let containerFeatherSize;let overflows;let containerState;let childStyle;$$self.$$.update=()=>{if($$self.$$.dirty[0]&/*scrollDirection*/2){$$invalidate(40,size=scrollDirection===\"x\"?\"width\":\"height\");}if($$self.$$.dirty[0]&/*scrollDirection*/2){$$invalidate(41,axis=scrollDirection.toUpperCase());}if($$self.$$.dirty[0]&/*container*/8){$$invalidate(42,containerStyle=container&&getComputedStyle(container));}if($$self.$$.dirty[0]&/*container*/8|$$self.$$.dirty[1]&/*containerStyle*/2048){$$invalidate(43,containerFeatherSize=containerStyle&&unitToPixels(containerStyle.getPropertyValue(\"--scrollable-feather-size\")));}if($$self.$$.dirty[0]&/*scrollRect, maskFeatherStartOpacity, maskFeatherEndOpacity*/1572868|$$self.$$.dirty[1]&/*$scrollOffset, scrollContainerRect, containerFeatherSize, size*/12808){if($scrollOffset!=null&&scrollContainerRect&&containerFeatherSize!=null&&scrollRect){const startOffset=-$scrollOffset/containerFeatherSize;const endOffset=-(scrollContainerRect[size]-scrollRect[size]-$scrollOffset)/containerFeatherSize;$$invalidate(19,maskFeatherStartOpacity=clamp(1-startOffset,0,1));$$invalidate(20,maskFeatherEndOpacity=clamp(1-endOffset,0,1));$$invalidate(18,maskFeatherSize=containerFeatherSize);$$invalidate(4,overflowStyle=`--scrollable-feather-start-opacity: ${maskFeatherStartOpacity};--scrollable-feather-end-opacity: ${maskFeatherEndOpacity}`);}}if($$self.$$.dirty[0]&/*container, scroll*/134217736){// update scroll position\nif(container&&scroll!==undefined){if(isNumber(scroll))setScrollOffset(scroll);else setScrollOffset(scroll.scrollOffset,scroll);}}if($$self.$$.dirty[0]&/*scrollRect*/4|$$self.$$.dirty[1]&/*scrollContainerRect, size*/520){$$invalidate(45,overflows=scrollContainerRect&&scrollRect?scrollRect[size]>scrollContainerRect[size]:undefined);}if($$self.$$.dirty[1]&/*scrollState, overflows*/16386){$$invalidate(5,containerState=arrayJoin([scrollState,overflows?\"overflows\":undefined]));}if($$self.$$.dirty[1]&/*overflows, axis, $scrollOffset*/25600){$$invalidate(6,childStyle=overflows?`transform: translate${axis}(${$scrollOffset}px)`:undefined);}};return[klass,scrollDirection,scrollRect,container,overflowStyle,containerState,childStyle,keysPressedStore,scrollOffset,handleDragStart,handleDragRelease,handleDragMove,handleDragEnd,handleResizeScrollContainer,handleWheel,handleFocus,handleScroll,handleNudge,maskFeatherSize,maskFeatherStartOpacity,maskFeatherEndOpacity,scrollBlockInteractionDist,scrollStep,scrollFocusMargin,scrollAutoCancel,elasticity,onscroll,scroll,$$scope,slots,measure_handler,div1_binding];}class Scrollable extends SvelteComponent{constructor(options){super();init(this,options,instance$6,create_fragment$6,safe_not_equal,{class:0,scrollBlockInteractionDist:21,scrollStep:22,scrollFocusMargin:23,scrollDirection:1,scrollAutoCancel:24,elasticity:25,onscroll:26,maskFeatherSize:18,maskFeatherStartOpacity:19,maskFeatherEndOpacity:20,scroll:27},[-1,-1]);}}function fade(node,{delay=0,duration=400,easing=identity}){const o=+getComputedStyle(node).opacity;return{delay,duration,easing,css:t=>`opacity: ${t*o}`};}/* src/core/ui/components/StatusMessage.svelte generated by Svelte v3.29.4 */function create_fragment$7(ctx){let span;let t;let measure_action;let span_transition;let current;let mounted;let dispose;return{c(){span=element(\"span\");t=text(/*text*/ctx[0]);attr(span,\"class\",\"DokaStatusMessage\");},m(target,anchor){insert(target,span,anchor);append(span,t);current=true;if(!mounted){dispose=[listen(span,\"measure\",function(){if(is_function(/*onmeasure*/ctx[1]))/*onmeasure*/ctx[1].apply(this,arguments);}),action_destroyer(measure_action=measurable.call(null,span))];mounted=true;}},p(new_ctx,[dirty]){ctx=new_ctx;if(!current||dirty&/*text*/1)set_data(t,/*text*/ctx[0]);},i(local){if(current)return;add_render_callback(()=>{if(!span_transition)span_transition=create_bidirectional_transition(span,fade,{},true);span_transition.run(1);});current=true;},o(local){if(!span_transition)span_transition=create_bidirectional_transition(span,fade,{},false);span_transition.run(0);current=false;},d(detaching){if(detaching)detach(span);if(detaching&&span_transition)span_transition.end();mounted=false;run_all(dispose);}};}function instance$7($$self,$$props,$$invalidate){let{text}=$$props;let{onmeasure=noop}=$$props;$$self.$$set=$$props=>{if(\"text\"in $$props)$$invalidate(0,text=$$props.text);if(\"onmeasure\"in $$props)$$invalidate(1,onmeasure=$$props.onmeasure);};return[text,onmeasure];}class StatusMessage extends SvelteComponent{constructor(options){super();init(this,options,instance$7,create_fragment$7,safe_not_equal,{text:0,onmeasure:1});}}/* src/core/ui/components/ProgressIndicator.svelte generated by Svelte v3.29.4 */function create_fragment$8(ctx){let span1;let svg;let g;let circle0;let circle1;let t0;let span0;let t1;return{c(){span1=element(\"span\");svg=svg_element(\"svg\");g=svg_element(\"g\");circle0=svg_element(\"circle\");circle1=svg_element(\"circle\");t0=space();span0=element(\"span\");t1=text(/*formattedValue*/ctx[0]);attr(circle0,\"class\",\"DokaProgressIndicatorBar\");attr(circle0,\"r\",\"8.5\");attr(circle0,\"cx\",\"10\");attr(circle0,\"cy\",\"10\");attr(circle0,\"stroke-linecap\",\"round\");attr(circle0,\"opacity\",\".25\");attr(circle1,\"class\",\"DokaProgressIndicatorFill\");attr(circle1,\"r\",\"8.5\");attr(circle1,\"stroke-dasharray\",/*circleValue*/ctx[1]);attr(circle1,\"cx\",\"10\");attr(circle1,\"cy\",\"10\");attr(circle1,\"transform\",\"rotate(-90) translate(-20)\");attr(g,\"fill\",\"none\");attr(g,\"stroke\",\"currentColor\");attr(g,\"stroke-width\",\"2.5\");attr(g,\"stroke-linecap\",\"round\");attr(g,\"opacity\",/*circleOpacity*/ctx[2]);attr(svg,\"width\",\"20\");attr(svg,\"height\",\"20\");attr(svg,\"viewBox\",\"0 0 20 20\");attr(svg,\"xmlns\",\"http://www.w3.org/2000/svg\");attr(svg,\"aria-hidden\",\"true\");attr(svg,\"focusable\",\"false\");attr(span0,\"class\",\"implicit\");attr(span1,\"class\",\"DokaProgressIndicator\");attr(span1,\"data-status\",/*status*/ctx[3]);},m(target,anchor){insert(target,span1,anchor);append(span1,svg);append(svg,g);append(g,circle0);append(g,circle1);append(span1,t0);append(span1,span0);append(span0,t1);},p(ctx,[dirty]){if(dirty&/*circleValue*/2){attr(circle1,\"stroke-dasharray\",/*circleValue*/ctx[1]);}if(dirty&/*circleOpacity*/4){attr(g,\"opacity\",/*circleOpacity*/ctx[2]);}if(dirty&/*formattedValue*/1)set_data(t1,/*formattedValue*/ctx[0]);if(dirty&/*status*/8){attr(span1,\"data-status\",/*status*/ctx[3]);}},i:noop$1,o:noop$1,d(detaching){if(detaching)detach(span1);}};}function instance$8($$self,$$props,$$invalidate){let $animatedProgressClamped;const dispatch=createEventDispatcher();let{progress}=$$props;let{min=0}=$$props;let{max=100}=$$props;let{labelBusy=\"Busy\"}=$$props;const animatedValue=spring(0,{precision:0.01});const animatedProgressClamped=derived([animatedValue],$animatedValue=>clamp($animatedValue,min,max));component_subscribe($$self,animatedProgressClamped,value=>$$invalidate(9,$animatedProgressClamped=value));animatedProgressClamped.subscribe(value=>{if(progress===1&&Math.round(value)>=100)dispatch(\"complete\");});$$self.$$set=$$props=>{if(\"progress\"in $$props)$$invalidate(5,progress=$$props.progress);if(\"min\"in $$props)$$invalidate(6,min=$$props.min);if(\"max\"in $$props)$$invalidate(7,max=$$props.max);if(\"labelBusy\"in $$props)$$invalidate(8,labelBusy=$$props.labelBusy);};let formattedValue;let circleValue;let circleOpacity;let status;$$self.$$.update=()=>{if($$self.$$.dirty&/*progress*/32){progress&&progress!==Infinity&&animatedValue.set(progress*100);}if($$self.$$.dirty&/*progress, labelBusy, $animatedProgressClamped*/800){$$invalidate(0,formattedValue=progress===Infinity?labelBusy:`${Math.round($animatedProgressClamped)}%`);}if($$self.$$.dirty&/*progress, $animatedProgressClamped*/544){$$invalidate(1,circleValue=progress===Infinity?\"26.5 53\":`${$animatedProgressClamped/100*53} 53`);}if($$self.$$.dirty&/*progress, $animatedProgressClamped*/544){$$invalidate(2,circleOpacity=Math.min(1,progress===Infinity?1:$animatedProgressClamped/10));}if($$self.$$.dirty&/*progress*/32){$$invalidate(3,status=progress===Infinity?\"busy\":\"loading\");}};return[formattedValue,circleValue,circleOpacity,status,animatedProgressClamped,progress,min,max,labelBusy];}class ProgressIndicator extends SvelteComponent{constructor(options){super();init(this,options,instance$8,create_fragment$8,safe_not_equal,{progress:5,min:6,max:7,labelBusy:8});}}/* src/core/ui/components/StatusProgress.svelte generated by Svelte v3.29.4 */function create_fragment$9(ctx){let span;let progressindicator;let current;progressindicator=new ProgressIndicator({props:{progress:/*progress*/ctx[0]}});progressindicator.$on(\"complete\",function(){if(is_function(/*oncomplete*/ctx[1]))/*oncomplete*/ctx[1].apply(this,arguments);});return{c(){span=element(\"span\");create_component(progressindicator.$$.fragment);attr(span,\"class\",\"DokaStatusProgress\");attr(span,\"style\",/*style*/ctx[2]);},m(target,anchor){insert(target,span,anchor);mount_component(progressindicator,span,null);current=true;},p(new_ctx,[dirty]){ctx=new_ctx;const progressindicator_changes={};if(dirty&/*progress*/1)progressindicator_changes.progress=/*progress*/ctx[0];progressindicator.$set(progressindicator_changes);if(!current||dirty&/*style*/4){attr(span,\"style\",/*style*/ctx[2]);}},i(local){if(current)return;transition_in(progressindicator.$$.fragment,local);current=true;},o(local){transition_out(progressindicator.$$.fragment,local);current=false;},d(detaching){if(detaching)detach(span);destroy_component(progressindicator);}};}function instance$9($$self,$$props,$$invalidate){let{offset=0}=$$props;let{visible=true}=$$props;let{progress}=$$props;let{oncomplete=noop}=$$props;$$self.$$set=$$props=>{if(\"offset\"in $$props)$$invalidate(3,offset=$$props.offset);if(\"visible\"in $$props)$$invalidate(4,visible=$$props.visible);if(\"progress\"in $$props)$$invalidate(0,progress=$$props.progress);if(\"oncomplete\"in $$props)$$invalidate(1,oncomplete=$$props.oncomplete);};let style;$$self.$$.update=()=>{if($$self.$$.dirty&/*offset, visible*/24){$$invalidate(2,style=`transform: translateX(${offset}px); opacity: ${visible?1:0}`);}};return[progress,oncomplete,style,offset,visible];}class StatusProgress extends SvelteComponent{constructor(options){super();init(this,options,instance$9,create_fragment$9,safe_not_equal,{offset:3,visible:4,progress:0,oncomplete:1});}}/* src/core/ui/components/DynamicComponentTree.svelte generated by Svelte v3.29.4 */function get_each_context$2(ctx,list,i){const child_ctx=ctx.slice();child_ctx[4]=list[i][0];child_ctx[5]=list[i][1];child_ctx[6]=list[i][2];child_ctx[0]=list[i][3];return child_ctx;}// (28:4) {:else}\nfunction create_else_block(ctx){let switch_instance;let switch_instance_anchor;let current;const switch_instance_spread_levels=[/*props*/ctx[6]];var switch_value=/*node*/ctx[4];function switch_props(ctx){let switch_instance_props={};for(let i=0;i<switch_instance_spread_levels.length;i+=1){switch_instance_props=assign(switch_instance_props,switch_instance_spread_levels[i]);}return{props:switch_instance_props};}if(switch_value){switch_instance=new switch_value(switch_props());}return{c(){if(switch_instance)create_component(switch_instance.$$.fragment);switch_instance_anchor=empty();},m(target,anchor){if(switch_instance){mount_component(switch_instance,target,anchor);}insert(target,switch_instance_anchor,anchor);current=true;},p(ctx,dirty){const switch_instance_changes=dirty&/*children*/1?get_spread_update(switch_instance_spread_levels,[get_spread_object(/*props*/ctx[6])]):{};if(switch_value!==(switch_value=/*node*/ctx[4])){if(switch_instance){group_outros();const old_component=switch_instance;transition_out(old_component.$$.fragment,1,0,()=>{destroy_component(old_component,1);});check_outros();}if(switch_value){switch_instance=new switch_value(switch_props());create_component(switch_instance.$$.fragment);transition_in(switch_instance.$$.fragment,1);mount_component(switch_instance,switch_instance_anchor.parentNode,switch_instance_anchor);}else{switch_instance=null;}}else if(switch_value){switch_instance.$set(switch_instance_changes);}},i(local){if(current)return;if(switch_instance)transition_in(switch_instance.$$.fragment,local);current=true;},o(local){if(switch_instance)transition_out(switch_instance.$$.fragment,local);current=false;},d(detaching){if(detaching)detach(switch_instance_anchor);if(switch_instance)destroy_component(switch_instance,detaching);}};}// (26:4) {#if isString(node)}\nfunction create_if_block$1(ctx){let div;let dynamiccomponenttree;let current;dynamiccomponenttree=new DynamicComponentTree_1({props:{items:/*children*/ctx[0],discardEmptyItems:true}});let div_levels=[/*props*/ctx[6]];let div_data={};for(let i=0;i<div_levels.length;i+=1){div_data=assign(div_data,div_levels[i]);}return{c(){div=element(\"div\");create_component(dynamiccomponenttree.$$.fragment);set_attributes(div,div_data);},m(target,anchor){insert(target,div,anchor);mount_component(dynamiccomponenttree,div,null);current=true;},p(ctx,dirty){const dynamiccomponenttree_changes={};if(dirty&/*children*/1)dynamiccomponenttree_changes.items=/*children*/ctx[0];dynamiccomponenttree.$set(dynamiccomponenttree_changes);set_attributes(div,div_data=get_spread_update(div_levels,[dirty&/*children*/1&&/*props*/ctx[6]]));},i(local){if(current)return;transition_in(dynamiccomponenttree.$$.fragment,local);current=true;},o(local){transition_out(dynamiccomponenttree.$$.fragment,local);current=false;},d(detaching){if(detaching)detach(div);destroy_component(dynamiccomponenttree);}};}// (25:0) {#each children as [node, key, props, children] (key) }\nfunction create_each_block$2(key_1,ctx){let first;let show_if;let current_block_type_index;let if_block;let if_block_anchor;let current;const if_block_creators=[create_if_block$1,create_else_block];const if_blocks=[];function select_block_type(ctx,dirty){if(dirty&/*children*/1)show_if=!!isString(/*node*/ctx[4]);if(show_if)return 0;return 1;}current_block_type_index=select_block_type(ctx,-1);if_block=if_blocks[current_block_type_index]=if_block_creators[current_block_type_index](ctx);return{key:key_1,first:null,c(){first=empty();if_block.c();if_block_anchor=empty();this.first=first;},m(target,anchor){insert(target,first,anchor);if_blocks[current_block_type_index].m(target,anchor);insert(target,if_block_anchor,anchor);current=true;},p(ctx,dirty){let previous_block_index=current_block_type_index;current_block_type_index=select_block_type(ctx,dirty);if(current_block_type_index===previous_block_index){if_blocks[current_block_type_index].p(ctx,dirty);}else{group_outros();transition_out(if_blocks[previous_block_index],1,1,()=>{if_blocks[previous_block_index]=null;});check_outros();if_block=if_blocks[current_block_type_index];if(!if_block){if_block=if_blocks[current_block_type_index]=if_block_creators[current_block_type_index](ctx);if_block.c();}transition_in(if_block,1);if_block.m(if_block_anchor.parentNode,if_block_anchor);}},i(local){if(current)return;transition_in(if_block);current=true;},o(local){transition_out(if_block);current=false;},d(detaching){if(detaching)detach(first);if_blocks[current_block_type_index].d(detaching);if(detaching)detach(if_block_anchor);}};}function create_fragment$a(ctx){let each_blocks=[];let each_1_lookup=new Map();let each_1_anchor;let current;let each_value=/*children*/ctx[0];const get_key=ctx=>/*key*/ctx[5];for(let i=0;i<each_value.length;i+=1){let child_ctx=get_each_context$2(ctx,each_value,i);let key=get_key(child_ctx);each_1_lookup.set(key,each_blocks[i]=create_each_block$2(key,child_ctx));}return{c(){for(let i=0;i<each_blocks.length;i+=1){each_blocks[i].c();}each_1_anchor=empty();},m(target,anchor){for(let i=0;i<each_blocks.length;i+=1){each_blocks[i].m(target,anchor);}insert(target,each_1_anchor,anchor);current=true;},p(ctx,[dirty]){if(dirty&/*children, isString*/1){const each_value=/*children*/ctx[0];group_outros();each_blocks=update_keyed_each(each_blocks,dirty,get_key,1,ctx,each_value,each_1_lookup,each_1_anchor.parentNode,outro_and_destroy_block,create_each_block$2,each_1_anchor,get_each_context$2);check_outros();}},i(local){if(current)return;for(let i=0;i<each_value.length;i+=1){transition_in(each_blocks[i]);}current=true;},o(local){for(let i=0;i<each_blocks.length;i+=1){transition_out(each_blocks[i]);}current=false;},d(detaching){for(let i=0;i<each_blocks.length;i+=1){each_blocks[i].d(detaching);}if(detaching)detach(each_1_anchor);}};}function instance$a($$self,$$props,$$invalidate){let{items}=$$props;let{discardEmptyItems=true}=$$props;const shouldRenderItem=item=>{// don't render falsy items\nif(!item)return false;// get relevant props\nconst[node,,,children]=item;// if item is component, we always render it\nif(!isString(node))return true;// item is tag, we have to check if children are empty\nreturn children.some(shouldRenderItem);};$$self.$$set=$$props=>{if(\"items\"in $$props)$$invalidate(1,items=$$props.items);if(\"discardEmptyItems\"in $$props)$$invalidate(2,discardEmptyItems=$$props.discardEmptyItems);};let children;$$self.$$.update=()=>{if($$self.$$.dirty&/*items, discardEmptyItems*/6){$$invalidate(0,children=(items&&discardEmptyItems?items.filter(shouldRenderItem):items)||[]);}};return[children,items,discardEmptyItems];}class DynamicComponentTree_1 extends SvelteComponent{constructor(options){super();init(this,options,instance$a,create_fragment$a,safe_not_equal,{items:1,discardEmptyItems:2});}}const ImageStoreProps=['file','size','loadState','processState','cropAspectRatio','cropLimitToImage','crop','cropMinSize','cropMaxSize','cropRange','cropOrigin','cropRectAspectRatio','rotation','rotationRange','targetSize','flipX','flipY','perspectiveX','perspectiveY','perspective','colorMatrix','convolutionMatrix','gamma','vignette','noise','decoration','annotation','backgroundColor','state'];const proxy=function(get,set,update){let subscribers=[];return{set,update,publish:value=>{subscribers.forEach(cb=>cb(value));},subscribe:cb=>{subscribers.push(cb);get(cb);return()=>{subscribers=subscribers.filter(item=>item!==cb);};}};};var createImageProxy=()=>{let unsubs;let image;const proxyStores=ImageStoreProps.reduce((prev,curr)=>{prev[curr]=proxy(// getter\ncb=>{// subscribe\nif(!image)return cb();const unsub=image.stores[curr].subscribe(cb);unsub();},// setter\nvalue=>{// set value on actual store if is defined\nif(!image)return;image.stores[curr].set(value);},// updater\ncb=>{if(!image)return;image.stores[curr].update(cb);});return prev;},{});const update=newImage=>{image=newImage;if(unsubs){// remove subscribers\nunsubs.forEach(unsub=>unsub());unsubs=undefined;}if(!newImage){// need to reset load state\nproxyStores['file'].publish(undefined);proxyStores['loadState'].publish(undefined);return;}unsubs=ImageStoreProps.map(prop=>newImage.stores[prop].subscribe(value=>proxyStores[prop].publish(value)));};return{update,stores:proxyStores};};var createPingRouter=(route,cancel=true)=>e=>{if(e.type!=='ping')return;if(cancel)e.stopPropagation();route(e.detail.type,e.detail.data);};var isTextarea=element=>/textarea/i.test(element.nodeName);var isTextInput=node=>/date|email|number|search|text|url/.test(node.type);var isTextField=node=>isTextarea(node)||isTextInput(node);var toKebabCase=(str,abbr)=>{return(abbr?stringReplace(str,abbr):str).replace(/([a-z])([A-Z])/g,'$1-$2').replace(/\\s+/g,'-').toLowerCase();};var matchMedia$1=(query,cb)=>{const mql=matchMedia(query);mql.addListener(cb);cb(mql);return{get matches(){return mql.matches;},destroy:()=>mql.removeListener(cb)};};var mediaQueryStore=(query,formatValue=passthrough)=>{const{subscribe,set}=writable(undefined);const mm=matchMedia$1(query,({matches})=>set(formatValue(matches)));return{subscribe,unsubscribe:mm.destroy};};var canPreventNavSwipe=()=>{// if not iOS we can't prevent swipe because it probably isn't a thing\nif(!isIOS())return false;// extract version number\nconst matches=navigator.userAgent.match(/OS (\\d+)_(\\d+)_?(\\d+)?/i)||[];const[,major,minor]=matches.map(v=>parseInt(v,10)||0);// is atleast version 13.4+\nreturn major>13||major===13&&minor>=4;};var calculateImageTransforms=(stageRect,rootRect,imageSize,cropRect,imageSelectionRect,imageScale,imagePerspectiveX,imagePerspectiveY,imageRotation,imageFlipX,imageFlipY)=>{if(!stageRect||!rootRect||!imageSize||!cropRect||!imageScale)return undefined;const viewRect=rectNormalizeOffset(rectClone(rootRect));const viewCenter=rectCenter(viewRect);const stageCenter=rectCenter(stageRect);const imageRect=rectCreateFromSize(imageSize);const imageCenter=rectCenter(imageRect);const imagePerspective=vectorCreate(imagePerspectiveX,imagePerspectiveY);// get base crop rect so we can correctly apply transforms\nconst cropRectBase=getBaseCropRect(imageSize,cropRect,imageRotation,imagePerspective);const cropRectBaseCenter=rectCenter(cropRectBase);const imageTranslation=vectorSubtract(vectorClone(imageCenter),cropRectBaseCenter);// calculate stage center offset from view center\nconst imageOffset=vectorSubtract(vectorClone(stageCenter),viewCenter);// correct for stage offset\nimageTranslation.x+=imageOffset.x;imageTranslation.y+=imageOffset.y;// set origin of translation (so rotates around center of selection)\nconst imageOrigin=vectorInvert(vectorClone(imageTranslation));// correct for stage offset\nimageOrigin.x+=imageOffset.x;imageOrigin.y+=imageOffset.y;// correct for image selection offset relative to view\nconst imageSelectionCenter=rectCenter(rectTranslate(rectClone(imageSelectionRect),stageRect));const imageSelectionOffset=vectorSubtract(imageSelectionCenter,stageCenter);vectorAdd(imageTranslation,imageSelectionOffset);return{// offset: imageOffset,\norigin:imageOrigin,translation:imageTranslation,rotation:{x:imageFlipY?Math.PI:0,y:imageFlipX?Math.PI:0,z:imageRotation},perspective:imagePerspective,scale:imageScale};};// @ts-ignore\nvar historyCreate=(getState,setState)=>{// set up pub/sub for history object\nconst{sub,pub}=pubsub();// current history state\nlet baseState;const entries=[];const index=writable(-1);const subs=[];const updateSubs=()=>subs.forEach(cb=>cb({index:get_store_value(index),length:entries.length}));const history={get index(){return get_store_value(index);},set index(i){// validate new index\ni=Number.isInteger(i)?i:-1;i=clamp(i,-1,entries.length-1);// remember\nindex.set(i);setState(entries[history.index]||baseState);// update subs\nupdateSubs();},get state(){return entries[entries.length-1]||baseState;},length(){return entries.length;},undo(){const newIndex=history.index--;pub('undo',newIndex);return newIndex;},redo(){const newIndex=history.index++;pub('redo',history.index);return newIndex;},revert(){entries.length=0;history.index=-1;pub('revert');},write(){// reset length to current index\nentries.length=history.index+1;// add new entry\nentries.push(getState());// move pointer to last added index\nindex.set(entries.length-1);updateSubs();},set(state={}){baseState=state;},subscribe(cb){subs.push(cb);cb({index:history.index,length:entries.length});return()=>subs.splice(subs.indexOf(cb),1);},on:sub};return history;};var isChrome=()=>isBrowser()&&!!window['chrome'];var imageBitmapToImageData=async imageBitmap=>canvasToImageData(await imageDataToCanvas(imageBitmap));var blobToImageBitmap=(file,ImageOrienter,canvasMemoryLimit)=>new Promise(async(resolve,reject)=>{// get orientation of image, should return 1 for normal orientation\nconst orientation=await ImageOrienter.read(file);// helper method to apply orientation fix if needed\nconst toImageData=file=>blobToImageData(file,canvasMemoryLimit).then(imageData=>ImageOrienter.apply(imageData,orientation)).then(resolve).catch(reject);// cannot create image bitmaps in worker\nif(!canCreateImageBitmap()||isSVGFile(file))return toImageData(file);// create image bitmap in thread\nlet imageBitmap;try{imageBitmap=await thread((file,done)=>createImageBitmap(file).then(bitmap=>done(null,bitmap)).catch(done),[file]);}catch(err){// fails silently on purpose, we'll try to turn the blob into image data in the main thread\n// console.error(err);\n}// no bitmap returned, something went wrong in `createImageBitmap` logic\nif(!imageBitmap||!imageBitmap.width)return toImageData(file);// if the browser can't orient images, we need to correct the orientation now\nif(!(await canOrientImages()))return resolve(ImageOrienter.apply(imageBitmap,orientation));// need to convert so oriented image can be used as WebGL texture\n// converting ImageBitmap to <canvas> (and then optionally to image data) fixes a Chrome render bug where the\n// ImageBitmap when used in WebGL doesn't render in the correct orientation\n// https://bugs.chromium.org/p/chromium/issues/detail?id=1082451&q=orientation%20imagebitmap&can=2\nif(isChrome()&&orientation>1)return resolve(await imageBitmapToImageData(imageBitmap));// yay we got our bitmap\nresolve(imageBitmap);});var imageDataContain=(imageData,size)=>new Promise(async resolve=>{if(imageData.width<size.width&&imageData.height<size.height)return resolve(imageData);const scalar=Math.min(size.width/imageData.width,size.height/imageData.height);// scale\nconst targetWidth=scalar*imageData.width;const targetHeight=scalar*imageData.height;const canvas=h('canvas',{width:targetWidth,height:targetHeight});const ctx=canvas.getContext('2d');const data=isImageData(imageData)?await imageDataToCanvas(imageData):imageData;ctx.drawImage(data,0,0,targetWidth,targetHeight);resolve(canvasToImageData(canvas));});let limit=null;var getWebGLTextureSizeLimit=()=>{if(limit!==null)return limit;const canvas=h('canvas');const gl=getWebGLContext(canvas);limit=gl?gl.getParameter(gl.MAX_TEXTURE_SIZE):undefined;releaseCanvas(canvas);return limit;};var getDevicePixelRatio=()=>isBrowser()&&window.devicePixelRatio||1;var hexToRGB=str=>{const[,q,w,e]=str.split('');str=str.length===4?`#${q}${q}${w}${w}${e}${e}`:str;const[,r,g,b]=/^#?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})$/i.exec(str);return[r,g,b].map(v=>parseInt(v,16)/255);};var colorStringToColorArray=color=>{// if rgba(128, 128, 128, .5)\nif(/^rgba/.test(color)){return color.substr(5).split(',').map(parseFloat).map((v,i)=>v/(i===3?1:255));}// if rgb(128, 128, 128)\nif(/^rgb/.test(color)){return color.substr(4).split(',').map(parseFloat).map(v=>v/255);}// if #777\nif(/^#/.test(color)){return hexToRGB(color);}};var isDarkColor=color=>{return color[0]<0.25&&color[1]<0.25&&color[2]<0.25;};let result$9=null;var supportsWebGL=()=>{if(result$9===null){const canvas=h('canvas');result$9=!!getWebGLContext(canvas);releaseCanvas(canvas);}return result$9;};/* src/core/ui/index.svelte generated by Svelte v3.29.4 */function create_if_block$2(ctx){let t;let if_block1_anchor;let current;let if_block0=/*isStatusVisible*/ctx[47]&&create_if_block_5(ctx);let if_block1=/*$imagePreview*/ctx[38]&&!/*isSupportsError*/ctx[32]&&create_if_block_1$1(ctx);return{c(){if(if_block0)if_block0.c();t=space();if(if_block1)if_block1.c();if_block1_anchor=empty();},m(target,anchor){if(if_block0)if_block0.m(target,anchor);insert(target,t,anchor);if(if_block1)if_block1.m(target,anchor);insert(target,if_block1_anchor,anchor);current=true;},p(ctx,dirty){if(/*isStatusVisible*/ctx[47]){if(if_block0){if_block0.p(ctx,dirty);if(dirty[1]&/*isStatusVisible*/65536){transition_in(if_block0,1);}}else{if_block0=create_if_block_5(ctx);if_block0.c();transition_in(if_block0,1);if_block0.m(t.parentNode,t);}}else if(if_block0){group_outros();transition_out(if_block0,1,1,()=>{if_block0=null;});check_outros();}if(/*$imagePreview*/ctx[38]&&!/*isSupportsError*/ctx[32]){if(if_block1){if_block1.p(ctx,dirty);if(dirty[1]&/*$imagePreview, isSupportsError*/130){transition_in(if_block1,1);}}else{if_block1=create_if_block_1$1(ctx);if_block1.c();transition_in(if_block1,1);if_block1.m(if_block1_anchor.parentNode,if_block1_anchor);}}else if(if_block1){group_outros();transition_out(if_block1,1,1,()=>{if_block1=null;});check_outros();}},i(local){if(current)return;transition_in(if_block0);transition_in(if_block1);current=true;},o(local){transition_out(if_block0);transition_out(if_block1);current=false;},d(detaching){if(if_block0)if_block0.d(detaching);if(detaching)detach(t);if(if_block1)if_block1.d(detaching);if(detaching)detach(if_block1_anchor);}};}// (1410:2) {#if isStatusVisible}\nfunction create_if_block_5(ctx){let div;let p;let current_block_type_index;let if_block;let p_style_value;let div_style_value;let current;const if_block_creators=[create_if_block_6,create_if_block_7,create_if_block_9];const if_blocks=[];function select_block_type(ctx,dirty){if(/*isSupportsError*/ctx[32])return 0;if(/*isWaitingForImage*/ctx[34]||/*isImageLoadError*/ctx[33]||/*isLoadingImageData*/ctx[36]||/*isCreatingImagePreview*/ctx[37])return 1;if(/*isProcessingImage*/ctx[39]&&/*imageProcessStatusLabel*/ctx[42])return 2;return-1;}if(~(current_block_type_index=select_block_type(ctx))){if_block=if_blocks[current_block_type_index]=if_block_creators[current_block_type_index](ctx);}return{c(){div=element(\"div\");p=element(\"p\");if(if_block)if_block.c();attr(p,\"style\",p_style_value=`transform: translateX(${/*$statusOffsetX*/ctx[48]}px)`);attr(div,\"class\",\"DokaStatus\");attr(div,\"style\",div_style_value=`opacity: ${/*$statusOpacity*/ctx[46]}`);},m(target,anchor){insert(target,div,anchor);append(div,p);if(~current_block_type_index){if_blocks[current_block_type_index].m(p,null);}current=true;},p(ctx,dirty){let previous_block_index=current_block_type_index;current_block_type_index=select_block_type(ctx);if(current_block_type_index===previous_block_index){if(~current_block_type_index){if_blocks[current_block_type_index].p(ctx,dirty);}}else{if(if_block){group_outros();transition_out(if_blocks[previous_block_index],1,1,()=>{if_blocks[previous_block_index]=null;});check_outros();}if(~current_block_type_index){if_block=if_blocks[current_block_type_index];if(!if_block){if_block=if_blocks[current_block_type_index]=if_block_creators[current_block_type_index](ctx);if_block.c();}transition_in(if_block,1);if_block.m(p,null);}else{if_block=null;}}if(!current||dirty[1]&/*$statusOffsetX*/131072&&p_style_value!==(p_style_value=`transform: translateX(${/*$statusOffsetX*/ctx[48]}px)`)){attr(p,\"style\",p_style_value);}if(!current||dirty[1]&/*$statusOpacity*/32768&&div_style_value!==(div_style_value=`opacity: ${/*$statusOpacity*/ctx[46]}`)){attr(div,\"style\",div_style_value);}},i(local){if(current)return;transition_in(if_block);current=true;},o(local){transition_out(if_block);current=false;},d(detaching){if(detaching)detach(div);if(~current_block_type_index){if_blocks[current_block_type_index].d();}}};}// (1433:58) \nfunction create_if_block_9(ctx){let statusmessage;let t0;let statusprogress;let t1;let if_block_anchor;let current;statusmessage=new StatusMessage({props:{text:/*imageProcessStatusLabel*/ctx[42],onmeasure:/*offsetProgress*/ctx[106]}});statusprogress=new StatusProgress({props:{offset:/*$progressOffsetX*/ctx[49],visible:/*imageProcessShowProgressIndicator*/ctx[44],progress:/*imageProcessProgress*/ctx[43]}});let if_block=/*isImageProcessingError*/ctx[45]&&create_if_block_10(ctx);return{c(){create_component(statusmessage.$$.fragment);t0=space();create_component(statusprogress.$$.fragment);t1=space();if(if_block)if_block.c();if_block_anchor=empty();},m(target,anchor){mount_component(statusmessage,target,anchor);insert(target,t0,anchor);mount_component(statusprogress,target,anchor);insert(target,t1,anchor);if(if_block)if_block.m(target,anchor);insert(target,if_block_anchor,anchor);current=true;},p(ctx,dirty){const statusmessage_changes={};if(dirty[1]&/*imageProcessStatusLabel*/2048)statusmessage_changes.text=/*imageProcessStatusLabel*/ctx[42];statusmessage.$set(statusmessage_changes);const statusprogress_changes={};if(dirty[1]&/*$progressOffsetX*/262144)statusprogress_changes.offset=/*$progressOffsetX*/ctx[49];if(dirty[1]&/*imageProcessShowProgressIndicator*/8192)statusprogress_changes.visible=/*imageProcessShowProgressIndicator*/ctx[44];if(dirty[1]&/*imageProcessProgress*/4096)statusprogress_changes.progress=/*imageProcessProgress*/ctx[43];statusprogress.$set(statusprogress_changes);if(/*isImageProcessingError*/ctx[45]){if(if_block){if_block.p(ctx,dirty);if(dirty[1]&/*isImageProcessingError*/16384){transition_in(if_block,1);}}else{if_block=create_if_block_10(ctx);if_block.c();transition_in(if_block,1);if_block.m(if_block_anchor.parentNode,if_block_anchor);}}else if(if_block){group_outros();transition_out(if_block,1,1,()=>{if_block=null;});check_outros();}},i(local){if(current)return;transition_in(statusmessage.$$.fragment,local);transition_in(statusprogress.$$.fragment,local);transition_in(if_block);current=true;},o(local){transition_out(statusmessage.$$.fragment,local);transition_out(statusprogress.$$.fragment,local);transition_out(if_block);current=false;},d(detaching){destroy_component(statusmessage,detaching);if(detaching)detach(t0);destroy_component(statusprogress,detaching);if(detaching)detach(t1);if(if_block)if_block.d(detaching);if(detaching)detach(if_block_anchor);}};}// (1422:99) \nfunction create_if_block_7(ctx){let statusmessage;let t0;let statusprogress;let t1;let if_block_anchor;let current;statusmessage=new StatusMessage({props:{text:/*imageLoadStatusLabel*/ctx[41],onmeasure:/*offsetProgress*/ctx[106]}});statusprogress=new StatusProgress({props:{offset:/*$progressOffsetX*/ctx[49],visible:/*imageLoadShowProgressIndicator*/ctx[40],progress:/*imageLoadProgress*/ctx[35]}});let if_block=/*isImageLoadError*/ctx[33]&&create_if_block_8(ctx);return{c(){create_component(statusmessage.$$.fragment);t0=space();create_component(statusprogress.$$.fragment);t1=space();if(if_block)if_block.c();if_block_anchor=empty();},m(target,anchor){mount_component(statusmessage,target,anchor);insert(target,t0,anchor);mount_component(statusprogress,target,anchor);insert(target,t1,anchor);if(if_block)if_block.m(target,anchor);insert(target,if_block_anchor,anchor);current=true;},p(ctx,dirty){const statusmessage_changes={};if(dirty[1]&/*imageLoadStatusLabel*/1024)statusmessage_changes.text=/*imageLoadStatusLabel*/ctx[41];statusmessage.$set(statusmessage_changes);const statusprogress_changes={};if(dirty[1]&/*$progressOffsetX*/262144)statusprogress_changes.offset=/*$progressOffsetX*/ctx[49];if(dirty[1]&/*imageLoadShowProgressIndicator*/512)statusprogress_changes.visible=/*imageLoadShowProgressIndicator*/ctx[40];if(dirty[1]&/*imageLoadProgress*/16)statusprogress_changes.progress=/*imageLoadProgress*/ctx[35];statusprogress.$set(statusprogress_changes);if(/*isImageLoadError*/ctx[33]){if(if_block){if_block.p(ctx,dirty);if(dirty[1]&/*isImageLoadError*/4){transition_in(if_block,1);}}else{if_block=create_if_block_8(ctx);if_block.c();transition_in(if_block,1);if_block.m(if_block_anchor.parentNode,if_block_anchor);}}else if(if_block){group_outros();transition_out(if_block,1,1,()=>{if_block=null;});check_outros();}},i(local){if(current)return;transition_in(statusmessage.$$.fragment,local);transition_in(statusprogress.$$.fragment,local);transition_in(if_block);current=true;},o(local){transition_out(statusmessage.$$.fragment,local);transition_out(statusprogress.$$.fragment,local);transition_out(if_block);current=false;},d(detaching){destroy_component(statusmessage,detaching);if(detaching)detach(t0);destroy_component(statusprogress,detaching);if(detaching)detach(t1);if(if_block)if_block.d(detaching);if(detaching)detach(if_block_anchor);}};}// (1414:3) {#if isSupportsError}\nfunction create_if_block_6(ctx){let statusmessage;let t;let span;let icon;let span_style_value;let current;statusmessage=new StatusMessage({props:{text:/*isSupportsError*/ctx[32],onmeasure:/*offsetProgress*/ctx[106]}});icon=new Icon({props:{$$slots:{default:[create_default_slot_4]},$$scope:{ctx}}});return{c(){create_component(statusmessage.$$.fragment);t=space();span=element(\"span\");create_component(icon.$$.fragment);attr(span,\"class\",\"DokaStatusIcon\");attr(span,\"style\",span_style_value=`transform: translateX(${/*$progressOffsetX*/ctx[49]}px)`);},m(target,anchor){mount_component(statusmessage,target,anchor);insert(target,t,anchor);insert(target,span,anchor);mount_component(icon,span,null);current=true;},p(ctx,dirty){const statusmessage_changes={};if(dirty[1]&/*isSupportsError*/2)statusmessage_changes.text=/*isSupportsError*/ctx[32];statusmessage.$set(statusmessage_changes);const icon_changes={};if(dirty[0]&/*locale*/4|dirty[8]&/*$$scope*/4096){icon_changes.$$scope={dirty,ctx};}icon.$set(icon_changes);if(!current||dirty[1]&/*$progressOffsetX*/262144&&span_style_value!==(span_style_value=`transform: translateX(${/*$progressOffsetX*/ctx[49]}px)`)){attr(span,\"style\",span_style_value);}},i(local){if(current)return;transition_in(statusmessage.$$.fragment,local);transition_in(icon.$$.fragment,local);current=true;},o(local){transition_out(statusmessage.$$.fragment,local);transition_out(icon.$$.fragment,local);current=false;},d(detaching){destroy_component(statusmessage,detaching);if(detaching)detach(t);if(detaching)detach(span);destroy_component(icon);}};}// (1438:4) {#if isImageProcessingError}\nfunction create_if_block_10(ctx){let span;let button;let span_style_value;let current;button=new Button({props:{onclick:/*handleCloseImageProcessError*/ctx[108],label:/*locale*/ctx[2].statusLabelButtonClose,icon:/*locale*/ctx[2].statusIconButtonClose,hideLabel:true}});return{c(){span=element(\"span\");create_component(button.$$.fragment);attr(span,\"class\",\"DokaStatusButton\");attr(span,\"style\",span_style_value=`transform: translateX(${/*$progressOffsetX*/ctx[49]}px)`);},m(target,anchor){insert(target,span,anchor);mount_component(button,span,null);current=true;},p(ctx,dirty){const button_changes={};if(dirty[0]&/*locale*/4)button_changes.label=/*locale*/ctx[2].statusLabelButtonClose;if(dirty[0]&/*locale*/4)button_changes.icon=/*locale*/ctx[2].statusIconButtonClose;button.$set(button_changes);if(!current||dirty[1]&/*$progressOffsetX*/262144&&span_style_value!==(span_style_value=`transform: translateX(${/*$progressOffsetX*/ctx[49]}px)`)){attr(span,\"style\",span_style_value);}},i(local){if(current)return;transition_in(button.$$.fragment,local);current=true;},o(local){transition_out(button.$$.fragment,local);current=false;},d(detaching){if(detaching)detach(span);destroy_component(button);}};}// (1427:4) {#if isImageLoadError}\nfunction create_if_block_8(ctx){let span;let button;let span_style_value;let current;button=new Button({props:{onclick:/*handleCloseImageLoadError*/ctx[107],label:/*locale*/ctx[2].statusLabelButtonClose,icon:/*locale*/ctx[2].statusIconButtonClose,hideLabel:true}});return{c(){span=element(\"span\");create_component(button.$$.fragment);attr(span,\"class\",\"DokaStatusButton\");attr(span,\"style\",span_style_value=`transform: translateX(${/*$progressOffsetX*/ctx[49]}px)`);},m(target,anchor){insert(target,span,anchor);mount_component(button,span,null);current=true;},p(ctx,dirty){const button_changes={};if(dirty[0]&/*locale*/4)button_changes.label=/*locale*/ctx[2].statusLabelButtonClose;if(dirty[0]&/*locale*/4)button_changes.icon=/*locale*/ctx[2].statusIconButtonClose;button.$set(button_changes);if(!current||dirty[1]&/*$progressOffsetX*/262144&&span_style_value!==(span_style_value=`transform: translateX(${/*$progressOffsetX*/ctx[49]}px)`)){attr(span,\"style\",span_style_value);}},i(local){if(current)return;transition_in(button.$$.fragment,local);current=true;},o(local){transition_out(button.$$.fragment,local);current=false;},d(detaching){if(detaching)detach(span);destroy_component(button);}};}// (1419:5) <Icon>\nfunction create_default_slot_4(ctx){let g;let raw_value=/*locale*/ctx[2].iconSupportError+\"\";return{c(){g=svg_element(\"g\");},m(target,anchor){insert(target,g,anchor);g.innerHTML=raw_value;},p(ctx,dirty){if(dirty[0]&/*locale*/4&&raw_value!==(raw_value=/*locale*/ctx[2].iconSupportError+\"\"))g.innerHTML=raw_value;},d(detaching){if(detaching)detach(g);}};}// (1449:2) {#if $imagePreview && !isSupportsError}\nfunction create_if_block_1$1(ctx){let t0;let t1;let current_block_type_index;let if_block2;let t2;let canvas;let t3;let div;let current;let if_block0=/*enableToolbar*/ctx[6]&&create_if_block_4(ctx);let if_block1=/*shouldRenderTabs*/ctx[16]&&/*showUtils*/ctx[14]&&create_if_block_3(ctx);const if_block_creators=[create_if_block_2,create_else_block$1];const if_blocks=[];function select_block_type_1(ctx,dirty){if(/*shouldRenderTabs*/ctx[16])return 0;return 1;}current_block_type_index=select_block_type_1(ctx);if_block2=if_blocks[current_block_type_index]=if_block_creators[current_block_type_index](ctx);canvas=new Canvas({props:{animate:/*shouldAnimate*/ctx[18],pixelRatio:/*$pixelRatio*/ctx[56],backgroundColor:/*$rootBackgroundColor*/ctx[28],maskRect:/*$imageSelectionRectPresentation*/ctx[31],imageSize:/*$imageSize*/ctx[17],imageData:/*$imagePreview*/ctx[38],imageProps:/*imageProps*/ctx[30],imagePreviews:/*$imagePreviews*/ctx[57],loadImageData:/*imageSourceToImageData*/ctx[8],willRender:/*func_2*/ctx[152]}});return{c(){if(if_block0)if_block0.c();t0=space();if(if_block1)if_block1.c();t1=space();if_block2.c();t2=space();create_component(canvas.$$.fragment);t3=space();div=element(\"div\");attr(div,\"class\",\"DokaRootPortal\");},m(target,anchor){if(if_block0)if_block0.m(target,anchor);insert(target,t0,anchor);if(if_block1)if_block1.m(target,anchor);insert(target,t1,anchor);if_blocks[current_block_type_index].m(target,anchor);insert(target,t2,anchor);mount_component(canvas,target,anchor);insert(target,t3,anchor);insert(target,div,anchor);/*div_binding*/ctx[153](div);current=true;},p(ctx,dirty){if(/*enableToolbar*/ctx[6]){if(if_block0){if_block0.p(ctx,dirty);if(dirty[0]&/*enableToolbar*/64){transition_in(if_block0,1);}}else{if_block0=create_if_block_4(ctx);if_block0.c();transition_in(if_block0,1);if_block0.m(t0.parentNode,t0);}}else if(if_block0){group_outros();transition_out(if_block0,1,1,()=>{if_block0=null;});check_outros();}if(/*shouldRenderTabs*/ctx[16]&&/*showUtils*/ctx[14]){if(if_block1){if_block1.p(ctx,dirty);if(dirty[0]&/*shouldRenderTabs, showUtils*/81920){transition_in(if_block1,1);}}else{if_block1=create_if_block_3(ctx);if_block1.c();transition_in(if_block1,1);if_block1.m(t1.parentNode,t1);}}else if(if_block1){group_outros();transition_out(if_block1,1,1,()=>{if_block1=null;});check_outros();}let previous_block_index=current_block_type_index;current_block_type_index=select_block_type_1(ctx);if(current_block_type_index===previous_block_index){if_blocks[current_block_type_index].p(ctx,dirty);}else{group_outros();transition_out(if_blocks[previous_block_index],1,1,()=>{if_blocks[previous_block_index]=null;});check_outros();if_block2=if_blocks[current_block_type_index];if(!if_block2){if_block2=if_blocks[current_block_type_index]=if_block_creators[current_block_type_index](ctx);if_block2.c();}transition_in(if_block2,1);if_block2.m(t2.parentNode,t2);}const canvas_changes={};if(dirty[0]&/*shouldAnimate*/262144)canvas_changes.animate=/*shouldAnimate*/ctx[18];if(dirty[1]&/*$pixelRatio*/33554432)canvas_changes.pixelRatio=/*$pixelRatio*/ctx[56];if(dirty[0]&/*$rootBackgroundColor*/268435456)canvas_changes.backgroundColor=/*$rootBackgroundColor*/ctx[28];if(dirty[1]&/*$imageSelectionRectPresentation*/1)canvas_changes.maskRect=/*$imageSelectionRectPresentation*/ctx[31];if(dirty[0]&/*$imageSize*/131072)canvas_changes.imageSize=/*$imageSize*/ctx[17];if(dirty[1]&/*$imagePreview*/128)canvas_changes.imageData=/*$imagePreview*/ctx[38];if(dirty[0]&/*imageProps*/1073741824)canvas_changes.imageProps=/*imageProps*/ctx[30];if(dirty[1]&/*$imagePreviews*/67108864)canvas_changes.imagePreviews=/*$imagePreviews*/ctx[57];if(dirty[0]&/*imageSourceToImageData*/256)canvas_changes.loadImageData=/*imageSourceToImageData*/ctx[8];if(dirty[0]&/*willRenderCanvas*/32|dirty[1]&/*$imageDecoration, $imageAnnotation, $imageOverlay*/939524096)canvas_changes.willRender=/*func_2*/ctx[152];canvas.$set(canvas_changes);},i(local){if(current)return;transition_in(if_block0);transition_in(if_block1);transition_in(if_block2);transition_in(canvas.$$.fragment,local);current=true;},o(local){transition_out(if_block0);transition_out(if_block1);transition_out(if_block2);transition_out(canvas.$$.fragment,local);current=false;},d(detaching){if(if_block0)if_block0.d(detaching);if(detaching)detach(t0);if(if_block1)if_block1.d(detaching);if(detaching)detach(t1);if_blocks[current_block_type_index].d(detaching);if(detaching)detach(t2);destroy_component(canvas,detaching);if(detaching)detach(t3);if(detaching)detach(div);/*div_binding*/ctx[153](null);}};}// (1451:3) {#if enableToolbar}\nfunction create_if_block_4(ctx){let div;let dynamiccomponenttree;let measurable_action;let current;let mounted;let dispose;dynamiccomponenttree=new DynamicComponentTree_1({props:{items:/*toolbarItems*/ctx[51]}});return{c(){div=element(\"div\");create_component(dynamiccomponenttree.$$.fragment);attr(div,\"class\",\"DokaNav DokaNavTools\");},m(target,anchor){insert(target,div,anchor);mount_component(dynamiccomponenttree,div,null);current=true;if(!mounted){dispose=[listen(div,\"measure\",/*measure_handler*/ctx[137]),action_destroyer(measurable_action=measurable.call(null,div))];mounted=true;}},p(ctx,dirty){const dynamiccomponenttree_changes={};if(dirty[1]&/*toolbarItems*/1048576)dynamiccomponenttree_changes.items=/*toolbarItems*/ctx[51];dynamiccomponenttree.$set(dynamiccomponenttree_changes);},i(local){if(current)return;transition_in(dynamiccomponenttree.$$.fragment,local);current=true;},o(local){transition_out(dynamiccomponenttree.$$.fragment,local);current=false;},d(detaching){if(detaching)detach(div);destroy_component(dynamiccomponenttree);mounted=false;run_all(dispose);}};}// (1457:3) {#if shouldRenderTabs && showUtils }\nfunction create_if_block_3(ctx){let div;let scrollable;let current;scrollable=new Scrollable({props:{elasticity:/*elasticityMultiplier*/ctx[4]*scrollElasticity,scrollDirection:/*isLandscape*/ctx[27]?\"y\":\"x\",$$slots:{default:[create_default_slot_1]},$$scope:{ctx}}});return{c(){div=element(\"div\");create_component(scrollable.$$.fragment);attr(div,\"class\",\"DokaNav DokaNavMain\");},m(target,anchor){insert(target,div,anchor);mount_component(scrollable,div,null);current=true;},p(ctx,dirty){const scrollable_changes={};if(dirty[0]&/*elasticityMultiplier*/16)scrollable_changes.elasticity=/*elasticityMultiplier*/ctx[4]*scrollElasticity;if(dirty[0]&/*isLandscape*/134217728)scrollable_changes.scrollDirection=/*isLandscape*/ctx[27]?\"y\":\"x\";if(dirty[0]&/*tabsConfig, tabs, utilSelected*/27262976|dirty[8]&/*$$scope*/4096){scrollable_changes.$$scope={dirty,ctx};}scrollable.$set(scrollable_changes);},i(local){if(current)return;transition_in(scrollable.$$.fragment,local);current=true;},o(local){transition_out(scrollable.$$.fragment,local);current=false;},d(detaching){if(detaching)detach(div);destroy_component(scrollable);}};}// (1461:6) <Icon>\nfunction create_default_slot_3(ctx){let g;let raw_value=/*tab*/ctx[259].icon+\"\";return{c(){g=svg_element(\"g\");},m(target,anchor){insert(target,g,anchor);g.innerHTML=raw_value;},p(ctx,dirty){if(dirty[8]&/*tab*/2048&&raw_value!==(raw_value=/*tab*/ctx[259].icon+\"\"))g.innerHTML=raw_value;},d(detaching){if(detaching)detach(g);}};}// (1460:5) <TabList {...tabsConfig} {tabs} on:select={({ detail }) => utilSelected = detail} let:tab={tab}>\nfunction create_default_slot_2(ctx){let icon;let t0;let span;let t1_value=/*tab*/ctx[259].label+\"\";let t1;let current;icon=new Icon({props:{$$slots:{default:[create_default_slot_3]},$$scope:{ctx}}});return{c(){create_component(icon.$$.fragment);t0=space();span=element(\"span\");t1=text(t1_value);},m(target,anchor){mount_component(icon,target,anchor);insert(target,t0,anchor);insert(target,span,anchor);append(span,t1);current=true;},p(ctx,dirty){const icon_changes={};if(dirty[8]&/*$$scope, tab*/6144){icon_changes.$$scope={dirty,ctx};}icon.$set(icon_changes);if((!current||dirty[8]&/*tab*/2048)&&t1_value!==(t1_value=/*tab*/ctx[259].label+\"\"))set_data(t1,t1_value);},i(local){if(current)return;transition_in(icon.$$.fragment,local);current=true;},o(local){transition_out(icon.$$.fragment,local);current=false;},d(detaching){destroy_component(icon,detaching);if(detaching)detach(t0);if(detaching)detach(span);}};}// (1459:4) <Scrollable elasticity={elasticityMultiplier * scrollElasticity} scrollDirection={isLandscape ? 'y' : 'x'}>\nfunction create_default_slot_1(ctx){let tablist;let current;const tablist_spread_levels=[/*tabsConfig*/ctx[23],{tabs:/*tabs*/ctx[24]}];let tablist_props={$$slots:{default:[create_default_slot_2,({tab})=>({259:tab}),({tab})=>[0,0,0,0,0,0,0,0,tab?2048:0]]},$$scope:{ctx}};for(let i=0;i<tablist_spread_levels.length;i+=1){tablist_props=assign(tablist_props,tablist_spread_levels[i]);}tablist=new TabList({props:tablist_props});tablist.$on(\"select\",/*select_handler*/ctx[138]);return{c(){create_component(tablist.$$.fragment);},m(target,anchor){mount_component(tablist,target,anchor);current=true;},p(ctx,dirty){const tablist_changes=dirty[0]&/*tabsConfig, tabs*/25165824?get_spread_update(tablist_spread_levels,[dirty[0]&/*tabsConfig*/8388608&&get_spread_object(/*tabsConfig*/ctx[23]),dirty[0]&/*tabs*/16777216&&{tabs:/*tabs*/ctx[24]}]):{};if(dirty[8]&/*$$scope, tab*/6144){tablist_changes.$$scope={dirty,ctx};}tablist.$set(tablist_changes);},i(local){if(current)return;transition_in(tablist.$$.fragment,local);current=true;},o(local){transition_out(tablist.$$.fragment,local);current=false;},d(detaching){destroy_component(tablist,detaching);}};}// (1481:3) {:else}\nfunction create_else_block$1(ctx){let panel;let updating_component;let current;function panel_component_binding_1(value){/*panel_component_binding_1*/ctx[147].call(null,value);}let panel_props={class:\"DokaMain\",content:_objectSpread(_objectSpread({},/*utilsMerged*/ctx[20].find(/*func_1*/ctx[146])),{},{props:/*pluginOptions*/ctx[7][/*utilSelected*/ctx[21]]}),locale:/*locale*/ctx[2],stores:/*utilStores*/ctx[101]};if(/*pluginInterface*/ctx[0][/*utilSelected*/ctx[21]]!==void 0){panel_props.component=/*pluginInterface*/ctx[0][/*utilSelected*/ctx[21]];}panel=new Panel({props:panel_props});binding_callbacks.push(()=>bind(panel,\"component\",panel_component_binding_1));panel.$on(\"measure\",/*measure_handler_3*/ctx[148]);panel.$on(\"show\",/*show_handler_1*/ctx[149]);panel.$on(\"hide\",/*hide_handler_1*/ctx[150]);panel.$on(\"fade\",/*fade_handler_1*/ctx[151]);return{c(){create_component(panel.$$.fragment);},m(target,anchor){mount_component(panel,target,anchor);current=true;},p(ctx,dirty){const panel_changes={};if(dirty[0]&/*utilsMerged, utilSelected, pluginOptions*/3145856)panel_changes.content=_objectSpread(_objectSpread({},/*utilsMerged*/ctx[20].find(/*func_1*/ctx[146])),{},{props:/*pluginOptions*/ctx[7][/*utilSelected*/ctx[21]]});if(dirty[0]&/*locale*/4)panel_changes.locale=/*locale*/ctx[2];if(!updating_component&&dirty[0]&/*pluginInterface, utilSelected*/2097153){updating_component=true;panel_changes.component=/*pluginInterface*/ctx[0][/*utilSelected*/ctx[21]];add_flush_callback(()=>updating_component=false);}panel.$set(panel_changes);},i(local){if(current)return;transition_in(panel.$$.fragment,local);current=true;},o(local){transition_out(panel.$$.fragment,local);current=false;},d(detaching){destroy_component(panel,detaching);}};}// (1468:3) {#if shouldRenderTabs}\nfunction create_if_block_2(ctx){let tabpanels;let current;const tabpanels_spread_levels=[{class:\"DokaMain\"},{visible:/*utilsVisible*/ctx[12]},/*tabsConfig*/ctx[23],{panels:/*panels*/ctx[25]}];let tabpanels_props={$$slots:{default:[create_default_slot$1,({panel})=>({258:panel}),({panel})=>[0,0,0,0,0,0,0,0,panel?1024:0]]},$$scope:{ctx}};for(let i=0;i<tabpanels_spread_levels.length;i+=1){tabpanels_props=assign(tabpanels_props,tabpanels_spread_levels[i]);}tabpanels=new TabPanels({props:tabpanels_props});tabpanels.$on(\"measure\",/*measure_handler_2*/ctx[145]);return{c(){create_component(tabpanels.$$.fragment);},m(target,anchor){mount_component(tabpanels,target,anchor);current=true;},p(ctx,dirty){const tabpanels_changes=dirty[0]&/*utilsVisible, tabsConfig, panels*/41947136?get_spread_update(tabpanels_spread_levels,[tabpanels_spread_levels[0],dirty[0]&/*utilsVisible*/4096&&{visible:/*utilsVisible*/ctx[12]},dirty[0]&/*tabsConfig*/8388608&&get_spread_object(/*tabsConfig*/ctx[23]),dirty[0]&/*panels*/33554432&&{panels:/*panels*/ctx[25]}]):{};if(dirty[0]&/*utilsMerged, pluginOptions, locale, utilSelected, pluginInterface, utilsVisible, utilsVisibleFraction*/7344261|dirty[1]&/*$utilRect*/16777216|dirty[8]&/*$$scope, panel*/5120){tabpanels_changes.$$scope={dirty,ctx};}tabpanels.$set(tabpanels_changes);},i(local){if(current)return;transition_in(tabpanels.$$.fragment,local);current=true;},o(local){transition_out(tabpanels.$$.fragment,local);current=false;},d(detaching){destroy_component(tabpanels,detaching);}};}// (1469:3) <TabPanels class=\"DokaMain\" visible={utilsVisible} {...tabsConfig} {panels} let:panel on:measure={e => $tabRect = e.detail}>\nfunction create_default_slot$1(ctx){let panel;let updating_component;let current;function func(...args){return(/*func*/ctx[139](/*panel*/ctx[258],...args));}function panel_component_binding(value){/*panel_component_binding*/ctx[140].call(null,value,/*panel*/ctx[258]);}function show_handler(...args){return(/*show_handler*/ctx[142](/*panel*/ctx[258],...args));}function hide_handler(...args){return(/*hide_handler*/ctx[143](/*panel*/ctx[258],...args));}function fade_handler(...args){return(/*fade_handler*/ctx[144](/*panel*/ctx[258],...args));}let panel_props={content:_objectSpread(_objectSpread({},/*utilsMerged*/ctx[20].find(func)),{},{props:/*pluginOptions*/ctx[7][/*panel*/ctx[258]]}),locale:/*locale*/ctx[2],isActive:/*panel*/ctx[258]===/*utilSelected*/ctx[21],stores:/*utilStores*/ctx[101]};if(/*pluginInterface*/ctx[0][/*panel*/ctx[258]]!==void 0){panel_props.component=/*pluginInterface*/ctx[0][/*panel*/ctx[258]];}panel=new Panel({props:panel_props});binding_callbacks.push(()=>bind(panel,\"component\",panel_component_binding));panel.$on(\"measure\",/*measure_handler_1*/ctx[141]);panel.$on(\"show\",show_handler);panel.$on(\"hide\",hide_handler);panel.$on(\"fade\",fade_handler);return{c(){create_component(panel.$$.fragment);},m(target,anchor){mount_component(panel,target,anchor);current=true;},p(new_ctx,dirty){ctx=new_ctx;const panel_changes={};if(dirty[0]&/*utilsMerged, pluginOptions*/1048704|dirty[8]&/*panel*/1024)panel_changes.content=_objectSpread(_objectSpread({},/*utilsMerged*/ctx[20].find(func)),{},{props:/*pluginOptions*/ctx[7][/*panel*/ctx[258]]});if(dirty[0]&/*locale*/4)panel_changes.locale=/*locale*/ctx[2];if(dirty[0]&/*utilSelected*/2097152|dirty[8]&/*panel*/1024)panel_changes.isActive=/*panel*/ctx[258]===/*utilSelected*/ctx[21];if(!updating_component&&dirty[0]&/*pluginInterface*/1|dirty[8]&/*panel*/1024){updating_component=true;panel_changes.component=/*pluginInterface*/ctx[0][/*panel*/ctx[258]];add_flush_callback(()=>updating_component=false);}panel.$set(panel_changes);},i(local){if(current)return;transition_in(panel.$$.fragment,local);current=true;},o(local){transition_out(panel.$$.fragment,local);current=false;},d(detaching){destroy_component(panel,detaching);}};}function create_fragment$b(ctx){let div;let measurable_action;let focusvisible_action;let dropable_action;let current;let mounted;let dispose;add_render_callback(/*onwindowresize*/ctx[136]);let if_block=/*canRender*/ctx[52]&&create_if_block$2(ctx);return{c(){div=element(\"div\");if(if_block)if_block.c();attr(div,\"id\",/*id*/ctx[3]);attr(div,\"class\",/*className*/ctx[26]);attr(div,\"data-env\",/*envStr*/ctx[29]);},m(target,anchor){insert(target,div,anchor);if(if_block)if_block.m(div,null);/*div_binding_1*/ctx[154](div);current=true;if(!mounted){dispose=[listen(window,\"keydown\",/*handleKeydown*/ctx[110]),listen(window,\"keyup\",/*handleKeyup*/ctx[111]),listen(window,\"blur\",/*handleWindowBlur*/ctx[112]),listen(window,\"resize\",/*onwindowresize*/ctx[136]),listen(div,\"ping\",function(){if(is_function(/*routePing*/ctx[53]))/*routePing*/ctx[53].apply(this,arguments);}),listen(div,\"contextmenu\",/*handleContextMenu*/ctx[113]),listen(div,\"touchstart\",function(){if(is_function(/*handleTouchStart*/ctx[50]))/*handleTouchStart*/ctx[50].apply(this,arguments);}),listen(div,\"transitionend\",/*handleTransitionEnd*/ctx[102]),listen(div,\"dropfiles\",/*handleDropFiles*/ctx[114]),listen(div,\"measure\",/*measure_handler_4*/ctx[155]),action_destroyer(measurable_action=measurable.call(null,div,{observeViewRect:true})),action_destroyer(focusvisible_action=focusvisible.call(null,div)),action_destroyer(dropable_action=dropable.call(null,div))];mounted=true;}},p(new_ctx,dirty){ctx=new_ctx;if(/*canRender*/ctx[52]){if(if_block){if_block.p(ctx,dirty);if(dirty[1]&/*canRender*/2097152){transition_in(if_block,1);}}else{if_block=create_if_block$2(ctx);if_block.c();transition_in(if_block,1);if_block.m(div,null);}}else if(if_block){group_outros();transition_out(if_block,1,1,()=>{if_block=null;});check_outros();}if(!current||dirty[0]&/*id*/8){attr(div,\"id\",/*id*/ctx[3]);}if(!current||dirty[0]&/*className*/67108864){attr(div,\"class\",/*className*/ctx[26]);}if(!current||dirty[0]&/*envStr*/536870912){attr(div,\"data-env\",/*envStr*/ctx[29]);}},i(local){if(current)return;transition_in(if_block);current=true;},o(local){transition_out(if_block);current=false;},d(detaching){if(detaching)detach(div);if(if_block)if_block.d();/*div_binding_1*/ctx[154](null);mounted=false;run_all(dispose);}};}const imageCropRectElasticity=5;// updating crop selection / the intended selection rect, combined with actual selection rect, used to render elasticity visualisation\nconst imageSelectionRectElasticity=1;const scrollElasticity=10;const rangeInputElasticity=5;function instance$b($$self,$$props,$$invalidate){let $images;let $clientRect;let $rootRect;let $imageState;let $imageLoadState;let $imageCropRectSnapshot;let $imageCropRectIntent;let $previewShouldUpscale;let $imageCropRect;let $isInteracting;let $imageSelectionRect;let $imageSelectionRectIntent;let $stageRect;let $stageScalar;let $imageSize;let $presentationScalar;let $imageSelectionRectSnapshot;let $prefersReducedMotion;let $tabRect;let $history,$$unsubscribe_history=noop$1,$$subscribe_history=()=>($$unsubscribe_history(),$$unsubscribe_history=subscribe(history,$$value=>$$invalidate(181,$history=$$value)),history);let $imageProcessingPreparing;let $rootBackgroundColor;let $env;let $pointerAccuracy;let $pointerHoverable;let $imageTransforms;let $imagePreviewModifiers;let $imageEffects;let $imageBackgroundColor;let $imageSelectionRectPresentation;let $imageVisualLoadComplete;let $imageFile;let $imagePreview;let $imageProcessState;let $statusOpacity;let $statusOffsetX;let $progressOffsetX;let $pressedKeysStore;let $isInteractingFraction;let $toolRect;let $utilRect;let $pixelRatio;let $imagePreviews;let $imageDecoration;let $imageAnnotation;let $imageOverlay;component_subscribe($$self,prefersReducedMotion,$$value=>$$invalidate(179,$prefersReducedMotion=$$value));$$self.$$.on_destroy.push(()=>$$unsubscribe_history());const eventProxy=pubsub();const dispatch=createEventDispatcher();//\n// View Props\n//\nlet{class:klass=undefined}=$$props;let{layout:layoutMode=undefined}=$$props;let{stores}=$$props;let{locale=undefined}=$$props;let{id=undefined}=$$props;let{util=undefined}=$$props;let{utils=undefined}=$$props;// which utils are active (list of ids), or is derived from plugins automatically\nlet{animations=\"auto\"}=$$props;let{previewUpscale=false}=$$props;let{elasticityMultiplier=10}=$$props;let{willRevert=()=>Promise.resolve(true)}=$$props;let{willRenderCanvas=passthrough}=$$props;let{willRenderToolbar=passthrough}=$$props;let{enableButtonExport=true}=$$props;let{enableButtonRevert=true}=$$props;let{enableNavigateHistory=true}=$$props;let{enableToolbar=true}=$$props;let{enableUtils=true}=$$props;let{enableButtonClose=false}=$$props;let{previewImageDataMaxSize=undefined}=$$props;let{enableDropImage=false}=$$props;let{imageOrienter={read:()=>1,apply:v=>v}}=$$props;let{pluginComponents=undefined}=$$props;let{pluginOptions={}}=$$props;const sub=eventProxy.sub;const pluginInterface={};let{root}=$$props;let registeredPluginsComponents=[];// \n// this method is used to read image resources (preview image / shape images)\nconst glMaxTextureSize=getWebGLTextureSizeLimit()||1024;const maxTextureSize=sizeCreate(glMaxTextureSize,glMaxTextureSize);const canvasMemoryLimit=isIOS()?4096*4096:Infinity;let{imageSourceToImageData=src=>isString(src)?fetch(src).then(res=>res.blob()).then(blob=>blobToImageBitmap(blob,imageOrienter,canvasMemoryLimit)).then(imageData=>imageDataContain(imageData,maxImageDataSize)):blobToImageBitmap(src,imageOrienter,canvasMemoryLimit).then(imageData=>imageDataContain(imageData,maxImageDataSize))}=$$props;const imageProxy=createImageProxy();const{file:imageFile,size:imageSize,loadState:imageLoadState,processState:imageProcessState,cropAspectRatio:imageCropAspectRatio,cropLimitToImage:imageCropLimitToImage,crop:imageCropRect,cropMinSize:imageCropMinSize,cropMaxSize:imageCropMaxSize,cropRange:imageCropRange,cropOrigin:imageCropRectOrigin,cropRectAspectRatio:imageCropRectAspectRatio,rotation:imageRotation,rotationRange:imageRotationRange,targetSize:imageOutputSize,flipX:imageFlipX,flipY:imageFlipY,backgroundColor:imageBackgroundColor,colorMatrix:imageColorMatrix,convolutionMatrix:imageConvolutionMatrix,gamma:imageGamma,vignette:imageVignette,noise:imageNoise,decoration:imageDecoration,annotation:imageAnnotation,state:imageState}=imageProxy.stores;component_subscribe($$self,imageFile,value=>$$invalidate(210,$imageFile=value));component_subscribe($$self,imageSize,value=>$$invalidate(17,$imageSize=value));component_subscribe($$self,imageLoadState,value=>$$invalidate(165,$imageLoadState=value));component_subscribe($$self,imageProcessState,value=>$$invalidate(211,$imageProcessState=value));component_subscribe($$self,imageCropRect,value=>$$invalidate(169,$imageCropRect=value));component_subscribe($$self,imageBackgroundColor,value=>$$invalidate(207,$imageBackgroundColor=value));component_subscribe($$self,imageDecoration,value=>$$invalidate(58,$imageDecoration=value));component_subscribe($$self,imageAnnotation,value=>$$invalidate(59,$imageAnnotation=value));component_subscribe($$self,imageState,value=>$$invalidate(164,$imageState=value));const{images,imageReader}=stores;component_subscribe($$self,images,value=>$$invalidate(162,$images=value));//\n// handles the view rect size, makes sure it is offset from the top\n//\n// root element reference used to read styles\nconst rootBackgroundColor=writable([0,0,0]);component_subscribe($$self,rootBackgroundColor,value=>$$invalidate(28,$rootBackgroundColor=value));// client rect is the doka editor rect excluding scroll offset\nconst clientRect=writable();component_subscribe($$self,clientRect,value=>$$invalidate(15,$clientRect=value));// root rect is the doka editor rect including scroll offset\nconst rootRect=writable();component_subscribe($$self,rootRect,value=>$$invalidate(163,$rootRect=value));// when in overlay mode force aspect ratio to aspect ratio of editor root\nconst syncRootAspectRatio=()=>{// set aspect ratio\nimageCropAspectRatio.set(rectAspectRatio($rootRect));// need to set history 0 point to this state\nhistory.set($imageState);};const tabRect=writable(rectCreateEmpty());component_subscribe($$self,tabRect,value=>$$invalidate(19,$tabRect=value));const toolRect=writable(rectCreateEmpty());component_subscribe($$self,toolRect,value=>$$invalidate(54,$toolRect=value));const utilRect=writable();// is undefined because we wait till util is set before defining stage rect\ncomponent_subscribe($$self,utilRect,value=>$$invalidate(55,$utilRect=value));const stageRect=derived([utilRect,tabRect,toolRect],([$utilRect,$tabRect,$toolRect],set)=>{if(!$utilRect)return set(undefined);const utiloffsetX=$tabRect.x;const utilOffsetY=$tabRect.y+(shouldRenderTabs&&showUtils||isOverlayModeEnabled?0:$toolRect.y+$toolRect.height);set(rectCreate(utiloffsetX+$utilRect.x,utilOffsetY+$utilRect.y,$utilRect.width,$utilRect.height));});component_subscribe($$self,stageRect,value=>$$invalidate(173,$stageRect=value));//\n// environment\n//\nconst pointerAccuracy=mediaQueryStore(\"(pointer: fine)\",matches=>matches?\"pointer-fine\":\"pointer-coarse\");component_subscribe($$self,pointerAccuracy,value=>$$invalidate(202,$pointerAccuracy=value));const pointerHoverable=mediaQueryStore(\"(hover: hover)\",matches=>matches?\"pointer-hover\":\"pointer-no-hover\");component_subscribe($$self,pointerHoverable,value=>$$invalidate(203,$pointerHoverable=value));//\n// app API\n//\nconst isInteracting=writable(false);component_subscribe($$self,isInteracting,value=>$$invalidate(170,$isInteracting=value));const isInteractingFraction=readable(undefined,set=>{const animator=spring(0);const updater=value=>{animator.set(value?1:0);};const subs=[isInteracting.subscribe(updater),animator.subscribe(set)];// destroy subs\nreturn()=>subs.forEach(unsub=>unsub());});component_subscribe($$self,isInteractingFraction,value=>$$invalidate(214,$isInteractingFraction=value));const previewShouldUpscale=writable(previewUpscale);component_subscribe($$self,previewShouldUpscale,value=>$$invalidate(168,$previewShouldUpscale=value));//\n// image related\n//\nconst stageScalar=derived([stageRect,imageCropRect],([$stageRect,$imageCropRect],set)=>{const isManipulatingImageCropRect=!!($imageCropRectSnapshot||$imageCropRectIntent);// update stage scalar, the crop output size relative to the stage, if image fits it's 1\nif(!$stageRect||!$imageCropRect||isManipulatingImageCropRect)return;// calculate scale factor needed to fit crop rect to stage\nconst scalar=Math.min($stageRect.width/$imageCropRect.width,$stageRect.height/$imageCropRect.height);// always scaled down to fit stage, if is allowed to upscale, zoom to fit stage\nconst scale=$previewShouldUpscale?scalar:Math.min(1,scalar);set(scale);});component_subscribe($$self,stageScalar,value=>$$invalidate(174,$stageScalar=value));const imageCropRectSnapshot=writable();component_subscribe($$self,imageCropRectSnapshot,value=>$$invalidate(166,$imageCropRectSnapshot=value));const imageCropRectIntent=writable();// should always be set before setting `imageCropRect`\ncomponent_subscribe($$self,imageCropRectIntent,value=>$$invalidate(167,$imageCropRectIntent=value));const imageCropRectPresentation=readable(undefined,set=>{const animator=spring(undefined,{precision:0.0001});const update=()=>{if(!$imageCropRect)return;const instantUpdate=$imageCropRectIntent===undefined||$isInteracting;const elasticRect=elastifyRects($imageCropRect,$imageCropRectIntent,imageCropRectElasticity*elasticityMultiplier);animator.set(elasticRect,{hard:instantUpdate});};const subs=[// need to update presentation rect when crop rect is updated\nimageCropRect.subscribe(update),// update parent store\nanimator.subscribe(set)];return()=>subs.forEach(unsub=>unsub());});const imageSelectionRect=writable();component_subscribe($$self,imageSelectionRect,value=>$$invalidate(171,$imageSelectionRect=value));const imageSelectionRectSnapshot=writable();component_subscribe($$self,imageSelectionRectSnapshot,value=>$$invalidate(176,$imageSelectionRectSnapshot=value));const imageSelectionRectIntent=writable(undefined);// should always be set before setting `imageSelectionRect`\ncomponent_subscribe($$self,imageSelectionRectIntent,value=>$$invalidate(172,$imageSelectionRectIntent=value));//\n// Image selection\n//\nconst imageSelectionRectPresentation=readable(undefined,set=>{const animator=spring(undefined,{precision:0.0001});const updater=()=>{if(!$imageSelectionRect)return;const instantUpdate=$isInteracting;const elasticRect=elastifyRects($imageSelectionRect,$imageSelectionRectIntent,imageSelectionRectElasticity*elasticityMultiplier);// prevent negative size (can happen because of elastics)\nif(elasticRect.width<0){elasticRect.width=0;elasticRect.x=$imageSelectionRect.x;}if(elasticRect.height<0){elasticRect.height=0;elasticRect.y=$imageSelectionRect.y;}// translate elastic rect x,y by stage rect x,y\nrectTranslate(elasticRect,$stageRect);animator.set(elasticRect,{hard:instantUpdate});};const subs=[// need to update selection rect when stage is resized\nstageRect.subscribe(updater),// listen for selection rect changes (as is assigned rect will always trigger, even if assigned same rect, this is needed to also update when intent changes)\nimageSelectionRect.subscribe(updater),// update parent store\nanimator.subscribe(set)];// destroy subs\nreturn()=>subs.forEach(unsub=>unsub());});component_subscribe($$self,imageSelectionRectPresentation,value=>$$invalidate(31,$imageSelectionRectPresentation=value));// when scaling the stage we need to recenter the image selection\nstageRect.subscribe(()=>{if(!$stageRect||!$imageCropRect)return;const imageCropRectFitsStage=$imageCropRect.width<=$stageRect.width&&$imageCropRect.height<=$stageRect.height;const centeredImageSelectionRect=// if we have a crop rect and it fits the stage, center it\nimageCropRectFitsStage?// center the crop rectangle to the stage\nrectCenterRect($stageRect,rectMultiply(rectClone($imageCropRect),$stageScalar||1)):// render a rectangle based on the fixed crop aspect ratio, or the aspect ratio of the current crop rectangle, or as a last resort the input image\nrectContainRect($stageRect,rectAspectRatio($imageCropRect||$imageSize));imageSelectionRect.set(centeredImageSelectionRect);});// if we've taken a snapshot of the selection, also take a snapshot of the crop rect and the presentationScalar\n// - cropRect so we can adjust it based on the adjustments to the imageSelectionRect\n// - presentationScalar so we can use the snapshot for the calculation of the cropRect scale relative to the original imageSelectionRect (if we use the live $presentationScalar small rounding errors of the scalar result in weird glitches)\nlet presentationScalarSnapshot;imageSelectionRectSnapshot.subscribe(rect=>{if(!rect){presentationScalarSnapshot=undefined;set_store_value(imageCropRectSnapshot,$imageCropRectSnapshot=undefined,$imageCropRectSnapshot);return;}presentationScalarSnapshot=$presentationScalar;const cropRectClone=rectClone($imageCropRect);imageCropRectSnapshot.set(cropRectClone);});// if image selection rect is being manipulated, and imageSelectionRectSnapshot has been defined, we also need to update the crop rect\nimageSelectionRect.subscribe(rect=>{// only sync crop rect with image selection rect when no longer manipulating\nif(!rect||!$imageSelectionRectSnapshot)return;const offset=rectSubtract(rectClone(rect),$imageSelectionRectSnapshot);rectDivide(offset,presentationScalarSnapshot);const crop=rectAdd(rectClone($imageCropRectSnapshot),offset);imageCropRect.set(crop);});imageCropRect.subscribe(rect=>{// don't update image selection rect while we're intertacting with the view, this prevents feedback loop from cropRect model updates\nif($isInteracting||$imageSelectionRectSnapshot||$imageCropRectIntent)return;// if no rect, we can't do anything\n// if no selection rect yet, we wait for a selection rect to be loaded\nif(!rect||!$imageSelectionRect)return;// only if crop aspect ratio differs from image selection aspect ratio we update image selection rectangle\nconst imageSelectionRectAspectRatio=rectAspectRatio($imageSelectionRect);const cropRectAspectRatio=rectAspectRatio(rect);if(fixPrecision(imageSelectionRectAspectRatio,6)===fixPrecision(cropRectAspectRatio,6))return;// TEMP DUPLICATE OF STAGESCALAR DERIVED STORE TO FIX ZOOM OUT AFTER WHEEL ISSUE\n// reproduce -> crop view => resize selection rect vertically, tap recenter, zoom out with scroll wheel\nconst scalar=Math.min($stageRect.width/$imageCropRect.width,$stageRect.height/$imageCropRect.height);// const scale = $previewShouldUpscale ? scalar : Math.min(1, scalar);\nconst size=sizeCreate(rect.width*scalar,rect.height*scalar);const tx=($imageSelectionRect.width-size.width)*0.5;const ty=($imageSelectionRect.height-size.height)*0.5;const selectionRect=rectCreate($imageSelectionRect.x+tx,$imageSelectionRect.y+ty,size.width,size.height);imageSelectionRect.set(selectionRect);});const imageScalar=derived([stageScalar,imageCropRect,imageSelectionRect],([$stageScalar,$imageCropRect,$imageSelectionRect],set)=>{// update the image scalar, the image zoom calculated by the image selection and the actual crop coordinates\nif(!$stageScalar||!$imageCropRect||!$imageSelectionRect)return;const selectionScaledWidth=$imageSelectionRect.width/$imageCropRect.width;const selectionScaledHeight=$imageSelectionRect.height/$imageCropRect.height;// need to correct for scale of stage\nconst scalar=Math.max(selectionScaledWidth,selectionScaledHeight)/$stageScalar;set(scalar);});const presentationScalar=derived([stageScalar,imageScalar],([$stageScalar,$imageScalar],set)=>{// can't scale presentation if no image scalar defined\nif(!$imageScalar)return;const scalar=$stageScalar*$imageScalar;set(scalar);});component_subscribe($$self,presentationScalar,value=>$$invalidate(175,$presentationScalar=value));//\n// UI Elements\n//\n// guides and edges rendered on top of image\nconst imageSelectionGuides=derived([rootBackgroundColor,isInteracting,imageSelectionRectPresentation,isInteractingFraction],([$rootBackgroundColor,$isInteracting,$rect,$opacity],set)=>{if(!$rect)return set([]);const{x,y,width,height}=$rect;const showGrid=$opacity>0;const rows=showGrid?3:1;const cols=showGrid?3:1;const w=width/cols;const h=height/rows;const guides=[];const strokeColor=isDarkColor($rootBackgroundColor)?[1,1,1]:[0,0,0];// rows\nfor(let r=0;r<=rows;r++){let isEdge=r===0||r===rows;if(isOverlayModeEnabled&&isEdge)continue;let o=isEdge?1:$opacity*0.25;let yo=y+h*r;guides.push({id:`image-selection-guide-row-${r}`,points:[vectorCreate(x,yo),vectorCreate(x+width,yo)],opacity:o,strokeWidth:1,strokeColor});}// cols\nfor(let c=0;c<=cols;c++){let isEdge=c===0||c===cols;if(isOverlayModeEnabled&&isEdge)continue;let o=isEdge?1:$opacity*0.25;let xo=x+w*c;guides.push({id:`image-selection-guide-col-${c}`,points:[vectorCreate(xo,y),vectorCreate(xo,y+height)],opacity:o,strokeWidth:1,strokeColor});}set(guides);});// custom markup rendered on top of image\nconst imageOverlayMarkup=writable([]);// the resulting overlay markup\nconst imageOverlay=derived([imageSelectionGuides,imageOverlayMarkup],([$imageSelectionGuides,$imageOverlayMarkup],set)=>{set($imageSelectionGuides.concat($imageOverlayMarkup));});component_subscribe($$self,imageOverlay,value=>$$invalidate(60,$imageOverlay=value));//\n// Loading the preview\n//\nconst imageVisualLoadComplete=writable(false);component_subscribe($$self,imageVisualLoadComplete,value=>$$invalidate(209,$imageVisualLoadComplete=value));let imagePreviewLoaderCancelToken;const createImagePreviewLoader=(file,token)=>new Promise((resolve,reject)=>{let cancelled=false;let timer;token.cancel=()=>cancelled=true;const now=Date.now();imageSourceToImageData(file).then(imageData=>{const dist=Date.now()-now;clearTimeout(timer);timer=setTimeout(()=>{if(cancelled)return;resolve(imageData);},Math.max(0,1000-dist));}).catch(reject);});const imagePreview=derived([imageVisualLoadComplete,imageFile],([$imageVisualLoadComplete,$imageFile],set)=>{// cancel existing loader\nif(imagePreviewLoaderCancelToken)imagePreviewLoaderCancelToken.cancel();// no data, reset preview data\nif(!$imageVisualLoadComplete||!$imageFile)return set(undefined);imagePreviewLoaderCancelToken={cancel:noop};createImagePreviewLoader($imageFile,imagePreviewLoaderCancelToken).then(set).catch(err=>set_store_value(imageLoadState,$imageLoadState.error=err,$imageLoadState));});component_subscribe($$self,imagePreview,value=>$$invalidate(38,$imagePreview=value));//\n// Calculates the image transforms and effects necessary for the preview\n//\nconst imagePreviewModifiers=writable({});component_subscribe($$self,imagePreviewModifiers,value=>$$invalidate(205,$imagePreviewModifiers=value));const imagePreviews=writable([]);component_subscribe($$self,imagePreviews,value=>$$invalidate(57,$imagePreviews=value));const imageTransforms=derived([stageRect,rootRect,imageSize,imageCropRectPresentation,imageSelectionRect,presentationScalar,imageRotation,imageFlipX,imageFlipY],([$stageRect,$rootRect,$imageSize,$imageCropRectPresentation,$imageSelectionRect,$presentationScalar,$imageRotation,$imageFlipX,$imageFlipY],set)=>{set(calculateImageTransforms($stageRect,$rootRect,$imageSize,$imageCropRectPresentation,$imageSelectionRect,$presentationScalar,0,0,$imageRotation,$imageFlipX,$imageFlipY));});component_subscribe($$self,imageTransforms,value=>$$invalidate(204,$imageTransforms=value));const imageEffects=derived([imageColorMatrix,imageConvolutionMatrix,imageGamma,imageVignette,imageNoise],([$colorMatrix,$convolutionMatrix,$gamma,$vignette,$noise],set)=>{const colorMatrices=$colorMatrix&&Object.keys($colorMatrix).map(name=>$colorMatrix[name]).filter(Boolean);const effects={gamma:$gamma||undefined,vignette:$vignette||undefined,noise:$noise||undefined,convolutionMatrix:$convolutionMatrix||undefined,colorMatrix:colorMatrices&&colorMatrices.length&&getColorMatrixFromColorMatrices(colorMatrices)};set(effects);});component_subscribe($$self,imageEffects,value=>$$invalidate(206,$imageEffects=value));//\n// current environment variables\n//\nlet windowWidth;let windowHeight;const shouldPreventSwipe=canPreventNavSwipe();const env=writable({});component_subscribe($$self,env,value=>$$invalidate(201,$env=value));const initialPixelRatio=getDevicePixelRatio();const pixelRatio=readable(initialPixelRatio,set=>{const handleResolutionChange=()=>set(getDevicePixelRatio());const resolutionObserver=matchMedia(`(resolution: ${initialPixelRatio}dppx)`);resolutionObserver.addListener(handleResolutionChange);return()=>resolutionObserver.removeListener(handleResolutionChange);});component_subscribe($$self,pixelRatio,value=>$$invalidate(56,$pixelRatio=value));const history=historyCreate(()=>$imageState,state=>{// set new state from history, $imageState will store a clone of the received state\nset_store_value(imageState,$imageState=state,$imageState);// image state will return a clone of the current state\n// trigger recenter of image selection rect\ntabRect.set($tabRect);});$$subscribe_history();imageLoadState.subscribe(({complete}={})=>{if(!complete)return;history.set($imageState);});const revert=()=>willRevert().then(shouldReset=>shouldReset&&history.revert());//\n// Visual processing of the image\n//\nconst imageProcessingPreparing=writable(false);component_subscribe($$self,imageProcessingPreparing,value=>$$invalidate(183,$imageProcessingPreparing=value));const handleExport=()=>{// this will trigger status overlay fade in\nset_store_value(imageProcessingPreparing,$imageProcessingPreparing=true,$imageProcessingPreparing);// wait for status to be done fading in, then requests image writing\nconst unsub=statusOpacity.subscribe(value=>{if(value!==1)return;// stop listening for\nunsub();// request write image\ndispatch(\"processImage\");});};imageProcessState.subscribe(state=>{if(!state)return;set_store_value(imageProcessingPreparing,$imageProcessingPreparing=true,$imageProcessingPreparing);const{task,error,complete}=state;if(complete)set_store_value(imageProcessingPreparing,$imageProcessingPreparing=false,$imageProcessingPreparing);});//\n// Configure the available views\n//\nconst utilStores=_objectSpread(_objectSpread({},stores),{},{// image\nimageFile,imageSize,imageCropAspectRatio,imageCropMinSize,imageCropMaxSize,imageCropLimitToImage,imageCropRect,imageCropRectOrigin,imageCropRectSnapshot,imageCropRectAspectRatio,imageCropRange,imageRotation,imageRotationRange,imageFlipX,imageFlipY,imageOutputSize,// effects\nimageColorMatrix,imageConvolutionMatrix,imageGamma,imageVignette,imageNoise,// markup\nimageDecoration,imageAnnotation,// image preview for utils that need access to pixel data\nimagePreview,// top left position of image preview\nimageTransforms,// allows utils to control how the preview is presented (for example more opacity for mask)\nimagePreviewModifiers,// history state and update\nhistory,// static env info\npixelRatio,elasticityMultiplier,scrollElasticity,rangeInputElasticity,// dynamic env info\npointerAccuracy,pointerHoverable,env,rootRect,stageRect,stageScalar,utilRect,presentationScalar,rootBackgroundColor,// (write) add guides to ui (for example is used by markup util to add lines for shape manipulator)\nimageOverlayMarkup,// (write) previews to render\nimagePreviews,// (write) set to true to disable animations\nisInteracting,// (write) the current intended crop rect\nimageCropRectIntent,// (read) the current presented crop rect\nimageCropRectPresentation,// (write) the current limited size of the image selection rect\nimageSelectionRect,// (write) the inteded rectangle by the user\nimageSelectionRectIntent,// (read) the current presentation of the image selection rect, includes elasticity etc.\nimageSelectionRectPresentation,// (read) a snapshot of the image selection rectangle, use to store the rectangle before modification so alterations to the rectangle can be applied to the snapshot\nimageSelectionRectSnapshot,// scalar of image in view\nimageScalar});// don't expose image store\ndelete utilStores.image;const utilsUniqueId=`util-${getUniqueId()}`;let utilsVisible=[];// env\nlet iOS=isIOS();// canvas background color\nconst syncBackgroundColor=()=>{const colorString=rootElementComputedStyle.getPropertyValue(\"background-color\");const colorArray=colorStringToColorArray(colorString);// hide transparent color\nif(colorArray[3]===0)return;// limit to opaque colors\ncolorArray.length=3;// update background\nset_store_value(rootBackgroundColor,$rootBackgroundColor=colorArray,$rootBackgroundColor);};const handleTransitionEnd=({target,propertyName})=>{if(target!==root||propertyName!==\"background-color\")return;syncBackgroundColor();};// test if some shapes have left/top/bottom/right offsets, if so, convert to crop space\n// updates original shape (which at this point is a flattened shape (clone))\nconst positionDecorationShape=(shape,canvasState)=>shapeComputeDisplay(shape,{x:$imageSelectionRectPresentation.x/canvasState.scale,y:$imageSelectionRectPresentation.y/canvasState.scale,width:$imageSelectionRectPresentation.width/canvasState.scale,height:$imageSelectionRectPresentation.height/canvasState.scale});// decoration is drawn relative to view space, so we need to translate relative to crop presentation rect\nconst transformDecorationShape=(shape,canvasState)=>{shapeComputeTransform(shape,$imageSelectionRectPresentation,canvasState.scale,canvasState.size);return shape;};const flattenShapes=shapes=>{const flattenedShapes=[];shapes.forEach(shape=>flattenedShapes.push(...flattenShape(shape)));return flattenedShapes.filter(Boolean);};const flattenShape=shape=>{// at this point shape is a copy of the original shape\n// the shapes to draw, can be multiple shapes\nconst drawableShapes=[shape];if(shapeIsLine(shape)){let start=vectorCreate(shape.x1,shape.y1);let end=vectorCreate(shape.x2,shape.y2);if(shape.lineStart){const style=shapeComputeLineEnd(start,shape.strokeWidth,shape.strokeColor,shape.lineStart,vectorCreate(end.x-start.x,end.y-start.y));start=style.position||start;drawableShapes.push(style.shape);}if(shape.lineEnd){const style=shapeComputeLineEnd(end,shape.strokeWidth,shape.strokeColor,shape.lineEnd,vectorCreate(start.x-end.x,start.y-end.y));end=style.position||start;drawableShapes.push(style.shape);}// transform into line\nshape.points=[start,end];}else if(shapeIsTriangle(shape)){shape.points=[vectorCreate(shape.x1,shape.y1),vectorCreate(shape.x2,shape.y2),vectorCreate(shape.x3,shape.y3)];}else// is empty text\nif(shapeIsTextEmpty(shape)){// make sure shape is still visible\nif(shapeIsTextLine(shape)){shape.width=5;shape.height=isFunction(shape.lineHeight)?shape.lineHeight(shape.fontSize):shape.lineHeight;}// set to empty text style\nshape.strokeWidth=1;shape.strokeColor=[1,1,1,0.5];shape.backgroundColor=[0,0,0,0.1];}return drawableShapes;};const statusOpacity=tweened(undefined,{duration:500});component_subscribe($$self,statusOpacity,value=>$$invalidate(46,$statusOpacity=value));let loadTimer;const statusOffsetX=spring(undefined,{stiffness:0.02,damping:0.5,precision:0.25});component_subscribe($$self,statusOffsetX,value=>$$invalidate(48,$statusOffsetX=value));const progressOffsetX=spring(undefined,{stiffness:0.03,damping:0.4,precision:0.25});component_subscribe($$self,progressOffsetX,value=>$$invalidate(49,$progressOffsetX=value));const hideStatus=()=>{statusOffsetX.set(undefined,{hard:true});progressOffsetX.set(undefined,{hard:true});};const offsetProgress=e=>{set_store_value(statusOffsetX,$statusOffsetX=Math.round(-e.detail.width*0.5)-16,$statusOffsetX);// -16 offsets text so it's better centered to the viewport\nset_store_value(progressOffsetX,$progressOffsetX=e.detail.width,$progressOffsetX);};const handleCloseImageLoadError=()=>{dispatch(\"abortLoadImage\");};const handleCloseImageProcessError=()=>{dispatch(\"abortProcessImage\");set_store_value(imageProcessingPreparing,$imageProcessingPreparing=false,$imageProcessingPreparing);};// context for children to know if a key is down\nconst pressedKeysStore=writable([]);component_subscribe($$self,pressedKeysStore,value=>$$invalidate(213,$pressedKeysStore=value));setContext(\"keysPressed\",pressedKeysStore);const handleKeydown=e=>{const{keyCode}=e;const keySet=new Set([...$pressedKeysStore,keyCode]);pressedKeysStore.set(Array.from(keySet));};const handleKeyup=({keyCode})=>{pressedKeysStore.set($pressedKeysStore.filter(pressedKey=>pressedKey!==keyCode));};// so no keys get stuck when user cmd-tabs out of the window, or when dev-tools open by key-press\nconst handleWindowBlur=()=>{pressedKeysStore.set([]);};// block context menu on everything but text input fields\nconst handleContextMenu=e=>{if(isTextField(e.target))return;e.preventDefault();};// handle files being dropped on the editor\nconst handleDropFiles=e=>{// if no files dropped, exit!\nif(!enableDropImage||!e.detail.files.length)return;// request load image\ndispatch(\"loadImage\",e.detail.files[0]);};// canvas drawing\nconst getStageState=()=>({// add information on which util is active\nutilVisibility:_objectSpread({},utilsVisibleFraction),// used to fade in elements when interacting\nisInteracting:$isInteracting,isInteractingFraction:$isInteractingFraction,// add the root rectangle so will render can use width/height of root element\nrootRect:rectClone($rootRect),// add the stage rectangle so will render knows where stage starts and ends\nstageRect:rectClone($stageRect),// preview selection rect\nselectionRect:rectClone($imageSelectionRectPresentation)});const createCanvasState=(canvasState,annotationShapes,decorationShapes,interfaceShapes)=>({annotationShapes:flattenShapes(annotationShapes.filter(shapeIsVisible).map(shapeDeepCopy).map(shape=>shapeComputeDisplay(shape,$imageSize))),decorationShapes:flattenShapes(decorationShapes.filter(shapeIsVisible).map(shapeDeepCopy).map(shape=>positionDecorationShape(shape,canvasState)).map(shape=>transformDecorationShape(shape,canvasState))),interfaceShapes:flattenShapes(interfaceShapes.filter(shapeIsVisible))});// setup root portal for detail panel dropdown\nlet rootPortal;const rootPortalStore=writable();setContext(\"rootPortal\",rootPortalStore);// setup root rect store for global access\nsetContext(\"rootRect\",rootRect);function onwindowresize(){$$invalidate(10,windowWidth=window.innerWidth);$$invalidate(11,windowHeight=window.innerHeight);}const measure_handler=e=>set_store_value(toolRect,$toolRect=e.detail,$toolRect);const select_handler=({detail})=>$$invalidate(21,utilSelected=detail);const func=(panel,util)=>util.id===panel;function panel_component_binding(value,panel){pluginInterface[panel]=value;($$invalidate(0,pluginInterface),$$invalidate(7,pluginOptions)),$$invalidate(134,pluginComponents);}const measure_handler_1=e=>set_store_value(utilRect,$utilRect=e.detail,$utilRect);const show_handler=panel=>$$invalidate(12,utilsVisible=utilsVisible.concat(panel));const hide_handler=panel=>$$invalidate(12,utilsVisible=utilsVisible.filter(util=>util!==panel));const fade_handler=(panel,{detail})=>$$invalidate(22,utilsVisibleFraction[panel]=detail,utilsVisibleFraction);const measure_handler_2=e=>set_store_value(tabRect,$tabRect=e.detail,$tabRect);const func_1=util=>util.id===utilSelected;function panel_component_binding_1(value){pluginInterface[utilSelected]=value;($$invalidate(0,pluginInterface),$$invalidate(7,pluginOptions)),$$invalidate(134,pluginComponents);}const measure_handler_3=e=>set_store_value(utilRect,$utilRect=e.detail,$utilRect);const show_handler_1=()=>$$invalidate(12,utilsVisible=utilsVisible.concat(utilSelected));const hide_handler_1=()=>$$invalidate(12,utilsVisible=utilsVisible.filter(util=>util!==utilSelected));const fade_handler_1=({detail})=>$$invalidate(22,utilsVisibleFraction[utilSelected]=detail,utilsVisibleFraction);const func_2=canvasState=>{// current draw state\nconst drawState=_objectSpread(_objectSpread({},canvasState),getStageState());// allow dev to add custom overlay to `imageOverlay`\nconst{annotationShapes,decorationShapes,interfaceShapes}=willRenderCanvas({decorationShapes:$imageDecoration,annotationShapes:$imageAnnotation,interfaceShapes:$imageOverlay},drawState);// need to map shapes\nreturn createCanvasState(drawState,annotationShapes,decorationShapes,interfaceShapes);};function div_binding($$value){binding_callbacks[$$value?\"unshift\":\"push\"](()=>{rootPortal=$$value;$$invalidate(13,rootPortal);});}function div_binding_1($$value){binding_callbacks[$$value?\"unshift\":\"push\"](()=>{root=$$value;$$invalidate(1,root);});}const measure_handler_4=e=>set_store_value(clientRect,$clientRect=e.detail,$clientRect);$$self.$$set=$$props=>{if(\"class\"in $$props)$$invalidate(117,klass=$$props.class);if(\"layout\"in $$props)$$invalidate(118,layoutMode=$$props.layout);if(\"stores\"in $$props)$$invalidate(119,stores=$$props.stores);if(\"locale\"in $$props)$$invalidate(2,locale=$$props.locale);if(\"id\"in $$props)$$invalidate(3,id=$$props.id);if(\"util\"in $$props)$$invalidate(120,util=$$props.util);if(\"utils\"in $$props)$$invalidate(121,utils=$$props.utils);if(\"animations\"in $$props)$$invalidate(122,animations=$$props.animations);if(\"previewUpscale\"in $$props)$$invalidate(123,previewUpscale=$$props.previewUpscale);if(\"elasticityMultiplier\"in $$props)$$invalidate(4,elasticityMultiplier=$$props.elasticityMultiplier);if(\"willRevert\"in $$props)$$invalidate(124,willRevert=$$props.willRevert);if(\"willRenderCanvas\"in $$props)$$invalidate(5,willRenderCanvas=$$props.willRenderCanvas);if(\"willRenderToolbar\"in $$props)$$invalidate(125,willRenderToolbar=$$props.willRenderToolbar);if(\"enableButtonExport\"in $$props)$$invalidate(126,enableButtonExport=$$props.enableButtonExport);if(\"enableButtonRevert\"in $$props)$$invalidate(127,enableButtonRevert=$$props.enableButtonRevert);if(\"enableNavigateHistory\"in $$props)$$invalidate(128,enableNavigateHistory=$$props.enableNavigateHistory);if(\"enableToolbar\"in $$props)$$invalidate(6,enableToolbar=$$props.enableToolbar);if(\"enableUtils\"in $$props)$$invalidate(129,enableUtils=$$props.enableUtils);if(\"enableButtonClose\"in $$props)$$invalidate(130,enableButtonClose=$$props.enableButtonClose);if(\"previewImageDataMaxSize\"in $$props)$$invalidate(131,previewImageDataMaxSize=$$props.previewImageDataMaxSize);if(\"enableDropImage\"in $$props)$$invalidate(132,enableDropImage=$$props.enableDropImage);if(\"imageOrienter\"in $$props)$$invalidate(133,imageOrienter=$$props.imageOrienter);if(\"pluginComponents\"in $$props)$$invalidate(134,pluginComponents=$$props.pluginComponents);if(\"pluginOptions\"in $$props)$$invalidate(7,pluginOptions=$$props.pluginOptions);if(\"root\"in $$props)$$invalidate(1,root=$$props.root);if(\"imageSourceToImageData\"in $$props)$$invalidate(8,imageSourceToImageData=$$props.imageSourceToImageData);};let isOverlayModeEnabled;let showUtils;let maxImageDataSize;let canAnimate;let acceptsAnimations;let shouldAnimate;let canUndo;let canRedo;let utilsFiltered;let utilsAvailable;let utilsDefined;let utilsMerged;let utilSelected;let utilTools;let utilsVisibleFraction;let tabsConfig;let tabs;let panels;let shouldRenderTabs;let className;let orientation;let isLandscape;let horizontalSpace;let hasLimitedSpace;let verticalSpace;let isModal;let isCenteredHorizontally;let isCenteredVertically;let isCentered;let isNarrow;let isCompact;let hasSwipeNavigation;let shouldRenderUtilTools;let rootElementComputedStyle;let envStr;let imageProps;let missingFeatures;let isSupportsError;let isImageLoadError;let isWaitingForImage;let imageLoadProgress;let isLoadingImageData;let isCreatingImagePreview;let isProcessingImage;let imageLoadShowProgressIndicator;let imageLoadStatusLabel;let imageProcessStatusLabel;let imageProcessProgress;let imageProcessShowProgressIndicator;let isImageProcessingError;let isStatusVisible;let handleTouchStart;let toolbarItems;let hasClientRect;let canRender;let routePing;$$self.$$.update=()=>{if($$self.$$.dirty[3]&/*layoutMode*/33554432){$$invalidate(160,isOverlayModeEnabled=layoutMode===\"overlay\");}if($$self.$$.dirty[4]&/*enableUtils*/32|$$self.$$.dirty[5]&/*isOverlayModeEnabled*/32){$$invalidate(14,showUtils=enableUtils&&!isOverlayModeEnabled);}if($$self.$$.dirty[0]&/*pluginOptions, pluginInterface*/129){// map plugin options to plugin interface\nif(pluginOptions){// for every plugin in plugin options\nObject.keys(pluginOptions).forEach(plugin=>{// for every prop defined for this plugin\nObject.keys(pluginOptions[plugin]).forEach(prop=>{// set value to interface\nif(!pluginInterface[plugin])return;// set prop value\n$$invalidate(0,pluginInterface[plugin][prop]=pluginOptions[plugin][prop],pluginInterface);});});}}if($$self.$$.dirty[0]&/*pluginInterface*/1|$$self.$$.dirty[4]&/*pluginComponents*/1024){{let changed=false;pluginComponents.forEach(([key])=>{if(pluginInterface[key])return;$$invalidate(0,pluginInterface[key]={},pluginInterface);changed=true;});if(changed){$$invalidate(156,registeredPluginsComponents=[...pluginComponents]);}}}if($$self.$$.dirty[4]&/*previewImageDataMaxSize*/128){maxImageDataSize=previewImageDataMaxSize?sizeMin(previewImageDataMaxSize,maxTextureSize):maxTextureSize;}if($$self.$$.dirty[5]&/*$images*/128){imageProxy.update($images[0]);}if($$self.$$.dirty[0]&/*$clientRect*/32768){$clientRect&&rootRect.set(rectCreate($clientRect.x,$clientRect.y,$clientRect.width,$clientRect.height));}if($$self.$$.dirty[5]&/*$rootRect, isOverlayModeEnabled, $imageLoadState*/1312){$rootRect&&isOverlayModeEnabled&&$imageLoadState&&$imageLoadState.complete&&syncRootAspectRatio();}if($$self.$$.dirty[3]&/*previewUpscale*/1073741824|$$self.$$.dirty[5]&/*isOverlayModeEnabled*/32){previewShouldUpscale.set(previewUpscale||isOverlayModeEnabled);}if($$self.$$.dirty[5]&/*$isInteracting*/32768){//\n// Animations based on prefers-reduced-motion, automatically checks if user prefers reduced animations\n//\n$$invalidate(177,canAnimate=!$isInteracting);}if($$self.$$.dirty[5]&/*$prefersReducedMotion*/16777216){$$invalidate(178,acceptsAnimations=!$prefersReducedMotion);}if($$self.$$.dirty[3]&/*animations*/536870912|$$self.$$.dirty[5]&/*canAnimate, acceptsAnimations*/12582912){$$invalidate(18,shouldAnimate=animations===\"always\"?canAnimate:animations===\"never\"?false:canAnimate&&acceptsAnimations);}if($$self.$$.dirty[5]&/*$history*/67108864){$$invalidate(180,canUndo=$history.index>-1);}if($$self.$$.dirty[5]&/*$history*/67108864){$$invalidate(182,canRedo=$history.index<$history.length-1);}if($$self.$$.dirty[0]&/*locale*/4|$$self.$$.dirty[3]&/*utils*/268435456|$$self.$$.dirty[5]&/*registeredPluginsComponents*/2){$$invalidate(184,utilsFiltered=locale&&registeredPluginsComponents.length?utils||registeredPluginsComponents.map(([id])=>id):[]);}if($$self.$$.dirty[5]&/*registeredPluginsComponents, utilsFiltered*/536870914){$$invalidate(185,utilsAvailable=registeredPluginsComponents.filter(([id])=>utilsFiltered.includes(id)));}if($$self.$$.dirty[5]&/*utilsAvailable*/1073741824){$$invalidate(186,utilsDefined=utilsAvailable.length);}if($$self.$$.dirty[0]&/*locale*/4|$$self.$$.dirty[5]&/*utilsFiltered, utilsAvailable*/1610612736){$$invalidate(20,utilsMerged=utilsFiltered.map(utilId=>{const util=utilsAvailable.find(([id])=>utilId===id);// [id, view]\nif(!util)return;return{id:utilId,view:util[1],tabIcon:locale[`${utilId}Icon`],tabLabel:locale[`${utilId}Label`]};}).filter(Boolean)||[]);}if($$self.$$.dirty[3]&/*util*/134217728|$$self.$$.dirty[5]&/*utilsFiltered*/536870912|$$self.$$.dirty[6]&/*utilsDefined*/1){$$invalidate(21,utilSelected=util&&typeof util===\"string\"&&utilsFiltered.includes(util)?util:utilsDefined&&utilsFiltered[0]);}if($$self.$$.dirty[0]&/*utilSelected, pluginInterface*/2097153){$$invalidate(187,utilTools=utilSelected&&pluginInterface[utilSelected].tools||[]);}if($$self.$$.dirty[0]&/*utilsMerged, utilsVisibleFraction*/5242880){$$invalidate(22,utilsVisibleFraction=utilsMerged.reduce((prev,curr)=>{prev[curr.id]=utilsVisibleFraction&&utilsVisibleFraction[curr.id]||0;return prev;},{}));}if($$self.$$.dirty[0]&/*utilSelected*/2097152){$$invalidate(23,tabsConfig={name:utilsUniqueId,selected:utilSelected});}if($$self.$$.dirty[0]&/*utilsMerged*/1048576){$$invalidate(24,tabs=utilsMerged.map(util=>({id:util.id,icon:util.tabIcon,label:util.tabLabel})));}if($$self.$$.dirty[0]&/*utilsMerged*/1048576){$$invalidate(25,panels=utilsMerged.map(util=>util.id));}if($$self.$$.dirty[5]&/*utilsFiltered*/536870912){$$invalidate(16,shouldRenderTabs=utilsFiltered.length>1);}if($$self.$$.dirty[3]&/*klass*/16777216){$$invalidate(26,className=arrayJoin([\"DokaRoot\",\"DokaRootComponent\",klass]));}if($$self.$$.dirty[5]&/*$rootRect*/256){$$invalidate(188,orientation=$rootRect&&($rootRect.width>$rootRect.height?\"landscape\":\"portrait\"));}if($$self.$$.dirty[6]&/*orientation*/4){$$invalidate(27,isLandscape=orientation===\"landscape\");}if($$self.$$.dirty[5]&/*$rootRect*/256){$$invalidate(189,horizontalSpace=$rootRect&&($rootRect.width>1000?\"wide\":$rootRect.width<600?\"narrow\":undefined));}if($$self.$$.dirty[5]&/*$rootRect*/256){$$invalidate(190,hasLimitedSpace=$rootRect&&($rootRect.width<=320||$rootRect.height<=460));}if($$self.$$.dirty[5]&/*$rootRect*/256){$$invalidate(191,verticalSpace=$rootRect&&($rootRect.height>1000?\"tall\":$rootRect.height<600?\"short\":undefined));}if($$self.$$.dirty[0]&/*root*/2){$$invalidate(192,isModal=root&&root.parentNode&&root.parentNode.classList.contains(\"DokaModal\"));}if($$self.$$.dirty[0]&/*windowWidth*/1024|$$self.$$.dirty[5]&/*$rootRect*/256|$$self.$$.dirty[6]&/*isModal*/64){$$invalidate(193,isCenteredHorizontally=isModal&&$rootRect&&windowWidth>$rootRect.width);}if($$self.$$.dirty[0]&/*windowHeight*/2048|$$self.$$.dirty[5]&/*$rootRect*/256|$$self.$$.dirty[6]&/*isModal*/64){$$invalidate(194,isCenteredVertically=isModal&&$rootRect&&windowHeight>$rootRect.height);}if($$self.$$.dirty[6]&/*isCenteredHorizontally, isCenteredVertically*/384){$$invalidate(195,isCentered=isCenteredHorizontally&&isCenteredVertically);}if($$self.$$.dirty[6]&/*horizontalSpace*/8){$$invalidate(196,isNarrow=horizontalSpace===\"narrow\");}if($$self.$$.dirty[6]&/*isNarrow, verticalSpace*/1056){$$invalidate(197,isCompact=isNarrow||verticalSpace===\"short\");}if($$self.$$.dirty[0]&/*windowWidth*/1024|$$self.$$.dirty[5]&/*$rootRect*/256){$$invalidate(198,hasSwipeNavigation=iOS&&$rootRect&&windowWidth===$rootRect.width&&!shouldPreventSwipe);}if($$self.$$.dirty[6]&/*utilTools, verticalSpace*/34){$$invalidate(199,shouldRenderUtilTools=utilTools.length&&verticalSpace===\"short\");}if($$self.$$.dirty[0]&/*root*/2){// will update when root element is available\n$$invalidate(200,rootElementComputedStyle=root&&getComputedStyle(root));}if($$self.$$.dirty[6]&/*rootElementComputedStyle*/16384){// sync for first time\nif(rootElementComputedStyle)syncBackgroundColor();}if($$self.$$.dirty[0]&/*enableToolbar, shouldRenderTabs, showUtils*/81984|$$self.$$.dirty[3]&/*layoutMode*/33554432|$$self.$$.dirty[6]&/*$env, orientation, horizontalSpace, verticalSpace, isModal, isCentered, isCenteredHorizontally, isCenteredVertically, $pointerAccuracy, $pointerHoverable, isCompact, hasSwipeNavigation, hasLimitedSpace*/236540){env.set(_objectSpread(_objectSpread({},$env),{},{layoutMode,orientation,horizontalSpace,verticalSpace,isModal,isCentered,isCenteredHorizontally,isCenteredVertically,pointerAccuracy:$pointerAccuracy,pointerHoverable:$pointerHoverable,isCompact,hasSwipeNavigation,hasLimitedSpace,hasToolbar:enableToolbar,hasNavigation:shouldRenderTabs&&showUtils,isIOS:iOS}));}if($$self.$$.dirty[6]&/*$env*/32768){$$invalidate(29,envStr=Object.keys($env).map(key=>{// is true boolean prop, use key\nif(/^is|has/.test(key)){return $env[key]?toKebabCase(key):undefined;}// use value\nreturn $env[key];}).filter(Boolean).join(\" \"));}if($$self.$$.dirty[5]&/*$imageCropRect*/16384|$$self.$$.dirty[6]&/*$imageTransforms, $imagePreviewModifiers, $imageEffects, $imageBackgroundColor*/3932160){$$invalidate(30,imageProps=$imageTransforms?_objectSpread(_objectSpread(_objectSpread(_objectSpread({},Object.keys($imagePreviewModifiers).filter(key=>$imagePreviewModifiers[key]!=null).reduce((prev,curr)=>{prev=_objectSpread(_objectSpread({},prev),$imagePreviewModifiers[curr]);return prev;},{})),$imageTransforms),$imageEffects),{},{backgroundColor:$imageBackgroundColor,size:sizeCreateFromRect($imageCropRect)}):undefined);}if($$self.$$.dirty[0]&/*locale*/4|$$self.$$.dirty[6]&/*missingFeatures*/4194304){$$invalidate(32,isSupportsError=locale&&missingFeatures.length&&locale.labelSupportError(missingFeatures));}if($$self.$$.dirty[5]&/*$imageLoadState*/1024){//\n// loading status\n//\n$$invalidate(33,isImageLoadError=$imageLoadState&&!!$imageLoadState.error);}if($$self.$$.dirty[5]&/*$imageLoadState*/1024){$$invalidate(34,isWaitingForImage=!$imageLoadState||!$imageLoadState.complete&&$imageLoadState.task===undefined);}if($$self.$$.dirty[5]&/*$imageLoadState*/1024){$$invalidate(35,imageLoadProgress=$imageLoadState&&($imageLoadState.taskLengthComputable?$imageLoadState.taskProgress:Infinity));}if($$self.$$.dirty[5]&/*$imageLoadState, loadTimer*/1040){if($imageLoadState&&$imageLoadState.complete){// TODO: derive visual load complete from interface rest state instead of arbitrary timer\nclearTimeout(loadTimer);$$invalidate(159,loadTimer=setTimeout(()=>{set_store_value(imageVisualLoadComplete,$imageVisualLoadComplete=true,$imageVisualLoadComplete);},500));}else if(!$imageLoadState){set_store_value(imageVisualLoadComplete,$imageVisualLoadComplete=false,$imageVisualLoadComplete);}}if($$self.$$.dirty[1]&/*isImageLoadError, isWaitingForImage*/12|$$self.$$.dirty[5]&/*$imageLoadState*/1024|$$self.$$.dirty[6]&/*$imageVisualLoadComplete*/8388608){$$invalidate(36,isLoadingImageData=$imageLoadState&&!isImageLoadError&&!isWaitingForImage&&!$imageVisualLoadComplete);}if($$self.$$.dirty[1]&/*$imagePreview*/128|$$self.$$.dirty[6]&/*$imageFile*/16777216){$$invalidate(37,isCreatingImagePreview=!!($imageFile&&!$imagePreview));}if($$self.$$.dirty[5]&/*$imageProcessingPreparing*/268435456|$$self.$$.dirty[6]&/*$imageProcessState*/33554432){//\n// processing status\n//\n$$invalidate(39,isProcessingImage=$imageProcessingPreparing||$imageProcessState&&$imageProcessState.progress!==undefined&&!$imageProcessState.complete);}if($$self.$$.dirty[1]&/*isWaitingForImage*/8|$$self.$$.dirty[5]&/*$imageLoadState*/1024){$$invalidate(40,imageLoadShowProgressIndicator=$imageLoadState&&!($imageLoadState.error||isWaitingForImage));}if($$self.$$.dirty[0]&/*locale*/4|$$self.$$.dirty[5]&/*$imageLoadState*/1024){$$invalidate(41,imageLoadStatusLabel=locale&&(!$imageLoadState?locale.statusLabelLoadImage($imageLoadState):!$imageLoadState.complete?stringReplace(locale.statusLabelLoadImage($imageLoadState),$imageLoadState.error&&$imageLoadState.error.metadata,\"{\",\"}\"):locale.statusLabelLoadImage({progress:Infinity,task:\"blob-to-bitmap\"})));}if($$self.$$.dirty[0]&/*locale*/4|$$self.$$.dirty[6]&/*$imageProcessState*/33554432){$$invalidate(42,imageProcessStatusLabel=$imageProcessState&&locale&&locale.statusLabelProcessImage($imageProcessState));}if($$self.$$.dirty[6]&/*$imageProcessState*/33554432){$$invalidate(43,imageProcessProgress=$imageProcessState&&($imageProcessState.taskLengthComputable?$imageProcessState.taskProgress:Infinity));}if($$self.$$.dirty[6]&/*$imageProcessState*/33554432){$$invalidate(44,imageProcessShowProgressIndicator=$imageProcessState&&!$imageProcessState.error);}if($$self.$$.dirty[6]&/*$imageProcessState*/33554432){$$invalidate(45,isImageProcessingError=$imageProcessState&&$imageProcessState.error);}if($$self.$$.dirty[1]&/*isSupportsError, isWaitingForImage, isImageLoadError, isLoadingImageData, isCreatingImagePreview, isProcessingImage*/366){set_store_value(statusOpacity,$statusOpacity=isSupportsError||isWaitingForImage||isImageLoadError||isLoadingImageData||isCreatingImagePreview||isProcessingImage?1:0,$statusOpacity);}if($$self.$$.dirty[1]&/*$statusOpacity*/32768){$$invalidate(47,isStatusVisible=$statusOpacity>0);}if($$self.$$.dirty[1]&/*$statusOpacity*/32768){if($statusOpacity<=0)hideStatus();}if($$self.$$.dirty[0]&/*windowWidth*/1024){$$invalidate(50,handleTouchStart=shouldPreventSwipe&&(e=>{// get touch or event itself (fixes issue with chrome dev tools)\nconst event=e.touches?e.touches[0]:e;// if is not an attempt to swipe back or forward\nif(event.pageX>10&&event.pageX<windowWidth-10)return;// stop the navigation attempt\ne.preventDefault();}));}if($$self.$$.dirty[0]&/*locale*/4|$$self.$$.dirty[4]&/*willRenderToolbar, enableButtonClose, enableButtonRevert, enableNavigateHistory, enableButtonExport*/94|$$self.$$.dirty[5]&/*canUndo, canRedo*/167772160|$$self.$$.dirty[6]&/*shouldRenderUtilTools, utilTools, isNarrow, $env*/41986){// dynamic IO menu\n$$invalidate(51,toolbarItems=locale&&willRenderToolbar([[\"div\",\"alpha\",{class:\"DokaNavGroup\"},[[\"div\",\"alpha-set\",{class:\"DokaNavSet\"},[// button close\nenableButtonClose&&[Button,\"close\",{label:locale.labelClose,icon:locale.iconButtonClose,onclick:()=>dispatch(\"close\"),hideLabel:true}],// button revert\nenableButtonRevert&&[Button,\"revert\",{label:locale.labelButtonRevert,icon:locale.iconButtonRevert,disabled:!canUndo,onclick:revert,hideLabel:true}]]]]],[\"div\",\"beta\",{class:\"DokaNavGroup DokaNavGroupFloat\"},[enableNavigateHistory&&[\"div\",\"history\",{class:\"DokaNavSet\"},[[Button,\"undo\",{label:locale.labelButtonUndo,icon:locale.iconButtonUndo,disabled:!canUndo,onclick:history.undo,hideLabel:true}],[Button,\"redo\",{label:locale.labelButtonRedo,icon:locale.iconButtonRedo,disabled:!canRedo,onclick:history.redo,hideLabel:true}]]],shouldRenderUtilTools&&[\"div\",\"plugin-tools\",{class:\"DokaNavSet\"},utilTools.filter(Boolean).map(// in\n([component,key,props])=>// out\n[component,key,_objectSpread(_objectSpread({},props),{},{hideLabel:true})])]]],[\"div\",\"gamma\",{class:\"DokaNavGroup\"},[enableButtonExport&&[Button,\"export\",{label:locale.labelButtonExport,icon:isNarrow&&locale.iconButtonExport,class:\"DokaButtonExport\",onclick:handleExport,hideLabel:isNarrow}]]]],_objectSpread({},$env)));}if($$self.$$.dirty[0]&/*$clientRect*/32768){$$invalidate(212,hasClientRect=$clientRect&&$clientRect.width>0&&$clientRect.height>0);}if($$self.$$.dirty[0]&/*locale*/4|$$self.$$.dirty[6]&/*hasClientRect, utilsDefined*/67108865){$$invalidate(52,canRender=hasClientRect&&locale&&utilsDefined);}if($$self.$$.dirty[0]&/*rootPortal*/8192){rootPortal&&rootPortalStore.set(rootPortal);}};$$invalidate(208,missingFeatures=[!supportsWebGL()&&\"WebGL\"].filter(Boolean));// used to route ping events\n$$invalidate(53,routePing=createPingRouter(eventProxy.pub));return[pluginInterface,root,locale,id,elasticityMultiplier,willRenderCanvas,enableToolbar,pluginOptions,imageSourceToImageData,history,windowWidth,windowHeight,utilsVisible,rootPortal,showUtils,$clientRect,shouldRenderTabs,$imageSize,shouldAnimate,$tabRect,utilsMerged,utilSelected,utilsVisibleFraction,tabsConfig,tabs,panels,className,isLandscape,$rootBackgroundColor,envStr,imageProps,$imageSelectionRectPresentation,isSupportsError,isImageLoadError,isWaitingForImage,imageLoadProgress,isLoadingImageData,isCreatingImagePreview,$imagePreview,isProcessingImage,imageLoadShowProgressIndicator,imageLoadStatusLabel,imageProcessStatusLabel,imageProcessProgress,imageProcessShowProgressIndicator,isImageProcessingError,$statusOpacity,isStatusVisible,$statusOffsetX,$progressOffsetX,handleTouchStart,toolbarItems,canRender,routePing,$toolRect,$utilRect,$pixelRatio,$imagePreviews,$imageDecoration,$imageAnnotation,$imageOverlay,imageFile,imageSize,imageLoadState,imageProcessState,imageCropRect,imageBackgroundColor,imageDecoration,imageAnnotation,imageState,images,rootBackgroundColor,clientRect,rootRect,tabRect,toolRect,utilRect,stageRect,pointerAccuracy,pointerHoverable,isInteracting,isInteractingFraction,previewShouldUpscale,stageScalar,imageCropRectSnapshot,imageCropRectIntent,imageSelectionRect,imageSelectionRectSnapshot,imageSelectionRectIntent,imageSelectionRectPresentation,presentationScalar,imageOverlay,imageVisualLoadComplete,imagePreview,imagePreviewModifiers,imagePreviews,imageTransforms,imageEffects,env,pixelRatio,imageProcessingPreparing,utilStores,handleTransitionEnd,statusOpacity,statusOffsetX,progressOffsetX,offsetProgress,handleCloseImageLoadError,handleCloseImageProcessError,pressedKeysStore,handleKeydown,handleKeyup,handleWindowBlur,handleContextMenu,handleDropFiles,getStageState,createCanvasState,klass,layoutMode,stores,util,utils,animations,previewUpscale,willRevert,willRenderToolbar,enableButtonExport,enableButtonRevert,enableNavigateHistory,enableUtils,enableButtonClose,previewImageDataMaxSize,enableDropImage,imageOrienter,pluginComponents,sub,onwindowresize,measure_handler,select_handler,func,panel_component_binding,measure_handler_1,show_handler,hide_handler,fade_handler,measure_handler_2,func_1,panel_component_binding_1,measure_handler_3,show_handler_1,hide_handler_1,fade_handler_1,func_2,div_binding,div_binding_1,measure_handler_4];}class Ui extends SvelteComponent{constructor(options){super();init(this,options,instance$b,create_fragment$b,safe_not_equal,{class:117,layout:118,stores:119,locale:2,id:3,util:120,utils:121,animations:122,previewUpscale:123,elasticityMultiplier:4,willRevert:124,willRenderCanvas:5,willRenderToolbar:125,enableButtonExport:126,enableButtonRevert:127,enableNavigateHistory:128,enableToolbar:6,enableUtils:129,enableButtonClose:130,previewImageDataMaxSize:131,enableDropImage:132,imageOrienter:133,pluginComponents:134,pluginOptions:7,sub:135,pluginInterface:0,root:1,imageSourceToImageData:8,history:9},[-1,-1,-1,-1,-1,-1,-1,-1,-1]);}get class(){return this.$$.ctx[117];}set class(klass){this.$set({class:klass});flush();}get layout(){return this.$$.ctx[118];}set layout(layoutMode){this.$set({layout:layoutMode});flush();}get stores(){return this.$$.ctx[119];}set stores(stores){this.$set({stores});flush();}get locale(){return this.$$.ctx[2];}set locale(locale){this.$set({locale});flush();}get id(){return this.$$.ctx[3];}set id(id){this.$set({id});flush();}get util(){return this.$$.ctx[120];}set util(util){this.$set({util});flush();}get utils(){return this.$$.ctx[121];}set utils(utils){this.$set({utils});flush();}get animations(){return this.$$.ctx[122];}set animations(animations){this.$set({animations});flush();}get previewUpscale(){return this.$$.ctx[123];}set previewUpscale(previewUpscale){this.$set({previewUpscale});flush();}get elasticityMultiplier(){return this.$$.ctx[4];}set elasticityMultiplier(elasticityMultiplier){this.$set({elasticityMultiplier});flush();}get willRevert(){return this.$$.ctx[124];}set willRevert(willRevert){this.$set({willRevert});flush();}get willRenderCanvas(){return this.$$.ctx[5];}set willRenderCanvas(willRenderCanvas){this.$set({willRenderCanvas});flush();}get willRenderToolbar(){return this.$$.ctx[125];}set willRenderToolbar(willRenderToolbar){this.$set({willRenderToolbar});flush();}get enableButtonExport(){return this.$$.ctx[126];}set enableButtonExport(enableButtonExport){this.$set({enableButtonExport});flush();}get enableButtonRevert(){return this.$$.ctx[127];}set enableButtonRevert(enableButtonRevert){this.$set({enableButtonRevert});flush();}get enableNavigateHistory(){return this.$$.ctx[128];}set enableNavigateHistory(enableNavigateHistory){this.$set({enableNavigateHistory});flush();}get enableToolbar(){return this.$$.ctx[6];}set enableToolbar(enableToolbar){this.$set({enableToolbar});flush();}get enableUtils(){return this.$$.ctx[129];}set enableUtils(enableUtils){this.$set({enableUtils});flush();}get enableButtonClose(){return this.$$.ctx[130];}set enableButtonClose(enableButtonClose){this.$set({enableButtonClose});flush();}get previewImageDataMaxSize(){return this.$$.ctx[131];}set previewImageDataMaxSize(previewImageDataMaxSize){this.$set({previewImageDataMaxSize});flush();}get enableDropImage(){return this.$$.ctx[132];}set enableDropImage(enableDropImage){this.$set({enableDropImage});flush();}get imageOrienter(){return this.$$.ctx[133];}set imageOrienter(imageOrienter){this.$set({imageOrienter});flush();}get pluginComponents(){return this.$$.ctx[134];}set pluginComponents(pluginComponents){this.$set({pluginComponents});flush();}get pluginOptions(){return this.$$.ctx[7];}set pluginOptions(pluginOptions){this.$set({pluginOptions});flush();}get sub(){return this.$$.ctx[135];}get pluginInterface(){return this.$$.ctx[0];}get root(){return this.$$.ctx[1];}set root(root){this.$set({root});flush();}get imageSourceToImageData(){return this.$$.ctx[8];}set imageSourceToImageData(imageSourceToImageData){this.$set({imageSourceToImageData});flush();}get history(){return this.$$.ctx[9];}}// which props to filter out of exported props\nconst utilPrivateProps=['klass','stores','isVisible','isActive','isActiveFraction','locale'];const viewPrivateProps=[// methods\n'history',// props\n'klass','stores','navButtons','pluginComponents','pluginInterface','pluginOptions','sub'];// view options array\nlet editorProps;const pluginProps=new Set([]);const propPluginRef={};// loops over plugins and registers all available options so we can define getters/setters\nconst pluginComponents=new Map();const setEditorViewPlugins=(...args)=>{args.forEach(plugin=>{const[id,Component]=plugin.util;pluginComponents.set(id,Component);getComponentExportedProps(Component).filter(prop=>!utilPrivateProps.includes(prop)).forEach(prop=>{pluginProps.add(prop);if(propPluginRef[prop]){propPluginRef[prop].push(id);return;}propPluginRef[prop]=[id];});});};const getEditorViewProps=()=>{editorProps=new Set(getComponentExportedProps(Ui).filter(prop=>!viewPrivateProps.includes(prop)));return[...editorProps,...pluginProps];};const attachEditorView=(target,stores)=>{const accessors={};const editor=new Ui({target,props:{stores,pluginComponents:Array.from(pluginComponents)}});// set up accessors for editor props\nif(!editorProps)editorProps=new Set(getComponentExportedProps(Ui).filter(prop=>!viewPrivateProps.includes(prop)));editorProps.forEach(prop=>{Object.defineProperty(accessors,prop,{get:()=>editor.prop,set:value=>editor[prop]=value});});// set up accessors for plugin props\npluginProps.forEach(prop=>{const plugins=propPluginRef[prop];const plugin=plugins[0];// will always get value from first plugin, when plugins share a property the value will be in sync when set\nObject.defineProperty(accessors,prop,{get:()=>editor.pluginInterface[plugin][prop],set:value=>{const opts=plugins.reduce((prev,plugin)=>{prev[plugin]=_objectSpread(_objectSpread({},editor.pluginOptions[plugin]),{},{[prop]:value});return prev;},{});editor.pluginOptions=_objectSpread(_objectSpread({},editor.pluginOptions),opts);}});});// add element root query\nObject.defineProperty(accessors,'element',{get:()=>editor.root,set:()=>undefined});defineMethods(accessors,{on:(event,cb)=>{if(/undo|redo|revert/.test(event))return editor.history.on(event,cb);const unsubs=[editor.sub(event,cb),editor.$on(event,e=>cb(e instanceof CustomEvent&&!e.detail?undefined:e))].filter(Boolean);return()=>unsubs.forEach(unsub=>unsub());},undo:()=>editor.history.undo(),redo:()=>editor.history.redo(),revert:()=>editor.history.clear(),close:()=>editor.pub('close'),destroy:()=>editor.$destroy()});// clean up on window unload\nif(isBrowser())window.addEventListener('pagehide',()=>editor&&editor.$destroy());return accessors;};var linkAccessors=(destination,origin)=>{const descriptors=Object.getOwnPropertyDescriptors(destination);Object.keys(descriptors).forEach(key=>{// props, set new setter and getter\nif(!!descriptors[key]['get']){Object.defineProperty(origin,key,{get:()=>destination[key],set:value=>destination[key]=value});}// method, copy reference\nelse{origin[key]=destination[key];}});};var editorEvents=[...editorEventsToBubble,'undo','redo','revert','destroy','show','hide','close','selectshape','updateshape','addshape','removeshape'];var hasDoctype=()=>isBrowser()&&document.doctype!==null;var initEditorView=target=>{const accessors={};const{sub,pub}=pubsub();// catch missing doctype\nif(!hasDoctype())console.warn('Missing Document Type Declaration');// create editor core\nconst core=createImageEditor();linkAccessors(core,accessors);// create editor view\nconst view=attachEditorView(target,core.stores);linkAccessors(view,accessors);// listen for UI interaction and link to editor API (internals)\nconst unsubs=['loadImage','processImage','abortProcessImage','abortLoadImage'].map(event=>view.on(event,e=>core[event](e&&e.detail)));// auto subscribes on each possible publisher\nconst subscribe=(event,cb)=>{const unsubInit=sub(event,cb);const unsubCore=core.on(event,cb);const unsubView=view.on(event,cb);return()=>{unsubInit();unsubCore();unsubView();};};// handles every event, useful for routing events from the options object\naccessors.handleEvent=noop;const handleEventUnsubs=editorEvents.map(type=>subscribe(type,res=>accessors.handleEvent(type,res)));// set up new api\ndefineMethods(accessors,{on:subscribe,close:()=>{pub('close');},destroy:()=>{// unsub\n[...unsubs,...handleEventUnsubs].forEach(unsub=>unsub());// destroy\nview.destroy();core.destroy();// destroyed\npub('destroy');}});return accessors;};var appendEditor=(target,options={})=>{const element=isString(target)?document.querySelector(target):target;if(!element)return undefined;options.class=options.class?`doka-image-editor ${options.class}`:'doka-image-editor';const accessors=initEditorView(element);return Object.assign(accessors,options);};var appendEditors=(targets,options={})=>{const elements=isString(targets)?Array.from(document.querySelectorAll(targets)):targets;return elements.filter(Boolean).map(element=>appendEditor(element,deepCopy(options)));};/* src/core/ui/modal/index.svelte generated by Svelte v3.29.4 */const{document:document_1}=globals;function create_fragment$c(ctx){let t;let div;let mounted;let dispose;add_render_callback(/*onwindowresize*/ctx[14]);return{c(){t=space();div=element(\"div\");attr(div,\"class\",\"doka-image-editor DokaModal\");attr(div,\"style\",/*style*/ctx[4]);},m(target,anchor){insert(target,t,anchor);insert(target,div,anchor);/*div_binding*/ctx[15](div);if(!mounted){dispose=[listen(window,\"keydown\",/*handleKey*/ctx[9]),listen(window,\"orientationchange\",/*spawnMeasureElement*/ctx[10]),listen(window,\"resize\",/*onwindowresize*/ctx[14]),listen(document_1.body,\"focusin\",function(){if(is_function(!/*hidden*/ctx[1]&&/*handleFocusIn*/ctx[6]))(!/*hidden*/ctx[1]&&/*handleFocusIn*/ctx[6]).apply(this,arguments);}),listen(document_1.body,\"focusout\",function(){if(is_function(/*hasFocussedTextField*/ctx[2]&&/*handleFocusOut*/ctx[7]))(/*hasFocussedTextField*/ctx[2]&&/*handleFocusOut*/ctx[7]).apply(this,arguments);}),listen(div,\"wheel\",/*handleWheel*/ctx[8])];mounted=true;}},p(new_ctx,dirty){ctx=new_ctx;if(dirty[0]&/*style*/16){attr(div,\"style\",/*style*/ctx[4]);}},i:noop$1,o:noop$1,d(detaching){if(detaching)detach(t);if(detaching)detach(div);/*div_binding*/ctx[15](null);mounted=false;run_all(dispose);}};}function instance$c($$self,$$props,$$invalidate){let $opacity;const dispatch=createEventDispatcher();let{root}=$$props;let{preventZoomViewport=true}=$$props;let hidden=true;let hiding=false;let showing=false;const opacity=spring(0,{precision:0.001,damping:0.5});component_subscribe($$self,opacity,value=>$$invalidate(25,$opacity=value));// animate hide and show\nconst unsub=opacity.subscribe(o=>{if(showing&&o>=1){showing=false;// now shown\n$$invalidate(1,hidden=false);dispatch(\"show\");}else if(hiding&&o<=0){hiding=false;// now hidden\n$$invalidate(1,hidden=true);dispatch(\"hide\");}});// clean up when removed\nonDestroy(()=>unsub());let hasFocussedTextField=false;let viewportDefaults=undefined;let showTimeoutId=undefined;const getViewPortElement=()=>document.querySelector(\"meta[name=viewport]\");const show=()=>{// is visible, or busy becoming visible\nif(showing||!hidden)return;// now in 'showing' transition\nshowing=true;// store default viewport element values\nconst viewportElement=getViewPortElement()||h(\"meta\",{name:\"viewport\"});viewportDefaults=!viewportDefaults&&viewportElement.getAttribute(\"content\");viewportElement.setAttribute(\"content\",viewportRules+(/cover/.test(viewportDefaults)?\",viewport-fit=cover\":\"\"));if(!viewportElement.parentNode)document.head.appendChild(viewportElement);clearTimeout(showTimeoutId);showTimeoutId=setTimeout(()=>set_store_value(opacity,$opacity=1,$opacity),250);};const hide=()=>{// is hiding or already hidden\nif(hiding||hidden)return;// if previous command was show, we need to prevent the timeout from kicking off\nclearTimeout(showTimeoutId);// now in 'hiding' transition\nhiding=true;// get a reference to the viewport element, it should be there as we created it earlier, \n// we restore defaults if the viewport metatag was defined, if not, we destroy it\nconst viewportElement=getViewPortElement();if(viewportDefaults)viewportElement.setAttribute(\"content\",viewportDefaults);else document.head.removeChild(viewportElement);// let's hide!\nset_store_value(opacity,$opacity=0,$opacity);};// handle soft keyboard impact on window height\nlet focusOutTimer;let focusInWindowHeight;const handleFocusIn=e=>{// test if is text input element\nif(!/textarea/i.test(e.target))return;// now focussing a field\n$$invalidate(2,hasFocussedTextField=true);focusInWindowHeight=windowHeight;};const handleFocusOut=e=>{// test if is text input element\nif(!/textarea/i.test(e.target))return;// prevent accidentally setting two timers\nclearTimeout(focusOutTimer);// test if window height changed, if not, no soft keyboard appeared and we can set false to focus state immidiately\nif(focusInWindowHeight===windowHeight){$$invalidate(2,hasFocussedTextField=false);}else// soft keyboard might have appeared, test for window height change before setting unfocus state\n{const windowCurrentHeight=windowHeight;runWhen(()=>windowHeight!==windowCurrentHeight,()=>$$invalidate(2,hasFocussedTextField=false));}};const runWhen=(test,cb)=>{const frame=()=>{if(test()){cb();return;}requestAnimationFrame(frame);};requestAnimationFrame(frame);};// end soft keyboard logic\n// prevent mousewheel from scrolling content behind modal\nconst handleWheel=e=>e.preventDefault();// handle escape to close modal\nconst handleKey=e=>{// get key type\nconst{key}=e;// only deal with escape key\nif(!/escape/i.test(key))return;// don't close when in an input or textuarea\nconst targetElement=e.target;if(targetElement&&/input|textarea/i.test(targetElement.nodeName))return;hide();};// this logic scales modal to fit viewport height\nlet windowHeight=0;let windowHeightComputed;// iOS measure actual page height so we can make optional use of available space\nlet measureElement;let measureElementHeight=undefined;const spawnMeasureElement=()=>{// can't spawn more than one\nif(measureElement)return;measureElement=h(\"div\",{style:\"position:fixed;height:100vh;top:0\"});document.body.appendChild(measureElement);};onMount(()=>{// no need to run this logic if is not on iOS\nif(!isIOS())return;// will be used in first read to determine page height and bottom padding\nspawnMeasureElement();});afterUpdate(()=>{// will only run on iOS\nif(!measureElement)return;// get height and store\n$$invalidate(23,measureElementHeight=measureElement.offsetHeight);// remove measure element\nmeasureElement.parentNode.removeChild(measureElement);measureElement=undefined;});function onwindowresize(){$$invalidate(3,windowHeight=window.innerHeight);}function div_binding($$value){binding_callbacks[$$value?\"unshift\":\"push\"](()=>{root=$$value;$$invalidate(0,root);});}$$self.$$set=$$props=>{if(\"root\"in $$props)$$invalidate(0,root=$$props.root);if(\"preventZoomViewport\"in $$props)$$invalidate(11,preventZoomViewport=$$props.preventZoomViewport);};let viewportRules;let isIOSFooterVisible;let style;$$self.$$.update=()=>{if($$self.$$.dirty[0]&/*preventZoomViewport*/2048){viewportRules=\"width=device-width,height=device-height,initial-scale=1\"+(preventZoomViewport?\",maximum-scale=1,user-scalable=0\":\"\");}if($$self.$$.dirty[0]&/*hasFocussedTextField, windowHeight*/12){if(!hasFocussedTextField)$$invalidate(21,windowHeightComputed=windowHeight);}if($$self.$$.dirty[0]&/*measureElementHeight, windowHeight*/8388616){$$invalidate(26,isIOSFooterVisible=isIOS()?`--viewport-pad-footer:${measureElementHeight>windowHeight?0:1}`:\"\");}if($$self.$$.dirty[0]&/*windowHeightComputed, $opacity, isIOSFooterVisible*/102760448){$$invalidate(4,style=`height:${windowHeightComputed}px;opacity:${$opacity};--editor-modal:1;${isIOSFooterVisible}`);}};return[root,hidden,hasFocussedTextField,windowHeight,style,opacity,handleFocusIn,handleFocusOut,handleWheel,handleKey,spawnMeasureElement,preventZoomViewport,show,hide,onwindowresize,div_binding];}class Modal extends SvelteComponent{constructor(options){super();init(this,options,instance$c,create_fragment$c,safe_not_equal,{root:0,preventZoomViewport:11,show:12,hide:13},[-1,-1]);}get root(){return this.$$.ctx[0];}set root(root){this.$set({root});flush();}get preventZoomViewport(){return this.$$.ctx[11];}set preventZoomViewport(preventZoomViewport){this.$set({preventZoomViewport});flush();}get show(){return this.$$.ctx[12];}get hide(){return this.$$.ctx[13];}}// @ts-ignore\n// we export a function that renders the view as to not export svelte component related code to outside the ui dir\nvar createModal=(options={},parent)=>new Modal({target:parent||document.body,props:{preventZoomViewport:options.preventZoomViewport}});var openEditor=(options={},parent)=>{// set up pub/sub for the app layer\nconst{sub,pub}=pubsub();const accessors={};const modal=createModal(options,parent);const hide=()=>{modal.hide();};const show=()=>{modal.show();};const view=initEditorView(modal.root);linkAccessors(view,accessors);// link up handle event\naccessors.handleEvent=noop;view.handleEvent=(type,detail)=>accessors.handleEvent(type,detail);// route close request from view to modal\nview.on('close',hide);const subscribe=(event,cb)=>{// capture modal related events\nif(/show|hide/.test(event))return sub(event,cb);// route rest of events to view\nreturn view.on(event,cb);};const modalHandleEventUnsubs=['show','hide'].map(type=>subscribe(type,detail=>accessors.handleEvent(type,detail)));// cleans up view\nconst destroy=()=>{// unsub\nmodalHandleEventUnsubs.forEach(unsub=>unsub());// remove\nhide();modal.$destroy();view.destroy();};defineMethods(accessors,{on:subscribe,destroy,hide,show});// add element root query\nObject.defineProperty(accessors,'modal',{get:()=>modal.root,set:()=>undefined});// destroy when hidden\nmodal.$on('show',()=>pub('show'));modal.$on('hide',()=>{pub('hide');destroy();});// modal behavior\nview.on('process',hide);view.on('loadstart',show);// test if should\nif(options.enableButtonClose!==false)options.enableButtonClose=true;// update props\nObject.assign(accessors,options);return accessors;};var overlayEditor=(target,options)=>{const editor=appendEditor(target,_objectSpread(_objectSpread({},options),{},{layout:'overlay'}));return editor;};const dispatchElementEvent=(target,event,detail)=>target.dispatchEvent(new CustomEvent(event,{detail,bubbles:true,cancelable:true}));var dispatchEditorEvents=(editor,handler,options={})=>{const{prefix='doka:'}=options;return editorEvents.map(event=>editor.on(event,value=>isElement(handler)?dispatchElementEvent(handler,`${prefix}${event}`,value):handler(event,value)));};const TAG='doka-image-editor';var customElement=()=>new Promise(resolve=>{if(!DokaImageEditorElement)return resolve([]);customElements.define(TAG,DokaImageEditorElement);customElements.whenDefined(TAG).then(()=>resolve(document.querySelectorAll(TAG)));});const DokaImageEditorElement=isBrowser()&&class extends HTMLElement{constructor(){super();this._editor=undefined;this._unsubs=undefined;}static get observedAttributes(){return['src'];}attributeChangedCallback(attrName,oldValue,newValue){this[attrName]=newValue;}connectedCallback(){this._editor=initEditorView(this);linkAccessors(this._editor,this);this._editor.src=this.getAttribute('src');this._unsubs=dispatchEditorEvents(this._editor,this);}disconnectedCallback(){this._editor.destroy();this._unsubs.forEach(unsub=>unsub());}};var arrayInsert=(array,index,item)=>{array.splice(index,0,item);return array;};// first index is always id, so if is string, it's a node\nconst isNode=item=>isString(item[0]);// if it's not a node, it's a nodelist\nconst isNodeList=item=>!isNode(item);const getNodeId=node=>node[1];const getNodeChildren=node=>node[3]||[];const createNode=(instance,id,props={},children=[])=>[instance,id,props,children];const insertNode=(node,needle,haystack,getIndex=index=>index)=>{const nodeList=findNodeList(needle,haystack);const targetIndex=nodeList.findIndex(item=>getNodeId(item)===needle);arrayInsert(nodeList,getIndex(targetIndex),node);};const insertNodeBefore=(node,needle,haystack)=>insertNode(node,needle,haystack);const insertNodeAfter=(node,needle,haystack)=>insertNode(node,needle,haystack,index=>index+1);const appendNode=(node,needle,haystack)=>{const parent=findNode(needle,haystack);getNodeChildren(parent).push(node);return parent;};const removeNode=(needle,haystack)=>{const nodeList=findNodeList(needle,haystack);arrayRemove(nodeList,item=>getNodeId(item)===needle);return nodeList;};const findNode=(needle,haystack)=>{return isNode(haystack)?// haystack is a node, maybe node is a match or one of children is a match\ngetNodeId(haystack)===needle?haystack:findNode(needle,getNodeChildren(haystack)):// haystack is a list of nodes\nhaystack.find(item=>findNode(needle,item));};const findNodeList=(needle,haystack)=>{// haystack is node list\nif(isNodeList(haystack)){// lets search nodes in this haystack\nif(haystack.find(item=>getNodeId(item)===needle))return haystack;// not found, lets move the search to the childnodes\nreturn haystack.find(item=>findNodeList(needle,getNodeChildren(item)));}// is node, lets find in children\nreturn findNodeList(needle,getNodeChildren(haystack));};//#region markup\nconst propertyMap={borderColor:'strokeColor',borderWidth:'strokeWidth',lineWidth:'strokeWidth',fontColor:'color',lineColor:'strokeColor',src:'backgroundImage',fit:'backgroundSize'};const convertValue=value=>{if(value===0)return 0;if(value==='0%')return 0;if(value==='0px')return 0;if(/px$/.test(value))return parseInt(value,10);if(/\\%$/.test(value))return value;if(value<=1)return`${value*100}%`;};const addValues=(a,b)=>{let _a,_b;if(/%$/.test(a)){_a=parseFloat(a);_b=parseFloat(b);return`${_a+_b}%`;}if(/px$/.test(a)){_a=parseInt(a,10);_b=parseInt(b,10);return`${_a+_b}px`;}};const shapeFromLegacyMarkup=(crop,type,style)=>{const shape=Object.keys(style).reduce((res,prop)=>{let value=style[prop];// rename prop\nprop=propertyMap[prop]||prop;// if is px value\nif(/px$/.test(value)){value=convertValue(value);}// if is number convert to percentage\nelse if(/^(?:x|y|left|right|top|bottom|width|height|fontSize|strokeWidth)$/.test(prop)&&typeof value==='number'){if(/strokeWidth/.test(prop))value*=2;value=convertValue(value);}// if is color value\nif(/color/i.test(prop)){value=colorStringToColorArray(value);}if(value===null)value=undefined;res[prop]=value;return res;},{});if(type==='line'){if(shape.lineDecoration.length===1)shape.lineEnd='arrow';if(shape.lineDecoration.length===2)shape.lineStart='arrow';shape.x1=shape.x;shape.y1=shape.y;shape.x2=addValues(shape.x,shape.width);shape.y2=addValues(shape.y,shape.height);delete shape.x;delete shape.y;delete shape.width;delete shape.height;delete shape.lineDecoration;delete shape.lineStyle;}if(type==='text'){shape.y=addValues(shape.y,'-'+shape.fontSize);delete shape.width;delete shape.height;delete shape.borderStyle;}if(type==='ellipse'){let w,h;// calculate `rx` and `ry` based on `width` and `h`eight`\nif(/%$/.test(shape.width)){w=parseFloat(shape.width)/100;h=parseFloat(shape.height)/100;const widthAbsolute=w*crop.width;const heightAbsolute=h*crop.height;w=widthAbsolute/crop.width*100;h=heightAbsolute/crop.height*100;}else{w=shape.width;h=shape.height;}shape.rx=w*0.5;shape.ry=h*0.5;if(/%$/.test(shape.width)){shape.rx+='%';shape.ry+='%';}shape.x=addValues(shape.x,shape.rx);shape.y=addValues(shape.y,shape.ry);delete shape.width;delete shape.height;delete shape.borderStyle;}if(type==='rect'){delete shape.borderStyle;}if(type==='path'){shape.points=shape.points.map(point=>{return{x:convertValue(point.x),y:convertValue(point.y)};});}return shape;};//#endregion\n//#region crop\nconst getOffsetPointOnEdge=(length,rotation)=>{const a=length;const A=1.5707963267948966;const B=rotation;const C=1.5707963267948966-rotation;const sinA=Math.sin(A);const sinB=Math.sin(B);const sinC=Math.sin(C);const cosC=Math.cos(C);const ratio=a/sinA;const b=ratio*sinB;const c=ratio*sinC;return vectorCreate(cosC*b,cosC*c);};const getRotatedRectSize=(rect,rotation)=>{const w=rect.width;const h=rect.height;const hor=getOffsetPointOnEdge(w,rotation);const ver=getOffsetPointOnEdge(h,rotation);const tl=vectorCreate(rect.x+Math.abs(hor.x),rect.y-Math.abs(hor.y));const tr=vectorCreate(rect.x+rect.width+Math.abs(ver.y),rect.y+Math.abs(ver.x));const bl=vectorCreate(rect.x-Math.abs(ver.y),rect.y+rect.height-Math.abs(ver.x));return{width:vectorDistance(tl,tr),height:vectorDistance(tl,bl)};};const getBoundsAroundCenter=(imageSize,center)=>{const cx=center.x>0.5?1-center.x:center.x;const cy=center.y>0.5?1-center.y:center.y;return sizeCreate(cx*2*imageSize.width,cy*2*imageSize.height);};const getCanvasSize=(imageSize,canvasAspectRatio,zoom=1)=>{const imageAspectRatio=imageSize.height/imageSize.width;// determine actual pixels on x and y axis\nlet canvasWidth=1;let canvasHeight=canvasAspectRatio;let imgWidth=1;let imgHeight=imageAspectRatio;if(imgHeight>canvasHeight){imgHeight=canvasHeight;imgWidth=imgHeight/imageAspectRatio;}const scalar=Math.max(canvasWidth/imgWidth,canvasHeight/imgHeight);const width=imageSize.width/(zoom*scalar*imgWidth);const height=width*canvasAspectRatio;return{width:width,height:height};};const getCenteredCropRect=(imageSize,aspectRatio)=>{let width=imageSize.width;let height=width*aspectRatio;if(height>imageSize.height){height=imageSize.height;width=height/aspectRatio;}const x=(imageSize.width-width)*0.5;const y=(imageSize.height-height)*0.5;return rectCreate(x,y,width,height);};const getCorrectedLegacyAspectRatio=(imageSize,aspectRatio)=>aspectRatio!=null?// fox the aspect ratio\n1/aspectRatio:// set image aspect ratio\nimageSize.width/imageSize.height;const imagePropertiesFromLegacyCrop=(imageSize,{flip,aspectRatio,rotation,center,zoom,scaleToFit})=>{const res={};// is centered crop\nconst isCenteredCrop=!center||center&&center.x===0.5&&center.y===0.5;// handle basic props\nif(flip&&flip.horizontal)res.flipHorizontal=flip.horizontal;if(flip&&flip.vertical)res.flipVertical=flip.vertical;// fix aspect ratio, in FilePond and Doka classic it's height/width instead of width/height\nconst correctedAspectRatio=getCorrectedLegacyAspectRatio(imageSize,aspectRatio);// image bounds\nconst cropLimit=!(scaleToFit===false);const canvasSize=getCanvasSize(imageSize,aspectRatio,zoom);const cropSize=isCenteredCrop?imageSize:getBoundsAroundCenter(imageSize,cropLimit?center:{x:0.5,y:0.5});const cropCentered=getCenteredCropRect(imageSize,aspectRatio);// has different aspect ratio than image\nif(aspectRatio||!isCenteredCrop||zoom){res.crop=rectContainRect(rectCreateFromSize(cropSize),correctedAspectRatio);}if(typeof rotation==='number'&&rotation!==null){if(rotation!=null)res.rotation=rotation;const rotatedCropSize=getRotatedRectSize(cropCentered,rotation);const scalar=Math.max(rotatedCropSize.width/cropSize.width,rotatedCropSize.height/cropSize.height);// window.clear();\n// crop position in non-rotated image\nconst cropCenter=vectorCreate(center.x*imageSize.width,center.y*imageSize.height);// const imageCenter = sizeCenter(imageSize);\n// const imageCenterToCropCenter = vectorCreate(\n//     imageCenter.x - cropCenter.x,\n//     imageCenter.y - cropCenter.y\n// );\n// get rotated image center\nconst rotatedImageSize=getImageTransformedRect(imageSize,rotation);const rotatedImageCenter=sizeCenter(rotatedImageSize);const rotatedImageOffset=vectorCreate((rotatedImageSize.width-imageSize.width)*0.5,(rotatedImageSize.height-imageSize.height)*0.5);// window.draw(rotatedImageCenter, 'red');\n// window.draw(rotatedImageSize, 'red');\n// window.draw(\n//     {\n//         x: rotatedImageOffset.x,\n//         y: rotatedImageOffset.y,\n//         width: imageSize.width,\n//         height: imageSize.height,\n//     },\n//     'cyan'\n// );\n// const imagePoints = rectRotate(\n//     rectCreate(\n//         rotatedImageOffset.x,\n//         rotatedImageOffset.y,\n//         imageSize.width,\n//         imageSize.height\n//     ),\n//     rotation\n// );\n// window.draw(imagePoints, 'orange');\nconst cropPoints=rectRotate({x:rotatedImageOffset.x+cropCenter.x-canvasSize.width/scalar*0.5,y:rotatedImageOffset.y+cropCenter.y-canvasSize.height/scalar*0.5,width:canvasSize.width/scalar,height:canvasSize.height/scalar},rotation);// window.draw(cropPoints, 'cyan');\nconst cropBoundsPoints=vectorsRotate(cropPoints.map(vectorClone),rotation,rotatedImageCenter.x,rotatedImageCenter.y);// window.draw(cropBoundsPoints, 'orange');\nconst cropBoundsPointsCenter=rectCenter(rectCreateFromPoints(cropBoundsPoints));// window.draw(cropBoundsPointsCenter, 'green');\nconst deRotatedCropBoundsPoints=vectorsRotate(cropBoundsPoints.map(vectorClone),-(rotation*2),cropBoundsPointsCenter.x,cropBoundsPointsCenter.y);// window.draw(deRotatedCropBoundsPoints, 'green');\nres.crop=rectCreateFromPoints(deRotatedCropBoundsPoints);}else if(zoom!=null){rectScale(res.crop,1/zoom);}if(!cropLimit){res.cropLimitToImage=false;}return res;};//#endregion\nconst isLegacyData=(data={})=>{if('markup'in data||'color'in data||'filter'in data)return true;const{crop}=data;if(crop&&('flip'in crop||'center'in crop||'aspectRatio'in crop||'rotation'in crop))return true;return false;};var legacyDataToImageState=(editor,imageSize,data={})=>{const res={};// test if isn't legacy data\nif(!isLegacyData(data))return data;if(data.crop){Object.assign(res,imagePropertiesFromLegacyCrop(imageSize,data.crop));}if(data.markup){res.decoration=data.markup.map(markup=>shapeFromLegacyMarkup(res.crop||imageSize,markup[0],markup[1])).sort((a,b)=>{if(a.zIndex<b.zIndex)return-1;if(a.zIndex>b.zIndex)return 1;return 0;}).map(shape=>{delete shape.zIndex;return shape;});}if(data.color){res.colorMatrix={brightness:data.color.brightness.matrix,contrast:data.color.contrast.matrix,exposure:data.color.exposure.matrix,saturation:data.color.saturation.matrix};}if(data.filter){if(!res.colorMatrix)res.colorMatrix={};res.colorMatrix.filter=typeof data.filter==='string'&&editor['filterFunctions'][data.filter]?editor['filterFunctions'][data.filter]():data.filter.matrix;}return res;};const isOperaMini=()=>Object.prototype.toString.call(window['operamini'])==='[object OperaMini]';const hasPromises=()=>'Promise'in window;const hasCreateObjectURL=()=>'URL'in window&&'createObjectURL'in window.URL;const hasVisibility=()=>'visibilityState'in document;const hasTiming=()=>'performance'in window;// iOS 8.x\nconst hasFileConstructor=()=>'File'in window;// excludes IE11\nlet result$a=null;var isModernBrowser=()=>{if(result$a===null)result$a=isBrowser()&&// Can't run on Opera Mini due to lack of everything\n!isOperaMini()&&// Require these APIs to feature detect a modern browser\nhasVisibility()&&hasPromises()&&hasFileConstructor()&&hasCreateObjectURL()&&hasTiming();return result$a;};const toPercentageNumber=v=>Math.round(v*100);const brightness={base:0,min:-0.25,max:0.25,getLabel:value=>{return toPercentageNumber(value/0.25);},getStore:({imageColorMatrix})=>imageColorMatrix,getValue:store=>{if(!store.brightness)return;return store.brightness[4];},setValue:(store,v)=>store.update(matrices=>_objectSpread(_objectSpread({},matrices),{},{// prettier-ignore\nbrightness:[1,0,0,0,v,0,1,0,0,v,0,0,1,0,v,0,0,0,1,0]}))};const contrast={base:1,min:0.5,max:1.5,getLabel:value=>{return toPercentageNumber(-1+(value-0.5)*2);},getStore:({imageColorMatrix})=>imageColorMatrix,getValue:store=>{if(!store.contrast)return;return store.contrast[0];},setValue:(store,v)=>store.update(matrices=>_objectSpread(_objectSpread({},matrices),{},{// prettier-ignore\ncontrast:[v,0,0,0,.5*(1-v),0,v,0,0,.5*(1-v),0,0,v,0,.5*(1-v),0,0,0,1,0]}))};const saturation={base:1,min:0,max:2,getLabel:value=>{return toPercentageNumber(value-1);},getStore:({imageColorMatrix})=>imageColorMatrix,getValue:store=>{if(!store.saturation)return;return(store.saturation[0]-0.213)/0.787;},setValue:(store,v)=>store.update(matrices=>_objectSpread(_objectSpread({},matrices),{},{// prettier-ignore\nsaturation:[.213+.787*v,.715-.715*v,.072-.072*v,0,0,.213-.213*v,.715+.285*v,.072-.072*v,0,0,.213-.213*v,.715-.715*v,.072+.928*v,0,0,0,0,0,1,0]}))};const exposure={base:1,min:0.5,max:1.5,getLabel:value=>{return toPercentageNumber(-1+(value-0.5)*2);},getStore:({imageColorMatrix})=>imageColorMatrix,getValue:store=>{if(!store.exposure)return;return store.exposure[0];},setValue:(store,v)=>store.update(matrices=>_objectSpread(_objectSpread({},matrices),{},{// prettier-ignore\nexposure:[v,0,0,0,0,0,v,0,0,0,0,0,v,0,0,0,0,0,1,0]}))};const gamma={base:1,min:0.15,max:4,getLabel:value=>{if(value<1){return toPercentageNumber((value-0.15)/0.85-1);}return toPercentageNumber((value-1)/3);},getStore:({imageGamma})=>imageGamma};const vignette={base:0,min:-1,max:1,getStore:({imageVignette})=>imageVignette};const clarity={base:0,min:-1,max:1,getStore:({imageConvolutionMatrix})=>imageConvolutionMatrix,getValue:store=>{if(!store.clarity)return;if(store.clarity[0]===0){return store.clarity[1]/-1;}else{return store.clarity[1]/-2;}},setValue:(store,v)=>{store.update(matrices=>_objectSpread(_objectSpread({},matrices),{},{// prettier-ignore\nclarity:v>=0?[0,-1*v,0,-1*v,1+4*v,-1*v,0,-1*v,0]:[-1*v,-2*v,-1*v,-2*v,1+-3*v,-2*v,-1*v,-2*v,-1*v]}));}};const temperature={base:0,min:-1,max:1,getStore:({imageColorMatrix})=>imageColorMatrix,getValue:store=>{if(!store.temperature)return;const v=store.temperature[0];if(v>=1){return(v-1)/0.1;}return(1-v)/-0.15;},setValue:(store,v)=>store.update(matrices=>_objectSpread(_objectSpread({},matrices),{},{// prettier-ignore\ntemperature:v>0?[1+v*.1,0,0,0,0,0,1,0,0,0,0,0,1+-v*.1,0,0,0,0,0,1,0]:[1+v*.15,0,0,0,0,0,1+v*.05,0,0,0,0,0,1+-v*.15,0,0,0,0,0,1,0]}))};const finetuneControlConfigurationDefault={gamma,brightness,contrast,saturation,exposure,temperature,clarity,vignette};const finetuneOptionsDefault=[['brightness',locale=>locale.finetuneLabelBrightness],['contrast',locale=>locale.finetuneLabelContrast],['saturation',locale=>locale.finetuneLabelSaturation],['exposure',locale=>locale.finetuneLabelExposure],['temperature',locale=>locale.finetuneLabelTemperature],['gamma',locale=>locale.finetuneLabelGamma],['clarity',locale=>locale.finetuneLabelClarity],['vignette',locale=>locale.finetuneLabelVignette]];var defaults={finetuneControlConfiguration:finetuneControlConfigurationDefault,finetuneOptions:finetuneOptionsDefault};/*\nTODO: fix inverse fn in getValue\nexport const hue = {\n    base: 0,\n    min: 0,\n    max: Math.PI,\n    getStore: ({ imageColorMatrix }) => imageColorMatrix,\n    getValue: (store) => {\n        if (!store.hue) return;\n\n        const v = store.hue[1];\n\n        const o = -(Math.acos((0.715 - v) / Math.sqrt(2) / 0.715) - Math.PI / 4);\n\n        return o;\n    },\n    setValue: (store, v: number) => {\n        store.update((matrices) => {\n            // const value = v * (Math.PI);\n\n            const cos = Math.cos(v);\n            const sin = Math.sin(v);\n\n            const a00 = 0.213 + cos * 0.787 - sin * 0.213;\n            const a01 = 0.715 - cos * 0.715 - sin * 0.715;\n            const a02 = 0.072 - cos * 0.072 + sin * 0.928;\n            const a10 = 0.213 - cos * 0.213 + sin * 0.143;\n            const a11 = 0.715 + cos * 0.285 + sin * 0.14;\n            const a12 = 0.072 - cos * 0.072 - sin * 0.283;\n            const a20 = 0.213 - cos * 0.213 - sin * 0.787;\n            const a21 = 0.715 - cos * 0.715 + sin * 0.715;\n            const a22 = 0.072 + cos * 0.928 + sin * 0.072;\n\n            return {\n                ...matrices,\n\n                // prettier-ignore\n                hue: [\n                    a00, a01, a02, 0, 0,\n                    a10, a11, a12, 0, 0,\n                    a20, a21, a22, 0, 0,\n                      0,   0,   0, 1, 0,\n                ]\n            };\n        });\n    },\n};\n*/const pastel=()=>// prettier-ignore\n[0.75,0.25,0.25,0,0,0.25,0.75,0.25,0,0,0.25,0.25,0.75,0,0,0,0,0,1,0];const chrome=()=>// prettier-ignore\n[1.398,-0.316,0.065,-0.273,0.201,-0.051,1.278,-0.080,-0.273,0.201,-0.051,0.119,1.151,-0.290,0.215,0,0,0,1,0];const fade$1=()=>// prettier-ignore\n[1.073,-0.015,0.092,-0.115,-0.017,0.107,0.859,0.184,-0.115,-0.017,0.015,0.077,1.104,-0.115,-0.017,0,0,0,1,0];const warm=()=>// prettier-ignore\n[1.06,0,0,0,0,0,1.01,0,0,0,0,0,0.93,0,0,0,0,0,1,0];const cold=()=>// prettier-ignore\n[1.1,0,0,0,-.1,0,1.1,0,0,-.1,0,0,1.2,0,-.1,0,0,0,1,0];const invert=()=>// prettier-ignore\n[-1,0,0,1,0,0,-1,0,1,0,0,0,-1,1,0,0,0,0,1,0];const monoDefault=()=>// prettier-ignore\n[0.212,0.715,0.114,0,0,0.212,0.715,0.114,0,0,0.212,0.715,0.114,0,0,0,0,0,1,0];const monoNoir=()=>// prettier-ignore\n[0.15,1.3,-0.25,0.1,-0.2,0.15,1.3,-0.25,0.1,-0.2,0.15,1.3,-0.25,0.1,-0.2,0,0,0,1,0];const monoWash=()=>// prettier-ignore\n[0.163,0.518,0.084,-0.010,0.208,0.163,0.529,0.082,-0.020,0.210,0.171,0.529,0.084,0.000,0.214,0.000,0.000,0.000,1.000,0.000];const monoStark=()=>// prettier-ignore\n[0.338,0.991,0.117,0.093,-0.196,0.302,1.049,0.096,0.078,-0.196,0.286,1.016,0.146,0.101,-0.196,0.000,0.000,0.000,1.000,0.000];const sepiaDefault=()=>// prettier-ignore\n[0.393,0.768,0.188,0,0,0.349,0.685,0.167,0,0,0.272,0.533,0.130,0,0,0,0,0,1,0];const sepiaBlues=()=>// prettier-ignore\n[0.289,0.620,0.185,0.000,0.077,0.257,0.566,0.163,0.000,0.115,0.200,0.430,0.128,0.000,0.188,0.000,0.000,0.000,1.000,0.000];const sepiaRust=()=>// prettier-ignore\n[0.269,0.764,0.172,0.050,0.100,0.239,0.527,0.152,0.000,0.176,0.186,0.400,0.119,0.000,0.159,0.000,0.000,0.000,1.000,0.000];const sepiaColor=()=>// prettier-ignore\n[0.547,0.764,0.134,0.000,-0.147,0.281,0.925,0.120,0.000,-0.135,0.225,0.558,0.330,0.000,-0.113,0.000,0.000,0.000,1.000,0.000];//\n// default filter set\n//\nconst filterFunctionsDefault={chrome,fade:fade$1,pastel,cold,warm,monoDefault,monoWash,monoNoir,monoStark,sepiaDefault,sepiaRust,sepiaBlues,sepiaColor};const filterOptionsDefault=[['Default',[[undefined,locale=>locale.labelDefault]]],['Classic',[['chrome',locale=>locale.filterLabelChrome],['fade',locale=>locale.filterLabelFade],['cold',locale=>locale.filterLabelCold],['warm',locale=>locale.filterLabelWarm],['pastel',locale=>locale.filterLabelPastel]]],['Monochrome',[['monoDefault',locale=>locale.filterLabelMonoDefault],['monoNoir',locale=>locale.filterLabelMonoNoir],['monoStark',locale=>locale.filterLabelMonoStark],['monoWash',locale=>locale.filterLabelMonoWash]]],['Sepia',[['sepiaDefault',locale=>locale.filterLabelSepiaDefault],['sepiaRust',locale=>locale.filterLabelSepiaRust],['sepiaBlues',locale=>locale.filterLabelSepiaBlues],['sepiaColor',locale=>locale.filterLabelSepiaColor]]]];var defaults$1={filterFunctions:filterFunctionsDefault,filterOptions:filterOptionsDefault};// if this is a non retina display snap to pixel\nlet fn=null;var snapToPixel=v=>{if(fn===null)fn=getDevicePixelRatio()===1?v=>Math.round(v):v=>v;return fn(v);};/* src/core/ui/components/Details.svelte generated by Svelte v3.29.4 */const get_details_slot_changes=dirty=>({});const get_details_slot_context=ctx=>({});const get_label_slot_changes=dirty=>({});const get_label_slot_context=ctx=>({});// (167:0) <Button bind:this={buttonComponent}      class={arrayJoin(['DokaDetailsButton', buttonClass])}      onkeydown={handleButtonKeydown}      onclick={handleClick}>\nfunction create_default_slot$2(ctx){let current;const label_slot_template=/*#slots*/ctx[19].label;const label_slot=create_slot(label_slot_template,ctx,/*$$scope*/ctx[23],get_label_slot_context);return{c(){if(label_slot)label_slot.c();},m(target,anchor){if(label_slot){label_slot.m(target,anchor);}current=true;},p(ctx,dirty){if(label_slot){if(label_slot.p&&dirty[0]&/*$$scope*/8388608){update_slot(label_slot,label_slot_template,ctx,/*$$scope*/ctx[23],dirty,get_label_slot_changes,get_label_slot_context);}}},i(local){if(current)return;transition_in(label_slot,local);current=true;},o(local){transition_out(label_slot,local);current=false;},d(detaching){if(label_slot)label_slot.d(detaching);}};}// (174:0) {#if isVisible}\nfunction create_if_block_1$2(ctx){let div;let div_class_value;let measure_action;let current;let mounted;let dispose;const details_slot_template=/*#slots*/ctx[19].details;const details_slot=create_slot(details_slot_template,ctx,/*$$scope*/ctx[23],get_details_slot_context);return{c(){div=element(\"div\");if(details_slot)details_slot.c();attr(div,\"class\",div_class_value=arrayJoin([\"DokaDetailsPanel\",/*panelClass*/ctx[1]]));attr(div,\"tabindex\",\"-1\");attr(div,\"style\",/*style*/ctx[6]);},m(target,anchor){insert(target,div,anchor);if(details_slot){details_slot.m(div,null);}/*div_binding*/ctx[21](div);current=true;if(!mounted){dispose=[listen(div,\"keydown\",/*handlePanelKeydown*/ctx[16]),listen(div,\"measure\",/*measure_handler*/ctx[22]),action_destroyer(measure_action=measurable.call(null,div))];mounted=true;}},p(ctx,dirty){if(details_slot){if(details_slot.p&&dirty[0]&/*$$scope*/8388608){update_slot(details_slot,details_slot_template,ctx,/*$$scope*/ctx[23],dirty,get_details_slot_changes,get_details_slot_context);}}if(!current||dirty[0]&/*panelClass*/2&&div_class_value!==(div_class_value=arrayJoin([\"DokaDetailsPanel\",/*panelClass*/ctx[1]]))){attr(div,\"class\",div_class_value);}if(!current||dirty[0]&/*style*/64){attr(div,\"style\",/*style*/ctx[6]);}},i(local){if(current)return;transition_in(details_slot,local);current=true;},o(local){transition_out(details_slot,local);current=false;},d(detaching){if(detaching)detach(div);if(details_slot)details_slot.d(detaching);/*div_binding*/ctx[21](null);mounted=false;run_all(dispose);}};}function create_fragment$d(ctx){let t0;let button;let t1;let t2;let if_block1_anchor;let current;let mounted;let dispose;let button_props={class:arrayJoin([\"DokaDetailsButton\",/*buttonClass*/ctx[0]]),onkeydown:/*handleButtonKeydown*/ctx[15],onclick:/*handleClick*/ctx[14],$$slots:{default:[create_default_slot$2]},$$scope:{ctx}};button=new Button({props:button_props});/*button_binding*/ctx[20](button);let if_block0=/*isVisible*/ctx[5]&&create_if_block_1$2(ctx);let if_block1=false;return{c(){t0=space();create_component(button.$$.fragment);t1=space();if(if_block0)if_block0.c();t2=space();if_block1_anchor=empty();},m(target,anchor){insert(target,t0,anchor);mount_component(button,target,anchor);insert(target,t1,anchor);if(if_block0)if_block0.m(target,anchor);insert(target,t2,anchor);insert(target,if_block1_anchor,anchor);current=true;if(!mounted){dispose=[listen(document.body,\"pointerdown\",function(){if(is_function(/*handleDown*/ctx[7]))/*handleDown*/ctx[7].apply(this,arguments);}),listen(document.body,\"pointerup\",function(){if(is_function(/*handleUp*/ctx[8]))/*handleUp*/ctx[8].apply(this,arguments);})];mounted=true;}},p(new_ctx,dirty){ctx=new_ctx;const button_changes={};if(dirty[0]&/*buttonClass*/1)button_changes.class=arrayJoin([\"DokaDetailsButton\",/*buttonClass*/ctx[0]]);if(dirty[0]&/*$$scope*/8388608){button_changes.$$scope={dirty,ctx};}button.$set(button_changes);if(/*isVisible*/ctx[5]){if(if_block0){if_block0.p(ctx,dirty);if(dirty[0]&/*isVisible*/32){transition_in(if_block0,1);}}else{if_block0=create_if_block_1$2(ctx);if_block0.c();transition_in(if_block0,1);if_block0.m(t2.parentNode,t2);}}else if(if_block0){group_outros();transition_out(if_block0,1,1,()=>{if_block0=null;});check_outros();}},i(local){if(current)return;transition_in(button.$$.fragment,local);transition_in(if_block0);transition_in(if_block1);current=true;},o(local){transition_out(button.$$.fragment,local);transition_out(if_block0);transition_out(if_block1);current=false;},d(detaching){if(detaching)detach(t0);/*button_binding*/ctx[20](null);destroy_component(button,detaching);if(detaching)detach(t1);if(if_block0)if_block0.d(detaching);if(detaching)detach(t2);if(detaching)detach(if_block1_anchor);mounted=false;run_all(dispose);}};}let panelMargin=12;function instance$d($$self,$$props,$$invalidate){let $portalRootRect;let $position;let $opacity;let $offset;let $portal;let{$$slots:slots={},$$scope}=$$props;let{buttonClass=undefined}=$$props;let{panelClass=undefined}=$$props;let{isActive=false}=$$props;let{onshow=({panel})=>panel.focus()}=$$props;const portal=getContext(\"rootPortal\");component_subscribe($$self,portal,value=>$$invalidate(35,$portal=value));const portalRootRect=getContext(\"rootRect\");component_subscribe($$self,portalRootRect,value=>$$invalidate(29,$portalRootRect=value));let panelSize;let buttonComponent;let buttonRect;let dir=vectorCreateEmpty();let opacity=spring(0);component_subscribe($$self,opacity,value=>$$invalidate(31,$opacity=value));const position=writable({x:0,y:0});component_subscribe($$self,position,value=>$$invalidate(30,$position=value));const offset=spring(-5);component_subscribe($$self,offset,value=>$$invalidate(34,$offset=value));const isTargetSelf=e=>isEventTarget(e,$portal)||buttonComponent.isEventTarget(e);let downOutsidePanel=false;// move detail panel to portal\nlet detailPanel;let trigger;// test keydown press to open\nconst handleClick=e=>{if(!isActive)$$invalidate(24,buttonRect=buttonElement.getBoundingClientRect());$$invalidate(27,trigger=e);$$invalidate(17,isActive=!isActive);};const handleButtonKeydown=e=>{if(!/down/i.test(e.key))return;$$invalidate(17,isActive=true);$$invalidate(27,trigger=e);};const handlePanelKeydown=e=>{if(!/esc/i.test(e.key))return;$$invalidate(17,isActive=false);buttonElement.focus();};// clean up panel if it was appended to a portal\nonDestroy(()=>{if(!$portal||!detailPanel)return;$portal.removeChild(detailPanel);});function button_binding($$value){binding_callbacks[$$value?\"unshift\":\"push\"](()=>{buttonComponent=$$value;$$invalidate(3,buttonComponent);});}function div_binding($$value){binding_callbacks[$$value?\"unshift\":\"push\"](()=>{detailPanel=$$value;$$invalidate(4,detailPanel);});}const measure_handler=e=>$$invalidate(2,panelSize=sizeCreateFromAny(e.detail));$$self.$$set=$$props=>{if(\"buttonClass\"in $$props)$$invalidate(0,buttonClass=$$props.buttonClass);if(\"panelClass\"in $$props)$$invalidate(1,panelClass=$$props.panelClass);if(\"isActive\"in $$props)$$invalidate(17,isActive=$$props.isActive);if(\"onshow\"in $$props)$$invalidate(18,onshow=$$props.onshow);if(\"$$scope\"in $$props)$$invalidate(23,$$scope=$$props.$$scope);};let buttonElement;let isVisible;let isAnimating;let transform;let style;let handleDown;let handleUp;$$self.$$.update=()=>{if($$self.$$.dirty[0]&/*buttonComponent*/8){buttonElement=buttonComponent&&buttonComponent.getElement();}if($$self.$$.dirty[0]&/*isActive, downOutsidePanel*/67239936){$$invalidate(8,handleUp=isActive?e=>{if(!downOutsidePanel)return;$$invalidate(26,downOutsidePanel=false);if(isTargetSelf(e))return;$$invalidate(17,isActive=false);}:undefined);}if($$self.$$.dirty[0]&/*isActive*/131072){opacity.set(isActive?1:0);}if($$self.$$.dirty[0]&/*isActive*/131072){offset.set(isActive?0:-5);}if($$self.$$.dirty[0]&/*$portalRootRect, panelSize, buttonRect*/553648132){if($portalRootRect&&panelSize&&buttonRect){// as a starting point we'll align panel to center of button and position below\nlet x=buttonRect.x-$portalRootRect.x+buttonRect.width*0.5-panelSize.width*0.5;let y=buttonRect.y-$portalRootRect.y+buttonRect.height;const parentLeft=panelMargin;const parentTop=panelMargin;const parentRight=$portalRootRect.width-panelMargin;const parentBottom=$portalRootRect.height-panelMargin;const panelLeft=x;const panelTop=y;const panelRight=panelLeft+panelSize.width;const panelBottom=panelTop+panelSize.height;// move to right\nif(panelLeft<parentLeft){x=parentLeft;}// move to left\nif(panelRight>parentRight){x=parentRight-panelSize.width;}if(panelBottom>parentBottom){// doesn't fit vertically, push up\n$$invalidate(25,dir.y=-1,dir);const positionedAboveButtonY=y-panelSize.height-buttonRect.height;const panelFitsAboveButton=parentTop<positionedAboveButtonY;if(panelFitsAboveButton){y-=panelSize.height+buttonRect.height;}else{// overlap with button\ny-=panelBottom-parentBottom;}}else{// all is fine\n$$invalidate(25,dir.y=1,dir);}set_store_value(position,$position=vectorApply(vectorCreate(x,y),snapToPixel),$position);}}if($$self.$$.dirty[1]&/*$opacity*/1){$$invalidate(5,isVisible=$opacity>0);}if($$self.$$.dirty[1]&/*$opacity*/1){$$invalidate(32,isAnimating=$opacity<1);}if($$self.$$.dirty[0]&/*$position, dir*/1107296256|$$self.$$.dirty[1]&/*$offset*/8){$$invalidate(33,transform=`translateX(${$position.x+dir.x*panelMargin}px) translateY(${$position.y+dir.y*panelMargin+dir.y*$offset}px)`);}if($$self.$$.dirty[1]&/*isAnimating, $opacity, transform*/7){$$invalidate(6,style=isAnimating?`opacity: ${$opacity}; pointer-events: ${$opacity<1?\"none\":\"all\"}; transform: ${transform};`:`transform: ${transform}`);}if($$self.$$.dirty[0]&/*isActive*/131072){$$invalidate(7,handleDown=isActive?e=>{if(isTargetSelf(e))return;$$invalidate(26,downOutsidePanel=true);}:undefined);}if($$self.$$.dirty[0]&/*isVisible, detailPanel*/48|$$self.$$.dirty[1]&/*$portal*/16){if(isVisible&&$portal&&detailPanel&&detailPanel.parentNode!==$portal)$portal.appendChild(detailPanel);}if($$self.$$.dirty[0]&/*isActive*/131072){if(!isActive)$$invalidate(27,trigger=undefined);}if($$self.$$.dirty[0]&/*isVisible, detailPanel, onshow, trigger*/134479920){if(isVisible&&detailPanel)onshow({e:trigger,panel:detailPanel});}};return[buttonClass,panelClass,panelSize,buttonComponent,detailPanel,isVisible,style,handleDown,handleUp,portal,portalRootRect,opacity,position,offset,handleClick,handleButtonKeydown,handlePanelKeydown,isActive,onshow,slots,button_binding,div_binding,measure_handler,$$scope];}class Details extends SvelteComponent{constructor(options){super();init(this,options,instance$d,create_fragment$d,safe_not_equal,{buttonClass:0,panelClass:1,isActive:17,onshow:18},[-1,-1]);}}/* src/core/ui/components/RadioItem.svelte generated by Svelte v3.29.4 */function create_fragment$e(ctx){let li;let input;let t;let label_1;let li_class_value;let current;let mounted;let dispose;const default_slot_template=/*#slots*/ctx[14].default;const default_slot=create_slot(default_slot_template,ctx,/*$$scope*/ctx[13],null);return{c(){li=element(\"li\");input=element(\"input\");t=space();label_1=element(\"label\");if(default_slot)default_slot.c();attr(input,\"type\",\"radio\");attr(input,\"class\",\"implicit\");attr(input,\"id\",/*inputId*/ctx[6]);attr(input,\"name\",/*name*/ctx[0]);input.value=/*value*/ctx[3];input.disabled=/*disabled*/ctx[5];input.checked=/*checked*/ctx[4];attr(label_1,\"for\",/*inputId*/ctx[6]);attr(label_1,\"title\",/*label*/ctx[2]);attr(li,\"class\",li_class_value=arrayJoin([\"DokaRadioGroupOption\",/*klass*/ctx[1]]));attr(li,\"data-disabled\",/*disabled*/ctx[5]);attr(li,\"data-selected\",/*checked*/ctx[4]);},m(target,anchor){insert(target,li,anchor);append(li,input);append(li,t);append(li,label_1);if(default_slot){default_slot.m(label_1,null);}current=true;if(!mounted){dispose=[listen(input,\"change\",stop_propagation(/*change_handler*/ctx[15])),listen(input,\"keydown\",/*handleKeydown*/ctx[8]),listen(input,\"click\",/*handleClick*/ctx[9])];mounted=true;}},p(ctx,[dirty]){if(!current||dirty&/*inputId*/64){attr(input,\"id\",/*inputId*/ctx[6]);}if(!current||dirty&/*name*/1){attr(input,\"name\",/*name*/ctx[0]);}if(!current||dirty&/*value*/8){input.value=/*value*/ctx[3];}if(!current||dirty&/*disabled*/32){input.disabled=/*disabled*/ctx[5];}if(!current||dirty&/*checked*/16){input.checked=/*checked*/ctx[4];}if(default_slot){if(default_slot.p&&dirty&/*$$scope*/8192){update_slot(default_slot,default_slot_template,ctx,/*$$scope*/ctx[13],dirty,null,null);}}if(!current||dirty&/*inputId*/64){attr(label_1,\"for\",/*inputId*/ctx[6]);}if(!current||dirty&/*label*/4){attr(label_1,\"title\",/*label*/ctx[2]);}if(!current||dirty&/*klass*/2&&li_class_value!==(li_class_value=arrayJoin([\"DokaRadioGroupOption\",/*klass*/ctx[1]]))){attr(li,\"class\",li_class_value);}if(!current||dirty&/*disabled*/32){attr(li,\"data-disabled\",/*disabled*/ctx[5]);}if(!current||dirty&/*checked*/16){attr(li,\"data-selected\",/*checked*/ctx[4]);}},i(local){if(current)return;transition_in(default_slot,local);current=true;},o(local){transition_out(default_slot,local);current=false;},d(detaching){if(detaching)detach(li);if(default_slot)default_slot.d(detaching);mounted=false;run_all(dispose);}};}function instance$e($$self,$$props,$$invalidate){let $keysPressedStored;let{$$slots:slots={},$$scope}=$$props;let{name}=$$props;let{class:klass=undefined}=$$props;let{label}=$$props;let{id}=$$props;let{value}=$$props;let{checked}=$$props;let{onkeydown}=$$props;let{onclick}=$$props;let{disabled=false}=$$props;const keysPressedStored=getContext(\"keysPressed\");component_subscribe($$self,keysPressedStored,value=>$$invalidate(16,$keysPressedStored=value));const handleKeydown=e=>{onkeydown(e);};const handleClick=e=>{if($keysPressedStored.length)return;onclick(e);};function change_handler(event){bubble($$self,event);}$$self.$$set=$$props=>{if(\"name\"in $$props)$$invalidate(0,name=$$props.name);if(\"class\"in $$props)$$invalidate(1,klass=$$props.class);if(\"label\"in $$props)$$invalidate(2,label=$$props.label);if(\"id\"in $$props)$$invalidate(10,id=$$props.id);if(\"value\"in $$props)$$invalidate(3,value=$$props.value);if(\"checked\"in $$props)$$invalidate(4,checked=$$props.checked);if(\"onkeydown\"in $$props)$$invalidate(11,onkeydown=$$props.onkeydown);if(\"onclick\"in $$props)$$invalidate(12,onclick=$$props.onclick);if(\"disabled\"in $$props)$$invalidate(5,disabled=$$props.disabled);if(\"$$scope\"in $$props)$$invalidate(13,$$scope=$$props.$$scope);};let inputId;$$self.$$.update=()=>{if($$self.$$.dirty&/*name, id*/1025){$$invalidate(6,inputId=`${name}-${id}`);}};return[name,klass,label,value,checked,disabled,inputId,keysPressedStored,handleKeydown,handleClick,id,onkeydown,onclick,$$scope,slots,change_handler];}class RadioItem extends SvelteComponent{constructor(options){super();init(this,options,instance$e,create_fragment$e,safe_not_equal,{name:0,class:1,label:2,id:10,value:3,checked:4,onkeydown:11,onclick:12,disabled:5});}}var flattenOptions=(options=[])=>options.reduce((prev,current)=>{const isGroup=isArray(current)?isArray(current[1]):!!current.options;if(isGroup){return prev.concat(isArray(current)?current[1]:current.options);}prev.push(current);return prev;},[]);const mapOption=(option,index,optionMapper)=>{let mappedOption;if(isArray(option)){mappedOption=_objectSpread({id:index,value:option[0],label:option[1]},option[2]||{});}else{mappedOption=option;mappedOption.id=mappedOption.id!=null?mappedOption.id:index;}return optionMapper?optionMapper(mappedOption):mappedOption;};var mapOptions=(options=[],optionMapper)=>{let index=0;return options.map(option=>{index++;if(isArray(option)){// is either [label, options] or [value, label]\nif(isArray(option[1])){return{id:index,label:option[0],options:option[1].map(option=>mapOption(option,++index,optionMapper))};}return mapOption(option,index,optionMapper);}else{// is either { id?, label, options } or { id?, value, label }\nif(option.options){return{id:option.id||index,label:option.label,options:option.options.map(option=>mapOption(option,++index,optionMapper))};}return mapOption(option,index,optionMapper);}});};var opop=(fn,...args)=>fn&&fn(...args);var localize=(prop,locale,params)=>isFunction(prop)?prop(locale,params):prop;const localizeOptions=(options,locale)=>options.map(([value,label,props])=>{if(isArray(label)){return[localize(value,locale),localizeOptions(label,locale)];}else{const res=[value,localize(label,locale)];if(props){let obj=_objectSpread({},props);if(props.icon)obj.icon=localize(props.icon,locale);res.push(obj);}return res;}});var localizeOptions$1=(options,locale)=>localizeOptions(options,locale);/* src/core/ui/components/RadioGroup.svelte generated by Svelte v3.29.4 */const get_option_slot_changes_1=dirty=>({option:dirty[0]&/*mappedOptions*/2048});const get_option_slot_context_1=ctx=>({option:/*option*/ctx[27]});const get_option_slot_changes=dirty=>({option:dirty[0]&/*mappedOptions*/2048});const get_option_slot_context=ctx=>({option:/*option*/ctx[27]});function get_each_context_1(ctx,list,i){const child_ctx=ctx.slice();child_ctx[27]=list[i];return child_ctx;}const get_group_slot_changes=dirty=>({option:dirty[0]&/*mappedOptions*/2048});const get_group_slot_context=ctx=>({option:/*option*/ctx[27]});function get_each_context$3(ctx,list,i){const child_ctx=ctx.slice();child_ctx[27]=list[i];return child_ctx;}// (83:0) {#if localizedOptions.length}\nfunction create_if_block_1$3(ctx){let fieldset;let t;let ul;let each_blocks=[];let each_1_lookup=new Map();let fieldset_class_value;let current;let if_block=/*label*/ctx[1]&&create_if_block_7$1(ctx);let each_value=/*mappedOptions*/ctx[11];const get_key=ctx=>/*option*/ctx[27].id;for(let i=0;i<each_value.length;i+=1){let child_ctx=get_each_context$3(ctx,each_value,i);let key=get_key(child_ctx);each_1_lookup.set(key,each_blocks[i]=create_each_block$3(key,child_ctx));}return{c(){fieldset=element(\"fieldset\");if(if_block)if_block.c();t=space();ul=element(\"ul\");for(let i=0;i<each_blocks.length;i+=1){each_blocks[i].c();}attr(ul,\"class\",\"DokaRadioGroupOptions\");attr(fieldset,\"class\",fieldset_class_value=arrayJoin([\"DokaRadioGroup\",/*klass*/ctx[3]]));attr(fieldset,\"data-layout\",/*layout*/ctx[5]);attr(fieldset,\"title\",/*title*/ctx[7]);},m(target,anchor){insert(target,fieldset,anchor);if(if_block)if_block.m(fieldset,null);append(fieldset,t);append(fieldset,ul);for(let i=0;i<each_blocks.length;i+=1){each_blocks[i].m(ul,null);}current=true;},p(ctx,dirty){if(/*label*/ctx[1]){if(if_block){if_block.p(ctx,dirty);}else{if_block=create_if_block_7$1(ctx);if_block.c();if_block.m(fieldset,t);}}else if(if_block){if_block.d(1);if_block=null;}if(dirty[0]&/*optionGroupClass, mappedOptions, name, optionClass, getOptionIndex, selectedIndex, handleRadioKeydown, handleRadioClick, optionLabelClass, $$scope*/4225873){const each_value=/*mappedOptions*/ctx[11];group_outros();each_blocks=update_keyed_each(each_blocks,dirty,get_key,1,ctx,each_value,each_1_lookup,ul,outro_and_destroy_block,create_each_block$3,null,get_each_context$3);check_outros();}if(!current||dirty[0]&/*klass*/8&&fieldset_class_value!==(fieldset_class_value=arrayJoin([\"DokaRadioGroup\",/*klass*/ctx[3]]))){attr(fieldset,\"class\",fieldset_class_value);}if(!current||dirty[0]&/*layout*/32){attr(fieldset,\"data-layout\",/*layout*/ctx[5]);}if(!current||dirty[0]&/*title*/128){attr(fieldset,\"title\",/*title*/ctx[7]);}},i(local){if(current)return;for(let i=0;i<each_value.length;i+=1){transition_in(each_blocks[i]);}current=true;},o(local){for(let i=0;i<each_blocks.length;i+=1){transition_out(each_blocks[i]);}current=false;},d(detaching){if(detaching)detach(fieldset);if(if_block)if_block.d();for(let i=0;i<each_blocks.length;i+=1){each_blocks[i].d();}}};}// (85:4) {#if label}\nfunction create_if_block_7$1(ctx){let legend;let t;let legend_class_value;return{c(){legend=element(\"legend\");t=text(/*label*/ctx[1]);attr(legend,\"class\",legend_class_value=/*hideLabel*/ctx[2]&&\"implicit\");},m(target,anchor){insert(target,legend,anchor);append(legend,t);},p(ctx,dirty){if(dirty[0]&/*label*/2)set_data(t,/*label*/ctx[1]);if(dirty[0]&/*hideLabel*/4&&legend_class_value!==(legend_class_value=/*hideLabel*/ctx[2]&&\"implicit\")){attr(legend,\"class\",legend_class_value);}},d(detaching){if(detaching)detach(legend);}};}// (115:8) {:else}\nfunction create_else_block$2(ctx){let radioitem;let current;radioitem=new RadioItem({props:{name:/*name*/ctx[4],label:/*option*/ctx[27].label,id:/*option*/ctx[27].id,value:/*option*/ctx[27].value,disabled:/*option*/ctx[27].disabled,class:/*optionClass*/ctx[8],checked:/*getOptionIndex*/ctx[12](/*option*/ctx[27])===/*selectedIndex*/ctx[0],onkeydown:/*handleRadioKeydown*/ctx[13](/*option*/ctx[27]),onclick:/*handleRadioClick*/ctx[14](/*option*/ctx[27]),$$slots:{default:[create_default_slot_2$1]},$$scope:{ctx}}});return{c(){create_component(radioitem.$$.fragment);},m(target,anchor){mount_component(radioitem,target,anchor);current=true;},p(ctx,dirty){const radioitem_changes={};if(dirty[0]&/*name*/16)radioitem_changes.name=/*name*/ctx[4];if(dirty[0]&/*mappedOptions*/2048)radioitem_changes.label=/*option*/ctx[27].label;if(dirty[0]&/*mappedOptions*/2048)radioitem_changes.id=/*option*/ctx[27].id;if(dirty[0]&/*mappedOptions*/2048)radioitem_changes.value=/*option*/ctx[27].value;if(dirty[0]&/*mappedOptions*/2048)radioitem_changes.disabled=/*option*/ctx[27].disabled;if(dirty[0]&/*optionClass*/256)radioitem_changes.class=/*optionClass*/ctx[8];if(dirty[0]&/*mappedOptions, selectedIndex*/2049)radioitem_changes.checked=/*getOptionIndex*/ctx[12](/*option*/ctx[27])===/*selectedIndex*/ctx[0];if(dirty[0]&/*mappedOptions*/2048)radioitem_changes.onkeydown=/*handleRadioKeydown*/ctx[13](/*option*/ctx[27]);if(dirty[0]&/*mappedOptions*/2048)radioitem_changes.onclick=/*handleRadioClick*/ctx[14](/*option*/ctx[27]);if(dirty[0]&/*$$scope, optionLabelClass, mappedOptions*/4196416){radioitem_changes.$$scope={dirty,ctx};}radioitem.$set(radioitem_changes);},i(local){if(current)return;transition_in(radioitem.$$.fragment,local);current=true;},o(local){transition_out(radioitem.$$.fragment,local);current=false;},d(detaching){destroy_component(radioitem,detaching);}};}// (90:8) {#if option.options}\nfunction create_if_block_2$1(ctx){let li;let t0;let ul;let each_blocks=[];let each_1_lookup=new Map();let t1;let li_class_value;let current;const group_slot_template=/*#slots*/ctx[21].group;const group_slot=create_slot(group_slot_template,ctx,/*$$scope*/ctx[22],get_group_slot_context);const group_slot_or_fallback=group_slot||fallback_block_1(ctx);let each_value_1=/*option*/ctx[27].options;const get_key=ctx=>/*option*/ctx[27].id;for(let i=0;i<each_value_1.length;i+=1){let child_ctx=get_each_context_1(ctx,each_value_1,i);let key=get_key(child_ctx);each_1_lookup.set(key,each_blocks[i]=create_each_block_1(key,child_ctx));}return{c(){li=element(\"li\");if(group_slot_or_fallback)group_slot_or_fallback.c();t0=space();ul=element(\"ul\");for(let i=0;i<each_blocks.length;i+=1){each_blocks[i].c();}t1=space();attr(ul,\"class\",\"DokaRadioGroupOptions\");attr(li,\"class\",li_class_value=arrayJoin([\"DokaRadioGroupOptionGroup\",/*optionGroupClass*/ctx[9]]));},m(target,anchor){insert(target,li,anchor);if(group_slot_or_fallback){group_slot_or_fallback.m(li,null);}append(li,t0);append(li,ul);for(let i=0;i<each_blocks.length;i+=1){each_blocks[i].m(ul,null);}append(li,t1);current=true;},p(ctx,dirty){if(group_slot){if(group_slot.p&&dirty[0]&/*$$scope, mappedOptions*/4196352){update_slot(group_slot,group_slot_template,ctx,/*$$scope*/ctx[22],dirty,get_group_slot_changes,get_group_slot_context);}}else{if(group_slot_or_fallback&&group_slot_or_fallback.p&&dirty[0]&/*mappedOptions*/2048){group_slot_or_fallback.p(ctx,dirty);}}if(dirty[0]&/*name, mappedOptions, optionClass, getOptionIndex, selectedIndex, handleRadioKeydown, handleRadioClick, optionLabelClass, $$scope*/4225361){const each_value_1=/*option*/ctx[27].options;group_outros();each_blocks=update_keyed_each(each_blocks,dirty,get_key,1,ctx,each_value_1,each_1_lookup,ul,outro_and_destroy_block,create_each_block_1,null,get_each_context_1);check_outros();}if(!current||dirty[0]&/*optionGroupClass*/512&&li_class_value!==(li_class_value=arrayJoin([\"DokaRadioGroupOptionGroup\",/*optionGroupClass*/ctx[9]]))){attr(li,\"class\",li_class_value);}},i(local){if(current)return;transition_in(group_slot_or_fallback,local);for(let i=0;i<each_value_1.length;i+=1){transition_in(each_blocks[i]);}current=true;},o(local){transition_out(group_slot_or_fallback,local);for(let i=0;i<each_blocks.length;i+=1){transition_out(each_blocks[i]);}current=false;},d(detaching){if(detaching)detach(li);if(group_slot_or_fallback)group_slot_or_fallback.d(detaching);for(let i=0;i<each_blocks.length;i+=1){each_blocks[i].d();}}};}// (126:16) {#if option.icon}\nfunction create_if_block_6$1(ctx){let icon;let current;icon=new Icon({props:{$$slots:{default:[create_default_slot_3$1]},$$scope:{ctx}}});return{c(){create_component(icon.$$.fragment);},m(target,anchor){mount_component(icon,target,anchor);current=true;},p(ctx,dirty){const icon_changes={};if(dirty[0]&/*$$scope, mappedOptions*/4196352){icon_changes.$$scope={dirty,ctx};}icon.$set(icon_changes);},i(local){if(current)return;transition_in(icon.$$.fragment,local);current=true;},o(local){transition_out(icon.$$.fragment,local);current=false;},d(detaching){destroy_component(icon,detaching);}};}// (127:16) <Icon>\nfunction create_default_slot_3$1(ctx){let g;let raw_value=/*option*/ctx[27].icon+\"\";return{c(){g=svg_element(\"g\");},m(target,anchor){insert(target,g,anchor);g.innerHTML=raw_value;},p(ctx,dirty){if(dirty[0]&/*mappedOptions*/2048&&raw_value!==(raw_value=/*option*/ctx[27].icon+\"\"))g.innerHTML=raw_value;},d(detaching){if(detaching)detach(g);}};}// (129:16) {#if !option.hideLabel}\nfunction create_if_block_5$1(ctx){let span;let t_value=/*option*/ctx[27].label+\"\";let t;return{c(){span=element(\"span\");t=text(t_value);attr(span,\"class\",/*optionLabelClass*/ctx[6]);},m(target,anchor){insert(target,span,anchor);append(span,t);},p(ctx,dirty){if(dirty[0]&/*mappedOptions*/2048&&t_value!==(t_value=/*option*/ctx[27].label+\"\"))set_data(t,t_value);if(dirty[0]&/*optionLabelClass*/64){attr(span,\"class\",/*optionLabelClass*/ctx[6]);}},d(detaching){if(detaching)detach(span);}};}// (125:76)                  \nfunction fallback_block_2(ctx){let t0;let t1;let current;let if_block0=/*option*/ctx[27].icon&&create_if_block_6$1(ctx);let if_block1=!/*option*/ctx[27].hideLabel&&create_if_block_5$1(ctx);return{c(){if(if_block0)if_block0.c();t0=space();if(if_block1)if_block1.c();t1=space();},m(target,anchor){if(if_block0)if_block0.m(target,anchor);insert(target,t0,anchor);if(if_block1)if_block1.m(target,anchor);insert(target,t1,anchor);current=true;},p(ctx,dirty){if(/*option*/ctx[27].icon){if(if_block0){if_block0.p(ctx,dirty);if(dirty[0]&/*mappedOptions*/2048){transition_in(if_block0,1);}}else{if_block0=create_if_block_6$1(ctx);if_block0.c();transition_in(if_block0,1);if_block0.m(t0.parentNode,t0);}}else if(if_block0){group_outros();transition_out(if_block0,1,1,()=>{if_block0=null;});check_outros();}if(!/*option*/ctx[27].hideLabel){if(if_block1){if_block1.p(ctx,dirty);}else{if_block1=create_if_block_5$1(ctx);if_block1.c();if_block1.m(t1.parentNode,t1);}}else if(if_block1){if_block1.d(1);if_block1=null;}},i(local){if(current)return;transition_in(if_block0);current=true;},o(local){transition_out(if_block0);current=false;},d(detaching){if(if_block0)if_block0.d(detaching);if(detaching)detach(t0);if(if_block1)if_block1.d(detaching);if(detaching)detach(t1);}};}// (116:8) <RadioItem              {name}              label={option.label}             id={option.id}             value={option.value}             disabled={option.disabled}             class={optionClass}             checked={getOptionIndex(option) === selectedIndex}             onkeydown={handleRadioKeydown(option)}             onclick={handleRadioClick(option)}>\nfunction create_default_slot_2$1(ctx){let current;const option_slot_template=/*#slots*/ctx[21].option;const option_slot=create_slot(option_slot_template,ctx,/*$$scope*/ctx[22],get_option_slot_context_1);const option_slot_or_fallback=option_slot||fallback_block_2(ctx);return{c(){if(option_slot_or_fallback)option_slot_or_fallback.c();},m(target,anchor){if(option_slot_or_fallback){option_slot_or_fallback.m(target,anchor);}current=true;},p(ctx,dirty){if(option_slot){if(option_slot.p&&dirty[0]&/*$$scope, mappedOptions*/4196352){update_slot(option_slot,option_slot_template,ctx,/*$$scope*/ctx[22],dirty,get_option_slot_changes_1,get_option_slot_context_1);}}else{if(option_slot_or_fallback&&option_slot_or_fallback.p&&dirty[0]&/*optionLabelClass, mappedOptions*/2112){option_slot_or_fallback.p(ctx,dirty);}}},i(local){if(current)return;transition_in(option_slot_or_fallback,local);current=true;},o(local){transition_out(option_slot_or_fallback,local);current=false;},d(detaching){if(option_slot_or_fallback)option_slot_or_fallback.d(detaching);}};}// (92:47) <span class=\"DokaRadioGroupOptionGroupLabel\">\nfunction fallback_block_1(ctx){let span;let t_value=/*option*/ctx[27].label+\"\";let t;return{c(){span=element(\"span\");t=text(t_value);attr(span,\"class\",\"DokaRadioGroupOptionGroupLabel\");},m(target,anchor){insert(target,span,anchor);append(span,t);},p(ctx,dirty){if(dirty[0]&/*mappedOptions*/2048&&t_value!==(t_value=/*option*/ctx[27].label+\"\"))set_data(t,t_value);},d(detaching){if(detaching)detach(span);}};}// (105:24) {#if option.icon}\nfunction create_if_block_4$1(ctx){let icon;let current;icon=new Icon({props:{$$slots:{default:[create_default_slot_1$1]},$$scope:{ctx}}});return{c(){create_component(icon.$$.fragment);},m(target,anchor){mount_component(icon,target,anchor);current=true;},p(ctx,dirty){const icon_changes={};if(dirty[0]&/*$$scope, mappedOptions*/4196352){icon_changes.$$scope={dirty,ctx};}icon.$set(icon_changes);},i(local){if(current)return;transition_in(icon.$$.fragment,local);current=true;},o(local){transition_out(icon.$$.fragment,local);current=false;},d(detaching){destroy_component(icon,detaching);}};}// (106:24) <Icon>\nfunction create_default_slot_1$1(ctx){let g;let raw_value=/*option*/ctx[27].icon+\"\";return{c(){g=svg_element(\"g\");},m(target,anchor){insert(target,g,anchor);g.innerHTML=raw_value;},p(ctx,dirty){if(dirty[0]&/*mappedOptions*/2048&&raw_value!==(raw_value=/*option*/ctx[27].icon+\"\"))g.innerHTML=raw_value;},d(detaching){if(detaching)detach(g);}};}// (108:24) {#if !option.hideLabel}\nfunction create_if_block_3$1(ctx){let span;let t_value=/*option*/ctx[27].label+\"\";let t;return{c(){span=element(\"span\");t=text(t_value);attr(span,\"class\",/*optionLabelClass*/ctx[6]);},m(target,anchor){insert(target,span,anchor);append(span,t);},p(ctx,dirty){if(dirty[0]&/*mappedOptions*/2048&&t_value!==(t_value=/*option*/ctx[27].label+\"\"))set_data(t,t_value);if(dirty[0]&/*optionLabelClass*/64){attr(span,\"class\",/*optionLabelClass*/ctx[6]);}},d(detaching){if(detaching)detach(span);}};}// (104:84)                          \nfunction fallback_block$1(ctx){let t0;let t1;let current;let if_block0=/*option*/ctx[27].icon&&create_if_block_4$1(ctx);let if_block1=!/*option*/ctx[27].hideLabel&&create_if_block_3$1(ctx);return{c(){if(if_block0)if_block0.c();t0=space();if(if_block1)if_block1.c();t1=space();},m(target,anchor){if(if_block0)if_block0.m(target,anchor);insert(target,t0,anchor);if(if_block1)if_block1.m(target,anchor);insert(target,t1,anchor);current=true;},p(ctx,dirty){if(/*option*/ctx[27].icon){if(if_block0){if_block0.p(ctx,dirty);if(dirty[0]&/*mappedOptions*/2048){transition_in(if_block0,1);}}else{if_block0=create_if_block_4$1(ctx);if_block0.c();transition_in(if_block0,1);if_block0.m(t0.parentNode,t0);}}else if(if_block0){group_outros();transition_out(if_block0,1,1,()=>{if_block0=null;});check_outros();}if(!/*option*/ctx[27].hideLabel){if(if_block1){if_block1.p(ctx,dirty);}else{if_block1=create_if_block_3$1(ctx);if_block1.c();if_block1.m(t1.parentNode,t1);}}else if(if_block1){if_block1.d(1);if_block1=null;}},i(local){if(current)return;transition_in(if_block0);current=true;},o(local){transition_out(if_block0);current=false;},d(detaching){if(if_block0)if_block0.d(detaching);if(detaching)detach(t0);if(if_block1)if_block1.d(detaching);if(detaching)detach(t1);}};}// (95:16) <RadioItem                      {name}                      label={option.label}                     id={option.id}                     value={option.value}                     disabled={option.disabled}                     class={optionClass}                     checked={getOptionIndex(option) === selectedIndex}                     onkeydown={handleRadioKeydown(option)}                     onclick={handleRadioClick(option)}>\nfunction create_default_slot$3(ctx){let current;const option_slot_template=/*#slots*/ctx[21].option;const option_slot=create_slot(option_slot_template,ctx,/*$$scope*/ctx[22],get_option_slot_context);const option_slot_or_fallback=option_slot||fallback_block$1(ctx);return{c(){if(option_slot_or_fallback)option_slot_or_fallback.c();},m(target,anchor){if(option_slot_or_fallback){option_slot_or_fallback.m(target,anchor);}current=true;},p(ctx,dirty){if(option_slot){if(option_slot.p&&dirty[0]&/*$$scope, mappedOptions*/4196352){update_slot(option_slot,option_slot_template,ctx,/*$$scope*/ctx[22],dirty,get_option_slot_changes,get_option_slot_context);}}else{if(option_slot_or_fallback&&option_slot_or_fallback.p&&dirty[0]&/*optionLabelClass, mappedOptions*/2112){option_slot_or_fallback.p(ctx,dirty);}}},i(local){if(current)return;transition_in(option_slot_or_fallback,local);current=true;},o(local){transition_out(option_slot_or_fallback,local);current=false;},d(detaching){if(option_slot_or_fallback)option_slot_or_fallback.d(detaching);}};}// (94:16) {#each option.options as option (option.id) }\nfunction create_each_block_1(key_1,ctx){let first;let radioitem;let current;radioitem=new RadioItem({props:{name:/*name*/ctx[4],label:/*option*/ctx[27].label,id:/*option*/ctx[27].id,value:/*option*/ctx[27].value,disabled:/*option*/ctx[27].disabled,class:/*optionClass*/ctx[8],checked:/*getOptionIndex*/ctx[12](/*option*/ctx[27])===/*selectedIndex*/ctx[0],onkeydown:/*handleRadioKeydown*/ctx[13](/*option*/ctx[27]),onclick:/*handleRadioClick*/ctx[14](/*option*/ctx[27]),$$slots:{default:[create_default_slot$3]},$$scope:{ctx}}});return{key:key_1,first:null,c(){first=empty();create_component(radioitem.$$.fragment);this.first=first;},m(target,anchor){insert(target,first,anchor);mount_component(radioitem,target,anchor);current=true;},p(ctx,dirty){const radioitem_changes={};if(dirty[0]&/*name*/16)radioitem_changes.name=/*name*/ctx[4];if(dirty[0]&/*mappedOptions*/2048)radioitem_changes.label=/*option*/ctx[27].label;if(dirty[0]&/*mappedOptions*/2048)radioitem_changes.id=/*option*/ctx[27].id;if(dirty[0]&/*mappedOptions*/2048)radioitem_changes.value=/*option*/ctx[27].value;if(dirty[0]&/*mappedOptions*/2048)radioitem_changes.disabled=/*option*/ctx[27].disabled;if(dirty[0]&/*optionClass*/256)radioitem_changes.class=/*optionClass*/ctx[8];if(dirty[0]&/*mappedOptions, selectedIndex*/2049)radioitem_changes.checked=/*getOptionIndex*/ctx[12](/*option*/ctx[27])===/*selectedIndex*/ctx[0];if(dirty[0]&/*mappedOptions*/2048)radioitem_changes.onkeydown=/*handleRadioKeydown*/ctx[13](/*option*/ctx[27]);if(dirty[0]&/*mappedOptions*/2048)radioitem_changes.onclick=/*handleRadioClick*/ctx[14](/*option*/ctx[27]);if(dirty[0]&/*$$scope, optionLabelClass, mappedOptions*/4196416){radioitem_changes.$$scope={dirty,ctx};}radioitem.$set(radioitem_changes);},i(local){if(current)return;transition_in(radioitem.$$.fragment,local);current=true;},o(local){transition_out(radioitem.$$.fragment,local);current=false;},d(detaching){if(detaching)detach(first);destroy_component(radioitem,detaching);}};}// (89:8) {#each mappedOptions as option (option.id) }\nfunction create_each_block$3(key_1,ctx){let first;let current_block_type_index;let if_block;let if_block_anchor;let current;const if_block_creators=[create_if_block_2$1,create_else_block$2];const if_blocks=[];function select_block_type(ctx,dirty){if(/*option*/ctx[27].options)return 0;return 1;}current_block_type_index=select_block_type(ctx);if_block=if_blocks[current_block_type_index]=if_block_creators[current_block_type_index](ctx);return{key:key_1,first:null,c(){first=empty();if_block.c();if_block_anchor=empty();this.first=first;},m(target,anchor){insert(target,first,anchor);if_blocks[current_block_type_index].m(target,anchor);insert(target,if_block_anchor,anchor);current=true;},p(ctx,dirty){let previous_block_index=current_block_type_index;current_block_type_index=select_block_type(ctx);if(current_block_type_index===previous_block_index){if_blocks[current_block_type_index].p(ctx,dirty);}else{group_outros();transition_out(if_blocks[previous_block_index],1,1,()=>{if_blocks[previous_block_index]=null;});check_outros();if_block=if_blocks[current_block_type_index];if(!if_block){if_block=if_blocks[current_block_type_index]=if_block_creators[current_block_type_index](ctx);if_block.c();}transition_in(if_block,1);if_block.m(if_block_anchor.parentNode,if_block_anchor);}},i(local){if(current)return;transition_in(if_block);current=true;},o(local){transition_out(if_block);current=false;},d(detaching){if(detaching)detach(first);if_blocks[current_block_type_index].d(detaching);if(detaching)detach(if_block_anchor);}};}function create_fragment$f(ctx){let t;let if_block1_anchor;let current;let if_block0=/*localizedOptions*/ctx[10].length&&create_if_block_1$3(ctx);let if_block1=false;return{c(){if(if_block0)if_block0.c();t=space();if_block1_anchor=empty();},m(target,anchor){if(if_block0)if_block0.m(target,anchor);insert(target,t,anchor);insert(target,if_block1_anchor,anchor);current=true;},p(ctx,dirty){if(/*localizedOptions*/ctx[10].length){if(if_block0){if_block0.p(ctx,dirty);if(dirty[0]&/*localizedOptions*/1024){transition_in(if_block0,1);}}else{if_block0=create_if_block_1$3(ctx);if_block0.c();transition_in(if_block0,1);if_block0.m(t.parentNode,t);}}else if(if_block0){group_outros();transition_out(if_block0,1,1,()=>{if_block0=null;});check_outros();}},i(local){if(current)return;transition_in(if_block0);transition_in(if_block1);current=true;},o(local){transition_out(if_block0);transition_out(if_block1);current=false;},d(detaching){if(if_block0)if_block0.d(detaching);if(detaching)detach(t);if(detaching)detach(if_block1_anchor);}};}function instance$f($$self,$$props,$$invalidate){let{$$slots:slots={},$$scope}=$$props;const dispatch=createEventDispatcher();let{label=undefined}=$$props;let{hideLabel=true}=$$props;let{class:klass=undefined}=$$props;let{name=`doka-radio-group-${getUniqueId()}`}=$$props;let{selectedIndex=-1}=$$props;let{options=[]}=$$props;let{onchange=undefined}=$$props;let{layout=undefined}=$$props;let{optionMapper=undefined}=$$props;let{optionFilter=undefined}=$$props;let{value=undefined}=$$props;let{optionLabelClass=undefined}=$$props;let{title=undefined}=$$props;let{locale=undefined}=$$props;let{optionClass=undefined}=$$props;let{optionGroupClass=undefined}=$$props;const getOptionIndex=option=>flattenedOptions.findIndex(flattenedOption=>flattenedOption.id===option.id);const isConfirm=key=>/enter| /i.test(key);const changeSelection=option=>{$$invalidate(0,selectedIndex=getOptionIndex(option));const payload=_objectSpread({index:selectedIndex},option);opop(onchange,payload);dispatch(\"change\",payload);};const handleRadioKeydown=option=>e=>{// is confirm key ([enter] or [space])\nif(!isConfirm(e.key))return;changeSelection(option);};const handleRadioClick=option=>e=>{changeSelection(option);};$$self.$$set=$$props=>{if(\"label\"in $$props)$$invalidate(1,label=$$props.label);if(\"hideLabel\"in $$props)$$invalidate(2,hideLabel=$$props.hideLabel);if(\"class\"in $$props)$$invalidate(3,klass=$$props.class);if(\"name\"in $$props)$$invalidate(4,name=$$props.name);if(\"selectedIndex\"in $$props)$$invalidate(0,selectedIndex=$$props.selectedIndex);if(\"options\"in $$props)$$invalidate(15,options=$$props.options);if(\"onchange\"in $$props)$$invalidate(16,onchange=$$props.onchange);if(\"layout\"in $$props)$$invalidate(5,layout=$$props.layout);if(\"optionMapper\"in $$props)$$invalidate(17,optionMapper=$$props.optionMapper);if(\"optionFilter\"in $$props)$$invalidate(18,optionFilter=$$props.optionFilter);if(\"value\"in $$props)$$invalidate(19,value=$$props.value);if(\"optionLabelClass\"in $$props)$$invalidate(6,optionLabelClass=$$props.optionLabelClass);if(\"title\"in $$props)$$invalidate(7,title=$$props.title);if(\"locale\"in $$props)$$invalidate(20,locale=$$props.locale);if(\"optionClass\"in $$props)$$invalidate(8,optionClass=$$props.optionClass);if(\"optionGroupClass\"in $$props)$$invalidate(9,optionGroupClass=$$props.optionGroupClass);if(\"$$scope\"in $$props)$$invalidate(22,$$scope=$$props.$$scope);};let localizedOptions;let mappedOptions;let flattenedOptions;$$self.$$.update=()=>{if($$self.$$.dirty[0]&/*optionFilter, options, locale*/1343488){$$invalidate(10,localizedOptions=localizeOptions$1(optionFilter?options.filter(optionFilter):options,locale));}if($$self.$$.dirty[0]&/*localizedOptions, optionMapper*/132096){$$invalidate(11,mappedOptions=mapOptions(localizedOptions,optionMapper));}if($$self.$$.dirty[0]&/*mappedOptions*/2048){$$invalidate(23,flattenedOptions=flattenOptions(mappedOptions));}if($$self.$$.dirty[0]&/*value, selectedIndex, flattenedOptions*/8912897){// can optionally pass value to have radio button group try to auto-select the right option\nif(value&&selectedIndex<0){$$invalidate(0,selectedIndex=flattenedOptions.findIndex(option=>option.value===value));}}};return[selectedIndex,label,hideLabel,klass,name,layout,optionLabelClass,title,optionClass,optionGroupClass,localizedOptions,mappedOptions,getOptionIndex,handleRadioKeydown,handleRadioClick,options,onchange,optionMapper,optionFilter,value,locale,slots,$$scope];}class RadioGroup extends SvelteComponent{constructor(options){super();init(this,options,instance$f,create_fragment$f,safe_not_equal,{label:1,hideLabel:2,class:3,name:4,selectedIndex:0,options:15,onchange:16,layout:5,optionMapper:17,optionFilter:18,value:19,optionLabelClass:6,title:7,locale:20,optionClass:8,optionGroupClass:9},[-1,-1]);}}var isDeepEqual=(a,b)=>{if(Array.isArray(a)&&Array.isArray(b))return arrayEqual(a,b);return a===b;};/* src/core/ui/components/Dropdown.svelte generated by Svelte v3.29.4 */function create_if_block_2$2(ctx){let icon_1;let current;icon_1=new Icon({props:{$$slots:{default:[create_default_slot_3$2]},$$scope:{ctx}}});return{c(){create_component(icon_1.$$.fragment);},m(target,anchor){mount_component(icon_1,target,anchor);current=true;},p(ctx,dirty){const icon_1_changes={};if(dirty&/*$$scope, icon*/134217792){icon_1_changes.$$scope={dirty,ctx};}icon_1.$set(icon_1_changes);},i(local){if(current)return;transition_in(icon_1.$$.fragment,local);current=true;},o(local){transition_out(icon_1.$$.fragment,local);current=false;},d(detaching){destroy_component(icon_1,detaching);}};}// (145:8) <Icon>\nfunction create_default_slot_3$2(ctx){let g;return{c(){g=svg_element(\"g\");},m(target,anchor){insert(target,g,anchor);g.innerHTML=/*icon*/ctx[6];},p(ctx,dirty){if(dirty&/*icon*/64)g.innerHTML=/*icon*/ctx[6];},d(detaching){if(detaching)detach(g);}};}// (147:8) {#if !hideLabel}\nfunction create_if_block_1$4(ctx){let span;let t_value=(/*label*/ctx[2]||/*selectedLabel*/ctx[18])+\"\";let t;let span_class_value;return{c(){span=element(\"span\");t=text(t_value);attr(span,\"class\",span_class_value=arrayJoin([\"DokaButtonLabel\",/*labelClass*/ctx[3]]));},m(target,anchor){insert(target,span,anchor);append(span,t);},p(ctx,dirty){if(dirty&/*label, selectedLabel*/262148&&t_value!==(t_value=(/*label*/ctx[2]||/*selectedLabel*/ctx[18])+\"\"))set_data(t,t_value);if(dirty&/*labelClass*/8&&span_class_value!==(span_class_value=arrayJoin([\"DokaButtonLabel\",/*labelClass*/ctx[3]]))){attr(span,\"class\",span_class_value);}},d(detaching){if(detaching)detach(span);}};}// (143:4) <span slot=\"label\" title={localize(title, locale)} class={arrayJoin(['DokaButtonInner', innerClass])} >\nfunction create_label_slot(ctx){let span;let t;let span_title_value;let span_class_value;let current;let if_block0=/*icon*/ctx[6]&&create_if_block_2$2(ctx);let if_block1=!/*hideLabel*/ctx[5]&&create_if_block_1$4(ctx);return{c(){span=element(\"span\");if(if_block0)if_block0.c();t=space();if(if_block1)if_block1.c();attr(span,\"slot\",\"label\");attr(span,\"title\",span_title_value=localize(/*title*/ctx[1],/*locale*/ctx[15]));attr(span,\"class\",span_class_value=arrayJoin([\"DokaButtonInner\",/*innerClass*/ctx[4]]));},m(target,anchor){insert(target,span,anchor);if(if_block0)if_block0.m(span,null);append(span,t);if(if_block1)if_block1.m(span,null);current=true;},p(ctx,dirty){if(/*icon*/ctx[6]){if(if_block0){if_block0.p(ctx,dirty);if(dirty&/*icon*/64){transition_in(if_block0,1);}}else{if_block0=create_if_block_2$2(ctx);if_block0.c();transition_in(if_block0,1);if_block0.m(span,t);}}else if(if_block0){group_outros();transition_out(if_block0,1,1,()=>{if_block0=null;});check_outros();}if(!/*hideLabel*/ctx[5]){if(if_block1){if_block1.p(ctx,dirty);}else{if_block1=create_if_block_1$4(ctx);if_block1.c();if_block1.m(span,null);}}else if(if_block1){if_block1.d(1);if_block1=null;}if(!current||dirty&/*title, locale*/32770&&span_title_value!==(span_title_value=localize(/*title*/ctx[1],/*locale*/ctx[15]))){attr(span,\"title\",span_title_value);}if(!current||dirty&/*innerClass*/16&&span_class_value!==(span_class_value=arrayJoin([\"DokaButtonInner\",/*innerClass*/ctx[4]]))){attr(span,\"class\",span_class_value);}},i(local){if(current)return;transition_in(if_block0);current=true;},o(local){transition_out(if_block0);current=false;},d(detaching){if(detaching)detach(span);if(if_block0)if_block0.d();if(if_block1)if_block1.d();}};}// (165:12) <span slot=\"group\">\nfunction create_group_slot(ctx){let span;let t_value=/*option*/ctx[26].label+\"\";let t;return{c(){span=element(\"span\");t=text(t_value);attr(span,\"slot\",\"group\");},m(target,anchor){insert(target,span,anchor);append(span,t);},p(ctx,dirty){if(dirty&/*option*/67108864&&t_value!==(t_value=/*option*/ctx[26].label+\"\"))set_data(t,t_value);},d(detaching){if(detaching)detach(span);}};}// (167:16) {#if option.icon}\nfunction create_if_block$3(ctx){let icon_1;let current;icon_1=new Icon({props:{style:isFunction(/*optionIconStyle*/ctx[13])?/*optionIconStyle*/ctx[13](/*option*/ctx[26].value):/*optionIconStyle*/ctx[13],$$slots:{default:[create_default_slot_2$2]},$$scope:{ctx}}});return{c(){create_component(icon_1.$$.fragment);},m(target,anchor){mount_component(icon_1,target,anchor);current=true;},p(ctx,dirty){const icon_1_changes={};if(dirty&/*optionIconStyle, option*/67117056)icon_1_changes.style=isFunction(/*optionIconStyle*/ctx[13])?/*optionIconStyle*/ctx[13](/*option*/ctx[26].value):/*optionIconStyle*/ctx[13];if(dirty&/*$$scope, option*/201326592){icon_1_changes.$$scope={dirty,ctx};}icon_1.$set(icon_1_changes);},i(local){if(current)return;transition_in(icon_1.$$.fragment,local);current=true;},o(local){transition_out(icon_1.$$.fragment,local);current=false;},d(detaching){destroy_component(icon_1,detaching);}};}// (168:16) <Icon style={isFunction(optionIconStyle) ? optionIconStyle(option.value) : optionIconStyle}>\nfunction create_default_slot_2$2(ctx){let g;let raw_value=/*option*/ctx[26].icon+\"\";return{c(){g=svg_element(\"g\");},m(target,anchor){insert(target,g,anchor);g.innerHTML=raw_value;},p(ctx,dirty){if(dirty&/*option*/67108864&&raw_value!==(raw_value=/*option*/ctx[26].icon+\"\"))g.innerHTML=raw_value;},d(detaching){if(detaching)detach(g);}};}// (166:12) <span slot=\"option\">\nfunction create_option_slot(ctx){let span0;let t0;let span1;let t1_value=/*option*/ctx[26].label+\"\";let t1;let span1_style_value;let span1_class_value;let current;let if_block=/*option*/ctx[26].icon&&create_if_block$3(ctx);return{c(){span0=element(\"span\");if(if_block)if_block.c();t0=space();span1=element(\"span\");t1=text(t1_value);attr(span1,\"style\",span1_style_value=isFunction(/*optionLabelStyle*/ctx[14])?/*optionLabelStyle*/ctx[14](/*option*/ctx[26].value):/*optionLabelStyle*/ctx[14]);attr(span1,\"class\",span1_class_value=arrayJoin([\"DokaDropdownOptionLabel\",/*optionLabelClass*/ctx[10]]));attr(span0,\"slot\",\"option\");},m(target,anchor){insert(target,span0,anchor);if(if_block)if_block.m(span0,null);append(span0,t0);append(span0,span1);append(span1,t1);current=true;},p(ctx,dirty){if(/*option*/ctx[26].icon){if(if_block){if_block.p(ctx,dirty);if(dirty&/*option*/67108864){transition_in(if_block,1);}}else{if_block=create_if_block$3(ctx);if_block.c();transition_in(if_block,1);if_block.m(span0,t0);}}else if(if_block){group_outros();transition_out(if_block,1,1,()=>{if_block=null;});check_outros();}if((!current||dirty&/*option*/67108864)&&t1_value!==(t1_value=/*option*/ctx[26].label+\"\"))set_data(t1,t1_value);if(!current||dirty&/*optionLabelStyle, option*/67125248&&span1_style_value!==(span1_style_value=isFunction(/*optionLabelStyle*/ctx[14])?/*optionLabelStyle*/ctx[14](/*option*/ctx[26].value):/*optionLabelStyle*/ctx[14])){attr(span1,\"style\",span1_style_value);}if(!current||dirty&/*optionLabelClass*/1024&&span1_class_value!==(span1_class_value=arrayJoin([\"DokaDropdownOptionLabel\",/*optionLabelClass*/ctx[10]]))){attr(span1,\"class\",span1_class_value);}},i(local){if(current)return;transition_in(if_block);current=true;},o(local){transition_out(if_block);current=false;},d(detaching){if(detaching)detach(span0);if(if_block)if_block.d();}};}// (153:8) <RadioGroup              {name}             {value}             {selectedIndex}             {optionFilter}             {optionMapper}             optionLabelClass={arrayJoin(['DokaDropdownOptionLabel', optionLabelClass])}             optionGroupClass=\"DokaDropdownOptionGroup\"             optionClass=\"DokaDropdownOption\"             options={localizedOptions}             onchange={handleSelect}             let:option>\nfunction create_default_slot_1$2(ctx){let t;return{c(){t=space();},m(target,anchor){insert(target,t,anchor);},p:noop$1,i:noop$1,o:noop$1,d(detaching){if(detaching)detach(t);}};}// (152:4) <div class=\"DokaDropdownPanel\" slot=\"details\" on:keydown={handleKeydown}>\nfunction create_details_slot(ctx){let div;let radiogroup;let current;let mounted;let dispose;radiogroup=new RadioGroup({props:{name:/*name*/ctx[7],value:/*value*/ctx[9],selectedIndex:/*selectedIndex*/ctx[8],optionFilter:/*optionFilter*/ctx[11],optionMapper:/*optionMapper*/ctx[12],optionLabelClass:arrayJoin([\"DokaDropdownOptionLabel\",/*optionLabelClass*/ctx[10]]),optionGroupClass:\"DokaDropdownOptionGroup\",optionClass:\"DokaDropdownOption\",options:/*localizedOptions*/ctx[17],onchange:/*handleSelect*/ctx[19],$$slots:{default:[create_default_slot_1$2,({option})=>({26:option}),({option})=>option?67108864:0],option:[create_option_slot,({option})=>({26:option}),({option})=>option?67108864:0],group:[create_group_slot,({option})=>({26:option}),({option})=>option?67108864:0]},$$scope:{ctx}}});return{c(){div=element(\"div\");create_component(radiogroup.$$.fragment);attr(div,\"class\",\"DokaDropdownPanel\");attr(div,\"slot\",\"details\");},m(target,anchor){insert(target,div,anchor);mount_component(radiogroup,div,null);current=true;if(!mounted){dispose=listen(div,\"keydown\",/*handleKeydown*/ctx[21]);mounted=true;}},p(ctx,dirty){const radiogroup_changes={};if(dirty&/*name*/128)radiogroup_changes.name=/*name*/ctx[7];if(dirty&/*value*/512)radiogroup_changes.value=/*value*/ctx[9];if(dirty&/*selectedIndex*/256)radiogroup_changes.selectedIndex=/*selectedIndex*/ctx[8];if(dirty&/*optionFilter*/2048)radiogroup_changes.optionFilter=/*optionFilter*/ctx[11];if(dirty&/*optionMapper*/4096)radiogroup_changes.optionMapper=/*optionMapper*/ctx[12];if(dirty&/*optionLabelClass*/1024)radiogroup_changes.optionLabelClass=arrayJoin([\"DokaDropdownOptionLabel\",/*optionLabelClass*/ctx[10]]);if(dirty&/*localizedOptions*/131072)radiogroup_changes.options=/*localizedOptions*/ctx[17];if(dirty&/*$$scope, optionLabelStyle, option, optionLabelClass, optionIconStyle*/201352192){radiogroup_changes.$$scope={dirty,ctx};}radiogroup.$set(radiogroup_changes);},i(local){if(current)return;transition_in(radiogroup.$$.fragment,local);current=true;},o(local){transition_out(radiogroup.$$.fragment,local);current=false;},d(detaching){if(detaching)detach(div);destroy_component(radiogroup);mounted=false;dispose();}};}// (139:0) <Details bind:isActive={dropdownVisible}      onshow={handleShowPanel}      buttonClass={arrayJoin(['DokaDropdownButton',klass, hideLabel && 'DokaDropdownIconOnly'])}>\nfunction create_default_slot$4(ctx){let t;return{c(){t=space();},m(target,anchor){insert(target,t,anchor);},p:noop$1,i:noop$1,o:noop$1,d(detaching){if(detaching)detach(t);}};}function create_fragment$g(ctx){let details;let updating_isActive;let current;function details_isActive_binding(value){/*details_isActive_binding*/ctx[24].call(null,value);}let details_props={onshow:/*handleShowPanel*/ctx[20],buttonClass:arrayJoin([\"DokaDropdownButton\",/*klass*/ctx[0],/*hideLabel*/ctx[5]&&\"DokaDropdownIconOnly\"]),$$slots:{default:[create_default_slot$4],details:[create_details_slot],label:[create_label_slot]},$$scope:{ctx}};if(/*dropdownVisible*/ctx[16]!==void 0){details_props.isActive=/*dropdownVisible*/ctx[16];}details=new Details({props:details_props});binding_callbacks.push(()=>bind(details,\"isActive\",details_isActive_binding));return{c(){create_component(details.$$.fragment);},m(target,anchor){mount_component(details,target,anchor);current=true;},p(ctx,[dirty]){const details_changes={};if(dirty&/*klass, hideLabel*/33)details_changes.buttonClass=arrayJoin([\"DokaDropdownButton\",/*klass*/ctx[0],/*hideLabel*/ctx[5]&&\"DokaDropdownIconOnly\"]);if(dirty&/*$$scope, name, value, selectedIndex, optionFilter, optionMapper, optionLabelClass, localizedOptions, optionLabelStyle, optionIconStyle, title, locale, innerClass, labelClass, label, selectedLabel, hideLabel, icon*/134676478){details_changes.$$scope={dirty,ctx};}if(!updating_isActive&&dirty&/*dropdownVisible*/65536){updating_isActive=true;details_changes.isActive=/*dropdownVisible*/ctx[16];add_flush_callback(()=>updating_isActive=false);}details.$set(details_changes);},i(local){if(current)return;transition_in(details.$$.fragment,local);current=true;},o(local){transition_out(details.$$.fragment,local);current=false;},d(detaching){destroy_component(details,detaching);}};}function instance$g($$self,$$props,$$invalidate){let{class:klass=undefined}=$$props;let{title=undefined}=$$props;let{label=undefined}=$$props;let{labelClass=undefined}=$$props;let{innerClass=undefined}=$$props;let{hideLabel=false}=$$props;let{icon=undefined}=$$props;let{name=undefined}=$$props;let{options=[]}=$$props;let{selectedIndex=-1}=$$props;let{value=undefined}=$$props;let{optionLabelClass=undefined}=$$props;let{optionFilter=undefined}=$$props;let{optionMapper=undefined}=$$props;let{optionIconStyle=undefined}=$$props;let{optionLabelStyle=undefined}=$$props;let{onchange=undefined}=$$props;let{locale=undefined}=$$props;const getUndefinedOptionLabel=options=>{const option=localizedOptions.find(option=>option[0]===undefined);if(!option)return undefined;return option[1];};let dropdownVisible;const handleSelect=detail=>{// triggers label update\n$$invalidate(18,selectedLabel=detail.value);// update value\nonchange(detail);// hide details\n$$invalidate(16,dropdownVisible=false);};const handleShowPanel=({e,panel})=>{if(e&&e.key&&/up|down/i.test(e.key))return panel.querySelector(\"input:not([disabled])\").focus();panel.querySelector(\"fieldset\").focus();};const handleKeydown=e=>{// don't allow tabbing ([tab] is also blocked in normal <select>)\nif(/tab/i.test(e.key))e.preventDefault();};function details_isActive_binding(value){dropdownVisible=value;$$invalidate(16,dropdownVisible);}$$self.$$set=$$props=>{if(\"class\"in $$props)$$invalidate(0,klass=$$props.class);if(\"title\"in $$props)$$invalidate(1,title=$$props.title);if(\"label\"in $$props)$$invalidate(2,label=$$props.label);if(\"labelClass\"in $$props)$$invalidate(3,labelClass=$$props.labelClass);if(\"innerClass\"in $$props)$$invalidate(4,innerClass=$$props.innerClass);if(\"hideLabel\"in $$props)$$invalidate(5,hideLabel=$$props.hideLabel);if(\"icon\"in $$props)$$invalidate(6,icon=$$props.icon);if(\"name\"in $$props)$$invalidate(7,name=$$props.name);if(\"options\"in $$props)$$invalidate(22,options=$$props.options);if(\"selectedIndex\"in $$props)$$invalidate(8,selectedIndex=$$props.selectedIndex);if(\"value\"in $$props)$$invalidate(9,value=$$props.value);if(\"optionLabelClass\"in $$props)$$invalidate(10,optionLabelClass=$$props.optionLabelClass);if(\"optionFilter\"in $$props)$$invalidate(11,optionFilter=$$props.optionFilter);if(\"optionMapper\"in $$props)$$invalidate(12,optionMapper=$$props.optionMapper);if(\"optionIconStyle\"in $$props)$$invalidate(13,optionIconStyle=$$props.optionIconStyle);if(\"optionLabelStyle\"in $$props)$$invalidate(14,optionLabelStyle=$$props.optionLabelStyle);if(\"onchange\"in $$props)$$invalidate(23,onchange=$$props.onchange);if(\"locale\"in $$props)$$invalidate(15,locale=$$props.locale);};let localizedOptions;let selectedLabel;$$self.$$.update=()=>{if($$self.$$.dirty&/*options, locale*/4227072){$$invalidate(17,localizedOptions=localizeOptions$1(options,locale));}if($$self.$$.dirty&/*localizedOptions, value*/131584){$$invalidate(18,selectedLabel=localizedOptions.reduce((prev,curr)=>{if(prev)return prev;const[optionValue,optionLabel]=curr;if(isDeepEqual(optionValue,value))return optionLabel;},undefined)||getUndefinedOptionLabel());}};return[klass,title,label,labelClass,innerClass,hideLabel,icon,name,selectedIndex,value,optionLabelClass,optionFilter,optionMapper,optionIconStyle,optionLabelStyle,locale,dropdownVisible,localizedOptions,selectedLabel,handleSelect,handleShowPanel,handleKeydown,options,onchange,details_isActive_binding];}class Dropdown extends SvelteComponent{constructor(options){super();init(this,options,instance$g,create_fragment$g,safe_not_equal,{class:0,title:1,label:2,labelClass:3,innerClass:4,hideLabel:5,icon:6,name:7,options:22,selectedIndex:8,value:9,optionLabelClass:10,optionFilter:11,optionMapper:12,optionIconStyle:13,optionLabelStyle:14,onchange:23,locale:15});}}/* src/core/ui/components/Slider.svelte generated by Svelte v3.29.4 */function create_fragment$h(ctx){let div3;let input_1;let nudgeable_action;let t0;let div0;let t1;let div2;let div1;let div2_style_value;let div3_class_value;let mounted;let dispose;return{c(){div3=element(\"div\");input_1=element(\"input\");t0=space();div0=element(\"div\");t1=space();div2=element(\"div\");div1=element(\"div\");attr(input_1,\"type\",\"range\");attr(input_1,\"id\",/*id*/ctx[4]);attr(input_1,\"min\",/*min*/ctx[1]);attr(input_1,\"max\",/*max*/ctx[2]);attr(input_1,\"step\",/*step*/ctx[3]);input_1.value=/*value*/ctx[0];attr(div0,\"class\",\"DokaSliderTrack\");attr(div0,\"style\",/*trackStyle*/ctx[5]);attr(div1,\"class\",\"DokaSliderKnob\");attr(div1,\"style\",/*knobStyle*/ctx[6]);attr(div2,\"class\",\"DokaSliderKnobController\");attr(div2,\"style\",div2_style_value=`transform: translateX(${/*position*/ctx[9]}%)`);attr(div3,\"class\",div3_class_value=arrayJoin([\"DokaSlider\",/*klass*/ctx[7]]));},m(target,anchor){insert(target,div3,anchor);append(div3,input_1);/*input_1_binding*/ctx[14](input_1);append(div3,t0);append(div3,div0);append(div3,t1);append(div3,div2);append(div2,div1);if(!mounted){dispose=[listen(input_1,\"pointerdown\",/*handlePointerDown*/ctx[12]),listen(input_1,\"input\",/*handleInput*/ctx[10]),listen(input_1,\"nudge\",/*handleNudge*/ctx[11]),action_destroyer(nudgeable_action=nudgeable.call(null,input_1))];mounted=true;}},p(ctx,[dirty]){if(dirty&/*id*/16){attr(input_1,\"id\",/*id*/ctx[4]);}if(dirty&/*min*/2){attr(input_1,\"min\",/*min*/ctx[1]);}if(dirty&/*max*/4){attr(input_1,\"max\",/*max*/ctx[2]);}if(dirty&/*step*/8){attr(input_1,\"step\",/*step*/ctx[3]);}if(dirty&/*value*/1){input_1.value=/*value*/ctx[0];}if(dirty&/*trackStyle*/32){attr(div0,\"style\",/*trackStyle*/ctx[5]);}if(dirty&/*knobStyle*/64){attr(div1,\"style\",/*knobStyle*/ctx[6]);}if(dirty&/*position*/512&&div2_style_value!==(div2_style_value=`transform: translateX(${/*position*/ctx[9]}%)`)){attr(div2,\"style\",div2_style_value);}if(dirty&/*klass*/128&&div3_class_value!==(div3_class_value=arrayJoin([\"DokaSlider\",/*klass*/ctx[7]]))){attr(div3,\"class\",div3_class_value);}},i:noop$1,o:noop$1,d(detaching){if(detaching)detach(div3);/*input_1_binding*/ctx[14](null);mounted=false;run_all(dispose);}};}function instance$h($$self,$$props,$$invalidate){let{min=0}=$$props;let{max=100}=$$props;let{step=1}=$$props;let{id=undefined}=$$props;let{value=0}=$$props;let{trackStyle=undefined}=$$props;let{knobStyle=undefined}=$$props;let{onchange=undefined}=$$props;let{class:klass=undefined}=$$props;let input;let inputWidth;let inputOffsetX;let pageOffsetX;const setValueByOffsetX=(offsetX,inputWidth)=>{$$invalidate(0,value=clamp(min+offsetX/inputWidth*range,min,max));onchange(value);};const handleInput=e=>{// already handled by pointer events\nif(inputWidth)return;$$invalidate(0,value=parseFloat(e.target.value));onchange(value);};const handleNudge=e=>{const width=input.offsetWidth;const offset=value/range*width;setValueByOffsetX(offset+e.detail.x,width);};const handlePointerDown=e=>{e.stopPropagation();inputWidth=input.offsetWidth;inputOffsetX=e.offsetX;pageOffsetX=e.pageX;setValueByOffsetX(inputOffsetX,inputWidth);document.documentElement.addEventListener(\"pointermove\",handlePointerMove);document.documentElement.addEventListener(\"pointerup\",handlePointerUp);};const handlePointerMove=e=>{const dx=e.pageX-pageOffsetX;setValueByOffsetX(inputOffsetX+dx,inputWidth);};const handlePointerUp=e=>{inputWidth=undefined;document.documentElement.removeEventListener(\"pointermove\",handlePointerMove);document.documentElement.removeEventListener(\"pointerup\",handlePointerUp);onchange(value);};function input_1_binding($$value){binding_callbacks[$$value?\"unshift\":\"push\"](()=>{input=$$value;$$invalidate(8,input);});}$$self.$$set=$$props=>{if(\"min\"in $$props)$$invalidate(1,min=$$props.min);if(\"max\"in $$props)$$invalidate(2,max=$$props.max);if(\"step\"in $$props)$$invalidate(3,step=$$props.step);if(\"id\"in $$props)$$invalidate(4,id=$$props.id);if(\"value\"in $$props)$$invalidate(0,value=$$props.value);if(\"trackStyle\"in $$props)$$invalidate(5,trackStyle=$$props.trackStyle);if(\"knobStyle\"in $$props)$$invalidate(6,knobStyle=$$props.knobStyle);if(\"onchange\"in $$props)$$invalidate(13,onchange=$$props.onchange);if(\"class\"in $$props)$$invalidate(7,klass=$$props.class);};let range;let position;$$self.$$.update=()=>{if($$self.$$.dirty&/*max, min*/6){$$invalidate(18,range=max-min);}if($$self.$$.dirty&/*value, range*/262145){$$invalidate(9,position=value/range*100);}};return[value,min,max,step,id,trackStyle,knobStyle,klass,input,position,handleInput,handleNudge,handlePointerDown,onchange,input_1_binding];}class Slider extends SvelteComponent{constructor(options){super();init(this,options,instance$h,create_fragment$h,safe_not_equal,{min:1,max:2,step:3,id:4,value:0,trackStyle:5,knobStyle:6,onchange:13,class:7});}}var RGBToHSV=(r,g,b)=>{let v=Math.max(r,g,b),n=v-Math.min(r,g,b);let h=n&&(v==r?(g-b)/n:v==g?2+(b-r)/n:4+(r-g)/n);return[60*(h<0?h+6:h)/360,v&&n/v,v];};var HSVToRGB=(h,s,v)=>{let r,g,b;const i=Math.floor(h*6);const f=h*6-i;const p=v*(1-s);const q=v*(1-f*s);const t=v*(1-(1-f)*s);switch(i%6){case 0:r=v,g=t,b=p;break;case 1:r=q,g=v,b=p;break;case 2:r=p,g=v,b=t;break;case 3:r=p,g=q,b=v;break;case 4:r=t,g=p,b=v;break;case 5:r=v,g=p,b=q;break;}return[r,g,b];};/* src/core/ui/components/ColorPreview.svelte generated by Svelte v3.29.4 */function create_fragment$i(ctx){let div;let span;let div_style_value;return{c(){div=element(\"div\");span=element(\"span\");attr(div,\"class\",\"DokaColorPreview\");attr(div,\"title\",/*title*/ctx[0]);attr(div,\"style\",div_style_value=`--color:${/*colorValue*/ctx[1]}`);},m(target,anchor){insert(target,div,anchor);append(div,span);},p(ctx,[dirty]){if(dirty&/*title*/1){attr(div,\"title\",/*title*/ctx[0]);}if(dirty&/*colorValue*/2&&div_style_value!==(div_style_value=`--color:${/*colorValue*/ctx[1]}`)){attr(div,\"style\",div_style_value);}},i:noop$1,o:noop$1,d(detaching){if(detaching)detach(div);}};}function instance$i($$self,$$props,$$invalidate){let{color=undefined}=$$props;let{title=undefined}=$$props;$$self.$$set=$$props=>{if(\"color\"in $$props)$$invalidate(2,color=$$props.color);if(\"title\"in $$props)$$invalidate(0,title=$$props.title);};let colorValue;$$self.$$.update=()=>{if($$self.$$.dirty&/*color*/4){$$invalidate(1,colorValue=color?colorArrayToRGBA(color):\"transparent\");}};return[title,colorValue,color];}class ColorPreview extends SvelteComponent{constructor(options){super();init(this,options,instance$i,create_fragment$i,safe_not_equal,{color:2,title:0});}}/* src/core/ui/components/ColorPicker.svelte generated by Svelte v3.29.4 */function create_if_block_4$2(ctx){let span;let t;return{c(){span=element(\"span\");t=text(/*label*/ctx[0]);},m(target,anchor){insert(target,span,anchor);append(span,t);},p(ctx,dirty){if(dirty[0]&/*label*/1)set_data(t,/*label*/ctx[0]);},d(detaching){if(detaching)detach(span);}};}// (312:4) <span slot=\"label\" class=\"DokaButtonLabel\">\nfunction create_label_slot$1(ctx){let span;let colorpreview;let t;let current;colorpreview=new ColorPreview({props:{color:/*value*/ctx[4],title:localize(/*title*/ctx[8],/*locale*/ctx[10])}});let if_block=!/*hidePresetLabel*/ctx[9]&&create_if_block_4$2(ctx);return{c(){span=element(\"span\");create_component(colorpreview.$$.fragment);t=space();if(if_block)if_block.c();attr(span,\"slot\",\"label\");attr(span,\"class\",\"DokaButtonLabel\");},m(target,anchor){insert(target,span,anchor);mount_component(colorpreview,span,null);append(span,t);if(if_block)if_block.m(span,null);current=true;},p(ctx,dirty){const colorpreview_changes={};if(dirty[0]&/*value*/16)colorpreview_changes.color=/*value*/ctx[4];if(dirty[0]&/*title, locale*/1280)colorpreview_changes.title=localize(/*title*/ctx[8],/*locale*/ctx[10]);colorpreview.$set(colorpreview_changes);if(!/*hidePresetLabel*/ctx[9]){if(if_block){if_block.p(ctx,dirty);}else{if_block=create_if_block_4$2(ctx);if_block.c();if_block.m(span,null);}}else if(if_block){if_block.d(1);if_block=null;}},i(local){if(current)return;transition_in(colorpreview.$$.fragment,local);current=true;},o(local){transition_out(colorpreview.$$.fragment,local);current=false;},d(detaching){if(detaching)detach(span);destroy_component(colorpreview);if(if_block)if_block.d();}};}// (324:8) {#if enablePicker}\nfunction create_if_block_2$3(ctx){let div3;let div2;let div1;let div0;let div0_style_value;let nudgeable_action;let div1_style_value;let div2_style_value;let t0;let slider;let t1;let current;let mounted;let dispose;slider=new Slider({props:{class:\"DokaHuePicker\",knobStyle:`background-color:${/*valueAsRGBAFullySaturated*/ctx[19]}`,onchange:/*updateHue*/ctx[24],value:/*hue*/ctx[14],min:0,max:1,step:0.001}});let if_block=/*enableOpacity*/ctx[11]&&create_if_block_3$2(ctx);return{c(){div3=element(\"div\");div2=element(\"div\");div1=element(\"div\");div0=element(\"div\");t0=space();create_component(slider.$$.fragment);t1=space();if(if_block)if_block.c();attr(div0,\"role\",\"button\");attr(div0,\"class\",\"DokaPickerKnob\");attr(div0,\"tabindex\",\"0\");attr(div0,\"style\",div0_style_value=`background-color:${/*valueAsRGBAFullyOpaque*/ctx[18]};`);attr(div1,\"class\",\"DokaPickerKnobController\");attr(div1,\"style\",div1_style_value=`transform:translate(${/*sx*/ctx[21]}%,${/*sy*/ctx[22]}%)`);attr(div2,\"class\",\"DokaSaturationPicker\");attr(div2,\"style\",div2_style_value=`background-color: ${/*valueAsRGBAFullySaturated*/ctx[19]}`);attr(div3,\"class\",\"DokaPicker\");},m(target,anchor){insert(target,div3,anchor);append(div3,div2);append(div2,div1);append(div1,div0);/*div2_binding*/ctx[29](div2);append(div3,t0);mount_component(slider,div3,null);append(div3,t1);if(if_block)if_block.m(div3,null);current=true;if(!mounted){dispose=[listen(div0,\"nudge\",/*handleNudge*/ctx[27]),action_destroyer(nudgeable_action=nudgeable.call(null,div0)),listen(div2,\"pointerdown\",/*handlePointerDown*/ctx[26])];mounted=true;}},p(ctx,dirty){if(!current||dirty[0]&/*valueAsRGBAFullyOpaque*/262144&&div0_style_value!==(div0_style_value=`background-color:${/*valueAsRGBAFullyOpaque*/ctx[18]};`)){attr(div0,\"style\",div0_style_value);}if(!current||dirty[0]&/*sx, sy*/6291456&&div1_style_value!==(div1_style_value=`transform:translate(${/*sx*/ctx[21]}%,${/*sy*/ctx[22]}%)`)){attr(div1,\"style\",div1_style_value);}if(!current||dirty[0]&/*valueAsRGBAFullySaturated*/524288&&div2_style_value!==(div2_style_value=`background-color: ${/*valueAsRGBAFullySaturated*/ctx[19]}`)){attr(div2,\"style\",div2_style_value);}const slider_changes={};if(dirty[0]&/*valueAsRGBAFullySaturated*/524288)slider_changes.knobStyle=`background-color:${/*valueAsRGBAFullySaturated*/ctx[19]}`;if(dirty[0]&/*hue*/16384)slider_changes.value=/*hue*/ctx[14];slider.$set(slider_changes);if(/*enableOpacity*/ctx[11]){if(if_block){if_block.p(ctx,dirty);if(dirty[0]&/*enableOpacity*/2048){transition_in(if_block,1);}}else{if_block=create_if_block_3$2(ctx);if_block.c();transition_in(if_block,1);if_block.m(div3,null);}}else if(if_block){group_outros();transition_out(if_block,1,1,()=>{if_block=null;});check_outros();}},i(local){if(current)return;transition_in(slider.$$.fragment,local);transition_in(if_block);current=true;},o(local){transition_out(slider.$$.fragment,local);transition_out(if_block);current=false;},d(detaching){if(detaching)detach(div3);/*div2_binding*/ctx[29](null);destroy_component(slider);if(if_block)if_block.d();mounted=false;run_all(dispose);}};}// (344:12) {#if enableOpacity}\nfunction create_if_block_3$2(ctx){let slider;let current;slider=new Slider({props:{class:\"DokaOpacityPicker\",knobStyle:`background-color: ${/*valueAsRGBA*/ctx[16]}`,trackStyle:`background-image: linear-gradient(to right, ${/*valueAsRGBAFullyTransparent*/ctx[17]}, ${/*valueAsRGBAFullyOpaque*/ctx[18]})`,onchange:/*updateOpacity*/ctx[25],value:/*opacity*/ctx[15],min:0,max:1,step:0.001}});return{c(){create_component(slider.$$.fragment);},m(target,anchor){mount_component(slider,target,anchor);current=true;},p(ctx,dirty){const slider_changes={};if(dirty[0]&/*valueAsRGBA*/65536)slider_changes.knobStyle=`background-color: ${/*valueAsRGBA*/ctx[16]}`;if(dirty[0]&/*valueAsRGBAFullyTransparent, valueAsRGBAFullyOpaque*/393216)slider_changes.trackStyle=`background-image: linear-gradient(to right, ${/*valueAsRGBAFullyTransparent*/ctx[17]}, ${/*valueAsRGBAFullyOpaque*/ctx[18]})`;if(dirty[0]&/*opacity*/32768)slider_changes.value=/*opacity*/ctx[15];slider.$set(slider_changes);},i(local){if(current)return;transition_in(slider.$$.fragment,local);current=true;},o(local){transition_out(slider.$$.fragment,local);current=false;},d(detaching){destroy_component(slider,detaching);}};}// (357:8) {#if enablePresets}\nfunction create_if_block$4(ctx){let radiogroup;let current;radiogroup=new RadioGroup({props:{label:\"Presets\",class:arrayJoin([\"DokaColorPresets\",/*hidePresetLabel*/ctx[9]?\"DokaColorPresetsGrid\":\"DokaColorPresetsList\"]),hideLabel:false,name:/*name*/ctx[1],value:/*value*/ctx[4],optionGroupClass:\"DokaDropdownOptionGroup\",optionClass:\"DokaDropdownOption\",options:/*options*/ctx[2].map(/*func*/ctx[30]),selectedIndex:/*selectedIndex*/ctx[3],optionMapper:/*optionMapper*/ctx[7],optionLabelClass:/*optionLabelClass*/ctx[6],onchange:/*func_1*/ctx[31],$$slots:{default:[create_default_slot_1$3,({option})=>({44:option}),({option})=>[0,option?8192:0]],option:[create_option_slot$1,({option})=>({44:option}),({option})=>[0,option?8192:0]],group:[create_group_slot$1,({option})=>({44:option}),({option})=>[0,option?8192:0]]},$$scope:{ctx}}});return{c(){create_component(radiogroup.$$.fragment);},m(target,anchor){mount_component(radiogroup,target,anchor);current=true;},p(ctx,dirty){const radiogroup_changes={};if(dirty[0]&/*hidePresetLabel*/512)radiogroup_changes.class=arrayJoin([\"DokaColorPresets\",/*hidePresetLabel*/ctx[9]?\"DokaColorPresetsGrid\":\"DokaColorPresetsList\"]);if(dirty[0]&/*name*/2)radiogroup_changes.name=/*name*/ctx[1];if(dirty[0]&/*value*/16)radiogroup_changes.value=/*value*/ctx[4];if(dirty[0]&/*options, locale*/1028)radiogroup_changes.options=/*options*/ctx[2].map(/*func*/ctx[30]);if(dirty[0]&/*selectedIndex*/8)radiogroup_changes.selectedIndex=/*selectedIndex*/ctx[3];if(dirty[0]&/*optionMapper*/128)radiogroup_changes.optionMapper=/*optionMapper*/ctx[7];if(dirty[0]&/*optionLabelClass*/64)radiogroup_changes.optionLabelClass=/*optionLabelClass*/ctx[6];if(dirty[0]&/*hidePresetLabel*/512|dirty[1]&/*$$scope, option*/24576){radiogroup_changes.$$scope={dirty,ctx};}radiogroup.$set(radiogroup_changes);},i(local){if(current)return;transition_in(radiogroup.$$.fragment,local);current=true;},o(local){transition_out(radiogroup.$$.fragment,local);current=false;},d(detaching){destroy_component(radiogroup,detaching);}};}// (373:12) <span slot=\"group\">\nfunction create_group_slot$1(ctx){let span;let t_value=/*option*/ctx[44].label+\"\";let t;return{c(){span=element(\"span\");t=text(t_value);attr(span,\"slot\",\"group\");},m(target,anchor){insert(target,span,anchor);append(span,t);},p(ctx,dirty){if(dirty[1]&/*option*/8192&&t_value!==(t_value=/*option*/ctx[44].label+\"\"))set_data(t,t_value);},d(detaching){if(detaching)detach(span);}};}// (378:16) {#if !hidePresetLabel}\nfunction create_if_block_1$5(ctx){let span;let t_value=/*option*/ctx[44].label+\"\";let t;return{c(){span=element(\"span\");t=text(t_value);attr(span,\"class\",\"DokaButtonLabel\");},m(target,anchor){insert(target,span,anchor);append(span,t);},p(ctx,dirty){if(dirty[1]&/*option*/8192&&t_value!==(t_value=/*option*/ctx[44].label+\"\"))set_data(t,t_value);},d(detaching){if(detaching)detach(span);}};}// (376:12) <span slot=\"option\">\nfunction create_option_slot$1(ctx){let span;let colorpreview;let t;let current;colorpreview=new ColorPreview({props:{title:/*option*/ctx[44].label,color:/*option*/ctx[44].value}});let if_block=!/*hidePresetLabel*/ctx[9]&&create_if_block_1$5(ctx);return{c(){span=element(\"span\");create_component(colorpreview.$$.fragment);t=space();if(if_block)if_block.c();attr(span,\"slot\",\"option\");},m(target,anchor){insert(target,span,anchor);mount_component(colorpreview,span,null);append(span,t);if(if_block)if_block.m(span,null);current=true;},p(ctx,dirty){const colorpreview_changes={};if(dirty[1]&/*option*/8192)colorpreview_changes.title=/*option*/ctx[44].label;if(dirty[1]&/*option*/8192)colorpreview_changes.color=/*option*/ctx[44].value;colorpreview.$set(colorpreview_changes);if(!/*hidePresetLabel*/ctx[9]){if(if_block){if_block.p(ctx,dirty);}else{if_block=create_if_block_1$5(ctx);if_block.c();if_block.m(span,null);}}else if(if_block){if_block.d(1);if_block=null;}},i(local){if(current)return;transition_in(colorpreview.$$.fragment,local);current=true;},o(local){transition_out(colorpreview.$$.fragment,local);current=false;},d(detaching){if(detaching)detach(span);destroy_component(colorpreview);if(if_block)if_block.d();}};}// (359:8) <RadioGroup              label=\"Presets\"             class={arrayJoin(['DokaColorPresets', hidePresetLabel ? 'DokaColorPresetsGrid' : 'DokaColorPresetsList'])}             hideLabel={false}             {name}             {value}             optionGroupClass=\"DokaDropdownOptionGroup\"             optionClass=\"DokaDropdownOption\"             options={options.map(([color, label]) => [color, isFunction(label) ? label(locale) : label])}             {selectedIndex}             {optionMapper}             {optionLabelClass}             onchange={(detail) => updateColorArray(detail.value)}             let:option>\nfunction create_default_slot_1$3(ctx){let t;return{c(){t=space();},m(target,anchor){insert(target,t,anchor);},p:noop$1,i:noop$1,o:noop$1,d(detaching){if(detaching)detach(t);}};}// (321:4) <div slot=\"details\" class=\"DokaColorPickerPanel\">\nfunction create_details_slot$1(ctx){let div;let t;let current;let if_block0=/*enablePicker*/ctx[13]&&create_if_block_2$3(ctx);let if_block1=/*enablePresets*/ctx[12]&&create_if_block$4(ctx);return{c(){div=element(\"div\");if(if_block0)if_block0.c();t=space();if(if_block1)if_block1.c();attr(div,\"slot\",\"details\");attr(div,\"class\",\"DokaColorPickerPanel\");},m(target,anchor){insert(target,div,anchor);if(if_block0)if_block0.m(div,null);append(div,t);if(if_block1)if_block1.m(div,null);current=true;},p(ctx,dirty){if(/*enablePicker*/ctx[13]){if(if_block0){if_block0.p(ctx,dirty);if(dirty[0]&/*enablePicker*/8192){transition_in(if_block0,1);}}else{if_block0=create_if_block_2$3(ctx);if_block0.c();transition_in(if_block0,1);if_block0.m(div,t);}}else if(if_block0){group_outros();transition_out(if_block0,1,1,()=>{if_block0=null;});check_outros();}if(/*enablePresets*/ctx[12]){if(if_block1){if_block1.p(ctx,dirty);if(dirty[0]&/*enablePresets*/4096){transition_in(if_block1,1);}}else{if_block1=create_if_block$4(ctx);if_block1.c();transition_in(if_block1,1);if_block1.m(div,null);}}else if(if_block1){group_outros();transition_out(if_block1,1,1,()=>{if_block1=null;});check_outros();}},i(local){if(current)return;transition_in(if_block0);transition_in(if_block1);current=true;},o(local){transition_out(if_block0);transition_out(if_block1);current=false;},d(detaching){if(detaching)detach(div);if(if_block0)if_block0.d();if(if_block1)if_block1.d();}};}// (310:0) <Details buttonClass={arrayJoin(['DokaColorPickerButton', buttonClass])}>\nfunction create_default_slot$5(ctx){let t;return{c(){t=space();},m(target,anchor){insert(target,t,anchor);},p:noop$1,i:noop$1,o:noop$1,d(detaching){if(detaching)detach(t);}};}function create_fragment$j(ctx){let details;let current;details=new Details({props:{buttonClass:arrayJoin([\"DokaColorPickerButton\",/*buttonClass*/ctx[5]]),$$slots:{default:[create_default_slot$5],details:[create_details_slot$1],label:[create_label_slot$1]},$$scope:{ctx}}});return{c(){create_component(details.$$.fragment);},m(target,anchor){mount_component(details,target,anchor);current=true;},p(ctx,dirty){const details_changes={};if(dirty[0]&/*buttonClass*/32)details_changes.buttonClass=arrayJoin([\"DokaColorPickerButton\",/*buttonClass*/ctx[5]]);if(dirty[0]&/*hidePresetLabel, name, value, options, locale, selectedIndex, optionMapper, optionLabelClass, enablePresets, valueAsRGBA, valueAsRGBAFullyTransparent, valueAsRGBAFullyOpaque, opacity, enableOpacity, valueAsRGBAFullySaturated, hue, input, sx, sy, enablePicker, label, title*/8388575|dirty[1]&/*$$scope*/16384){details_changes.$$scope={dirty,ctx};}details.$set(details_changes);},i(local){if(current)return;transition_in(details.$$.fragment,local);current=true;},o(local){transition_out(details.$$.fragment,local);current=false;},d(detaching){destroy_component(details,detaching);}};}function instance$j($$self,$$props,$$invalidate){let{label=undefined}=$$props;let{name=undefined}=$$props;let{options=[]}=$$props;let{selectedIndex=-1}=$$props;let{value=undefined}=$$props;let{buttonClass=undefined}=$$props;let{optionLabelClass=undefined}=$$props;let{optionMapper=undefined}=$$props;let{onchange=undefined}=$$props;let{title=undefined}=$$props;let{hidePresetLabel=true}=$$props;let{locale=undefined}=$$props;let{enableOpacity=true}=$$props;let{enablePresets=true}=$$props;let{enablePicker=true}=$$props;// inputs\nlet hue;let saturation;let brightness;let opacity;// shortcuts\nlet valueAsRGB;let valueAsRGBA;let valueAsRGBAFullyTransparent;let valueAsRGBAFullyOpaque;let valueAsRGBAFullySaturated;const updateProps=(color,syncControls)=>{valueAsRGB=[color[0],color[1],color[2]];if(syncControls){let valueAsHSV=RGBToHSV(...valueAsRGB);$$invalidate(14,hue=valueAsHSV[0]);$$invalidate(32,saturation=valueAsHSV[1]);$$invalidate(33,brightness=valueAsHSV[2]);$$invalidate(15,opacity=isNumber(color[3])?color[3]:1);}$$invalidate(16,valueAsRGBA=colorArrayToRGBA(color));$$invalidate(17,valueAsRGBAFullyTransparent=colorArrayToRGBA([...valueAsRGB,0]));$$invalidate(18,valueAsRGBAFullyOpaque=colorArrayToRGBA([...valueAsRGB,1]));$$invalidate(19,valueAsRGBAFullySaturated=colorArrayToRGBA(HSVToRGB(hue,1,1)));};value&&updateProps(value,true);const update=()=>{const rgb=HSVToRGB(hue,saturation,brightness);const rgba=[...rgb,opacity];updateProps(rgba);onchange(rgba);};const updateColorArray=arr=>{const rgba=arr.length===3?[...arr,1]:arr;updateProps(rgba,true);onchange(rgba);};const updateHue=h=>{$$invalidate(14,hue=h);if(opacity===0)$$invalidate(15,opacity=1);update();};const updateSaturationAndBrightness=(s,b)=>{$$invalidate(32,saturation=s);$$invalidate(33,brightness=b);if(opacity===0)$$invalidate(15,opacity=1);update();};const updateOpacity=o=>{$$invalidate(15,opacity=o);update();};const setValueByOffset=(offset,inputSize)=>{const x=clamp(offset.x/inputSize.width,0,1);const y=clamp(offset.y/inputSize.height,0,1);updateSaturationAndBrightness(x,1-y);};let input;let inputSize;let inputOffset;let inputPageOffset;const handlePointerDown=e=>{e.stopPropagation();inputSize=sizeCreate(input.offsetWidth,input.offsetHeight);inputOffset=vectorCreateFromPointerEventOffset(e);inputPageOffset=vectorCreateFromPointerEvent(e);setValueByOffset(inputOffset,inputSize);document.documentElement.addEventListener(\"pointermove\",handlePointerMove);document.documentElement.addEventListener(\"pointerup\",handlePointerUp);};const handlePointerMove=e=>{const d=vectorSubtract(vectorCreateFromPointerEvent(e),inputPageOffset);setValueByOffset(vectorAdd(vectorClone(inputOffset),d),inputSize);};const handlePointerUp=e=>{inputSize=undefined;document.documentElement.removeEventListener(\"pointermove\",handlePointerMove);document.documentElement.removeEventListener(\"pointerup\",handlePointerUp);};const handleNudge=e=>{inputSize=sizeCreate(input.offsetWidth,input.offsetHeight);const x=sx/100*inputSize.width;const y=sy/100*inputSize.height;setValueByOffset({x:x+e.detail.x,y:y+e.detail.y},inputSize);};function div2_binding($$value){binding_callbacks[$$value?\"unshift\":\"push\"](()=>{input=$$value;$$invalidate(20,input);});}const func=([color,label])=>[color,isFunction(label)?label(locale):label];const func_1=detail=>updateColorArray(detail.value);$$self.$$set=$$props=>{if(\"label\"in $$props)$$invalidate(0,label=$$props.label);if(\"name\"in $$props)$$invalidate(1,name=$$props.name);if(\"options\"in $$props)$$invalidate(2,options=$$props.options);if(\"selectedIndex\"in $$props)$$invalidate(3,selectedIndex=$$props.selectedIndex);if(\"value\"in $$props)$$invalidate(4,value=$$props.value);if(\"buttonClass\"in $$props)$$invalidate(5,buttonClass=$$props.buttonClass);if(\"optionLabelClass\"in $$props)$$invalidate(6,optionLabelClass=$$props.optionLabelClass);if(\"optionMapper\"in $$props)$$invalidate(7,optionMapper=$$props.optionMapper);if(\"onchange\"in $$props)$$invalidate(28,onchange=$$props.onchange);if(\"title\"in $$props)$$invalidate(8,title=$$props.title);if(\"hidePresetLabel\"in $$props)$$invalidate(9,hidePresetLabel=$$props.hidePresetLabel);if(\"locale\"in $$props)$$invalidate(10,locale=$$props.locale);if(\"enableOpacity\"in $$props)$$invalidate(11,enableOpacity=$$props.enableOpacity);if(\"enablePresets\"in $$props)$$invalidate(12,enablePresets=$$props.enablePresets);if(\"enablePicker\"in $$props)$$invalidate(13,enablePicker=$$props.enablePicker);};let sx;let sy;$$self.$$.update=()=>{if($$self.$$.dirty[1]&/*saturation*/2){$$invalidate(21,sx=saturation*100);}if($$self.$$.dirty[1]&/*brightness*/4){$$invalidate(22,sy=100-brightness*100);}};return[label,name,options,selectedIndex,value,buttonClass,optionLabelClass,optionMapper,title,hidePresetLabel,locale,enableOpacity,enablePresets,enablePicker,hue,opacity,valueAsRGBA,valueAsRGBAFullyTransparent,valueAsRGBAFullyOpaque,valueAsRGBAFullySaturated,input,sx,sy,updateColorArray,updateHue,updateOpacity,handlePointerDown,handleNudge,onchange,div2_binding,func,func_1];}class ColorPicker extends SvelteComponent{constructor(options){super();init(this,options,instance$j,create_fragment$j,safe_not_equal,{label:0,name:1,options:2,selectedIndex:3,value:4,buttonClass:5,optionLabelClass:6,optionMapper:7,onchange:28,title:8,hidePresetLabel:9,locale:10,enableOpacity:11,enablePresets:12,enablePicker:13},[-1,-1]);}}var upperCaseFirstLetter=str=>str.charAt(0).toUpperCase()+str.slice(1);// @ts-ignore\nconst toLocaleFn=(key,localePrefix)=>locale=>locale[localePrefix?`${localePrefix}${upperCaseFirstLetter(key)}`:key];const mapToSizeOption=v=>[v,`${v}`];const createLocaleMapper=(options,localePrefix)=>key=>[options[key],toLocaleFn(key,localePrefix)];const toolColorDefault=[1,0.2549,0.2118];const toolStrokeColorDefault=[1,1,1,0];//#region tools\nconst toolShapeDefaults={path:()=>({points:[],disableErase:false}),line:()=>({x1:0,y1:0,x2:0,y2:0,disableErase:false}),rectangle:()=>({x:0,y:0,width:0,height:0}),ellipse:()=>({x:0,y:0,rx:0,ry:0}),text:()=>({x:0,y:0,text:'Text'})};const createToolStyle=(type,shape={},options={position:'relative'})=>{if(!toolShapeDefaults[type])return;const shapeDef=_objectSpread(_objectSpread({},toolShapeDefaults[type]()),shape);return[shapeDef,options];};const createToolStyles=tools=>_objectSpread({sharpie:createToolStyle('path',{strokeWidth:'0.5%',strokeColor:[...toolColorDefault]}),line:createToolStyle('line',{strokeColor:[...toolColorDefault],strokeWidth:'0.5%'}),arrow:createToolStyle('line',{lineEnd:'arrow-solid',strokeColor:[...toolColorDefault],strokeWidth:'0.5%'}),rectangle:createToolStyle('rectangle',{strokeColor:[...toolStrokeColorDefault],backgroundColor:[...toolColorDefault]}),ellipse:createToolStyle('ellipse',{strokeColor:[...toolStrokeColorDefault],backgroundColor:[...toolColorDefault]}),text:createToolStyle('text',{color:[...toolColorDefault],fontSize:'2%'})},tools);//#endregion\n//#region toolbar\nconst createToolbarItem=(tool,label,props)=>[tool,label||toLocaleFn(tool,'shapeLabelTool'),_objectSpread({icon:toLocaleFn(tool,'shapeIconTool')},props)];const createToolbar=(tools=['sharpie','eraser','line','arrow','rectangle','ellipse','text','preset'])=>tools.map(tool=>{// default tool definition, assume locale in\nif(isString(tool))return createToolbarItem(tool);// tool def with propery\nif(Array.isArray(tool)){// state update of tool with key in locale object\nif(isObject(tool[1]))return createToolbarItem(tool[0],undefined,tool[1]);// should be string, string\nreturn createToolbarItem(tool[0],tool[1],tool[2]);}}).filter(Boolean);//#endregion\n//#region style option defaults\nconst createDefaultColorOptions=()=>({transparent:[1,1,1,0],white:[1,1,1],silver:[0.8667,0.8667,0.8667],gray:[0.6667,0.6667,0.6667],black:[0,0,0],navy:[0,0.1216,0.2471],blue:[0,0.4549,0.851],aqua:[0.498,0.8588,1],teal:[0.2235,0.8,0.8],olive:[0.2392,0.6,0.4392],green:[0.1804,0.8,0.251],yellow:[1,0.8627,0],orange:[1,0.5216,0.1059],red:[1,0.2549,0.2118],maroon:[0.5216,0.0784,0.2941],fuchsia:[0.9412,0.0706,0.7451],purple:[0.6941,0.051,0.7882]});const createDefaultFontSizeOptions=()=>[16,18,20,24,30,36,48,64,72,96,144];const createDefaultFontScaleOptions=()=>({extraSmall:'2%',small:'4%',mediumSmall:'8%',medium:'10%',mediumLarge:'15%',large:'20%',extraLarge:'25%'});const createDefaultStrokeWidthOptions=()=>[1,2,3,4,6,8,12,16,20,24,32,48];const createDefaultStrokeScaleOptions=()=>({extraSmall:'0.25%',small:'0.5%',mediumSmall:'1%',medium:'1.75%',mediumLarge:'2.5%',large:'3.5%',extraLarge:'5%'});const createDefaultLineEndStyleOptions=()=>['bar','arrow','arrowSolid','circle','circleSolid','square','squareSolid'];const createDefaultFontFamilyOptions=()=>[[`Helvetica, Arial, Verdana, 'Droid Sans', sans-serif`,'Sans Serif'],[`'Arial Black', 'Avenir-Black', 'Arial Bold'`,'Black'],[`'Arial Narrow', 'Futura-CondensedMedium'`,'Narrow'],[`'Trebuchet MS'`,'Humanist'],[`Georgia, 'Avenir-Black', 'Times New Roman', 'Droid Serif', serif`,'Serif'],[`Palatino`,'Old-Style'],[`'Times New Roman', 'TimesNewRomanPSMT'`,'Transitional'],[`Menlo, Monaco, 'Lucida Console', monospace`,'Monospaced'],[`'Courier New', monospace`,'Slab Serif']];const createDefaultTextAlignOptions=()=>['left','center','right'];const createDefaultFontStyleOptions=()=>[['normal','bold'],['italic','normal'],['italic','bold']];//#endregion\n//#region style options\nconst createColorOptions=colors=>Object.keys(colors).map(createLocaleMapper(colors,'shapeTitleColor'));const createFontSizeOptions=sizes=>sizes.map(mapToSizeOption);const createFontScaleOptions=scales=>Object.keys(scales).map(createLocaleMapper(scales,'labelSize'));const createStrokeWidthOptions=sizes=>sizes.map(mapToSizeOption);const createStrokeScaleOptions=scales=>Object.keys(scales).map(createLocaleMapper(scales,'labelSize'));const createFontFamilyOptions=fonts=>[...fonts];const createFontStyleOptions=styles=>styles.map(style=>[style,locale=>locale[`shapeLabelFontStyle${style.filter(v=>v!=='normal').map(upperCaseFirstLetter).join('')}`]]);const createLineEndStyleOptions=styles=>styles.map(style=>[toKebabCase(style),locale=>locale[`shapeTitleLineDecoration${upperCaseFirstLetter(style)}`],{icon:locale=>locale[`shapeIconLineDecoration${upperCaseFirstLetter(style)}`]}]);const createTextAlignOptions=options=>options.map(align=>[align,locale=>locale[`shapeTitleTextAlign${upperCaseFirstLetter(align)}`],{hideLabel:true,icon:locale=>locale[`shapeIconTextAlign${upperCaseFirstLetter(align)}`]}]);const createControlOptions=(items,options)=>{const{defaultKey,defaultOptions}=options||{};let arr=[];if(defaultKey)arr[0]=[undefined,locale=>locale[defaultKey],_objectSpread({},defaultOptions)];return[...arr,...items];};//#endregion\n//#region shape style controls\nconst createFontFamilyControl=fontFamilies=>[Dropdown,{title:locale=>locale.shapeTitleFontFamily,optionLabelStyle:value=>`font-family: ${value}`,options:createControlOptions(fontFamilies,{defaultKey:'labelDefault'}),optionFilter:fontFamilyOption=>{// don't filter if not in browser context\nif(!isBrowser())return true;// get font stack\nconst[stack]=fontFamilyOption;// allow if undefined\nif(!stack)return true;// filter out fonts that aren't available\nreturn stack.split(',').map(name=>name.trim()).some(name=>{// @ts-ignore\nreturn document.fonts.check(`16px ${name}`);});}}];const createBackgroundColorControl=items=>[ColorPicker,{title:locale=>locale.shapeTitleBackgroundColor,options:createControlOptions(items)}];const createStrokeColorControl=(items,options={})=>[ColorPicker,{title:locale=>locale.shapeTitleStrokeColor,options:createControlOptions(items),buttonClass:'DokaColorPickerButtonStroke',onchange:(value,shape)=>{// get shape strokeWidth as number\nlet strokeWidth=shape.strokeWidth;let strokeWidthParsed=isNumber(strokeWidth)||isString(strokeWidth)?parseFloat(strokeWidth):0;// already has outline\nif(strokeWidthParsed>0)return;// set outline to first stroke width\nshape.strokeWidth=options&&options.defaultStrokeWidth||'0.5%';}}];const createStrokeWidthControl=items=>[Dropdown,{title:locale=>locale.shapeTitleStrokeWidth,options:shape=>{if(hasProp(shape,'backgroundColor'))return createControlOptions(items,{defaultKey:'shapeLabelStrokeNone'});return createControlOptions(items);}}];const createLineControl=(items,titleKey,optionIconStyle)=>[Dropdown,{title:locale=>locale[titleKey],options:createControlOptions(items,{defaultKey:'labelNone',defaultOptions:{icon:`<g stroke=\"currentColor\" stroke-linecap=\"round\" stroke-width=\".125em\"><path d=\"M5,12 H14\"/></g>`}}),optionIconStyle}];const createLineStartStyleControl=items=>createLineControl(items,'shapeTitleLineStart',`transform: scaleX(-1)`);const createLineEndStyleControl=items=>createLineControl(items,'shapeTitleLineEnd');const createFontColorControl=items=>[ColorPicker,{title:locale=>locale.shapeTitleTextColor,options:createControlOptions(items)}];const createFontStyleControl=items=>[Dropdown,{title:locale=>locale.shapeTitleFontStyle,optionLabelStyle:value=>value&&`font-style:${value[0]};font-weight:${value[1]}`,options:createControlOptions(items,{defaultKey:'shapeLabelFontStyleNormal'})}];const createFontSizeControl=items=>[Dropdown,{title:locale=>locale.shapeTitleFontSize,options:createControlOptions(items,{defaultKey:'labelDefault'})}];const createTextAlignControl=items=>[RadioGroup,{title:locale=>locale.shapeTitleTextAlign,options:createControlOptions(items)}];const createLineHeightControl=items=>[Dropdown,{title:locale=>locale.shapeTitleLineHeight,options:createControlOptions(items,{defaultKey:'labelAuto'})}];const createShapeStyleControls=(options={})=>{const{colorOptions=createColorOptions(createDefaultColorOptions()),strokeWidthOptions=createStrokeScaleOptions(createDefaultStrokeScaleOptions()),lineEndStyleOptions=createLineEndStyleOptions(createDefaultLineEndStyleOptions()),fontFamilyOptions=createFontFamilyOptions(createDefaultFontFamilyOptions()),fontStyleOptions=createFontStyleOptions(createDefaultFontStyleOptions()),fontSizeOptions=createFontScaleOptions(createDefaultFontScaleOptions()),textAlignOptions=createTextAlignOptions(createDefaultTextAlignOptions())}=options;return{// shape background\nbackgroundColor:colorOptions&&createBackgroundColorControl(colorOptions),// line/outline\nstrokeColor:colorOptions&&createStrokeColorControl(colorOptions),strokeWidth:strokeWidthOptions&&createStrokeWidthControl(strokeWidthOptions),// line\nlineStart:lineEndStyleOptions&&createLineStartStyleControl(lineEndStyleOptions),lineEnd:lineEndStyleOptions&&createLineEndStyleControl(lineEndStyleOptions),// text\ncolor:colorOptions&&createFontColorControl(colorOptions),fontFamily:fontFamilyOptions&&createFontFamilyControl(fontFamilyOptions),fontStyle_fontWeight:fontStyleOptions&&createFontStyleControl(fontStyleOptions),fontSize:fontSizeOptions&&createFontSizeControl(fontSizeOptions),textAlign:textAlignOptions&&createTextAlignControl(textAlignOptions)};};//#endregion\n/* src/core/ui/components/Measure.svelte generated by Svelte v3.29.4 */function create_fragment$k(ctx){let div;let measurable_action;let current;let mounted;let dispose;const default_slot_template=/*#slots*/ctx[3].default;const default_slot=create_slot(default_slot_template,ctx,/*$$scope*/ctx[2],null);return{c(){div=element(\"div\");if(default_slot)default_slot.c();attr(div,\"class\",/*klass*/ctx[0]);},m(target,anchor){insert(target,div,anchor);if(default_slot){default_slot.m(div,null);}current=true;if(!mounted){dispose=[listen(div,\"measure\",/*handleResize*/ctx[1]),action_destroyer(measurable_action=measurable.call(null,div))];mounted=true;}},p(ctx,[dirty]){if(default_slot){if(default_slot.p&&dirty&/*$$scope*/4){update_slot(default_slot,default_slot_template,ctx,/*$$scope*/ctx[2],dirty,null,null);}}if(!current||dirty&/*klass*/1){attr(div,\"class\",/*klass*/ctx[0]);}},i(local){if(current)return;transition_in(default_slot,local);current=true;},o(local){transition_out(default_slot,local);current=false;},d(detaching){if(detaching)detach(div);if(default_slot)default_slot.d(detaching);mounted=false;run_all(dispose);}};}function instance$k($$self,$$props,$$invalidate){let{$$slots:slots={},$$scope}=$$props;const dispatch=createEventDispatcher();let{class:klass=null}=$$props;const handleResize=({detail})=>dispatch(\"measure\",detail);$$self.$$set=$$props=>{if(\"class\"in $$props)$$invalidate(0,klass=$$props.class);if(\"$$scope\"in $$props)$$invalidate(2,$$scope=$$props.$$scope);};return[klass,handleResize,$$scope,slots];}class Measure extends SvelteComponent{constructor(options){super();init(this,options,instance$k,create_fragment$k,safe_not_equal,{class:0});}}/* src/core/ui/components/Util.svelte generated by Svelte v3.29.4 */const get_footer_slot_changes=dirty=>({});const get_footer_slot_context=ctx=>({});const get_main_slot_changes=dirty=>({});const get_main_slot_context=ctx=>({});const get_header_slot_changes=dirty=>({});const get_header_slot_context=ctx=>({});// (209:0) {#if hasHeader}\nfunction create_if_block_2$4(ctx){let div;let current;const header_slot_template=/*#slots*/ctx[4].header;const header_slot=create_slot(header_slot_template,ctx,/*$$scope*/ctx[3],get_header_slot_context);return{c(){div=element(\"div\");if(header_slot)header_slot.c();attr(div,\"class\",\"DokaUtilHeader\");},m(target,anchor){insert(target,div,anchor);if(header_slot){header_slot.m(div,null);}current=true;},p(ctx,dirty){if(header_slot){if(header_slot.p&&dirty&/*$$scope*/8){update_slot(header_slot,header_slot_template,ctx,/*$$scope*/ctx[3],dirty,get_header_slot_changes,get_header_slot_context);}}},i(local){if(current)return;transition_in(header_slot,local);current=true;},o(local){transition_out(header_slot,local);current=false;},d(detaching){if(detaching)detach(div);if(header_slot)header_slot.d(detaching);}};}// (216:22) <Measure class=\"DokaStage\" on:measure/>\nfunction fallback_block$2(ctx){let measure;let current;measure=new Measure({props:{class:\"DokaStage\"}});measure.$on(\"measure\",/*measure_handler*/ctx[5]);return{c(){create_component(measure.$$.fragment);},m(target,anchor){mount_component(measure,target,anchor);current=true;},p:noop$1,i(local){if(current)return;transition_in(measure.$$.fragment,local);current=true;},o(local){transition_out(measure.$$.fragment,local);current=false;},d(detaching){destroy_component(measure,detaching);}};}// (219:0) {#if hasFooter}\nfunction create_if_block_1$6(ctx){let div;let current;const footer_slot_template=/*#slots*/ctx[4].footer;const footer_slot=create_slot(footer_slot_template,ctx,/*$$scope*/ctx[3],get_footer_slot_context);return{c(){div=element(\"div\");if(footer_slot)footer_slot.c();attr(div,\"class\",\"DokaUtilFooter\");},m(target,anchor){insert(target,div,anchor);if(footer_slot){footer_slot.m(div,null);}current=true;},p(ctx,dirty){if(footer_slot){if(footer_slot.p&&dirty&/*$$scope*/8){update_slot(footer_slot,footer_slot_template,ctx,/*$$scope*/ctx[3],dirty,get_footer_slot_changes,get_footer_slot_context);}}},i(local){if(current)return;transition_in(footer_slot,local);current=true;},o(local){transition_out(footer_slot,local);current=false;},d(detaching){if(detaching)detach(div);if(footer_slot)footer_slot.d(detaching);}};}function create_fragment$l(ctx){let t0;let div;let t1;let t2;let if_block2_anchor;let current;let if_block0=/*hasHeader*/ctx[1]&&create_if_block_2$4(ctx);const main_slot_template=/*#slots*/ctx[4].main;const main_slot=create_slot(main_slot_template,ctx,/*$$scope*/ctx[3],get_main_slot_context);const main_slot_or_fallback=main_slot||fallback_block$2(ctx);let if_block1=/*hasFooter*/ctx[2]&&create_if_block_1$6(ctx);let if_block2=false;return{c(){if(if_block0)if_block0.c();t0=space();div=element(\"div\");if(main_slot_or_fallback)main_slot_or_fallback.c();t1=space();if(if_block1)if_block1.c();t2=space();if_block2_anchor=empty();attr(div,\"class\",\"DokaUtilMain\");},m(target,anchor){if(if_block0)if_block0.m(target,anchor);insert(target,t0,anchor);insert(target,div,anchor);if(main_slot_or_fallback){main_slot_or_fallback.m(div,null);}/*div_binding*/ctx[6](div);insert(target,t1,anchor);if(if_block1)if_block1.m(target,anchor);insert(target,t2,anchor);insert(target,if_block2_anchor,anchor);current=true;},p(ctx,[dirty]){if(/*hasHeader*/ctx[1]){if(if_block0){if_block0.p(ctx,dirty);if(dirty&/*hasHeader*/2){transition_in(if_block0,1);}}else{if_block0=create_if_block_2$4(ctx);if_block0.c();transition_in(if_block0,1);if_block0.m(t0.parentNode,t0);}}else if(if_block0){group_outros();transition_out(if_block0,1,1,()=>{if_block0=null;});check_outros();}if(main_slot){if(main_slot.p&&dirty&/*$$scope*/8){update_slot(main_slot,main_slot_template,ctx,/*$$scope*/ctx[3],dirty,get_main_slot_changes,get_main_slot_context);}}if(/*hasFooter*/ctx[2]){if(if_block1){if_block1.p(ctx,dirty);if(dirty&/*hasFooter*/4){transition_in(if_block1,1);}}else{if_block1=create_if_block_1$6(ctx);if_block1.c();transition_in(if_block1,1);if_block1.m(t2.parentNode,t2);}}else if(if_block1){group_outros();transition_out(if_block1,1,1,()=>{if_block1=null;});check_outros();}},i(local){if(current)return;transition_in(if_block0);transition_in(main_slot_or_fallback,local);transition_in(if_block1);transition_in(if_block2);current=true;},o(local){transition_out(if_block0);transition_out(main_slot_or_fallback,local);transition_out(if_block1);transition_out(if_block2);current=false;},d(detaching){if(if_block0)if_block0.d(detaching);if(detaching)detach(t0);if(detaching)detach(div);if(main_slot_or_fallback)main_slot_or_fallback.d(detaching);/*div_binding*/ctx[6](null);if(detaching)detach(t1);if(if_block1)if_block1.d(detaching);if(detaching)detach(t2);if(detaching)detach(if_block2_anchor);}};}function instance$l($$self,$$props,$$invalidate){let{$$slots:slots={},$$scope}=$$props;let{hasHeader=!!$$props.$$slots.header}=$$props;let{hasFooter=!!$$props.$$slots.footer}=$$props;let{root=undefined}=$$props;function measure_handler(event){bubble($$self,event);}function div_binding($$value){binding_callbacks[$$value?\"unshift\":\"push\"](()=>{root=$$value;$$invalidate(0,root);});}$$self.$$set=$$new_props=>{$$invalidate(7,$$props=assign(assign({},$$props),exclude_internal_props($$new_props)));if(\"hasHeader\"in $$new_props)$$invalidate(1,hasHeader=$$new_props.hasHeader);if(\"hasFooter\"in $$new_props)$$invalidate(2,hasFooter=$$new_props.hasFooter);if(\"root\"in $$new_props)$$invalidate(0,root=$$new_props.root);if(\"$$scope\"in $$new_props)$$invalidate(3,$$scope=$$new_props.$$scope);};$$props=exclude_internal_props($$props);return[root,hasHeader,hasFooter,$$scope,slots,measure_handler,div_binding];}class Util extends SvelteComponent{constructor(options){super();init(this,options,instance$l,create_fragment$l,safe_not_equal,{hasHeader:1,hasFooter:2,root:0});}}var toFraction=(value,min,max)=>(value-min)/(max-min);/* src/core/ui/components/RangeInput.svelte generated by Svelte v3.29.4 */function create_if_block$5(ctx){let div;let div_style_value;return{c(){div=element(\"div\");attr(div,\"class\",\"DokaRangeInputMeter\");attr(div,\"style\",div_style_value=`transform: translateX(${/*$position*/ctx[9].x-/*svgPadding*/ctx[10].x}px) translateY(${/*$position*/ctx[9].y-/*svgPadding*/ctx[10].y}px)`);},m(target,anchor){insert(target,div,anchor);div.innerHTML=/*svg*/ctx[6];},p(ctx,dirty){if(dirty[0]&/*svg*/64)div.innerHTML=/*svg*/ctx[6];if(dirty[0]&/*$position*/512&&div_style_value!==(div_style_value=`transform: translateX(${/*$position*/ctx[9].x-/*svgPadding*/ctx[10].x}px) translateY(${/*$position*/ctx[9].y-/*svgPadding*/ctx[10].y}px)`)){attr(div,\"style\",div_style_value);}},d(detaching){if(detaching)detach(div);}};}function create_fragment$m(ctx){let div1;let span;let t0;let t1;let button;let t2;let button_disabled_value;let t3;let div0;let interactable_action;let measurable_action;let nudgeable_action;let mounted;let dispose;let if_block=/*$position*/ctx[9]&&create_if_block$5(ctx);return{c(){div1=element(\"div\");span=element(\"span\");t0=text(/*valueLabel*/ctx[4]);t1=space();button=element(\"button\");t2=text(/*labelReset*/ctx[1]);t3=space();div0=element(\"div\");if(if_block)if_block.c();attr(span,\"class\",\"DokaRangeInputValue\");attr(button,\"class\",\"DokaRangeInputReset\");attr(button,\"type\",\"button\");button.disabled=button_disabled_value=/*value*/ctx[0]===/*base*/ctx[3];attr(div0,\"class\",\"DokaRangeInputInner\");attr(div0,\"style\",/*rangeMask*/ctx[8]);attr(div0,\"data-value-limited\",/*isLimited*/ctx[7]);attr(div1,\"class\",\"DokaRangeInput\");attr(div1,\"tabindex\",\"0\");},m(target,anchor){insert(target,div1,anchor);append(div1,span);append(span,t0);append(div1,t1);append(div1,button);append(button,t2);append(div1,t3);append(div1,div0);if(if_block)if_block.m(div0,null);if(!mounted){dispose=[listen(button,\"click\",/*handleReset*/ctx[15]),listen(div0,\"interactionstart\",/*handleDragStart*/ctx[11]),listen(div0,\"interactionupdate\",/*handleDragMove*/ctx[13]),listen(div0,\"interactionend\",/*handleDragEnd*/ctx[14]),listen(div0,\"interactionrelease\",/*handleDragRelease*/ctx[12]),action_destroyer(interactable_action=interactable.call(null,div0,{inertia:true})),listen(div0,\"measure\",/*measure_handler*/ctx[27]),action_destroyer(measurable_action=measurable.call(null,div0)),listen(div1,\"wheel\",/*handleWheel*/ctx[17]),listen(div1,\"nudge\",/*handleNudge*/ctx[18]),action_destroyer(nudgeable_action=nudgeable.call(null,div1,/*direction*/ctx[2]=\"horizontal\"))];mounted=true;}},p(ctx,dirty){if(dirty[0]&/*valueLabel*/16)set_data(t0,/*valueLabel*/ctx[4]);if(dirty[0]&/*labelReset*/2)set_data(t2,/*labelReset*/ctx[1]);if(dirty[0]&/*value, base*/9&&button_disabled_value!==(button_disabled_value=/*value*/ctx[0]===/*base*/ctx[3])){button.disabled=button_disabled_value;}if(/*$position*/ctx[9]){if(if_block){if_block.p(ctx,dirty);}else{if_block=create_if_block$5(ctx);if_block.c();if_block.m(div0,null);}}else if(if_block){if_block.d(1);if_block=null;}if(dirty[0]&/*rangeMask*/256){attr(div0,\"style\",/*rangeMask*/ctx[8]);}if(dirty[0]&/*isLimited*/128){attr(div0,\"data-value-limited\",/*isLimited*/ctx[7]);}if(nudgeable_action&&is_function(nudgeable_action.update)&&dirty[0]&/*direction*/4)nudgeable_action.update.call(null,/*direction*/ctx[2]=\"horizontal\");},i:noop$1,o:noop$1,d(detaching){if(detaching)detach(div1);if(if_block)if_block.d();mounted=false;run_all(dispose);}};}const radiusBig=2;const radiusSmall=0.75;const indicatorSpacing=10;const indicatorInterval=5;const indicatorCount=40;// must be even\nfunction instance$m($$self,$$props,$$invalidate){let $position;let{labelReset=\"Reset\"}=$$props;let{direction=\"x\"}=$$props;let{min=0}=$$props;let{max=1}=$$props;let{base=min}=$$props;let{value=0}=$$props;let{valueLabel=0}=$$props;let{valueMin=undefined}=$$props;let{valueMax=undefined}=$$props;let{oninputstart=noop}=$$props;let{oninputmove=noop}=$$props;let{oninputend=noop}=$$props;let{elasticity=0}=$$props;const round=(number,increment,offset)=>Math.ceil((number-offset)/increment)*increment+offset;let size;let svg;let svgSize;const svgPadding={x:2,y:0};function getMask(limitedMin,limitedMax){const step=1/indicatorCount;const from=toFraction(limitedMin,min,max);const to=toFraction(limitedMax,min,max);const fromSnapped=fixPrecision(round(from,step,0)-step*0.5);const toSnapped=fixPrecision(round(to,step,0)-step*0.5);return`--range-mask-from:${fromSnapped*100}%;--range-mask-to:${toSnapped*100}%`;}//\n// Dragging related\n//\nlet interactionOrigin=undefined;let interactionReleased=false;let interactionRange;let interactionOptions={snap:false,elastic:false};const handleDragStart=()=>{interactionReleased=false;interactionOrigin=get_store_value(position);interactionRange=[valueToPosition(valueMin!=null?valueMin:min,direction),valueToPosition(valueMax!=null?valueMax:max,direction)];oninputstart();};const handleDragRelease=()=>{interactionReleased=true;};const handleDragMove=({detail})=>{interactionOptions.snap=!interactionReleased;interactionOptions.elastic=!interactionReleased;translatePosition(interactionOrigin,detail.translation,interactionOptions);};const handleDragEnd=({detail})=>{interactionOptions.snap=false;interactionOptions.elastic=false;const valueAtPosition=translatePosition(interactionOrigin,detail.translation,interactionOptions);interactionOrigin=undefined;interactionRange=undefined;// if is near base position, set to base\nif(Math.abs(valueAtPosition-base)<0.01)return oninputend(base);oninputend(valueAtPosition);};const translatePosition=(origin,translation,options)=>{const target=origin[direction]+translation[direction];const targetLimited=clamp(target,interactionRange[1][direction],interactionRange[0][direction]);const targetElastic=elasticity?targetLimited+elastify(target-targetLimited,elasticity):targetLimited;const targetVisual=options.elastic?targetElastic:targetLimited;// set position\nconst targetValid=vectorCreate(0,0);targetValid[direction]=targetVisual;position.set(targetValid,{hard:options.snap});return clamp(positionToValue(targetValid,direction),min,max);};const handleReset=()=>{$$invalidate(0,value=clamp(base,valueMinLimited,valueMaxLimited));oninputstart();oninputend(value);};//\n// Meter position and value updates\n//\nconst position=spring();component_subscribe($$self,position,value=>$$invalidate(9,$position=value));const valueToPosition=(value,axis)=>{const offset=(size[axis]-barSize[axis])*0.5;const fraction=toFraction(value,min,max);const v=fraction*barSize[axis]-barSize[axis]*0.5;const pos=offset-v;return{x:axis===\"x\"?pos:0,y:axis===\"y\"?pos:0};};const positionToValue=(position,axis)=>{const dist=position[axis]-size[axis]*0.5;const fraction=-(dist/barSize[axis]);return min+fraction*range;};position.subscribe(currentPosition=>{// if not positioned yet or is not interacting we're not interested in this event\nif(!currentPosition||!interactionOrigin)return;oninputmove(clamp(positionToValue(currentPosition,direction),min,max));});const updatePosition=value=>{const interactionRange=[valueToPosition(valueMin!=null?valueMin:min,direction),valueToPosition(valueMax!=null?valueMax:max,direction)];const target={x:direction===\"x\"?$position.x+value:0,y:direction===\"y\"?$position.y+value:0};const targetLimited=clamp(target[direction],interactionRange[1][direction],interactionRange[0][direction]);const positionTarget=_objectSpread(_objectSpread({},$position),{},{[direction]:targetLimited});set_store_value(position,$position=positionTarget,$position);const result=clamp(positionToValue(positionTarget,direction),min,max);oninputstart();oninputmove(result);oninputend(result);};const handleWheel=e=>{// don't run default actions, prevent other actions from running\ne.preventDefault();e.stopPropagation();// apply wheel delta to offset\nconst step=8;const delta=getWheelDelta(e)*step;updatePosition(delta);};const handleNudge=({detail})=>{updatePosition(detail[direction]*8);};const measure_handler=e=>$$invalidate(5,size=vectorCreateFromSize(e.detail));$$self.$$set=$$props=>{if(\"labelReset\"in $$props)$$invalidate(1,labelReset=$$props.labelReset);if(\"direction\"in $$props)$$invalidate(2,direction=$$props.direction);if(\"min\"in $$props)$$invalidate(19,min=$$props.min);if(\"max\"in $$props)$$invalidate(20,max=$$props.max);if(\"base\"in $$props)$$invalidate(3,base=$$props.base);if(\"value\"in $$props)$$invalidate(0,value=$$props.value);if(\"valueLabel\"in $$props)$$invalidate(4,valueLabel=$$props.valueLabel);if(\"valueMin\"in $$props)$$invalidate(21,valueMin=$$props.valueMin);if(\"valueMax\"in $$props)$$invalidate(22,valueMax=$$props.valueMax);if(\"oninputstart\"in $$props)$$invalidate(23,oninputstart=$$props.oninputstart);if(\"oninputmove\"in $$props)$$invalidate(24,oninputmove=$$props.oninputmove);if(\"oninputend\"in $$props)$$invalidate(25,oninputend=$$props.oninputend);if(\"elasticity\"in $$props)$$invalidate(26,elasticity=$$props.elasticity);};let range;let valueMinLimited;let valueMaxLimited;let barSize;let baseFraction;let isLimited;let rangeMask;$$self.$$.update=()=>{if($$self.$$.dirty[0]&/*max, min*/1572864){//\n// derived\n//\n$$invalidate(33,range=max-min);}if($$self.$$.dirty[0]&/*valueMin, min*/2621440){$$invalidate(34,valueMinLimited=valueMin!=null?Math.max(valueMin,min):min);}if($$self.$$.dirty[0]&/*valueMax, max*/5242880){$$invalidate(35,valueMaxLimited=valueMax!=null?Math.min(valueMax,max):max);}if($$self.$$.dirty[0]&/*base, min, max*/1572872){$$invalidate(37,baseFraction=toFraction(base,min,max));}if($$self.$$.dirty[0]&/*size*/32|$$self.$$.dirty[1]&/*baseFraction*/64){if(size){const centerY=size.y*0.5;let indicatorCenter=indicatorCount*baseFraction;let indicators=\"\";let svgWidth;let svgHeight=size.y;for(let i=0;i<=indicatorCount;i++){const x=svgPadding.x+i*indicatorSpacing;const y=centerY;const r=i%indicatorInterval===0?radiusBig:radiusSmall;indicators+=`<circle cx=\"${x}\" cy=\"${y}\" r=\"${r}\"/>`;svgWidth=x+svgPadding.x;if(i===indicatorCenter){indicators+=`<path stroke=\"none\" fill=\"currentColor\" d=\"M${x} ${y-4} l2 3 l-2 -1 l-2 1 z\"/>`;}}$$invalidate(6,svg=`<svg width=\"${svgWidth}\" height=\"${svgHeight}\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 ${svgWidth} ${svgHeight}\" aria-hidden=\"true\" focusable=\"false\">${indicators}<rect rx=\"4\" ry=\"4\" y=\"${centerY-4}\"\" height=\"8\"></rect></svg>`);$$invalidate(28,svgSize={x:svgWidth-svgPadding.x*2,y:svgHeight});}}if($$self.$$.dirty[0]&/*size, svgSize*/268435488){barSize=size&&svgSize;}if($$self.$$.dirty[0]&/*min, max*/1572864|$$self.$$.dirty[1]&/*valueMinLimited, valueMaxLimited*/24){$$invalidate(7,isLimited=valueMinLimited!==min||valueMaxLimited!==max);}if($$self.$$.dirty[0]&/*isLimited*/128|$$self.$$.dirty[1]&/*valueMinLimited, valueMaxLimited*/24){$$invalidate(8,rangeMask=isLimited?getMask(valueMinLimited,valueMaxLimited):\"\");}if($$self.$$.dirty[0]&/*size, value, direction*/37|$$self.$$.dirty[1]&/*range*/4){// if has size (range is in here so the position is updated if the range is changed)\nif(range&&size&&size.x&&size.y){position.set(valueToPosition(value,direction));}}};return[value,labelReset,direction,base,valueLabel,size,svg,isLimited,rangeMask,$position,svgPadding,handleDragStart,handleDragRelease,handleDragMove,handleDragEnd,handleReset,position,handleWheel,handleNudge,min,max,valueMin,valueMax,oninputstart,oninputmove,oninputend,elasticity,measure_handler];}class RangeInput extends SvelteComponent{constructor(options){super();init(this,options,instance$m,create_fragment$m,safe_not_equal,{labelReset:1,direction:2,min:19,max:20,base:3,value:0,valueLabel:4,valueMin:21,valueMax:22,oninputstart:23,oninputmove:24,oninputend:25,elasticity:26},[-1,-1]);}}/* src/core/ui/components/Toolbar.svelte generated by Svelte v3.29.4 */function create_fragment$n(ctx){let div1;let div0;let measurable_action;let measurable_action_1;let current;let mounted;let dispose;const default_slot_template=/*#slots*/ctx[5].default;const default_slot=create_slot(default_slot_template,ctx,/*$$scope*/ctx[4],null);return{c(){div1=element(\"div\");div0=element(\"div\");if(default_slot)default_slot.c();attr(div0,\"class\",\"DokaToolbarInner\");attr(div1,\"class\",\"DokaToolbar\");attr(div1,\"data-layout\",/*layout*/ctx[1]);attr(div1,\"data-overflow\",/*overflow*/ctx[0]);},m(target,anchor){insert(target,div1,anchor);append(div1,div0);if(default_slot){default_slot.m(div0,null);}current=true;if(!mounted){dispose=[listen(div0,\"measure\",/*handleChildResizeEvent*/ctx[3]),action_destroyer(measurable_action=measurable.call(null,div0)),listen(div1,\"measure\",/*handleParentResizeEvent*/ctx[2]),action_destroyer(measurable_action_1=measurable.call(null,div1))];mounted=true;}},p(ctx,[dirty]){if(default_slot){if(default_slot.p&&dirty&/*$$scope*/16){update_slot(default_slot,default_slot_template,ctx,/*$$scope*/ctx[4],dirty,null,null);}}if(!current||dirty&/*layout*/2){attr(div1,\"data-layout\",/*layout*/ctx[1]);}if(!current||dirty&/*overflow*/1){attr(div1,\"data-overflow\",/*overflow*/ctx[0]);}},i(local){if(current)return;transition_in(default_slot,local);current=true;},o(local){transition_out(default_slot,local);current=false;},d(detaching){if(detaching)detach(div1);if(default_slot)default_slot.d(detaching);mounted=false;run_all(dispose);}};}function instance$n($$self,$$props,$$invalidate){let{$$slots:slots={},$$scope}=$$props;let childWidth=0;let childMaxWidth=0;let parentWidth=0;let overflow;const testOverflow=()=>{$$invalidate(0,overflow=layout===\"compact\"&&childWidth>parentWidth?\"overflow\":undefined);};const handleParentResizeEvent=({detail})=>{const{width,height}=detail;$$invalidate(8,parentWidth=width);testOverflow();};const handleChildResizeEvent=({detail})=>{const{width,height}=detail;if(width>childMaxWidth){$$invalidate(7,childMaxWidth=width);}childWidth=width;if(!overflow)testOverflow();};$$self.$$set=$$props=>{if(\"$$scope\"in $$props)$$invalidate(4,$$scope=$$props.$$scope);};let layout;$$self.$$.update=()=>{if($$self.$$.dirty&/*childMaxWidth, parentWidth*/384){$$invalidate(1,layout=childMaxWidth>parentWidth?\"compact\":\"default\");}};return[overflow,layout,handleParentResizeEvent,handleChildResizeEvent,$$scope,slots];}class Toolbar extends SvelteComponent{constructor(options){super();init(this,options,instance$n,create_fragment$n,safe_not_equal,{});}}// enum Direction {\n//     Top = 't',\n//     Right = 'r',\n//     Bottom = 'b',\n//     Left = 'l',\n//     TopLeft = 'tl',\n//     TopRight = 'tr',\n//     BottomRight = 'br',\n//     BottomLeft = 'bl',\n// }\n// export const { Top, Right, Bottom, Left, TopLeft, TopRight, BottomRight, BottomLeft } = Direction;\n// export default Direction;\nconst Direction={Top:'t',Right:'r',Bottom:'b',Left:'l',TopLeft:'tl',TopRight:'tr',BottomRight:'br',BottomLeft:'bl'};const{Top,Right,Bottom,Left,TopLeft,TopRight,BottomRight,BottomLeft}=Direction;var DirectionRectMap={[Top]:rect=>({x:rect.x,y:rect.y}),[TopRight]:rect=>({x:rect.x+rect.width,y:rect.y}),[Right]:rect=>({x:rect.x+rect.width,y:rect.y}),[BottomRight]:rect=>({x:rect.x+rect.width,y:rect.y+rect.height}),[Bottom]:rect=>({x:rect.x,y:rect.y+rect.height}),[BottomLeft]:rect=>({x:rect.x,y:rect.y+rect.height}),[Left]:rect=>({x:rect.x,y:rect.y}),[TopLeft]:rect=>({x:rect.x,y:rect.y})};/* src/core/ui/components/RectManipulator.svelte generated by Svelte v3.29.4 */function get_each_context$4(ctx,list,i){const child_ctx=ctx.slice();child_ctx[11]=list[i].key;child_ctx[12]=list[i].translate;child_ctx[13]=list[i].scale;child_ctx[14]=list[i].type;child_ctx[15]=list[i].opacity;return child_ctx;}// (210:0) {#each mappedDirections as { key, translate, scale, type, opacity }\nfunction create_each_block$4(key_1,ctx){let div;let div_tabindex_value;let div_data_direction_value;let div_data_shape_value;let div_style_value;let nudgeable_action;let interactable_action;let mounted;let dispose;return{key:key_1,first:null,c(){div=element(\"div\");attr(div,\"role\",\"button\");attr(div,\"tabindex\",div_tabindex_value=/*type*/ctx[14]===\"edge\"?-1:0);attr(div,\"class\",\"DokaRectManipulator\");attr(div,\"data-direction\",div_data_direction_value=/*key*/ctx[11]);attr(div,\"data-shape\",div_data_shape_value=`${/*type*/ctx[14]===\"edge\"?\"edge\":`${/*style*/ctx[0]}`}`);attr(div,\"style\",div_style_value=`transform: translate3d(${/*translate*/ctx[12].x}px, ${/*translate*/ctx[12].y}px, 0) scale(${/*scale*/ctx[13].x}, ${/*scale*/ctx[13].y}); opacity: ${/*opacity*/ctx[15]}`);this.first=div;},m(target,anchor){insert(target,div,anchor);if(!mounted){dispose=[listen(div,\"nudge\",function(){if(is_function(/*nudge*/ctx[5](/*key*/ctx[11])))/*nudge*/ctx[5](/*key*/ctx[11]).apply(this,arguments);}),action_destroyer(nudgeable_action=nudgeable.call(null,div)),listen(div,\"interactionstart\",function(){if(is_function(/*route*/ctx[4](\"resizestart\",/*key*/ctx[11])))/*route*/ctx[4](\"resizestart\",/*key*/ctx[11]).apply(this,arguments);}),listen(div,\"interactionupdate\",function(){if(is_function(/*route*/ctx[4](\"resizemove\",/*key*/ctx[11])))/*route*/ctx[4](\"resizemove\",/*key*/ctx[11]).apply(this,arguments);}),listen(div,\"interactionend\",function(){if(is_function(/*route*/ctx[4](\"resizeend\",/*key*/ctx[11])))/*route*/ctx[4](\"resizeend\",/*key*/ctx[11]).apply(this,arguments);}),action_destroyer(interactable_action=interactable.call(null,div))];mounted=true;}},p(new_ctx,dirty){ctx=new_ctx;if(dirty&/*mappedDirections*/2&&div_tabindex_value!==(div_tabindex_value=/*type*/ctx[14]===\"edge\"?-1:0)){attr(div,\"tabindex\",div_tabindex_value);}if(dirty&/*mappedDirections*/2&&div_data_direction_value!==(div_data_direction_value=/*key*/ctx[11])){attr(div,\"data-direction\",div_data_direction_value);}if(dirty&/*mappedDirections, style*/3&&div_data_shape_value!==(div_data_shape_value=`${/*type*/ctx[14]===\"edge\"?\"edge\":`${/*style*/ctx[0]}`}`)){attr(div,\"data-shape\",div_data_shape_value);}if(dirty&/*mappedDirections*/2&&div_style_value!==(div_style_value=`transform: translate3d(${/*translate*/ctx[12].x}px, ${/*translate*/ctx[12].y}px, 0) scale(${/*scale*/ctx[13].x}, ${/*scale*/ctx[13].y}); opacity: ${/*opacity*/ctx[15]}`)){attr(div,\"style\",div_style_value);}},d(detaching){if(detaching)detach(div);mounted=false;run_all(dispose);}};}function create_fragment$o(ctx){let each_blocks=[];let each_1_lookup=new Map();let each_1_anchor;let each_value=/*mappedDirections*/ctx[1];const get_key=ctx=>/*key*/ctx[11];for(let i=0;i<each_value.length;i+=1){let child_ctx=get_each_context$4(ctx,each_value,i);let key=get_key(child_ctx);each_1_lookup.set(key,each_blocks[i]=create_each_block$4(key,child_ctx));}return{c(){for(let i=0;i<each_blocks.length;i+=1){each_blocks[i].c();}each_1_anchor=empty();},m(target,anchor){for(let i=0;i<each_blocks.length;i+=1){each_blocks[i].m(target,anchor);}insert(target,each_1_anchor,anchor);},p(ctx,[dirty]){if(dirty&/*mappedDirections, style, nudge, route*/51){const each_value=/*mappedDirections*/ctx[1];each_blocks=update_keyed_each(each_blocks,dirty,get_key,1,ctx,each_value,each_1_lookup,each_1_anchor.parentNode,destroy_block,create_each_block$4,each_1_anchor,get_each_context$4);}},i:noop$1,o:noop$1,d(detaching){for(let i=0;i<each_blocks.length;i+=1){each_blocks[i].d(detaching);}if(detaching)detach(each_1_anchor);}};}function instance$o($$self,$$props,$$invalidate){let $selectionScale;let $selectionOpacity;let{rect=null}=$$props;let{visible=false}=$$props;let{style=undefined}=$$props;// is `undefined` to prevent bounce when first rendering view\nconst selectionScale=spring(undefined,{precision:0.0001,stiffness:0.2,damping:0.4});component_subscribe($$self,selectionScale,value=>$$invalidate(8,$selectionScale=value));const selectionOpacity=spring(0,{precision:0.001});component_subscribe($$self,selectionOpacity,value=>$$invalidate(9,$selectionOpacity=value));//\n// dragging\n//\nconst dispatch=createEventDispatcher();const route=(type,direction)=>({detail})=>dispatch(type,{direction,translation:detail&&detail.translation});const nudge=direction=>({detail})=>{dispatch(`resizestart`,{direction,translation:{x:0,y:0}});dispatch(`resizemove`,{direction,translation:detail});dispatch(`resizeend`,{direction,translation:{x:0,y:0}});};$$self.$$set=$$props=>{if(\"rect\"in $$props)$$invalidate(6,rect=$$props.rect);if(\"visible\"in $$props)$$invalidate(7,visible=$$props.visible);if(\"style\"in $$props)$$invalidate(0,style=$$props.style);};let mappedDirections;$$self.$$.update=()=>{if($$self.$$.dirty&/*visible*/128){selectionScale.set(visible?1:0.5);}if($$self.$$.dirty&/*visible*/128){selectionOpacity.set(visible?1:0);}if($$self.$$.dirty&/*rect, $selectionScale, $selectionOpacity*/832){//\n// rendering\n//\n$$invalidate(1,mappedDirections=Object.keys(Direction).map((key,i)=>{// get direction enum\nconst direction=Direction[key];// get position from direction\nconst position=DirectionRectMap[direction](rect);// corner or edge\nconst type=direction.length===1?\"edge\":\"corner\";const isCorner=type===\"corner\";return{key:direction,type,scale:{x:/^(t|b)$/.test(direction)?rect.width:isCorner?clamp($selectionScale,0.5,1.25):1,y:/^(r|l)$/.test(direction)?rect.height:isCorner?clamp($selectionScale,0.5,1.25):1},translate:{x:position.x,y:position.y},opacity:$selectionOpacity};}));}};return[style,mappedDirections,selectionScale,selectionOpacity,route,nudge,rect,visible];}class RectManipulator extends SvelteComponent{constructor(options){super();init(this,options,instance$o,create_fragment$o,safe_not_equal,{rect:6,visible:7,style:0});}}var getEventPositionInViewport=e=>vectorCreate(e.clientX,e.clientY);var getEventPositionInStage=(e,viewOffset,stageOffset)=>{const positionInViewport=getEventPositionInViewport(e);return vectorSubtract(vectorSubtract(positionInViewport,viewOffset),stageOffset);};var DirectionInversionTable={[Top]:Bottom,[Right]:Left,[Bottom]:Top,[Left]:Right,[TopLeft]:BottomRight,[TopRight]:BottomLeft,[BottomRight]:TopLeft,[BottomLeft]:TopRight};var DirectionCoordinateTable={[Top]:[0.5,0],[Right]:[1,0.5],[Bottom]:[0.5,1],[Left]:[0,0.5],[TopLeft]:[0,0],[TopRight]:[1,0],[BottomRight]:[1,1],[BottomLeft]:[0,1]};var getTranslationInfo=target=>{const translateToRight=target===Right||target===TopRight||target===BottomRight;const translateToLeft=target===Left||target===BottomLeft||target===TopLeft;const translateToTop=target===Top||target===TopRight||target===TopLeft;const translateToBottom=target===Bottom||target===BottomRight||target===BottomLeft;const translateHorizontally=target===Left||target===Right;const translateVertically=target===Top||target===Bottom;const translateAxis=translateHorizontally||translateVertically;return[translateToRight,translateToLeft,translateToTop,translateToBottom,translateHorizontally,translateVertically,translateAxis];};var limitRectDirectionTranslation=(rect,transform,bounds,options={})=>{// the transforms to apply\nconst{target,translate}=transform;// the transform requirements\nconst{aspectRatio,minSize,maxSize}=options;// get anchor coordinates and x,y position we need this for relative scaling of the view rectangle\nconst anchor=DirectionInversionTable[target];const anchorDirectionCoordinates=DirectionCoordinateTable[anchor];const anchorPosition=vectorAdd(vectorCreate(rect.x,rect.y),vectorCreate(anchorDirectionCoordinates[0]*rect.width,anchorDirectionCoordinates[1]*rect.height));// get coordinate of direction\nconst targetDirectionCoordinates=DirectionCoordinateTable[target];const targetPosition=vectorAdd(rectClone(rect),vectorCreate(targetDirectionCoordinates[0]*rect.width,targetDirectionCoordinates[1]*rect.height));// bools to determine which direction the interaction is moving in\nconst[translateToRight,translateToLeft,translateToTop,translateToBottom,translateHorizontally,translateVertically,translateAxis]=getTranslationInfo(target);let tx=translate.x;let ty=translate.y;if(translateHorizontally)ty=0;else if(translateVertically)tx=0;const interactionBounds=getInteractionBounds(anchorPosition,target,bounds,{aspectRatio,minSize,maxSize});// current bounds\nlet[t,r,b,l]=rectToBounds(rect);// update view bounds with anchor based on translation direction (one side is always locked)\nif(translateToRight)l=anchorPosition.x;else if(translateToLeft)r=anchorPosition.x;if(translateToBottom)t=anchorPosition.y;else if(translateToTop)b=anchorPosition.y;// update view bounds with interaction limits\nif(translateToRight){const innerR=interactionBounds.inner.x+interactionBounds.inner.width;const outerR=interactionBounds.outer.x+interactionBounds.outer.width;r=clamp(targetPosition.x+tx,innerR,outerR);}else if(translateToLeft){const innerL=interactionBounds.outer.x;const outerL=interactionBounds.inner.x;l=clamp(targetPosition.x+tx,innerL,outerL);}if(translateToBottom){const innerB=interactionBounds.inner.y+interactionBounds.inner.height;const outerB=interactionBounds.outer.y+interactionBounds.outer.height;b=clamp(targetPosition.y+ty,innerB,outerB);}else if(translateToTop){const innerT=interactionBounds.outer.y;const outerT=interactionBounds.inner.y;t=clamp(targetPosition.y+ty,innerT,outerT);}// if aspect ratio is set we need to scale both axis\nif(aspectRatio){// if translating over horizontal or vertical axis we need to update the other axis based on the aspect ratio as well\nif(translateAxis){let dx=r-l;let dy=b-t;if(translateHorizontally){dy=dx/aspectRatio;t=anchorPosition.y-dy*0.5;b=anchorPosition.y+dy*0.5;}else if(translateVertically){dx=dy*aspectRatio;l=anchorPosition.x-dx*0.5;r=anchorPosition.x+dx*0.5;}}// we're translating one of the corners in both the x and y direction, need to make sure it conforms to aspect ratio\nelse{const pointer=vectorCreate(targetPosition.x+tx-anchorPosition.x,targetPosition.y+ty-anchorPosition.y);// translations cannot be inverted, limited by anchor position\nif(target===TopRight){pointer.x=Math.max(0,pointer.x);pointer.y=Math.min(0,pointer.y);}else if(target===BottomRight){pointer.x=Math.max(0,pointer.x);pointer.y=Math.max(0,pointer.y);}else if(target===BottomLeft){pointer.x=Math.min(0,pointer.x);pointer.y=Math.max(0,pointer.y);}else if(target===TopLeft){pointer.x=Math.min(0,pointer.x);pointer.y=Math.min(0,pointer.y);}// calculate the translation pointer, then get its length, now create a new pointer based on the aspect ratio, and scale it based on the original (limited) length\nconst pointerLength=vectorLength(pointer);const pointerLengthMin=vectorLength(vectorCreate(interactionBounds.inner.width,interactionBounds.inner.height));const pointerLengthMax=vectorLength(vectorCreate(interactionBounds.outer.width,interactionBounds.outer.height));const pointerLengthLimited=clamp(pointerLength,pointerLengthMin,pointerLengthMax);const pointerAspectRatio=vectorCreate(aspectRatio,1);const pointerScaled=vectorMultiply(vectorNormalize(pointerAspectRatio),pointerLengthLimited);if(target===TopRight){r=anchorPosition.x+pointerScaled.x;t=anchorPosition.y-pointerScaled.y;}else if(target===BottomRight){r=anchorPosition.x+pointerScaled.x;b=anchorPosition.y+pointerScaled.y;}else if(target===BottomLeft){l=anchorPosition.x-pointerScaled.x;b=anchorPosition.y+pointerScaled.y;}else if(target===TopLeft){l=anchorPosition.x-pointerScaled.x;t=anchorPosition.y-pointerScaled.y;}}}return rectCreate(l,t,r-l,b-t);};const getInteractionBounds=(anchor,dir,bounds,options)=>{const{aspectRatio,minSize,maxSize}=options;const translateToRight=dir===Right||dir===TopRight||dir===BottomRight;const translateToLeft=dir===Left||dir===BottomLeft||dir===TopLeft;const translateToTop=dir===Top||dir===TopRight||dir===TopLeft;const translateToBottom=dir===Bottom||dir===BottomRight||dir===BottomLeft;const translateHorizontally=dir===Left||dir===Right;const translateVertically=dir===Top||dir===Bottom;// limit bounds based on anchor and direction\nconst limitedBounds=rectClone(bounds);if(translateToRight){limitedBounds.x=anchor.x;limitedBounds.width-=anchor.x;}else if(translateToLeft){limitedBounds.width=anchor.x;}if(translateToBottom){limitedBounds.y=anchor.y;limitedBounds.height-=anchor.y;}else if(translateToTop){limitedBounds.height=anchor.y;}// limit max size based on bounds\nconst maxSizeLimitedToBounds=rectCreateFromDimensions(Math.min(limitedBounds.width,maxSize.width),Math.min(limitedBounds.height,maxSize.height));if(aspectRatio){// limit height\nif(translateHorizontally){const verticalSpace=Math.min(anchor.y,bounds.height-anchor.y);maxSizeLimitedToBounds.height=Math.min(verticalSpace*2,maxSizeLimitedToBounds.height);}// limit width\nelse if(translateVertically){const horizontalSpace=Math.min(anchor.x,bounds.width-anchor.x);maxSizeLimitedToBounds.width=Math.min(horizontalSpace*2,maxSizeLimitedToBounds.width);}}const maxSizeLimited=aspectRatio?sizeCreateFromRect(rectContainRect(maxSizeLimitedToBounds,aspectRatio)):maxSizeLimitedToBounds;// limit min size\nconst minSizeLimited=aspectRatio?sizeCreateFromRect(rectCoverRect(rectCreateFromSize(minSize),aspectRatio)):minSize;let l,r,t,b;// set bounds\nif(translateToRight)l=anchor.x;else if(translateToLeft)r=anchor.x;if(translateToBottom)t=anchor.y;else if(translateToTop)b=anchor.y;// inner\nif(translateToRight){r=l+minSizeLimited.width;}else if(translateToLeft){l=r-minSizeLimited.width;}if(translateToBottom){b=t+minSizeLimited.height;}else if(translateToTop){t=b-minSizeLimited.height;}if(translateHorizontally){t=anchor.y-minSizeLimited.height*0.5;b=anchor.y+minSizeLimited.height*0.5;}else if(translateVertically){l=anchor.x-minSizeLimited.width*0.5;r=anchor.x+minSizeLimited.width*0.5;}const inner=rectCreateFromPoints(vectorCreate(l,t),vectorCreate(r,b));// outer\nif(translateToRight){r=l+maxSizeLimited.width;}else if(translateToLeft){l=r-maxSizeLimited.width;}if(translateToBottom){b=t+maxSizeLimited.height;}else if(translateToTop){t=b-maxSizeLimited.height;}if(translateHorizontally){t=anchor.y-maxSizeLimited.height*0.5;b=anchor.y+maxSizeLimited.height*0.5;}else if(translateVertically){l=anchor.x-maxSizeLimited.width*0.5;r=anchor.x+maxSizeLimited.width*0.5;}const outer=rectCreateFromPoints(vectorCreate(l,t),vectorCreate(r,b));return{inner,outer};};var applyRectDirectionTranslation=(rect,transform,options={})=>{// the transforms to apply\nconst{target,translate}=transform;// the transform requirements\nconst{aspectRatio}=options;// get anchor coordinates and x,y position we need this for relative scaling of the view rectangle\nconst anchor=DirectionInversionTable[target];const anchorDirectionCoordinates=DirectionCoordinateTable[anchor];const anchorPosition=vectorAdd(rectClone(rect),vectorCreate(anchorDirectionCoordinates[0]*rect.width,anchorDirectionCoordinates[1]*rect.height));// get coordinate of direction\nconst targetDirectionCoordinates=DirectionCoordinateTable[target];const targetPosition=vectorAdd(rectClone(rect),vectorCreate(targetDirectionCoordinates[0]*rect.width,targetDirectionCoordinates[1]*rect.height));// bools to determine which direction the interaction is moving in\nconst[translateToRight,translateToLeft,translateToTop,translateToBottom,translateHorizontally,translateVertically,translateAxis]=getTranslationInfo(target);let tx=translate.x;let ty=translate.y;if(translateHorizontally)ty=0;else if(translateVertically)tx=0;// current bounds\nlet[t,r,b,l]=rectToBounds(rect);// update view bounds with anchor based on translation direction (one side is always locked)\nif(translateToRight)l=anchorPosition.x;else if(translateToLeft)r=anchorPosition.x;if(translateToBottom)t=anchorPosition.y;else if(translateToTop)b=anchorPosition.y;// update view bounds with interaction limits\nif(translateToRight){r=targetPosition.x+tx;}else if(translateToLeft){l=targetPosition.x+tx;}if(translateToBottom){b=targetPosition.y+ty;}else if(translateToTop){t=targetPosition.y+ty;}// if aspect ratio is set we need to scale both axis\nif(aspectRatio){// if translating over horizontal or vertical axis we need to update the other axis based on the aspect ratio as well\nif(translateAxis){let dx=r-l;let dy=b-t;if(translateHorizontally){dy=dx/aspectRatio;t=anchorPosition.y-dy*0.5;b=anchorPosition.y+dy*0.5;}else if(translateVertically){dx=dy*aspectRatio;l=anchorPosition.x-dx*0.5;r=anchorPosition.x+dx*0.5;}}// we're translating one of the corners in both the x and y direction, need to make sure it conforms to aspect ratio\nelse{const pointer=vectorCreate(targetPosition.x+tx-anchorPosition.x,targetPosition.y+ty-anchorPosition.y);// translations cannot be inverted, limited by anchor position\nif(target===TopRight){pointer.x=Math.max(0,pointer.x);pointer.y=Math.min(0,pointer.y);}else if(target===BottomRight){pointer.x=Math.max(0,pointer.x);pointer.y=Math.max(0,pointer.y);}else if(target===BottomLeft){pointer.x=Math.min(0,pointer.x);pointer.y=Math.max(0,pointer.y);}else if(target===TopLeft){pointer.x=Math.min(0,pointer.x);pointer.y=Math.min(0,pointer.y);}// calculate the translation pointer, then get its length, now create a new pointer based on the aspect ratio, and scale it based on the original (limited) length\nconst pointerLength=vectorLength(pointer);const pointerAspectRatio=vectorCreate(aspectRatio,1);const pointerScaled=vectorMultiply(vectorNormalize(pointerAspectRatio),pointerLength);if(target===TopRight){r=anchorPosition.x+pointerScaled.x;t=anchorPosition.y-pointerScaled.y;}else if(target===BottomRight){r=anchorPosition.x+pointerScaled.x;b=anchorPosition.y+pointerScaled.y;}else if(target===BottomLeft){l=anchorPosition.x-pointerScaled.x;b=anchorPosition.y+pointerScaled.y;}else if(target===TopLeft){l=anchorPosition.x-pointerScaled.x;t=anchorPosition.y-pointerScaled.y;}}}return rectCreate(l,t,r-l,b-t);};var radToDeg=rad=>rad*180/Math.PI;/* src/core/ui/plugins/crop/components/ImageRotator.svelte generated by Svelte v3.29.4 */function create_fragment$p(ctx){let div;let rangeinput;let current;rangeinput=new RangeInput({props:{elasticity:/*elasticity*/ctx[5],min:/*min*/ctx[7],max:/*max*/ctx[8],value:/*value*/ctx[12],valueMin:/*valueMin*/ctx[0],valueMax:/*valueMax*/ctx[1],labelReset:/*labelReset*/ctx[6],base:/*center*/ctx[9],valueLabel:`${Math.round(radToDeg(/*value*/ctx[12]))}°`,oninputstart:/*oninputstart*/ctx[2],oninputmove:/*func*/ctx[14],oninputend:/*func_1*/ctx[15]}});return{c(){div=element(\"div\");create_component(rangeinput.$$.fragment);attr(div,\"class\",\"DokaImageRotator\");},m(target,anchor){insert(target,div,anchor);mount_component(rangeinput,div,null);current=true;},p(ctx,[dirty]){const rangeinput_changes={};if(dirty&/*elasticity*/32)rangeinput_changes.elasticity=/*elasticity*/ctx[5];if(dirty&/*min*/128)rangeinput_changes.min=/*min*/ctx[7];if(dirty&/*max*/256)rangeinput_changes.max=/*max*/ctx[8];if(dirty&/*value*/4096)rangeinput_changes.value=/*value*/ctx[12];if(dirty&/*valueMin*/1)rangeinput_changes.valueMin=/*valueMin*/ctx[0];if(dirty&/*valueMax*/2)rangeinput_changes.valueMax=/*valueMax*/ctx[1];if(dirty&/*labelReset*/64)rangeinput_changes.labelReset=/*labelReset*/ctx[6];if(dirty&/*center*/512)rangeinput_changes.base=/*center*/ctx[9];if(dirty&/*value*/4096)rangeinput_changes.valueLabel=`${Math.round(radToDeg(/*value*/ctx[12]))}°`;if(dirty&/*oninputstart*/4)rangeinput_changes.oninputstart=/*oninputstart*/ctx[2];if(dirty&/*oninputmove, sign, turns*/3080)rangeinput_changes.oninputmove=/*func*/ctx[14];if(dirty&/*oninputend, sign, turns*/3088)rangeinput_changes.oninputend=/*func_1*/ctx[15];rangeinput.$set(rangeinput_changes);},i(local){if(current)return;transition_in(rangeinput.$$.fragment,local);current=true;},o(local){transition_out(rangeinput.$$.fragment,local);current=false;},d(detaching){if(detaching)detach(div);destroy_component(rangeinput);}};}const MARGIN=1e-9;function instance$p($$self,$$props,$$invalidate){const HALF_PI=Math.PI/2;const QUARTER_PI=Math.PI/4;let{rotation}=$$props;let{valueMin}=$$props;let{valueMax}=$$props;let{oninputstart=noop}=$$props;let{oninputmove=noop}=$$props;let{oninputend=noop}=$$props;let{elasticity=0}=$$props;let{labelReset=undefined}=$$props;const func=value=>oninputmove(sign*turns+value);const func_1=value=>oninputend(sign*turns+value);$$self.$$set=$$props=>{if(\"rotation\"in $$props)$$invalidate(13,rotation=$$props.rotation);if(\"valueMin\"in $$props)$$invalidate(0,valueMin=$$props.valueMin);if(\"valueMax\"in $$props)$$invalidate(1,valueMax=$$props.valueMax);if(\"oninputstart\"in $$props)$$invalidate(2,oninputstart=$$props.oninputstart);if(\"oninputmove\"in $$props)$$invalidate(3,oninputmove=$$props.oninputmove);if(\"oninputend\"in $$props)$$invalidate(4,oninputend=$$props.oninputend);if(\"elasticity\"in $$props)$$invalidate(5,elasticity=$$props.elasticity);if(\"labelReset\"in $$props)$$invalidate(6,labelReset=$$props.labelReset);};let min;let max;let center;let sign;let turns;let value;$$self.$$.update=()=>{if($$self.$$.dirty&/*min, max*/384){$$invalidate(9,center=min+(max-min)*0.5);}if($$self.$$.dirty&/*rotation*/8192){$$invalidate(10,sign=Math.sign(rotation));}if($$self.$$.dirty&/*rotation*/8192){$$invalidate(11,turns=Math.round(Math.abs(rotation)/HALF_PI)*HALF_PI);}if($$self.$$.dirty&/*rotation, sign, turns*/11264){$$invalidate(12,value=rotation-sign*turns);}};$$invalidate(7,min=-QUARTER_PI+MARGIN);$$invalidate(8,max=QUARTER_PI-MARGIN);return[valueMin,valueMax,oninputstart,oninputmove,oninputend,elasticity,labelReset,min,max,center,sign,turns,value,rotation,func,func_1];}class ImageRotator extends SvelteComponent{constructor(options){super();init(this,options,instance$p,create_fragment$p,safe_not_equal,{rotation:13,valueMin:0,valueMax:1,oninputstart:2,oninputmove:3,oninputend:4,elasticity:5,labelReset:6});}}/* src/core/ui/plugins/crop/components/ImageInfo.svelte generated by Svelte v3.29.4 */function create_fragment$q(ctx){let div;let p;let t0;let t1;let t2;return{c(){div=element(\"div\");p=element(\"p\");t0=text(/*width*/ctx[0]);t1=text(\" × \");t2=text(/*height*/ctx[1]);attr(div,\"class\",\"DokaImageInfo\");},m(target,anchor){insert(target,div,anchor);append(div,p);append(p,t0);append(p,t1);append(p,t2);},p(ctx,[dirty]){if(dirty&/*width*/1)set_data(t0,/*width*/ctx[0]);if(dirty&/*height*/2)set_data(t2,/*height*/ctx[1]);},i:noop$1,o:noop$1,d(detaching){if(detaching)detach(div);}};}function instance$q($$self,$$props,$$invalidate){let{width}=$$props;let{height}=$$props;$$self.$$set=$$props=>{if(\"width\"in $$props)$$invalidate(0,width=$$props.width);if(\"height\"in $$props)$$invalidate(1,height=$$props.height);};return[width,height];}class ImageInfo extends SvelteComponent{constructor(options){super();init(this,options,instance$q,create_fragment$q,safe_not_equal,{width:0,height:1});}}var getSelectionPresetOptionIcon=(value,options={})=>{const{width=24,height=24,bounds=16,radius=3}=options;let aspectRatio=isArray(value)?getAspectRatio(value[0],value[1]):value;let aspectRatioDefined=!!aspectRatio;aspectRatio=aspectRatioDefined?aspectRatio:1;let x;let y;let w;let h;w=aspectRatio>1?bounds:aspectRatio*bounds;h=w/aspectRatio;x=Math.round((width-w)*0.5);y=Math.round((height-h)*0.5);const fill=aspectRatioDefined?'currentColor':'none';const stroke=aspectRatioDefined?'none':'currentColor';const strokeWidth=width/16;const strokeDashArray=[width/12,width/6].join(' ');return`<rect fill=\"${fill}\" stroke=\"${stroke}\" stroke-width=\"${strokeWidth}\" stroke-dasharray=\"${strokeDashArray}\" x=\"${x}\" y=\"${y}\" width=\"${w}\" height=\"${h}\" rx=\"${radius}\"/>`;};/* src/core/ui/plugins/crop/index.svelte generated by Svelte v3.29.4 */function create_default_slot_3$3(ctx){let dynamiccomponenttree;let current;dynamiccomponenttree=new DynamicComponentTree_1({props:{items:/*tools*/ctx[0]}});return{c(){create_component(dynamiccomponenttree.$$.fragment);},m(target,anchor){mount_component(dynamiccomponenttree,target,anchor);current=true;},p(ctx,dirty){const dynamiccomponenttree_changes={};if(dirty[0]&/*tools*/1)dynamiccomponenttree_changes.items=/*tools*/ctx[0];dynamiccomponenttree.$set(dynamiccomponenttree_changes);},i(local){if(current)return;transition_in(dynamiccomponenttree.$$.fragment,local);current=true;},o(local){transition_out(dynamiccomponenttree.$$.fragment,local);current=false;},d(detaching){destroy_component(dynamiccomponenttree,detaching);}};}// (1208:4) <div slot=\"header\">\nfunction create_header_slot(ctx){let div;let toolbar;let current;toolbar=new Toolbar({props:{$$slots:{default:[create_default_slot_3$3]},$$scope:{ctx}}});return{c(){div=element(\"div\");create_component(toolbar.$$.fragment);attr(div,\"slot\",\"header\");},m(target,anchor){insert(target,div,anchor);mount_component(toolbar,div,null);current=true;},p(ctx,dirty){const toolbar_changes={};if(dirty[0]&/*tools*/1|dirty[5]&/*$$scope*/16384){toolbar_changes.$$scope={dirty,ctx};}toolbar.$set(toolbar_changes);},i(local){if(current)return;transition_in(toolbar.$$.fragment,local);current=true;},o(local){transition_out(toolbar.$$.fragment,local);current=false;},d(detaching){if(detaching)detach(div);destroy_component(toolbar);}};}// (1232:12) {#if shouldRenderImageSelection && shouldRenderImageSelectionRecenterButton}\nfunction create_if_block_6$2(ctx){let button;let current;button=new Button({props:{onclick:/*handleRecenterAction*/ctx[74],label:/*locale*/ctx[4].cropLabelButtonRecenter,icon:/*locale*/ctx[4].cropIconButtonRecenter,class:\"DokaButtonCenter\",disabled:!/*canCenter*/ctx[11],hideLabel:true,style:`opacity: ${/*$recenterOpacity*/ctx[24]}; transform: translate3d(${/*$recenterOffset*/ctx[25].x}px, ${/*$recenterOffset*/ctx[25].y}px, 0)`}});return{c(){create_component(button.$$.fragment);},m(target,anchor){mount_component(button,target,anchor);current=true;},p(ctx,dirty){const button_changes={};if(dirty[0]&/*locale*/16)button_changes.label=/*locale*/ctx[4].cropLabelButtonRecenter;if(dirty[0]&/*locale*/16)button_changes.icon=/*locale*/ctx[4].cropIconButtonRecenter;if(dirty[0]&/*canCenter*/2048)button_changes.disabled=!/*canCenter*/ctx[11];if(dirty[0]&/*$recenterOpacity, $recenterOffset*/50331648)button_changes.style=`opacity: ${/*$recenterOpacity*/ctx[24]}; transform: translate3d(${/*$recenterOffset*/ctx[25].x}px, ${/*$recenterOffset*/ctx[25].y}px, 0)`;button.$set(button_changes);},i(local){if(current)return;transition_in(button.$$.fragment,local);current=true;},o(local){transition_out(button.$$.fragment,local);current=false;},d(detaching){destroy_component(button,detaching);}};}// (1244:12) {#if shouldRenderImageSelection}\nfunction create_if_block_5$2(ctx){let rectmanipulator;let current;rectmanipulator=new RectManipulator({props:{rect:/*imageSelectionRectOffset*/ctx[14],visible:/*$isActive*/ctx[16],style:/*cropImageSelectionCornerStyle*/ctx[2]}});rectmanipulator.$on(\"resizestart\",/*handleSelectionGrab*/ctx[57]);rectmanipulator.$on(\"resizemove\",/*handleSelectionDrag*/ctx[58]);rectmanipulator.$on(\"resizeend\",/*handleSelectionRelease*/ctx[59]);return{c(){create_component(rectmanipulator.$$.fragment);},m(target,anchor){mount_component(rectmanipulator,target,anchor);current=true;},p(ctx,dirty){const rectmanipulator_changes={};if(dirty[0]&/*imageSelectionRectOffset*/16384)rectmanipulator_changes.rect=/*imageSelectionRectOffset*/ctx[14];if(dirty[0]&/*$isActive*/65536)rectmanipulator_changes.visible=/*$isActive*/ctx[16];if(dirty[0]&/*cropImageSelectionCornerStyle*/4)rectmanipulator_changes.style=/*cropImageSelectionCornerStyle*/ctx[2];rectmanipulator.$set(rectmanipulator_changes);},i(local){if(current)return;transition_in(rectmanipulator.$$.fragment,local);current=true;},o(local){transition_out(rectmanipulator.$$.fragment,local);current=false;},d(detaching){destroy_component(rectmanipulator,detaching);}};}// (1256:8) {#if shouldRenderInfoIndicator}\nfunction create_if_block_4$3(ctx){let imageinfo;let current;imageinfo=new ImageInfo({props:{width:Math.round(/*$imageCropRect*/ctx[7].width),height:Math.round(/*$imageCropRect*/ctx[7].height)}});return{c(){create_component(imageinfo.$$.fragment);},m(target,anchor){mount_component(imageinfo,target,anchor);current=true;},p(ctx,dirty){const imageinfo_changes={};if(dirty[0]&/*$imageCropRect*/128)imageinfo_changes.width=Math.round(/*$imageCropRect*/ctx[7].width);if(dirty[0]&/*$imageCropRect*/128)imageinfo_changes.height=Math.round(/*$imageCropRect*/ctx[7].height);imageinfo.$set(imageinfo_changes);},i(local){if(current)return;transition_in(imageinfo.$$.fragment,local);current=true;},o(local){transition_out(imageinfo.$$.fragment,local);current=false;},d(detaching){destroy_component(imageinfo,detaching);}};}// (1214:4) <div slot=\"main\">\nfunction create_main_slot(ctx){let div0;let div1;let t0;let measurable_action;let interactable_action;let t1;let current;let mounted;let dispose;let if_block0=/*shouldRenderImageSelection*/ctx[13]&&/*shouldRenderImageSelectionRecenterButton*/ctx[15]&&create_if_block_6$2(ctx);let if_block1=/*shouldRenderImageSelection*/ctx[13]&&create_if_block_5$2(ctx);let if_block2=/*shouldRenderInfoIndicator*/ctx[12]&&create_if_block_4$3(ctx);return{c(){div0=element(\"div\");div1=element(\"div\");if(if_block0)if_block0.c();t0=space();if(if_block1)if_block1.c();t1=space();if(if_block2)if_block2.c();attr(div1,\"class\",\"DokaStage\");attr(div0,\"slot\",\"main\");},m(target,anchor){insert(target,div0,anchor);append(div0,div1);if(if_block0)if_block0.m(div1,null);append(div1,t0);if(if_block1)if_block1.m(div1,null);append(div0,t1);if(if_block2)if_block2.m(div0,null);current=true;if(!mounted){dispose=[listen(div1,\"measure\",/*measure_handler_1*/ctx[98]),action_destroyer(measurable_action=measurable.call(null,div1)),listen(div1,\"wheel\",function(){if(is_function(/*cropEnableZoom*/ctx[3]&&/*handleWheel*/ctx[73]))(/*cropEnableZoom*/ctx[3]&&/*handleWheel*/ctx[73]).apply(this,arguments);}),listen(div1,\"interactionstart\",/*handleImageDragStart*/ctx[63]),listen(div1,\"interactionupdate\",/*handleImageDrag*/ctx[64]),listen(div1,\"interactionrelease\",/*handleImageDragRelease*/ctx[66]),listen(div1,\"interactionend\",/*handleImageDragEnd*/ctx[65]),action_destroyer(interactable_action=interactable.call(null,div1,{drag:true,pinch:/*cropEnableZoom*/ctx[3],inertia:true,matchTarget:true,getEventPosition:/*interactable_function*/ctx[99]}))];mounted=true;}},p(new_ctx,dirty){ctx=new_ctx;if(/*shouldRenderImageSelection*/ctx[13]&&/*shouldRenderImageSelectionRecenterButton*/ctx[15]){if(if_block0){if_block0.p(ctx,dirty);if(dirty[0]&/*shouldRenderImageSelection, shouldRenderImageSelectionRecenterButton*/40960){transition_in(if_block0,1);}}else{if_block0=create_if_block_6$2(ctx);if_block0.c();transition_in(if_block0,1);if_block0.m(div1,t0);}}else if(if_block0){group_outros();transition_out(if_block0,1,1,()=>{if_block0=null;});check_outros();}if(/*shouldRenderImageSelection*/ctx[13]){if(if_block1){if_block1.p(ctx,dirty);if(dirty[0]&/*shouldRenderImageSelection*/8192){transition_in(if_block1,1);}}else{if_block1=create_if_block_5$2(ctx);if_block1.c();transition_in(if_block1,1);if_block1.m(div1,null);}}else if(if_block1){group_outros();transition_out(if_block1,1,1,()=>{if_block1=null;});check_outros();}if(interactable_action&&is_function(interactable_action.update)&&dirty[0]&/*cropEnableZoom, $rootRect*/1032)interactable_action.update.call(null,{drag:true,pinch:/*cropEnableZoom*/ctx[3],inertia:true,matchTarget:true,getEventPosition:/*interactable_function*/ctx[99]});if(/*shouldRenderInfoIndicator*/ctx[12]){if(if_block2){if_block2.p(ctx,dirty);if(dirty[0]&/*shouldRenderInfoIndicator*/4096){transition_in(if_block2,1);}}else{if_block2=create_if_block_4$3(ctx);if_block2.c();transition_in(if_block2,1);if_block2.m(div0,null);}}else if(if_block2){group_outros();transition_out(if_block2,1,1,()=>{if_block2=null;});check_outros();}},i(local){if(current)return;transition_in(if_block0);transition_in(if_block1);transition_in(if_block2);current=true;},o(local){transition_out(if_block0);transition_out(if_block1);transition_out(if_block2);current=false;},d(detaching){if(detaching)detach(div0);if(if_block0)if_block0.d();if(if_block1)if_block1.d();if(if_block2)if_block2.d();mounted=false;run_all(dispose);}};}// (1264:4) {#if shouldRenderFooter}\nfunction create_if_block$6(ctx){let t;let tabpanels;let current;let if_block=/*shouldRenderTabs*/ctx[19]&&create_if_block_3$3(ctx);const tabpanels_spread_levels=[{class:\"DokaControlPanels\"},{panelClass:\"DokaControlPanel\"},{panels:/*panels*/ctx[22]},/*tabsConfig*/ctx[20]];let tabpanels_props={$$slots:{default:[create_default_slot_1$4,({panel})=>({167:panel}),({panel})=>[0,0,0,0,0,panel?4096:0]]},$$scope:{ctx}};for(let i=0;i<tabpanels_spread_levels.length;i+=1){tabpanels_props=assign(tabpanels_props,tabpanels_spread_levels[i]);}tabpanels=new TabPanels({props:tabpanels_props});return{c(){if(if_block)if_block.c();t=space();create_component(tabpanels.$$.fragment);},m(target,anchor){if(if_block)if_block.m(target,anchor);insert(target,t,anchor);mount_component(tabpanels,target,anchor);current=true;},p(ctx,dirty){if(/*shouldRenderTabs*/ctx[19]){if(if_block){if_block.p(ctx,dirty);if(dirty[0]&/*shouldRenderTabs*/524288){transition_in(if_block,1);}}else{if_block=create_if_block_3$3(ctx);if_block.c();transition_in(if_block,1);if_block.m(t.parentNode,t);}}else if(if_block){group_outros();transition_out(if_block,1,1,()=>{if_block=null;});check_outros();}const tabpanels_changes=dirty[0]&/*panels, tabsConfig*/5242880?get_spread_update(tabpanels_spread_levels,[tabpanels_spread_levels[0],tabpanels_spread_levels[1],dirty[0]&/*panels*/4194304&&{panels:/*panels*/ctx[22]},dirty[0]&/*tabsConfig*/1048576&&get_spread_object(/*tabsConfig*/ctx[20])]):{};if(dirty[0]&/*$imageRotation, locale, $imageRotationRange, tabs, imageZoomLevelMin, $imageZoomLevelRange, $imageZoomLevel*/471859984|dirty[5]&/*$$scope, panel*/20480){tabpanels_changes.$$scope={dirty,ctx};}tabpanels.$set(tabpanels_changes);},i(local){if(current)return;transition_in(if_block);transition_in(tabpanels.$$.fragment,local);current=true;},o(local){transition_out(if_block);transition_out(tabpanels.$$.fragment,local);current=false;},d(detaching){if(if_block)if_block.d(detaching);if(detaching)detach(t);destroy_component(tabpanels,detaching);}};}// (1266:8) {#if shouldRenderTabs}\nfunction create_if_block_3$3(ctx){let tablist;let current;const tablist_spread_levels=[{class:\"DokaControlList\"},{tabs:/*tabs*/ctx[21]},/*tabsConfig*/ctx[20]];let tablist_props={$$slots:{default:[create_default_slot_2$3,({tab})=>({168:tab}),({tab})=>[0,0,0,0,0,tab?8192:0]]},$$scope:{ctx}};for(let i=0;i<tablist_spread_levels.length;i+=1){tablist_props=assign(tablist_props,tablist_spread_levels[i]);}tablist=new TabList({props:tablist_props});tablist.$on(\"select\",/*select_handler*/ctx[100]);return{c(){create_component(tablist.$$.fragment);},m(target,anchor){mount_component(tablist,target,anchor);current=true;},p(ctx,dirty){const tablist_changes=dirty[0]&/*tabs, tabsConfig*/3145728?get_spread_update(tablist_spread_levels,[tablist_spread_levels[0],dirty[0]&/*tabs*/2097152&&{tabs:/*tabs*/ctx[21]},dirty[0]&/*tabsConfig*/1048576&&get_spread_object(/*tabsConfig*/ctx[20])]):{};if(dirty[5]&/*$$scope, tab*/24576){tablist_changes.$$scope={dirty,ctx};}tablist.$set(tablist_changes);},i(local){if(current)return;transition_in(tablist.$$.fragment,local);current=true;},o(local){transition_out(tablist.$$.fragment,local);current=false;},d(detaching){destroy_component(tablist,detaching);}};}// (1267:8) <TabList class=\"DokaControlList\" {tabs} {...tabsConfig} on:select={({ detail }) => transformSelected = detail} let:tab={tab}>\nfunction create_default_slot_2$3(ctx){let span;let t_value=/*tab*/ctx[168].label+\"\";let t;return{c(){span=element(\"span\");t=text(t_value);},m(target,anchor){insert(target,span,anchor);append(span,t);},p(ctx,dirty){if(dirty[5]&/*tab*/8192&&t_value!==(t_value=/*tab*/ctx[168].label+\"\"))set_data(t,t_value);},d(detaching){if(detaching)detach(span);}};}// (1283:43) \nfunction create_if_block_2$5(ctx){let rangeinput;let current;rangeinput=new RangeInput({props:{elasticity:/*elasticityMultiplier*/ctx[34]*/*rangeInputElasticity*/ctx[35],base:imageZoomLevelBase,min:/*imageZoomLevelMin*/ctx[9],max:imageZoomLevelMax,valueMin:/*$imageZoomLevelRange*/ctx[27][0],valueMax:/*$imageZoomLevelRange*/ctx[27][1],value:/*$imageZoomLevel*/ctx[28],labelReset:/*locale*/ctx[4].labelReset,valueLabel:`${Math.round(/*$imageZoomLevel*/ctx[28]*100)}%`,oninputstart:/*handleResizeStart*/ctx[70],oninputmove:/*handleResizeMove*/ctx[71],oninputend:/*handleResizeEnd*/ctx[72]}});return{c(){create_component(rangeinput.$$.fragment);},m(target,anchor){mount_component(rangeinput,target,anchor);current=true;},p(ctx,dirty){const rangeinput_changes={};if(dirty[0]&/*imageZoomLevelMin*/512)rangeinput_changes.min=/*imageZoomLevelMin*/ctx[9];if(dirty[0]&/*$imageZoomLevelRange*/134217728)rangeinput_changes.valueMin=/*$imageZoomLevelRange*/ctx[27][0];if(dirty[0]&/*$imageZoomLevelRange*/134217728)rangeinput_changes.valueMax=/*$imageZoomLevelRange*/ctx[27][1];if(dirty[0]&/*$imageZoomLevel*/268435456)rangeinput_changes.value=/*$imageZoomLevel*/ctx[28];if(dirty[0]&/*locale*/16)rangeinput_changes.labelReset=/*locale*/ctx[4].labelReset;if(dirty[0]&/*$imageZoomLevel*/268435456)rangeinput_changes.valueLabel=`${Math.round(/*$imageZoomLevel*/ctx[28]*100)}%`;rangeinput.$set(rangeinput_changes);},i(local){if(current)return;transition_in(rangeinput.$$.fragment,local);current=true;},o(local){transition_out(rangeinput.$$.fragment,local);current=false;},d(detaching){destroy_component(rangeinput,detaching);}};}// (1273:12) {#if panel === tabs[0].id }\nfunction create_if_block_1$7(ctx){let imagerotator;let current;imagerotator=new ImageRotator({props:{elasticity:/*elasticityMultiplier*/ctx[34]*/*rangeInputElasticity*/ctx[35],rotation:/*$imageRotation*/ctx[8],labelReset:/*locale*/ctx[4].labelReset,valueMin:/*$imageRotationRange*/ctx[26][0],valueMax:/*$imageRotationRange*/ctx[26][1],oninputstart:/*handleRotateStart*/ctx[60],oninputmove:/*handleRotateMove*/ctx[61],oninputend:/*handleRotateEnd*/ctx[62]}});return{c(){create_component(imagerotator.$$.fragment);},m(target,anchor){mount_component(imagerotator,target,anchor);current=true;},p(ctx,dirty){const imagerotator_changes={};if(dirty[0]&/*$imageRotation*/256)imagerotator_changes.rotation=/*$imageRotation*/ctx[8];if(dirty[0]&/*locale*/16)imagerotator_changes.labelReset=/*locale*/ctx[4].labelReset;if(dirty[0]&/*$imageRotationRange*/67108864)imagerotator_changes.valueMin=/*$imageRotationRange*/ctx[26][0];if(dirty[0]&/*$imageRotationRange*/67108864)imagerotator_changes.valueMax=/*$imageRotationRange*/ctx[26][1];imagerotator.$set(imagerotator_changes);},i(local){if(current)return;transition_in(imagerotator.$$.fragment,local);current=true;},o(local){transition_out(imagerotator.$$.fragment,local);current=false;},d(detaching){destroy_component(imagerotator,detaching);}};}// (1272:8) <TabPanels class=\"DokaControlPanels\" panelClass=\"DokaControlPanel\" {panels} {...tabsConfig} let:panel>\nfunction create_default_slot_1$4(ctx){let current_block_type_index;let if_block;let if_block_anchor;let current;const if_block_creators=[create_if_block_1$7,create_if_block_2$5];const if_blocks=[];function select_block_type(ctx,dirty){if(/*panel*/ctx[167]===/*tabs*/ctx[21][0].id)return 0;if(/*panel*/ctx[167]===/*tabs*/ctx[21][1].id)return 1;return-1;}if(~(current_block_type_index=select_block_type(ctx))){if_block=if_blocks[current_block_type_index]=if_block_creators[current_block_type_index](ctx);}return{c(){if(if_block)if_block.c();if_block_anchor=empty();},m(target,anchor){if(~current_block_type_index){if_blocks[current_block_type_index].m(target,anchor);}insert(target,if_block_anchor,anchor);current=true;},p(ctx,dirty){let previous_block_index=current_block_type_index;current_block_type_index=select_block_type(ctx);if(current_block_type_index===previous_block_index){if(~current_block_type_index){if_blocks[current_block_type_index].p(ctx,dirty);}}else{if(if_block){group_outros();transition_out(if_blocks[previous_block_index],1,1,()=>{if_blocks[previous_block_index]=null;});check_outros();}if(~current_block_type_index){if_block=if_blocks[current_block_type_index];if(!if_block){if_block=if_blocks[current_block_type_index]=if_block_creators[current_block_type_index](ctx);if_block.c();}transition_in(if_block,1);if_block.m(if_block_anchor.parentNode,if_block_anchor);}else{if_block=null;}}},i(local){if(current)return;transition_in(if_block);current=true;},o(local){transition_out(if_block);current=false;},d(detaching){if(~current_block_type_index){if_blocks[current_block_type_index].d(detaching);}if(detaching)detach(if_block_anchor);}};}// (1263:4) <div slot=\"footer\" style={footerStyle}>\nfunction create_footer_slot(ctx){let div;let current;let if_block=/*shouldRenderFooter*/ctx[18]&&create_if_block$6(ctx);return{c(){div=element(\"div\");if(if_block)if_block.c();attr(div,\"slot\",\"footer\");attr(div,\"style\",/*footerStyle*/ctx[23]);},m(target,anchor){insert(target,div,anchor);if(if_block)if_block.m(div,null);current=true;},p(ctx,dirty){if(/*shouldRenderFooter*/ctx[18]){if(if_block){if_block.p(ctx,dirty);if(dirty[0]&/*shouldRenderFooter*/262144){transition_in(if_block,1);}}else{if_block=create_if_block$6(ctx);if_block.c();transition_in(if_block,1);if_block.m(div,null);}}else if(if_block){group_outros();transition_out(if_block,1,1,()=>{if_block=null;});check_outros();}if(!current||dirty[0]&/*footerStyle*/8388608){attr(div,\"style\",/*footerStyle*/ctx[23]);}},i(local){if(current)return;transition_in(if_block);current=true;},o(local){transition_out(if_block);current=false;},d(detaching){if(detaching)detach(div);if(if_block)if_block.d();}};}// (1206:0) <Util hasHeader={shouldRenderToolbar} on:measure bind:root>\nfunction create_default_slot$6(ctx){let t0;let t1;return{c(){t0=space();t1=space();},m(target,anchor){insert(target,t0,anchor);insert(target,t1,anchor);},p:noop$1,i:noop$1,o:noop$1,d(detaching){if(detaching)detach(t0);if(detaching)detach(t1);}};}function create_fragment$r(ctx){let util;let updating_root;let current;function util_root_binding(value){/*util_root_binding*/ctx[101].call(null,value);}let util_props={hasHeader:/*shouldRenderToolbar*/ctx[17],$$slots:{default:[create_default_slot$6],footer:[create_footer_slot],main:[create_main_slot],header:[create_header_slot]},$$scope:{ctx}};if(/*root*/ctx[6]!==void 0){util_props.root=/*root*/ctx[6];}util=new Util({props:util_props});binding_callbacks.push(()=>bind(util,\"root\",util_root_binding));util.$on(\"measure\",/*measure_handler*/ctx[102]);return{c(){create_component(util.$$.fragment);},m(target,anchor){mount_component(util,target,anchor);current=true;},p(ctx,dirty){const util_changes={};if(dirty[0]&/*shouldRenderToolbar*/131072)util_changes.hasHeader=/*shouldRenderToolbar*/ctx[17];if(dirty[0]&/*footerStyle, panels, tabsConfig, $imageRotation, locale, $imageRotationRange, tabs, imageZoomLevelMin, $imageZoomLevelRange, $imageZoomLevel, transformSelected, shouldRenderTabs, shouldRenderFooter, $imageCropRect, shouldRenderInfoIndicator, cropEnableZoom, $rootRect, imageSelectionRectOffset, $isActive, cropImageSelectionCornerStyle, shouldRenderImageSelection, canCenter, $recenterOpacity, $recenterOffset, shouldRenderImageSelectionRecenterButton, tools*/536739773|dirty[5]&/*$$scope*/16384){util_changes.$$scope={dirty,ctx};}if(!updating_root&&dirty[0]&/*root*/64){updating_root=true;util_changes.root=/*root*/ctx[6];add_flush_callback(()=>updating_root=false);}util.$set(util_changes);},i(local){if(current)return;transition_in(util.$$.fragment,local);current=true;},o(local){transition_out(util.$$.fragment,local);current=false;},d(detaching){destroy_component(util,detaching);}};}const imageZoomLevelMax=1;const imageZoomLevelBase=0;function instance$r($$self,$$props,$$invalidate){let $imageCropAspectRatio;let $imageCropRect;let $imageSize;let $imageRotation;let $imageFlipY;let $imageFlipX;let $selectedPresetIndex;let $imageOutputSize;let $imageCropMinSize;let $imageCropLimitToImage;let $isInteracting;let $imageSelectionRectSnapshot;let $imageSelectionRect;let $presentationScalar;let $imageCropMaxSize;let $imageSelectionRectIntent;let $utilRect;let $imageCropRectOrigin;let $imageCropRectIntent;let $imageCropRange;let $rootRect;let $stageRect;let $imageCropRangeAspectRatio;let $imageSelectionRectPresentation;let $env;let $imageScalar;let $isActive,$$unsubscribe_isActive=noop$1,$$subscribe_isActive=()=>($$unsubscribe_isActive(),$$unsubscribe_isActive=subscribe(isActive,$$value=>$$invalidate(16,$isActive=$$value)),isActive);let $imagePreviewModifiers;let $footerOffset;let $recenterOpacity;let $recenterOffset;let $imageRotationRange;let $imageZoomLevelRange;let $imageZoomLevel;$$self.$$.on_destroy.push(()=>$$unsubscribe_isActive());const name=\"crop\";let{isActive}=$$props;$$subscribe_isActive();let{stores}=$$props;let{cropImageSelectionCornerStyle=\"circle\"}=$$props;// 'circle', 'hook'\nlet{cropAutoCenterImageSelectionTimeout=undefined}=$$props;let{cropEnableZoomMatchImageAspectRatio=true}=$$props;let{cropEnableRotateMatchImageAspectRatio=\"never\"}=$$props;// 'always' | 'custom' | 'never'\nlet{cropEnableRotationInput=true}=$$props;let{cropEnableZoom=true}=$$props;let{cropEnableZoomInput=true}=$$props;let{cropEnableImageSelection=true}=$$props;let{cropEnableInfoIndicator=false}=$$props;let{cropEnableZoomTowardsWheelPosition=true}=$$props;let{cropEnableLimitWheelInputToCropSelection=true}=$$props;let{cropEnableCenterImageSelection=true}=$$props;let{cropEnableButtonRotateLeft=true}=$$props;let{cropEnableButtonRotateRight=false}=$$props;let{cropEnableButtonFlipHorizontal=true}=$$props;let{cropEnableButtonFlipVertical=false}=$$props;let{cropSelectPresetOptions=undefined}=$$props;let{cropEnableSelectPreset=true}=$$props;let{cropEnableButtonToggleCropLimit=false}=$$props;let{locale={}}=$$props;let{tools=[]}=$$props;const isCustomCrop=()=>$imageCropAspectRatio===undefined;const turnAspectRatio=aspectRatio=>1/aspectRatio;const hasValidRotatedCropAspectRatio=()=>{if($imageCropAspectRatio===1)return false;const rotatedImageCropAspectRatio=turnAspectRatio($imageCropAspectRatio);// no options available, forced crop aspect ratio\nif(!cropSelectPresetOptions)return false;// options available but no valid option in list\nif(!flattenOptions(cropSelectPresetOptions).find(([aspectRatio])=>aspectRatio===rotatedImageCropAspectRatio))return false;return true;};const isCropMaxSize=(imageCropRect,imageSize,imageRotation)=>isRotatedSideways(imageRotation)?imageSize.width===Math.round(imageCropRect.height)||imageSize.height===Math.round(imageCropRect.width):imageSize.width===Math.round(imageCropRect.width)||imageSize.height===Math.round(imageCropRect.height);const isCropCentered=(imageCropRect,imageSize,imageRotation)=>{const imageSizeRotated=sizeApply(sizeRotate(sizeClone(imageSize),imageRotation),v=>Math.abs(Math.round(v)));const imageCenter=sizeCenter(imageSizeRotated);const cropCenter=rectCenter(imageCropRect);return vectorEqual(imageCenter,cropCenter);};const canMatchCropAspectRatioToRotation=()=>(// is custom crop mode\nisCustomCrop()||// can match preset crop and preset is available\ncropEnableRotateMatchImageAspectRatio===\"always\"&&hasValidRotatedCropAspectRatio())&&isCropCentered($imageCropRect,$imageSize,$imageRotation)&&isCropMaxSize($imageCropRect,$imageSize,$imageRotation);const applyRotation=value=>{if(cropEnableRotateMatchImageAspectRatio!==\"never\"&&canMatchCropAspectRatioToRotation()){set_store_value(imageRotation,$imageRotation+=value,$imageRotation);const isRotated=isRotatedSideways($imageRotation);const w=isRotated?$imageSize.height:$imageSize.width;const h=isRotated?$imageSize.width:$imageSize.height;set_store_value(imageCropRect,$imageCropRect=rectCreate(0,0,w,h),$imageCropRect);if(!isCustomCrop())set_store_value(imageCropAspectRatio,$imageCropAspectRatio=getAspectRatio(w,h),$imageCropAspectRatio);}else{set_store_value(imageRotation,$imageRotation+=value,$imageRotation);}};const{history,env,isInteracting,rootRect,stageRect,utilRect,elasticityMultiplier,rangeInputElasticity,presentationScalar,// effect filtering\nimagePreviewModifiers,// crop selection\nimageFlipX,imageFlipY,imageRotation,imageRotationRange,imageOutputSize,imageSelectionRect,imageSelectionRectSnapshot,imageSelectionRectIntent,imageSelectionRectPresentation,imageCropRectIntent,imageCropRectOrigin,imageCropRect,imageCropMinSize,imageCropMaxSize,imageCropRange,imageCropAspectRatio,imageCropRectAspectRatio,imageCropLimitToImage,imageSize,imageScalar}=stores;// the actual limited rectangle\n// used to calculate rectangle while dragging\n// can be used to set set intended rectangle\n// readonly\ncomponent_subscribe($$self,env,value=>$$invalidate(140,$env=value));component_subscribe($$self,isInteracting,value=>$$invalidate(120,$isInteracting=value));component_subscribe($$self,rootRect,value=>$$invalidate(10,$rootRect=value));component_subscribe($$self,stageRect,value=>$$invalidate(130,$stageRect=value));component_subscribe($$self,utilRect,value=>$$invalidate(126,$utilRect=value));component_subscribe($$self,presentationScalar,value=>$$invalidate(123,$presentationScalar=value));component_subscribe($$self,imagePreviewModifiers,value=>$$invalidate(143,$imagePreviewModifiers=value));component_subscribe($$self,imageFlipX,value=>$$invalidate(113,$imageFlipX=value));component_subscribe($$self,imageFlipY,value=>$$invalidate(112,$imageFlipY=value));component_subscribe($$self,imageRotation,value=>$$invalidate(8,$imageRotation=value));component_subscribe($$self,imageRotationRange,value=>$$invalidate(26,$imageRotationRange=value));component_subscribe($$self,imageOutputSize,value=>$$invalidate(116,$imageOutputSize=value));component_subscribe($$self,imageSelectionRect,value=>$$invalidate(122,$imageSelectionRect=value));component_subscribe($$self,imageSelectionRectSnapshot,value=>$$invalidate(121,$imageSelectionRectSnapshot=value));component_subscribe($$self,imageSelectionRectIntent,value=>$$invalidate(125,$imageSelectionRectIntent=value));component_subscribe($$self,imageSelectionRectPresentation,value=>$$invalidate(134,$imageSelectionRectPresentation=value));component_subscribe($$self,imageCropRectIntent,value=>$$invalidate(128,$imageCropRectIntent=value));component_subscribe($$self,imageCropRectOrigin,value=>$$invalidate(127,$imageCropRectOrigin=value));component_subscribe($$self,imageCropRect,value=>$$invalidate(7,$imageCropRect=value));component_subscribe($$self,imageCropMinSize,value=>$$invalidate(118,$imageCropMinSize=value));component_subscribe($$self,imageCropMaxSize,value=>$$invalidate(124,$imageCropMaxSize=value));component_subscribe($$self,imageCropRange,value=>$$invalidate(129,$imageCropRange=value));component_subscribe($$self,imageCropAspectRatio,value=>$$invalidate(110,$imageCropAspectRatio=value));component_subscribe($$self,imageCropLimitToImage,value=>$$invalidate(119,$imageCropLimitToImage=value));component_subscribe($$self,imageSize,value=>$$invalidate(111,$imageSize=value));component_subscribe($$self,imageScalar,value=>$$invalidate(142,$imageScalar=value));//\n// resizing crop\n//\nlet presentationScalarSnapshot;let imageSelectionRectMinSize;let imageSelectionRectMaxSize;const handleSelectionGrab=()=>{// now interacting\nset_store_value(isInteracting,$isInteracting=true,$isInteracting);// we remember the current view rect and crop rect, because that is the crop rect we use as a starting point to transform while dragging\nset_store_value(imageSelectionRectSnapshot,$imageSelectionRectSnapshot=rectClone($imageSelectionRect),$imageSelectionRectSnapshot);// remember current scalar so we can update min and max size correctly\npresentationScalarSnapshot=$presentationScalar;imageSelectionRectMinSize=sizeScale(sizeClone($imageCropMinSize),presentationScalarSnapshot);imageSelectionRectMaxSize=sizeScale(sizeClone($imageCropMaxSize),presentationScalarSnapshot);};const handleSelectionDrag=({detail})=>{const{boundsLimited,boundsIntent}=translateSelection(detail.direction,detail.translation);// update actual image selection rectangle\nset_store_value(imageSelectionRectIntent,$imageSelectionRectIntent=boundsIntent,$imageSelectionRectIntent);// intent needs to be updated first because has no listeners attached\nset_store_value(imageSelectionRect,$imageSelectionRect=boundsLimited,$imageSelectionRect);};const handleSelectionRelease=({detail})=>{const{boundsLimited}=translateSelection(detail.direction,detail.translation);// we're no longer interacting with the image selection, we need to set this here so the image selection presentation is animated when applying the new bounds below\nset_store_value(isInteracting,$isInteracting=false,$isInteracting);// no more intent as we're finalizing the selection, so before setting the final selection, we set this to undefined | intent needs to be updated first because has no listeners attached\nset_store_value(imageSelectionRectIntent,$imageSelectionRectIntent=undefined,$imageSelectionRectIntent);// confirm the limited rect if actually made a change\nif(vectorLength(detail.translation)){set_store_value(imageSelectionRect,$imageSelectionRect=boundsLimited,$imageSelectionRect);history.write();}// need to set this to undefined after setting the final rect, the snapshot is used to calculate the crop rect transform\nset_store_value(imageSelectionRectSnapshot,$imageSelectionRectSnapshot=undefined,$imageSelectionRectSnapshot);};const translateSelection=(target,translate)=>{// - selection may grow to max bounds (util bounds)\n// - the image preview(!) is scaled to fit the selection, actual image size is not affected\n// - we need to make sure the selection adheres to the aspect ratio of the min size\nconst directionTranslation={target,translate};let rectIntended=applyRectDirectionTranslation($imageSelectionRectSnapshot,directionTranslation,{aspectRatio:$imageCropAspectRatio});let cropAspectRatioLimited;// size in crop rect\nconst cropSize=sizeCreateFromRect(rectDivide(rectClone(rectIntended),$presentationScalar));const imagePolygon=getImagePolygon($imageSize,$imageRotation);const imageCenter=quadCentroid(imagePolygon);// if one of the edges is small and not both are smaller we need to correct\nif(cropSize.width<$imageCropMinSize.width||cropSize.height<$imageCropMinSize.height){// if moving towards the center of the crop, it can't exceed bounds\nconst translateUp=translate.y<0;const translateRight=translate.x>0;const translateLeft=translate.x<0;const translateDown=translate.y>0;const couldExceedBounds=target===\"t\"&&translateUp||target===\"r\"&&translateRight||target===\"b\"&&translateDown||target===\"l\"&&translateLeft||target===\"tr\"&&(translateRight||translateUp)||target===\"tl\"&&(translateLeft||translateUp)||target===\"br\"&&(translateRight||translateDown)||target===\"bl\"&&(translateLeft||translateDown);// need the aspect ratio of the crop to determine if it violates min size\nconst cropAspectRatio=rectAspectRatio(cropSize);// find the maximum size for the current aspect ratio\nconst cropSizeMax=getMaxSizeInRect($imageSize,$imageRotation,cropAspectRatio);if(couldExceedBounds&&(cropSizeMax.width<$imageCropMinSize.width||cropSizeMax.height<$imageCropMinSize.height)){if($imageRotation!==0){const sign=Math.sign($imageRotation);const turns=Math.round(Math.abs($imageRotation)/HALF_PI)*HALF_PI;const value=$imageRotation-sign*turns;const imageIsRotated=turns/HALF_PI%2===1;const imageWidth=imageIsRotated?$imageSize.height:$imageSize.width;const imageHeight=imageIsRotated?$imageSize.width:$imageSize.height;const r=Math.abs(value);const sin=Math.sin(r);const cos=Math.cos(r);if(cropSize.width<$imageCropMinSize.width){// width doesn't fit, let's limit the width to the min size\ncropSize.width=$imageCropMinSize.width;// And now calculate the height\n//  - rotation = .15\n//  - image size = 384 x 288\n//  - crop size width = 200\n// height = 288 - (Math.sin(.15) * 200) / Math.cos(.15)\nconst w=cos*cropSize.width+sin*cropSize.height;const h=sin*cropSize.width+cos*cropSize.height;const dx=imageWidth-w;const dy=imageHeight-h;if(dx<dy){cropSize.height=(imageWidth-cos*cropSize.width)/sin;}else if(dy<dx){cropSize.height=(imageHeight-sin*cropSize.width)/cos;}}if(cropSize.height<$imageCropMinSize.height){// height doesn't fit, let's limit the height to the min size\ncropSize.height=$imageCropMinSize.height;// And now calculate the width\n//  - rotation = .15\n//  - image size = 384 x 288\n//  - crop size height = 200\nconst w=cos*cropSize.width+sin*cropSize.height;const h=sin*cropSize.width+cos*cropSize.height;const dx=imageWidth-w;const dy=imageHeight-h;if(dx<dy){// (384 - (Math.sin(.15) * 250)) / Math.cos(.15)\ncropSize.width=(imageWidth-sin*cropSize.height)/cos;}else if(dy<dx){// (288 - (Math.cos(.15) * 250)) / Math.sin(.15)\ncropSize.width=(imageHeight-cos*cropSize.height)/sin;}}}else{if(cropSize.width<$imageCropMinSize.width){cropSize.width=$imageCropMinSize.width;cropSize.height=$imageSize.height;}if(cropSize.height<$imageCropMinSize.height){cropSize.height=$imageCropMinSize.height;cropSize.width=$imageSize.width;}}// we now have a corrected size, let's calculate the new aspect ratio and use that to limit the translation\ncropAspectRatioLimited=rectAspectRatio(cropSize);}}if(cropAspectRatioLimited){rectIntended=applyRectDirectionTranslation($imageSelectionRectSnapshot,directionTranslation,{aspectRatio:cropAspectRatioLimited||$imageCropAspectRatio});}let rectLimited=limitRectDirectionTranslation($imageSelectionRectSnapshot,directionTranslation,$utilRect,{aspectRatio:$imageCropAspectRatio||cropAspectRatioLimited,minSize:imageSelectionRectMinSize,maxSize:imageSelectionRectMaxSize});return{boundsLimited:rectLimited,boundsIntent:rectIntended};};//\n// rotating\n//\nconst handleRotateStart=()=>{// now interacting with view\nset_store_value(isInteracting,$isInteracting=true,$isInteracting);// we need to know the origin of the crop so we can \"shrink\" the image to fit the crop rect while rotating\nset_store_value(imageCropRectOrigin,$imageCropRectOrigin=rectClone($imageCropRect),$imageCropRectOrigin);};const handleRotateMove=value=>{set_store_value(imageRotation,$imageRotation=value,$imageRotation);// will auto validate\n};const handleRotateEnd=value=>{// we're done interacting\nset_store_value(isInteracting,$isInteracting=false,$isInteracting);// apply our final rotation value\nset_store_value(imageRotation,$imageRotation=value,$imageRotation);history.write();// done, so we no longer need to \"shrink\" the image\nset_store_value(imageCropRectOrigin,$imageCropRectOrigin=undefined,$imageCropRectOrigin);};//\n// moving\n//\nlet interactionCropRect=undefined;let interactionCropRectForce=undefined;const handleImageDragStart=()=>{interactionCropRectForce=undefined;set_store_value(isInteracting,$isInteracting=true,$isInteracting);interactionCropRect=rectClone($imageCropRect);};const handleImageDrag=({detail})=>manipulateImage(detail);const handleImageDragEnd=({detail})=>{// done interacting\nset_store_value(isInteracting,$isInteracting=false,$isInteracting);// apply translation to the crop rect only if did make changes\nif(vectorLength(detail.translation)>0||detail.scalar!==0){manipulateImage(detail);history.write();}// no intent (needs to be set before crop rect is updated)\nset_store_value(imageCropRectIntent,$imageCropRectIntent=undefined,$imageCropRectIntent);// now done\ninteractionCropRect=undefined;};const handleImageDragRelease=({detail})=>{interactionCropRectForce=detail.translation;set_store_value(isInteracting,$isInteracting=false,$isInteracting);};const manipulateImage=({translation,scalar})=>{const imageSelectionRectZoomFactor=Math.min($imageSelectionRect.width/$imageCropRect.width,$imageSelectionRect.height/$imageCropRect.height);const scaledTranslation=vectorMultiply(vectorClone(translation),1/imageSelectionRectZoomFactor);// while we're interacting we apply changes to the original crop rectangle, after we apply a force\nlet cropIntent;if(!interactionCropRectForce){cropIntent=rectTranslate(rectClone(interactionCropRect),vectorInvert(vectorClone(scaledTranslation)));if(scalar!==undefined){rectScale(cropIntent,1-scalar);}}else{// we apply the force to the existing crop rect so animation is not borked\nconst forceTranslation=vectorSubtract(vectorClone(interactionCropRectForce),translation);interactionCropRectForce=translation;cropIntent=rectTranslate(rectClone($imageCropRect),forceTranslation);}// update crop rect\nset_store_value(imageCropRectIntent,$imageCropRectIntent=cropIntent,$imageCropRectIntent);// auto calculates an elastic effect if bounds exceeded (needs to be set before crop rect is updated)\nset_store_value(imageCropRect,$imageCropRect=cropIntent,$imageCropRect);// auto limits to bounds if needed\n};//\n// resizing with range input\n//\nconst calculateZoomLevel=(imageSize,size,imageRotation)=>{if(isRotatedSideways(imageRotation)){return 1-1/Math.min(imageSize.height/size.width,imageSize.width/size.height);}return 1-1/Math.min(imageSize.width/size.width,imageSize.height/size.height);};const imageCropRangeAspectRatio=derived([imageCropRange,imageCropRect],([$imageCropRange,$imageCropRect],set)=>{if(!$imageCropRect)return;const[minSize,maxSize]=$imageCropRange;const aspectRatio=rectAspectRatio($imageCropRect);set([sizeCreateFromRect(rectApply(rectCoverRect(minSize,aspectRatio),fixPrecision)),sizeCreateFromRect(rectApply(rectContainRect(maxSize,aspectRatio),fixPrecision))]);});component_subscribe($$self,imageCropRangeAspectRatio,value=>$$invalidate(131,$imageCropRangeAspectRatio=value));// this is the max value range that can be set (triggers white range indicator bar)\nconst imageZoomLevelRange=derived([imageSize,imageCropLimitToImage,imageCropMinSize,imageCropMaxSize,imageCropRange,imageRotation],([$imageSize,$imageCropLimitToImage,$imageCropMinSize,$imageCropMaxSize,$imageCropRange,$imageRotation],set)=>{if(!$imageSize)return;const rangeMinSize=$imageCropRange[0];const rangeMaxSize=$imageCropRange[1];let minZoom;let maxZoom;// can't zoom out\nif($imageCropLimitToImage){minZoom=calculateZoomLevel($imageSize,rangeMaxSize,$imageRotation);maxZoom=Math.min(rangeMinSize.width/$imageCropMinSize.width,rangeMinSize.height/$imageCropMinSize.height);}else{maxZoom=1;minZoom=-1;}const range=[fixPrecision(minZoom),fixPrecision(maxZoom)];set(range);});component_subscribe($$self,imageZoomLevelRange,value=>$$invalidate(27,$imageZoomLevelRange=value));const imageZoomLevel=derived([imageSize,imageCropRect,imageCropRange,imageRotation],([$imageSize,$imageCropRect,$imageCropRange,$imageRotation],set)=>{// need to check if this value is set, could be that it's empty while loading a new image\nif(!$imageSize||!$imageCropRect)return set(0);let z;const rangeMinSize=$imageCropRange[0];const rangeMaxSize=$imageCropRange[1];const currentCropWidth=$imageCropRect.width;const currentCropHeight=$imageCropRect.height;const currentCropAspectRatio=rectAspectRatio($imageCropRect);const imageRect=isRotatedSideways($imageRotation)?sizeCreate($imageSize.height,$imageSize.width):$imageSize;const imageCropMaxRect=rectContainRect(imageRect,currentCropAspectRatio);if(currentCropWidth<=imageCropMaxRect.width||currentCropHeight<=imageCropMaxRect.height){// zoomed in\nconst w=imageCropMaxRect.width-rangeMinSize.width;const h=imageCropMaxRect.height-rangeMinSize.height;// cannot zoom in\nif(w===0||h===0){z=1;}else{z=1-Math.min((currentCropWidth-rangeMinSize.width)/w,(currentCropHeight-rangeMinSize.height)/h);}}else{// zoomed out\nconst w=rangeMaxSize.width-imageCropMaxRect.width;const h=rangeMaxSize.height-imageCropMaxRect.height;const r=rectContainRect({width:w,height:h},currentCropAspectRatio);z=-Math.min((currentCropWidth-imageCropMaxRect.width)/r.width,(currentCropHeight-imageCropMaxRect.height)/r.height);}set(z);});component_subscribe($$self,imageZoomLevel,value=>$$invalidate(28,$imageZoomLevel=value));const snapshotCropRect=()=>{interactionCropRect=rectClone($imageCropRect);};const resizeImage=zoom=>{const aspectRatio=rectAspectRatio(interactionCropRect);let targetWidth;let targetHeight;let r;const imageRect=isRotatedSideways($imageRotation)?sizeCreate($imageSize.height,$imageSize.width):$imageSize;const imageCropMaxRect=rectContainRect(imageRect,aspectRatio);if(zoom>=0){// zoom in\nconst rangeWidth=imageCropMaxRect.width-$imageCropRange[0].width;const rangeHeight=imageCropMaxRect.height-$imageCropRange[0].height;targetWidth=imageCropMaxRect.width-rangeWidth*zoom;targetHeight=imageCropMaxRect.height-rangeHeight*zoom;r=rectCoverRect({width:targetWidth,height:targetHeight},aspectRatio);}else{// zoom out\nconst rangeWidth=$imageCropRange[1].width-imageCropMaxRect.width;const rangeHeight=$imageCropRange[1].height-imageCropMaxRect.height;targetWidth=imageCropMaxRect.width+rangeWidth*-zoom;targetHeight=imageCropMaxRect.height+rangeHeight*-zoom;r=rectContainRect({width:targetWidth,height:targetHeight},aspectRatio);}targetWidth=r.width;targetHeight=r.height;const targetX=interactionCropRect.x+interactionCropRect.width*0.5-targetWidth*0.5;const targetY=interactionCropRect.y+interactionCropRect.height*0.5-targetHeight*0.5;set_store_value(imageCropRect,$imageCropRect={x:targetX,y:targetY,width:targetWidth,height:targetHeight},$imageCropRect);};const handleResizeStart=()=>{// now interacting with view\nset_store_value(isInteracting,$isInteracting=true,$isInteracting);snapshotCropRect();};const handleResizeMove=value=>{// value range from 0 (no zoom) to 1 (100% zoom, 1x1 pixel)\nresizeImage(value);};const handleResizeEnd=value=>{resizeImage(value);history.write();// we're done interacting\nset_store_value(isInteracting,$isInteracting=false,$isInteracting);// now done\ninteractionCropRect=undefined;};//\n// resizing with wheel\n//\nlet zoomHistoryTimeoutId;const handleWheel=e=>{const stageWheelPosition=getEventPositionInStage(e,$rootRect,$stageRect);// only block input if wheel is used within image rectangle\nif(cropEnableLimitWheelInputToCropSelection&&!rectContainsPoint($imageSelectionRect,stageWheelPosition))return;// now interacting\nset_store_value(isInteracting,$isInteracting=true,$isInteracting);// don't run default actions, prevent other actions from running\ne.preventDefault();e.stopPropagation();// get current crop rect\nconst currentCropRect=rectClone($imageCropRect);// convert wheel delta to scalar\nconst delta=getWheelDelta(e);const scalar=1+delta/100;// if already zoomed in, block further zoom in instructions\nconst isMinSize=Math.min($imageCropRect.width/$imageCropMinSize.width,$imageCropRect.height/$imageCropMinSize.height)===1;// if is fully zoomed out and trying to zoom out more and crop shape is free, fit image aspect ratio\nif(cropEnableZoomMatchImageAspectRatio&&$imageCropLimitToImage){const isAtMaxCropSize=isCropMaxSize($imageCropRect,$imageSize,$imageRotation);if(isCustomCrop()&&isAtMaxCropSize&&delta>0&&isImageSelectionCentered){set_store_value(isInteracting,$isInteracting=false,$isInteracting);const newCropRect=isRotatedSideways($imageRotation)?rectCreateFromSize({height:$imageSize.width,width:$imageSize.height}):rectCreateFromSize($imageSize);// no change, exit\nif(rectEqual(currentCropRect,newCropRect))return;// if we were previously zooming in we need to clear the timeout to prevent two history entries\nclearTimeout(zoomHistoryTimeoutId);// test if crop rect in history is same as new crop rect, this is possible when zooming in and out real quick\nif(rectEqual(history.state.crop,newCropRect))return;// store new crop rect\nset_store_value(imageCropRect,$imageCropRect=newCropRect,$imageCropRect);history.write();return;}}// by default when zooming, zoom from center of crop rectangle\nlet origin=rectCenter($imageCropRect);// when zooming in, zoom in on the part of the image below the mouse cursor\nif(cropEnableZoomTowardsWheelPosition&&delta<0&&!isMinSize){const selectionOffset=vectorSubtract(vectorClone(stageWheelPosition),$imageSelectionRect);const imageSelectionScale=Math.min($imageSelectionRect.width/$imageCropRect.width,$imageSelectionRect.height/$imageCropRect.height);// if wheel is inside image selection rectangle (slightly expanded version), we zoom based on position in the rectangle, if not, we use the selection center\nconst expandedImageSelection=rectScale(rectClone($imageSelectionRect),1.1);origin=rectContainsPoint(expandedImageSelection,stageWheelPosition)?vectorAdd(rectClone($imageCropRect),vectorMultiply(selectionOffset,1/imageSelectionScale)):origin;}let newCropRect=rectScale(rectClone($imageCropRect),scalar,origin);// determin if is new crop rect exceeds min or max size, if so, limit\nif(!sizeContains($imageCropRangeAspectRatio[1],newCropRect)){// exceeds max size, limit to max size and position at new crop rect center\nnewCropRect=rectCreateWithCenter(rectCenter(newCropRect),$imageCropRangeAspectRatio[1]);}if(!sizeContains(newCropRect,$imageCropRangeAspectRatio[0])){// exceeds min size, limit to min size and position at new crop rect center\nnewCropRect=rectCreateWithCenter(rectCenter(newCropRect),$imageCropRangeAspectRatio[0]);}// no change, exit\nif(rectEqual(currentCropRect,newCropRect,fixPrecision)){set_store_value(isInteracting,$isInteracting=false,$isInteracting);return;}// attempt to update the rectangle, we use fixPrecision so the width and height are nice integers when at max zoom (this makes sure the `isMinSize` variable is set to true at this point)\nset_store_value(imageCropRect,$imageCropRect=rectApply(newCropRect,v=>fixPrecision(v,5)),$imageCropRect);// done!\nset_store_value(isInteracting,$isInteracting=false,$isInteracting);// write history timer\nclearTimeout(zoomHistoryTimeoutId);zoomHistoryTimeoutId=setTimeout(()=>{history.write();},500);};//\n// recenter\n//\n// the 'measure' event triggers the editor to center and scale up the crop\nconst dispatch=createEventDispatcher();const handleRecenterAction=()=>{dispatch(\"measure\",rectClone($utilRect));};// auto recenter after timeout\nlet cropAutoCenterImageSelectionTimeoutId;// animations\nconst recenterOpacity=spring(0,{precision:0.0001});component_subscribe($$self,recenterOpacity,value=>$$invalidate(24,$recenterOpacity=value));const recenterOffset=spring();component_subscribe($$self,recenterOffset,value=>$$invalidate(25,$recenterOffset=value));const footerOffset=spring(0);component_subscribe($$self,footerOffset,value=>$$invalidate(146,$footerOffset=value));//\n// crop selection presets\n//\nconst selectedPresetIndex=derived([imageCropAspectRatio,imageOutputSize],([$cropAspectRatio,$imageOutputSize],set)=>{if(!cropSelectPresetOptions)return;const options=flattenOptions(cropSelectPresetOptions);const matchedOptionValue=[...options].// to value\nmap(option=>option[0]).// sort sizes first\nsort((a,b)=>{if(isArray(a[0])&&!isArray(b[0]))return 1;return-1;}).// match value\nfind(value=>{if(isArray(value)&&$imageOutputSize){// size + aspect ratio\nconst[width,height]=value;const outputSizeMatches=$imageOutputSize.width===width&&$imageOutputSize.height===height;const aspectRatioMatches=$cropAspectRatio===getAspectRatio(width,height);return outputSizeMatches&&aspectRatioMatches;}// aspect ratio\nreturn value===$cropAspectRatio;});const index=options.// to value\nmap(option=>option[0]).// find index of matching value\nfindIndex(value=>isArray(value)?arrayEqual(value,matchedOptionValue):value===matchedOptionValue);set(index);});component_subscribe($$self,selectedPresetIndex,value=>$$invalidate(115,$selectedPresetIndex=value));const getSelectionPresetLabelIcon=selectedIndex=>{if(!cropSelectPresetOptions)return;const selectedValue=flattenOptions(cropSelectPresetOptions)[selectedIndex][0];const aspectRatio=!selectedValue?undefined:isArray(selectedValue)?getAspectRatio(selectedValue[0],selectedValue[1]):selectedValue;const[a,b,c]=!aspectRatio?[0.2,0.3,0.4]:[aspectRatio<1?1:0.3,aspectRatio===1?0.85:0.5,aspectRatio>1?1:0.3];return`<g fill=\"currentColor\">\n        <rect opacity=\"${a}\" x=\"2\" y=\"4\" width=\"10\" height=\"18\" rx=\"1\"/>\n        <rect opacity=\"${b}\" x=\"4\" y=\"8\" width=\"14\" height=\"14\" rx=\"1\"/>\n        <rect opacity=\"${c}\" x=\"6\" y=\"12\" width=\"17\" height=\"10\" rx=\"1\"/>\n    </g>`;};//\n// crop boundary\n//\nconst getCropBoundaryLabelIcon=isBoundToImage=>{const[a,b,c,d]=isBoundToImage?[0.3,1,0,0]:[0,0,0.3,1];return`<g fill=\"currentColor\">\n        <rect opacity=\"${a}\" x=\"2\" y=\"3\" width=\"20\" height=\"20\" rx=\"1\"/>\n        <rect opacity=\"${b}\" x=\"7\" y=\"8\" width=\"10\" height=\"10\" rx=\"1\"/>\n        <rect opacity=\"${c}\" x=\"4\" y=\"8\" width=\"14\" height=\"14\" rx=\"1\"/>\n        <rect opacity=\"${d}\" x=\"12\" y=\"4\" width=\"10\" height=\"10\" rx=\"1\"/>\n    </g>`;};const cropUniqueId=`crop-${getUniqueId()}`;let transformInitial=cropEnableRotationInput?\"rotation\":\"zoom\";let transformToolInitial=cropUniqueId+\"-\"+transformInitial;let transformSelected=transformToolInitial;let root=undefined;function measure_handler_1(event){bubble($$self,event);}const interactable_function=e=>getEventPositionInViewport(e);const select_handler=({detail})=>$$invalidate(5,transformSelected=detail);function util_root_binding(value){root=value;$$invalidate(6,root);}function measure_handler(event){bubble($$self,event);}$$self.$$set=$$props=>{if(\"isActive\"in $$props)$$subscribe_isActive($$invalidate(1,isActive=$$props.isActive));if(\"stores\"in $$props)$$invalidate(80,stores=$$props.stores);if(\"cropImageSelectionCornerStyle\"in $$props)$$invalidate(2,cropImageSelectionCornerStyle=$$props.cropImageSelectionCornerStyle);if(\"cropAutoCenterImageSelectionTimeout\"in $$props)$$invalidate(81,cropAutoCenterImageSelectionTimeout=$$props.cropAutoCenterImageSelectionTimeout);if(\"cropEnableZoomMatchImageAspectRatio\"in $$props)$$invalidate(82,cropEnableZoomMatchImageAspectRatio=$$props.cropEnableZoomMatchImageAspectRatio);if(\"cropEnableRotateMatchImageAspectRatio\"in $$props)$$invalidate(83,cropEnableRotateMatchImageAspectRatio=$$props.cropEnableRotateMatchImageAspectRatio);if(\"cropEnableRotationInput\"in $$props)$$invalidate(84,cropEnableRotationInput=$$props.cropEnableRotationInput);if(\"cropEnableZoom\"in $$props)$$invalidate(3,cropEnableZoom=$$props.cropEnableZoom);if(\"cropEnableZoomInput\"in $$props)$$invalidate(85,cropEnableZoomInput=$$props.cropEnableZoomInput);if(\"cropEnableImageSelection\"in $$props)$$invalidate(86,cropEnableImageSelection=$$props.cropEnableImageSelection);if(\"cropEnableInfoIndicator\"in $$props)$$invalidate(87,cropEnableInfoIndicator=$$props.cropEnableInfoIndicator);if(\"cropEnableZoomTowardsWheelPosition\"in $$props)$$invalidate(88,cropEnableZoomTowardsWheelPosition=$$props.cropEnableZoomTowardsWheelPosition);if(\"cropEnableLimitWheelInputToCropSelection\"in $$props)$$invalidate(89,cropEnableLimitWheelInputToCropSelection=$$props.cropEnableLimitWheelInputToCropSelection);if(\"cropEnableCenterImageSelection\"in $$props)$$invalidate(90,cropEnableCenterImageSelection=$$props.cropEnableCenterImageSelection);if(\"cropEnableButtonRotateLeft\"in $$props)$$invalidate(91,cropEnableButtonRotateLeft=$$props.cropEnableButtonRotateLeft);if(\"cropEnableButtonRotateRight\"in $$props)$$invalidate(92,cropEnableButtonRotateRight=$$props.cropEnableButtonRotateRight);if(\"cropEnableButtonFlipHorizontal\"in $$props)$$invalidate(93,cropEnableButtonFlipHorizontal=$$props.cropEnableButtonFlipHorizontal);if(\"cropEnableButtonFlipVertical\"in $$props)$$invalidate(94,cropEnableButtonFlipVertical=$$props.cropEnableButtonFlipVertical);if(\"cropSelectPresetOptions\"in $$props)$$invalidate(95,cropSelectPresetOptions=$$props.cropSelectPresetOptions);if(\"cropEnableSelectPreset\"in $$props)$$invalidate(96,cropEnableSelectPreset=$$props.cropEnableSelectPreset);if(\"cropEnableButtonToggleCropLimit\"in $$props)$$invalidate(97,cropEnableButtonToggleCropLimit=$$props.cropEnableButtonToggleCropLimit);if(\"locale\"in $$props)$$invalidate(4,locale=$$props.locale);if(\"tools\"in $$props)$$invalidate(0,tools=$$props.tools);};let imageZoomLevelMin;let imageSelectionOffset;let imageSelectionCenter;let imageSelectionCenteredRect;let isImageSelectionDisplayed;let isImageSelectionCentered;let isResizingSelection;let isMaxSelectionRect;let isOverlayMode;let canZoomToCenter;let canCenter;let shouldRenderInfoIndicator;let shouldRenderImageSelection;let shouldRenderImageSelectionRecenterButton;let imageSelectionRectOffset;let shouldRenderPresetSelect;let hasPlentyVerticalSpace;let shouldRenderToolbar;let shouldRenderZoomInput;let shouldRenderFooter;let shouldRenderTabs;let tabsConfig;let tabs;let panels;let footerStyle;$$self.$$.update=()=>{if($$self.$$.dirty[4]&/*$env*/65536){$$invalidate(139,isOverlayMode=$env.layoutMode===\"overlay\");}if($$self.$$.dirty[3]&/*cropEnableSelectPreset*/8|$$self.$$.dirty[4]&/*isOverlayMode*/32768){//\n// Transform tabs\n//\n$$invalidate(114,shouldRenderPresetSelect=cropEnableSelectPreset&&!isOverlayMode);}if($$self.$$.dirty[3]&/*$imageSelectionRect*/536870912|$$self.$$.dirty[4]&/*$utilRect*/4){// determine if we can center the crop, if we can, show the crop center button\n$$invalidate(135,imageSelectionCenteredRect=$utilRect&&$imageSelectionRect&&rectCenterRect($utilRect,$imageSelectionRect));}if($$self.$$.dirty[3]&/*$imageSelectionRect*/536870912|$$self.$$.dirty[4]&/*imageSelectionCenteredRect*/2048){$$invalidate(136,isImageSelectionDisplayed=!!($imageSelectionRect&&imageSelectionCenteredRect));}if($$self.$$.dirty[3]&/*$imageSelectionRect*/536870912|$$self.$$.dirty[4]&/*isImageSelectionDisplayed, imageSelectionCenteredRect*/6144){$$invalidate(117,isImageSelectionCentered=isImageSelectionDisplayed&&rectEqual($imageSelectionRect,imageSelectionCenteredRect,value=>fixPrecision(value,5)));}if($$self.$$.dirty[0]&/*locale, $imageRotation*/272|$$self.$$.dirty[2]&/*cropEnableButtonRotateLeft, cropEnableButtonRotateRight*/1610612736|$$self.$$.dirty[3]&/*cropEnableButtonFlipHorizontal, $imageFlipY, $imageFlipX, cropEnableButtonFlipVertical, shouldRenderPresetSelect, cropSelectPresetOptions, $selectedPresetIndex, isImageSelectionCentered, $imageSize, $imageCropMinSize, cropEnableButtonToggleCropLimit, $imageCropLimitToImage*/125566999){$$invalidate(0,tools=[cropEnableButtonRotateLeft&&[Button,\"rotate-left\",{label:locale.cropLabelButtonRotateLeft,labelClass:\"DokaToolbarContentWide\",icon:locale.cropIconButtonRotateLeft,onclick:()=>{applyRotation(-Math.PI/2);history.write();}}],cropEnableButtonRotateRight&&[Button,\"rotate-right\",{label:locale.cropLabelButtonRotateRight,labelClass:\"DokaToolbarContentWide\",icon:locale.cropIconButtonRotateRight,onclick:()=>{applyRotation(Math.PI/2);history.write();}}],cropEnableButtonFlipHorizontal&&[Button,\"flip-horizontal\",{label:locale.cropLabelButtonFlipHorizontal,labelClass:\"DokaToolbarContentWide\",icon:locale.cropIconButtonFlipHorizontal,onclick:()=>{if(isRotatedSideways($imageRotation)){set_store_value(imageFlipY,$imageFlipY=!$imageFlipY,$imageFlipY);}else{set_store_value(imageFlipX,$imageFlipX=!$imageFlipX,$imageFlipX);}history.write();}}],cropEnableButtonFlipVertical&&[Button,\"flip-vertical\",{label:locale.cropLabelButtonFlipVertical,labelClass:\"DokaToolbarContentWide\",icon:locale.cropIconButtonFlipVertical,onclick:()=>{if(isRotatedSideways($imageRotation)){set_store_value(imageFlipX,$imageFlipX=!$imageFlipX,$imageFlipX);}else{set_store_value(imageFlipY,$imageFlipY=!$imageFlipY,$imageFlipY);}history.write();}}],shouldRenderPresetSelect&&cropSelectPresetOptions&&[Dropdown,\"select-preset\",{icon:getSelectionPresetLabelIcon($selectedPresetIndex),label:locale.cropLabelSelectPreset,labelClass:\"DokaToolbarContentWide\",options:cropSelectPresetOptions,selectedIndex:$selectedPresetIndex,onchange:({value})=>{if(isArray(value)){set_store_value(imageCropAspectRatio,$imageCropAspectRatio=getAspectRatio(value[0],value[1]),$imageCropAspectRatio);set_store_value(imageOutputSize,$imageOutputSize=sizeCreateFromArray(value),$imageOutputSize);}else{set_store_value(imageCropAspectRatio,$imageCropAspectRatio=value,$imageCropAspectRatio);}if(isImageSelectionCentered){handleRecenterAction();}history.write();},optionMapper:option=>{// if no aspect ratio found we enable the option by default\nlet disabled=false;// get aspect ratio for this option\nconst optionAspectRatio=isArray(option.value)?option.value[0]/option.value[1]:option.value;// can be undefined in which case we don't need to check anything\nif(optionAspectRatio){const maxCropSize=getMaxSizeInRect($imageSize,$imageRotation,optionAspectRatio);disabled=maxCropSize.width<$imageCropMinSize.width||maxCropSize.height<$imageCropMinSize.height;}// add icon for this option\noption.icon=getSelectionPresetOptionIcon(option.value,{bounds:14});return _objectSpread(_objectSpread({},option),{},{disabled});}}],cropEnableButtonToggleCropLimit&&[Dropdown,\"select-crop-limit\",{icon:getCropBoundaryLabelIcon($imageCropLimitToImage),label:locale.cropLabelCropBoundary,labelClass:\"DokaToolbarContentWide\",onchange:({value})=>{set_store_value(imageCropLimitToImage,$imageCropLimitToImage=value,$imageCropLimitToImage);history.write();},options:[[true,locale.cropLabelCropBoundaryEdge,{icon:getCropBoundaryLabelIcon(true)}],[false,locale.cropLabelCropBoundaryNone,{icon:getCropBoundaryLabelIcon(false)}]]}]]);}if($$self.$$.dirty[3]&/*$imageCropLimitToImage*/67108864){$$invalidate(9,imageZoomLevelMin=$imageCropLimitToImage?0:-1);}if($$self.$$.dirty[4]&/*$utilRect, $stageRect*/68){$$invalidate(132,imageSelectionOffset=$utilRect&&vectorCreate(-($stageRect.x-$utilRect.x),-($stageRect.y-$utilRect.y)));}if($$self.$$.dirty[4]&/*$imageSelectionRectPresentation, imageSelectionOffset*/1280){// normalized crop bounds, we use these to limit the crop interactions to the view\n$$invalidate(133,imageSelectionCenter=$imageSelectionRectPresentation&&vectorCreate(snapToPixel($imageSelectionRectPresentation.x+$imageSelectionRectPresentation.width*0.5+imageSelectionOffset.x),snapToPixel($imageSelectionRectPresentation.y+$imageSelectionRectPresentation.height*0.5+imageSelectionOffset.y)));}if($$self.$$.dirty[3]&/*$imageSelectionRectSnapshot*/268435456){$$invalidate(137,isResizingSelection=$imageSelectionRectSnapshot!=null);}if($$self.$$.dirty[4]&/*$utilRect, imageSelectionCenteredRect*/2052){$$invalidate(138,isMaxSelectionRect=$utilRect&&imageSelectionCenteredRect&&(imageSelectionCenteredRect.height===$utilRect.height||imageSelectionCenteredRect.width===$utilRect.width));}if($$self.$$.dirty[3]&/*$presentationScalar*/1073741824|$$self.$$.dirty[4]&/*isMaxSelectionRect, $imageScalar*/278528){$$invalidate(141,canZoomToCenter=!isMaxSelectionRect&&$presentationScalar<1&&$imageScalar<1);}if($$self.$$.dirty[3]&/*isImageSelectionCentered*/16777216|$$self.$$.dirty[4]&/*isImageSelectionDisplayed, isResizingSelection, canZoomToCenter*/143360){$$invalidate(11,canCenter=isImageSelectionDisplayed&&!isResizingSelection&&(!isImageSelectionCentered||canZoomToCenter));}if($$self.$$.dirty[0]&/*$imageCropRect*/128|$$self.$$.dirty[2]&/*cropEnableInfoIndicator*/33554432|$$self.$$.dirty[4]&/*isOverlayMode*/32768){$$invalidate(12,shouldRenderInfoIndicator=cropEnableInfoIndicator&&!!$imageCropRect&&!isOverlayMode);}if($$self.$$.dirty[4]&/*$imageSelectionRectPresentation, imageSelectionOffset*/1280){$$invalidate(14,imageSelectionRectOffset=$imageSelectionRectPresentation&&imageSelectionOffset&&{x:$imageSelectionRectPresentation.x+imageSelectionOffset.x,y:$imageSelectionRectPresentation.y+imageSelectionOffset.y,width:$imageSelectionRectPresentation.width,height:$imageSelectionRectPresentation.height});}if($$self.$$.dirty[0]&/*imageSelectionRectOffset*/16384|$$self.$$.dirty[2]&/*cropEnableImageSelection*/16777216|$$self.$$.dirty[4]&/*isOverlayMode*/32768){$$invalidate(13,shouldRenderImageSelection=cropEnableImageSelection&&!!imageSelectionRectOffset&&!isOverlayMode);}if($$self.$$.dirty[2]&/*cropEnableCenterImageSelection, cropAutoCenterImageSelectionTimeout*/268959744|$$self.$$.dirty[4]&/*imageSelectionCenter*/512){$$invalidate(15,shouldRenderImageSelectionRecenterButton=cropEnableCenterImageSelection&&!!imageSelectionCenter&&!cropAutoCenterImageSelectionTimeout);}if($$self.$$.dirty[0]&/*canCenter*/2048|$$self.$$.dirty[2]&/*cropAutoCenterImageSelectionTimeout*/524288|$$self.$$.dirty[3]&/*$isInteracting, cropAutoCenterImageSelectionTimeoutId*/134283264){if(canCenter&&cropAutoCenterImageSelectionTimeout&&!$isInteracting){clearTimeout(cropAutoCenterImageSelectionTimeoutId);$$invalidate(109,cropAutoCenterImageSelectionTimeoutId=setTimeout(handleRecenterAction,cropAutoCenterImageSelectionTimeout));}}if($$self.$$.dirty[3]&/*$isInteracting, cropAutoCenterImageSelectionTimeoutId*/134283264){if($isInteracting)clearTimeout(cropAutoCenterImageSelectionTimeoutId);}if($$self.$$.dirty[0]&/*canCenter*/2048){recenterOpacity.set(canCenter?1:0);}if($$self.$$.dirty[4]&/*imageSelectionCenter*/512){recenterOffset.set(imageSelectionCenter);}if($$self.$$.dirty[0]&/*$isActive*/65536){footerOffset.set($isActive?0:20);}if($$self.$$.dirty[0]&/*$isActive*/65536|$$self.$$.dirty[4]&/*$imagePreviewModifiers*/524288){//\n// enable seeing the image outside of the crop area, and disable the vignette effect\n// \nif($isActive){set_store_value(imagePreviewModifiers,$imagePreviewModifiers[\"crop\"]={maskOpacity:0.85,maskMarkupOpacity:0.85},$imagePreviewModifiers);}else{delete $imagePreviewModifiers[\"crop\"];}}if($$self.$$.dirty[4]&/*isOverlayMode, $env*/98304){$$invalidate(144,hasPlentyVerticalSpace=isOverlayMode?false:$env.verticalSpace!==\"short\");}if($$self.$$.dirty[4]&/*hasPlentyVerticalSpace*/1048576){$$invalidate(17,shouldRenderToolbar=hasPlentyVerticalSpace);}if($$self.$$.dirty[0]&/*cropEnableZoom*/8|$$self.$$.dirty[2]&/*cropEnableZoomInput*/8388608|$$self.$$.dirty[4]&/*hasPlentyVerticalSpace*/1048576){$$invalidate(145,shouldRenderZoomInput=cropEnableZoom&&cropEnableZoomInput&&hasPlentyVerticalSpace);}if($$self.$$.dirty[2]&/*cropEnableRotationInput*/4194304|$$self.$$.dirty[4]&/*shouldRenderZoomInput*/2097152){$$invalidate(18,shouldRenderFooter=cropEnableRotationInput||shouldRenderZoomInput);}if($$self.$$.dirty[2]&/*cropEnableRotationInput*/4194304|$$self.$$.dirty[4]&/*shouldRenderZoomInput*/2097152){$$invalidate(19,shouldRenderTabs=cropEnableRotationInput&&shouldRenderZoomInput);}if($$self.$$.dirty[4]&/*shouldRenderZoomInput*/2097152){if(!shouldRenderZoomInput){$$invalidate(5,transformSelected=transformToolInitial);}}if($$self.$$.dirty[0]&/*transformSelected*/32){$$invalidate(20,tabsConfig={name:cropUniqueId,selected:transformSelected});}if($$self.$$.dirty[0]&/*locale*/16){$$invalidate(21,tabs=[{id:cropUniqueId+\"-rotation\",label:locale.cropLabelTabRotation},{id:cropUniqueId+\"-zoom\",label:locale.cropLabelTabZoom}]);}if($$self.$$.dirty[0]&/*tabs*/2097152){$$invalidate(22,panels=tabs.map(tab=>tab.id));}if($$self.$$.dirty[4]&/*$footerOffset*/4194304){$$invalidate(23,footerStyle=$footerOffset?`transform: translateY(${$footerOffset}px)`:undefined);}};return[tools,isActive,cropImageSelectionCornerStyle,cropEnableZoom,locale,transformSelected,root,$imageCropRect,$imageRotation,imageZoomLevelMin,$rootRect,canCenter,shouldRenderInfoIndicator,shouldRenderImageSelection,imageSelectionRectOffset,shouldRenderImageSelectionRecenterButton,$isActive,shouldRenderToolbar,shouldRenderFooter,shouldRenderTabs,tabsConfig,tabs,panels,footerStyle,$recenterOpacity,$recenterOffset,$imageRotationRange,$imageZoomLevelRange,$imageZoomLevel,env,isInteracting,rootRect,stageRect,utilRect,elasticityMultiplier,rangeInputElasticity,presentationScalar,imagePreviewModifiers,imageFlipX,imageFlipY,imageRotation,imageRotationRange,imageOutputSize,imageSelectionRect,imageSelectionRectSnapshot,imageSelectionRectIntent,imageSelectionRectPresentation,imageCropRectIntent,imageCropRectOrigin,imageCropRect,imageCropMinSize,imageCropMaxSize,imageCropRange,imageCropAspectRatio,imageCropLimitToImage,imageSize,imageScalar,handleSelectionGrab,handleSelectionDrag,handleSelectionRelease,handleRotateStart,handleRotateMove,handleRotateEnd,handleImageDragStart,handleImageDrag,handleImageDragEnd,handleImageDragRelease,imageCropRangeAspectRatio,imageZoomLevelRange,imageZoomLevel,handleResizeStart,handleResizeMove,handleResizeEnd,handleWheel,handleRecenterAction,recenterOpacity,recenterOffset,footerOffset,selectedPresetIndex,name,stores,cropAutoCenterImageSelectionTimeout,cropEnableZoomMatchImageAspectRatio,cropEnableRotateMatchImageAspectRatio,cropEnableRotationInput,cropEnableZoomInput,cropEnableImageSelection,cropEnableInfoIndicator,cropEnableZoomTowardsWheelPosition,cropEnableLimitWheelInputToCropSelection,cropEnableCenterImageSelection,cropEnableButtonRotateLeft,cropEnableButtonRotateRight,cropEnableButtonFlipHorizontal,cropEnableButtonFlipVertical,cropSelectPresetOptions,cropEnableSelectPreset,cropEnableButtonToggleCropLimit,measure_handler_1,interactable_function,select_handler,util_root_binding,measure_handler];}class Crop extends SvelteComponent{constructor(options){super();init(this,options,instance$r,create_fragment$r,safe_not_equal,{name:79,isActive:1,stores:80,cropImageSelectionCornerStyle:2,cropAutoCenterImageSelectionTimeout:81,cropEnableZoomMatchImageAspectRatio:82,cropEnableRotateMatchImageAspectRatio:83,cropEnableRotationInput:84,cropEnableZoom:3,cropEnableZoomInput:85,cropEnableImageSelection:86,cropEnableInfoIndicator:87,cropEnableZoomTowardsWheelPosition:88,cropEnableLimitWheelInputToCropSelection:89,cropEnableCenterImageSelection:90,cropEnableButtonRotateLeft:91,cropEnableButtonRotateRight:92,cropEnableButtonFlipHorizontal:93,cropEnableButtonFlipVertical:94,cropSelectPresetOptions:95,cropEnableSelectPreset:96,cropEnableButtonToggleCropLimit:97,locale:4,tools:0},[-1,-1,-1,-1,-1,-1]);}get name(){return this.$$.ctx[79];}get isActive(){return this.$$.ctx[1];}set isActive(isActive){this.$set({isActive});flush();}get stores(){return this.$$.ctx[80];}set stores(stores){this.$set({stores});flush();}get cropImageSelectionCornerStyle(){return this.$$.ctx[2];}set cropImageSelectionCornerStyle(cropImageSelectionCornerStyle){this.$set({cropImageSelectionCornerStyle});flush();}get cropAutoCenterImageSelectionTimeout(){return this.$$.ctx[81];}set cropAutoCenterImageSelectionTimeout(cropAutoCenterImageSelectionTimeout){this.$set({cropAutoCenterImageSelectionTimeout});flush();}get cropEnableZoomMatchImageAspectRatio(){return this.$$.ctx[82];}set cropEnableZoomMatchImageAspectRatio(cropEnableZoomMatchImageAspectRatio){this.$set({cropEnableZoomMatchImageAspectRatio});flush();}get cropEnableRotateMatchImageAspectRatio(){return this.$$.ctx[83];}set cropEnableRotateMatchImageAspectRatio(cropEnableRotateMatchImageAspectRatio){this.$set({cropEnableRotateMatchImageAspectRatio});flush();}get cropEnableRotationInput(){return this.$$.ctx[84];}set cropEnableRotationInput(cropEnableRotationInput){this.$set({cropEnableRotationInput});flush();}get cropEnableZoom(){return this.$$.ctx[3];}set cropEnableZoom(cropEnableZoom){this.$set({cropEnableZoom});flush();}get cropEnableZoomInput(){return this.$$.ctx[85];}set cropEnableZoomInput(cropEnableZoomInput){this.$set({cropEnableZoomInput});flush();}get cropEnableImageSelection(){return this.$$.ctx[86];}set cropEnableImageSelection(cropEnableImageSelection){this.$set({cropEnableImageSelection});flush();}get cropEnableInfoIndicator(){return this.$$.ctx[87];}set cropEnableInfoIndicator(cropEnableInfoIndicator){this.$set({cropEnableInfoIndicator});flush();}get cropEnableZoomTowardsWheelPosition(){return this.$$.ctx[88];}set cropEnableZoomTowardsWheelPosition(cropEnableZoomTowardsWheelPosition){this.$set({cropEnableZoomTowardsWheelPosition});flush();}get cropEnableLimitWheelInputToCropSelection(){return this.$$.ctx[89];}set cropEnableLimitWheelInputToCropSelection(cropEnableLimitWheelInputToCropSelection){this.$set({cropEnableLimitWheelInputToCropSelection});flush();}get cropEnableCenterImageSelection(){return this.$$.ctx[90];}set cropEnableCenterImageSelection(cropEnableCenterImageSelection){this.$set({cropEnableCenterImageSelection});flush();}get cropEnableButtonRotateLeft(){return this.$$.ctx[91];}set cropEnableButtonRotateLeft(cropEnableButtonRotateLeft){this.$set({cropEnableButtonRotateLeft});flush();}get cropEnableButtonRotateRight(){return this.$$.ctx[92];}set cropEnableButtonRotateRight(cropEnableButtonRotateRight){this.$set({cropEnableButtonRotateRight});flush();}get cropEnableButtonFlipHorizontal(){return this.$$.ctx[93];}set cropEnableButtonFlipHorizontal(cropEnableButtonFlipHorizontal){this.$set({cropEnableButtonFlipHorizontal});flush();}get cropEnableButtonFlipVertical(){return this.$$.ctx[94];}set cropEnableButtonFlipVertical(cropEnableButtonFlipVertical){this.$set({cropEnableButtonFlipVertical});flush();}get cropSelectPresetOptions(){return this.$$.ctx[95];}set cropSelectPresetOptions(cropSelectPresetOptions){this.$set({cropSelectPresetOptions});flush();}get cropEnableSelectPreset(){return this.$$.ctx[96];}set cropEnableSelectPreset(cropEnableSelectPreset){this.$set({cropEnableSelectPreset});flush();}get cropEnableButtonToggleCropLimit(){return this.$$.ctx[97];}set cropEnableButtonToggleCropLimit(cropEnableButtonToggleCropLimit){this.$set({cropEnableButtonToggleCropLimit});flush();}get locale(){return this.$$.ctx[4];}set locale(locale){this.$set({locale});flush();}get tools(){return this.$$.ctx[0];}set tools(tools){this.$set({tools});flush();}}// @ts-ignore\nvar index={util:['crop',Crop]};/* src/core/ui/plugins/filter/index.svelte generated by Svelte v3.29.4 */function create_option_slot$2(ctx){let div0;let div1;let measurable_action;let option=/*option*/ctx[61];let t0;let span;let t1_value=(isFunction(/*option*/ctx[61].label)?/*option*/ctx[61].label(/*locale*/ctx[2]):/*option*/ctx[61].label)+\"\";let t1;let mounted;let dispose;function measure_handler_1(...args){return(/*measure_handler_1*/ctx[29](/*option*/ctx[61],...args));}const assign_div1=()=>/*div1_binding*/ctx[30](div1,option);const unassign_div1=()=>/*div1_binding*/ctx[30](null,option);return{c(){div0=element(\"div\");div1=element(\"div\");t0=space();span=element(\"span\");t1=text(t1_value);attr(div1,\"class\",FILTER_PREVIEW_CLASS_NAME);attr(div0,\"slot\",\"option\");attr(div0,\"class\",\"DokaFilterOption\");},m(target,anchor){insert(target,div0,anchor);append(div0,div1);assign_div1();append(div0,t0);append(div0,span);append(span,t1);if(!mounted){dispose=[listen(div1,\"measure\",measure_handler_1),action_destroyer(measurable_action=measurable.call(null,div1))];mounted=true;}},p(new_ctx,dirty){ctx=new_ctx;if(option!==/*option*/ctx[61]){unassign_div1();option=/*option*/ctx[61];assign_div1();}if(dirty[0]&/*locale*/4|dirty[1]&/*option*/1073741824&&t1_value!==(t1_value=(isFunction(/*option*/ctx[61].label)?/*option*/ctx[61].label(/*locale*/ctx[2]):/*option*/ctx[61].label)+\"\"))set_data(t1,t1_value);},d(detaching){if(detaching)detach(div0);unassign_div1();mounted=false;run_all(dispose);}};}// (459:8) <Scrollable              elasticity={elasticityMultiplier * scrollElasticity}              onscroll={offset => tileScrollOffset = offset}              bind:maskFeatherStartOpacity={tileLeftOpacity}             bind:maskFeatherEndOpacity={tileRightOpacity}             bind:maskFeatherSize={tileMargin}             on:measure={e => tileScrollContainerRect = e.detail}>\nfunction create_default_slot_1$5(ctx){let radiogroup;let current;radiogroup=new RadioGroup({props:{locale:/*locale*/ctx[2],layout:\"row\",options:/*filterOptions*/ctx[3],selectedIndex:/*selectedFilterIndex*/ctx[10],onchange:/*handleChangeFilter*/ctx[25],$$slots:{option:[create_option_slot$2,({option})=>({61:option}),({option})=>[0,option?1073741824:0]]},$$scope:{ctx}}});return{c(){create_component(radiogroup.$$.fragment);},m(target,anchor){mount_component(radiogroup,target,anchor);current=true;},p(ctx,dirty){const radiogroup_changes={};if(dirty[0]&/*locale*/4)radiogroup_changes.locale=/*locale*/ctx[2];if(dirty[0]&/*filterOptions*/8)radiogroup_changes.options=/*filterOptions*/ctx[3];if(dirty[0]&/*selectedFilterIndex*/1024)radiogroup_changes.selectedIndex=/*selectedFilterIndex*/ctx[10];if(dirty[0]&/*locale, tileElements*/20|dirty[1]&/*option*/1073741824|dirty[2]&/*$$scope*/1){radiogroup_changes.$$scope={dirty,ctx};}radiogroup.$set(radiogroup_changes);},i(local){if(current)return;transition_in(radiogroup.$$.fragment,local);current=true;},o(local){transition_out(radiogroup.$$.fragment,local);current=false;},d(detaching){destroy_component(radiogroup,detaching);}};}// (458:4) <div slot=\"footer\" style={footerStyle} on:transitionend={handleTransitionEnd}>\nfunction create_footer_slot$1(ctx){let div;let scrollable;let updating_maskFeatherStartOpacity;let updating_maskFeatherEndOpacity;let updating_maskFeatherSize;let current;let mounted;let dispose;function scrollable_maskFeatherStartOpacity_binding(value){/*scrollable_maskFeatherStartOpacity_binding*/ctx[32].call(null,value);}function scrollable_maskFeatherEndOpacity_binding(value){/*scrollable_maskFeatherEndOpacity_binding*/ctx[33].call(null,value);}function scrollable_maskFeatherSize_binding(value){/*scrollable_maskFeatherSize_binding*/ctx[34].call(null,value);}let scrollable_props={elasticity:/*elasticityMultiplier*/ctx[14]*/*scrollElasticity*/ctx[15],onscroll:/*func*/ctx[31],$$slots:{default:[create_default_slot_1$5]},$$scope:{ctx}};if(/*tileLeftOpacity*/ctx[5]!==void 0){scrollable_props.maskFeatherStartOpacity=/*tileLeftOpacity*/ctx[5];}if(/*tileRightOpacity*/ctx[6]!==void 0){scrollable_props.maskFeatherEndOpacity=/*tileRightOpacity*/ctx[6];}if(/*tileMargin*/ctx[7]!==void 0){scrollable_props.maskFeatherSize=/*tileMargin*/ctx[7];}scrollable=new Scrollable({props:scrollable_props});binding_callbacks.push(()=>bind(scrollable,\"maskFeatherStartOpacity\",scrollable_maskFeatherStartOpacity_binding));binding_callbacks.push(()=>bind(scrollable,\"maskFeatherEndOpacity\",scrollable_maskFeatherEndOpacity_binding));binding_callbacks.push(()=>bind(scrollable,\"maskFeatherSize\",scrollable_maskFeatherSize_binding));scrollable.$on(\"measure\",/*measure_handler_2*/ctx[35]);return{c(){div=element(\"div\");create_component(scrollable.$$.fragment);attr(div,\"slot\",\"footer\");attr(div,\"style\",/*footerStyle*/ctx[11]);},m(target,anchor){insert(target,div,anchor);mount_component(scrollable,div,null);current=true;if(!mounted){dispose=listen(div,\"transitionend\",/*handleTransitionEnd*/ctx[23]);mounted=true;}},p(ctx,dirty){const scrollable_changes={};if(dirty[0]&/*tileScrollOffset*/256)scrollable_changes.onscroll=/*func*/ctx[31];if(dirty[0]&/*locale, filterOptions, selectedFilterIndex, tileElements*/1052|dirty[2]&/*$$scope*/1){scrollable_changes.$$scope={dirty,ctx};}if(!updating_maskFeatherStartOpacity&&dirty[0]&/*tileLeftOpacity*/32){updating_maskFeatherStartOpacity=true;scrollable_changes.maskFeatherStartOpacity=/*tileLeftOpacity*/ctx[5];add_flush_callback(()=>updating_maskFeatherStartOpacity=false);}if(!updating_maskFeatherEndOpacity&&dirty[0]&/*tileRightOpacity*/64){updating_maskFeatherEndOpacity=true;scrollable_changes.maskFeatherEndOpacity=/*tileRightOpacity*/ctx[6];add_flush_callback(()=>updating_maskFeatherEndOpacity=false);}if(!updating_maskFeatherSize&&dirty[0]&/*tileMargin*/128){updating_maskFeatherSize=true;scrollable_changes.maskFeatherSize=/*tileMargin*/ctx[7];add_flush_callback(()=>updating_maskFeatherSize=false);}scrollable.$set(scrollable_changes);if(!current||dirty[0]&/*footerStyle*/2048){attr(div,\"style\",/*footerStyle*/ctx[11]);}},i(local){if(current)return;transition_in(scrollable.$$.fragment,local);current=true;},o(local){transition_out(scrollable.$$.fragment,local);current=false;},d(detaching){if(detaching)detach(div);destroy_component(scrollable);mounted=false;dispose();}};}function create_fragment$s(ctx){let util;let current;util=new Util({props:{$$slots:{footer:[create_footer_slot$1]},$$scope:{ctx}}});util.$on(\"measure\",/*measure_handler*/ctx[36]);return{c(){create_component(util.$$.fragment);},m(target,anchor){mount_component(util,target,anchor);current=true;},p(ctx,dirty){const util_changes={};if(dirty[0]&/*footerStyle, tileScrollOffset, tileLeftOpacity, tileRightOpacity, tileMargin, tileScrollContainerRect, locale, filterOptions, selectedFilterIndex, tileElements*/4092|dirty[2]&/*$$scope*/1){util_changes.$$scope={dirty,ctx};}util.$set(util_changes);},i(local){if(current)return;transition_in(util.$$.fragment,local);current=true;},o(local){transition_out(util.$$.fragment,local);current=false;},d(detaching){destroy_component(util,detaching);}};}let FILTER_PREVIEW_CLASS_NAME=\"DokaFilterPreview\";function instance$s($$self,$$props,$$invalidate){let $imageColorMatrix;let $tileRects;let $canvasSize;let $imageTransforms;let $isActive,$$unsubscribe_isActive=noop$1,$$subscribe_isActive=()=>($$unsubscribe_isActive(),$$unsubscribe_isActive=subscribe(isActive,$$value=>$$invalidate(44,$isActive=$$value)),isActive);let $utilRect;let $stageRect;let $imageGamma;let $isActiveFraction,$$unsubscribe_isActiveFraction=noop$1,$$subscribe_isActiveFraction=()=>($$unsubscribe_isActiveFraction(),$$unsubscribe_isActiveFraction=subscribe(isActiveFraction,$$value=>$$invalidate(48,$isActiveFraction=$$value)),isActiveFraction);let $footerOffset;let $imageTiles;$$self.$$.on_destroy.push(()=>$$unsubscribe_isActive());$$self.$$.on_destroy.push(()=>$$unsubscribe_isActiveFraction());const name=\"filter\";let{isActive}=$$props;$$subscribe_isActive();let{isActiveFraction}=$$props;$$subscribe_isActiveFraction();let{stores}=$$props;let{locale}=$$props;let{filterFunctions}=$$props;let{filterOptions}=$$props;// connect filter choice to stores\nconst{history,imagePreviews,stageRect,utilRect,elasticityMultiplier,scrollElasticity,imageCropRect,imageSize,imageRotation,imageFlipX,imageFlipY,imageGamma,imageColorMatrix}=stores;component_subscribe($$self,stageRect,value=>$$invalidate(46,$stageRect=value));component_subscribe($$self,utilRect,value=>$$invalidate(45,$utilRect=value));component_subscribe($$self,imageGamma,value=>$$invalidate(47,$imageGamma=value));component_subscribe($$self,imageColorMatrix,value=>$$invalidate(40,$imageColorMatrix=value));const getFilterIndex=(imageColorMatrix,filterOptionsFlattened)=>{if(!imageColorMatrix||!imageColorMatrix[\"filter\"]||!filterOptionsFlattened)return 0;const filterColorMatrix=imageColorMatrix[\"filter\"];return filterOptionsFlattened.// get id and compare matrices\nfindIndex(([id])=>{if(!filterFunctions[id])return false;const matrix=filterFunctions[id]();return arrayEqual(matrix,filterColorMatrix);});};const tileRects=writable({});component_subscribe($$self,tileRects,value=>$$invalidate(41,$tileRects=value));const handleTileResize=(item,rect)=>set_store_value(tileRects,$tileRects[item.value]=rect,$tileRects);const canvasSize=derived(tileRects,$tileRects=>{if(!$tileRects[undefined])return;const tileRectFirst=$tileRects[undefined];if($canvasSize&&sizeEqual($canvasSize,tileRectFirst))return $canvasSize;return sizeClone(tileRectFirst);});component_subscribe($$self,canvasSize,value=>$$invalidate(42,$canvasSize=value));const imageTransforms=derived([isActive,canvasSize,imageCropRect,imageSize,imageRotation,imageFlipX,imageFlipY],([$isActive,$canvasSize,$imageCropRect,$imageSize,$imageRotation,$imageFlipX,$imageFlipY],set)=>{if(!$isActive||!$canvasSize||!$imageSize)return $imageTransforms;const imageRect=rectCreateFromSize($imageSize);const imageCenter=rectCenter(imageRect);// get base crop rect so we can correctly apply transforms\nconst cropRectBase=getBaseCropRect($imageSize,$imageCropRect,$imageRotation);const cropRectBaseCenter=rectCenter(cropRectBase);const imageTranslation=vectorSubtract(vectorClone(imageCenter),cropRectBaseCenter);const imageOrigin=vectorInvert(vectorClone(imageTranslation));// scalar\nconst imageScalar=Math.max($canvasSize.width/$imageCropRect.width,$canvasSize.height/$imageCropRect.height);// update preview transforms\nset({origin:imageOrigin,translation:imageTranslation,rotation:{x:$imageFlipY?Math.PI:0,y:$imageFlipX?Math.PI:0,z:$imageRotation},perspective:vectorCreateEmpty(),scale:imageScalar});});component_subscribe($$self,imageTransforms,value=>$$invalidate(43,$imageTransforms=value));const cloneImageTransforms=imageTransforms=>({origin:vectorClone(imageTransforms.origin),translation:vectorClone(imageTransforms.translation),rotation:_objectSpread({},imageTransforms.rotation),perspective:vectorClone(imageTransforms.perspective),scale:imageTransforms.scale});//\n// Footer\n//\nconst footerOffset=spring(0);component_subscribe($$self,footerOffset,value=>$$invalidate(49,$footerOffset=value));let tileCornerRadius;const tileElements={};const handleTransitionEnd=e=>{if(e.target.className!==FILTER_PREVIEW_CLASS_NAME)return;$$invalidate(37,tileCornerRadius=Object.keys(tileElements).reduce((prev,curr)=>{const element=tileElements[curr];const style=getComputedStyle(element);const corners=[\"top-left\",\"top-right\",\"bottom-left\",\"bottom-right\"].map(corner=>style.getPropertyValue(`border-${corner}-radius`)).map(unitToPixels).// this better aligns WebGL rounded corner with css rounded corner\nmap(v=>v*1.25);prev[curr]=corners;return prev;},{}));};let tileLeftOpacity;// set by Scrollable\nlet tileRightOpacity;// set by Scrollable\nlet tileMargin;// set by Scrollable\nlet tileScrollOffset={x:0,y:0};let tileScrollContainerRect;let tileWrapperOffset;const imageTiles=writable([]);component_subscribe($$self,imageTiles,value=>$$invalidate(50,$imageTiles=value));// clones an image tile for use in canvas\nconst cloneImageTile=tile=>{const clone=_objectSpread(_objectSpread({},tile),{},{offset:_objectSpread({},tile.offset),mask:_objectSpread({},tile.mask)});clone.opacity=$isActiveFraction;clone.offset.y+=$footerOffset;clone.mask.y+=$footerOffset;return clone;};const handleChangeFilter=({value})=>{set_store_value(imageColorMatrix,$imageColorMatrix=_objectSpread(_objectSpread({},$imageColorMatrix),{},{\"filter\":isFunction(filterFunctions[value])?filterFunctions[value]():undefined}),$imageColorMatrix);history.write();};const measure_handler_1=(option,e)=>handleTileResize(option,e.detail);function div1_binding($$value,option){binding_callbacks[$$value?\"unshift\":\"push\"](()=>{tileElements[option.value]=$$value;$$invalidate(4,tileElements);});}const func=offset=>$$invalidate(8,tileScrollOffset=offset);function scrollable_maskFeatherStartOpacity_binding(value){tileLeftOpacity=value;$$invalidate(5,tileLeftOpacity);}function scrollable_maskFeatherEndOpacity_binding(value){tileRightOpacity=value;$$invalidate(6,tileRightOpacity);}function scrollable_maskFeatherSize_binding(value){tileMargin=value;$$invalidate(7,tileMargin);}const measure_handler_2=e=>$$invalidate(9,tileScrollContainerRect=e.detail);function measure_handler(event){bubble($$self,event);}$$self.$$set=$$props=>{if(\"isActive\"in $$props)$$subscribe_isActive($$invalidate(0,isActive=$$props.isActive));if(\"isActiveFraction\"in $$props)$$subscribe_isActiveFraction($$invalidate(1,isActiveFraction=$$props.isActiveFraction));if(\"stores\"in $$props)$$invalidate(27,stores=$$props.stores);if(\"locale\"in $$props)$$invalidate(2,locale=$$props.locale);if(\"filterFunctions\"in $$props)$$invalidate(28,filterFunctions=$$props.filterFunctions);if(\"filterOptions\"in $$props)$$invalidate(3,filterOptions=$$props.filterOptions);};let filterOptionsFlattened;let selectedFilterIndex;let footerStyle;$$self.$$.update=()=>{if($$self.$$.dirty[0]&/*filterOptions*/8){$$invalidate(39,filterOptionsFlattened=flattenOptions(filterOptions));}if($$self.$$.dirty[1]&/*$imageColorMatrix, filterOptionsFlattened*/768){$$invalidate(10,selectedFilterIndex=getFilterIndex($imageColorMatrix,filterOptionsFlattened));}if($$self.$$.dirty[1]&/*$isActive*/8192){footerOffset.set($isActive?0:20);}if($$self.$$.dirty[1]&/*$isActive, $utilRect, $stageRect*/57344){if($isActive&&$utilRect&&$stageRect){const tileTopOffset=$stageRect.y+$stageRect.height+$utilRect.y;$$invalidate(38,tileWrapperOffset={x:$stageRect.x-$utilRect.x,y:tileTopOffset});}}if($$self.$$.dirty[0]&/*tileScrollOffset, tileScrollContainerRect, tileMargin, tileLeftOpacity, tileRightOpacity, filterFunctions*/268436448|$$self.$$.dirty[1]&/*$imageTransforms, tileWrapperOffset, tileCornerRadius, filterOptionsFlattened, $tileRects, $imageColorMatrix, $imageGamma*/71616){if($imageTransforms&&tileWrapperOffset&&tileScrollOffset&&tileScrollContainerRect&&tileCornerRadius){const boundsX=tileWrapperOffset.x+tileScrollContainerRect.x;const offsetX=boundsX+tileScrollOffset.x;const offsetY=tileWrapperOffset.y;const containerLeft=tileScrollContainerRect.x+tileWrapperOffset.x;const containerRight=containerLeft+tileScrollContainerRect.width;imageTiles.set(filterOptionsFlattened.map(([id],i)=>{const tileRect=$tileRects[id];// test if is outside of view\nconst tileLeft=tileScrollOffset.x+tileRect.x;const tileRight=tileLeft+tileRect.width;if(tileRight<0||tileLeft>tileScrollContainerRect.width)return false;const x=offsetX+tileRect.x;const y=offsetY+tileRect.y;const preview=cloneImageTransforms($imageTransforms);preview.offset=vectorCreate(tileRect.width*0.5+x,tileRect.height*0.5+y);let clipX=0;let clipWidth=0;preview.maskOpacity=1;preview.mask=rectCreate(x+clipX,y,tileRect.width+clipWidth,tileRect.height);preview.maskFeather=[1,0,1,0,1,containerRight,1,containerRight];if(tileLeft<tileMargin&&tileLeftOpacity<1){preview.maskFeather[0]=tileLeftOpacity;preview.maskFeather[1]=containerLeft;preview.maskFeather[2]=1;preview.maskFeather[3]=containerLeft+tileMargin;}if(tileRight>tileScrollContainerRect.width-tileMargin&&tileRightOpacity<1){preview.maskFeather[4]=tileRightOpacity;preview.maskFeather[5]=containerRight-tileMargin;preview.maskFeather[6]=1;preview.maskFeather[7]=containerRight;}preview.maskCornerRadius=tileCornerRadius[id];let colorMatrices=$imageColorMatrix&&Object.keys($imageColorMatrix).filter(name=>name!=\"filter\").map(name=>$imageColorMatrix[name])||[];if(isFunction(filterFunctions[id])){colorMatrices.push(filterFunctions[id]());}preview.colorMatrix=colorMatrices.length?getColorMatrixFromColorMatrices(colorMatrices):undefined;preview.gamma=$imageGamma;return preview;}).filter(Boolean));}}if($$self.$$.dirty[1]&/*$isActive, $imageTiles, $footerOffset, $isActiveFraction*/925696){// Will update `imagePreviews` store when\n// - $isActiveFraction is updated\n// - $imageTiles is updated\n// - $footerOffset is updated\nif($isActive&&$imageTiles){// clone tiles\nimagePreviews.set($imageTiles.map(cloneImageTile));}else{imagePreviews.set([]);}}if($$self.$$.dirty[1]&/*$footerOffset*/262144){$$invalidate(11,footerStyle=$footerOffset?`transform: translateY(${$footerOffset}px)`:undefined);}};return[isActive,isActiveFraction,locale,filterOptions,tileElements,tileLeftOpacity,tileRightOpacity,tileMargin,tileScrollOffset,tileScrollContainerRect,selectedFilterIndex,footerStyle,stageRect,utilRect,elasticityMultiplier,scrollElasticity,imageGamma,imageColorMatrix,tileRects,handleTileResize,canvasSize,imageTransforms,footerOffset,handleTransitionEnd,imageTiles,handleChangeFilter,name,stores,filterFunctions,measure_handler_1,div1_binding,func,scrollable_maskFeatherStartOpacity_binding,scrollable_maskFeatherEndOpacity_binding,scrollable_maskFeatherSize_binding,measure_handler_2,measure_handler];}class Filter extends SvelteComponent{constructor(options){super();init(this,options,instance$s,create_fragment$s,safe_not_equal,{name:26,isActive:0,isActiveFraction:1,stores:27,locale:2,filterFunctions:28,filterOptions:3},[-1,-1,-1]);}get name(){return this.$$.ctx[26];}get isActive(){return this.$$.ctx[0];}set isActive(isActive){this.$set({isActive});flush();}get isActiveFraction(){return this.$$.ctx[1];}set isActiveFraction(isActiveFraction){this.$set({isActiveFraction});flush();}get stores(){return this.$$.ctx[27];}set stores(stores){this.$set({stores});flush();}get locale(){return this.$$.ctx[2];}set locale(locale){this.$set({locale});flush();}get filterFunctions(){return this.$$.ctx[28];}set filterFunctions(filterFunctions){this.$set({filterFunctions});flush();}get filterOptions(){return this.$$.ctx[3];}set filterOptions(filterOptions){this.$set({filterOptions});flush();}}// @ts-ignore\nvar index$1={util:['filter',Filter]};/* src/core/ui/plugins/finetune/index.svelte generated by Svelte v3.29.4 */function create_default_slot_3$4(ctx){let span;let t_value=/*tab*/ctx[35].label+\"\";let t;return{c(){span=element(\"span\");t=text(t_value);},m(target,anchor){insert(target,span,anchor);append(span,t);},p(ctx,dirty){if(dirty[1]&/*tab*/16&&t_value!==(t_value=/*tab*/ctx[35].label+\"\"))set_data(t,t_value);},d(detaching){if(detaching)detach(span);}};}// (152:8) <Scrollable elasticity={elasticityMultiplier * scrollElasticity} class=\"DokaControlListScroller\">\nfunction create_default_slot_2$4(ctx){let tablist;let current;const tablist_spread_levels=[{class:\"DokaControlList\"},{tabs:/*tabs*/ctx[1]},/*tabsConfig*/ctx[3]];let tablist_props={$$slots:{default:[create_default_slot_3$4,({tab})=>({35:tab}),({tab})=>[0,tab?16:0]]},$$scope:{ctx}};for(let i=0;i<tablist_spread_levels.length;i+=1){tablist_props=assign(tablist_props,tablist_spread_levels[i]);}tablist=new TabList({props:tablist_props});tablist.$on(\"select\",/*select_handler*/ctx[17]);return{c(){create_component(tablist.$$.fragment);},m(target,anchor){mount_component(tablist,target,anchor);current=true;},p(ctx,dirty){const tablist_changes=dirty[0]&/*tabs, tabsConfig*/10?get_spread_update(tablist_spread_levels,[tablist_spread_levels[0],dirty[0]&/*tabs*/2&&{tabs:/*tabs*/ctx[1]},dirty[0]&/*tabsConfig*/8&&get_spread_object(/*tabsConfig*/ctx[3])]):{};if(dirty[1]&/*$$scope, tab*/48){tablist_changes.$$scope={dirty,ctx};}tablist.$set(tablist_changes);},i(local){if(current)return;transition_in(tablist.$$.fragment,local);current=true;},o(local){transition_out(tablist.$$.fragment,local);current=false;},d(detaching){destroy_component(tablist,detaching);}};}// (158:8) <TabPanels class=\"DokaControlPanels\" panelClass=\"DokaControlPanel\" {panels} {...tabsConfig} let:panel>\nfunction create_default_slot_1$6(ctx){let rangeinput;let current;const rangeinput_spread_levels=[/*$rangeInputConfig*/ctx[5][/*panel*/ctx[34]]];let rangeinput_props={};for(let i=0;i<rangeinput_spread_levels.length;i+=1){rangeinput_props=assign(rangeinput_props,rangeinput_spread_levels[i]);}rangeinput=new RangeInput({props:rangeinput_props});return{c(){create_component(rangeinput.$$.fragment);},m(target,anchor){mount_component(rangeinput,target,anchor);current=true;},p(ctx,dirty){const rangeinput_changes=dirty[0]&/*$rangeInputConfig*/32|dirty[1]&/*panel*/8?get_spread_update(rangeinput_spread_levels,[get_spread_object(/*$rangeInputConfig*/ctx[5][/*panel*/ctx[34]])]):{};rangeinput.$set(rangeinput_changes);},i(local){if(current)return;transition_in(rangeinput.$$.fragment,local);current=true;},o(local){transition_out(rangeinput.$$.fragment,local);current=false;},d(detaching){destroy_component(rangeinput,detaching);}};}// (150:4) <div slot=\"footer\" style={footerStyle}>\nfunction create_footer_slot$2(ctx){let div;let scrollable;let t;let tabpanels;let current;scrollable=new Scrollable({props:{elasticity:/*elasticityMultiplier*/ctx[8]*/*scrollElasticity*/ctx[7],class:\"DokaControlListScroller\",$$slots:{default:[create_default_slot_2$4]},$$scope:{ctx}}});const tabpanels_spread_levels=[{class:\"DokaControlPanels\"},{panelClass:\"DokaControlPanel\"},{panels:/*panels*/ctx[4]},/*tabsConfig*/ctx[3]];let tabpanels_props={$$slots:{default:[create_default_slot_1$6,({panel})=>({34:panel}),({panel})=>[0,panel?8:0]]},$$scope:{ctx}};for(let i=0;i<tabpanels_spread_levels.length;i+=1){tabpanels_props=assign(tabpanels_props,tabpanels_spread_levels[i]);}tabpanels=new TabPanels({props:tabpanels_props});return{c(){div=element(\"div\");create_component(scrollable.$$.fragment);t=space();create_component(tabpanels.$$.fragment);attr(div,\"slot\",\"footer\");attr(div,\"style\",/*footerStyle*/ctx[6]);},m(target,anchor){insert(target,div,anchor);mount_component(scrollable,div,null);append(div,t);mount_component(tabpanels,div,null);current=true;},p(ctx,dirty){const scrollable_changes={};if(dirty[0]&/*tabs, tabsConfig, tabSelected*/14|dirty[1]&/*$$scope*/32){scrollable_changes.$$scope={dirty,ctx};}scrollable.$set(scrollable_changes);const tabpanels_changes=dirty[0]&/*panels, tabsConfig*/24?get_spread_update(tabpanels_spread_levels,[tabpanels_spread_levels[0],tabpanels_spread_levels[1],dirty[0]&/*panels*/16&&{panels:/*panels*/ctx[4]},dirty[0]&/*tabsConfig*/8&&get_spread_object(/*tabsConfig*/ctx[3])]):{};if(dirty[0]&/*$rangeInputConfig*/32|dirty[1]&/*$$scope, panel*/40){tabpanels_changes.$$scope={dirty,ctx};}tabpanels.$set(tabpanels_changes);if(!current||dirty[0]&/*footerStyle*/64){attr(div,\"style\",/*footerStyle*/ctx[6]);}},i(local){if(current)return;transition_in(scrollable.$$.fragment,local);transition_in(tabpanels.$$.fragment,local);current=true;},o(local){transition_out(scrollable.$$.fragment,local);transition_out(tabpanels.$$.fragment,local);current=false;},d(detaching){if(detaching)detach(div);destroy_component(scrollable);destroy_component(tabpanels);}};}function create_fragment$t(ctx){let util;let current;util=new Util({props:{$$slots:{footer:[create_footer_slot$2]},$$scope:{ctx}}});util.$on(\"measure\",/*measure_handler*/ctx[18]);return{c(){create_component(util.$$.fragment);},m(target,anchor){mount_component(util,target,anchor);current=true;},p(ctx,dirty){const util_changes={};if(dirty[0]&/*footerStyle, panels, tabsConfig, $rangeInputConfig, tabs, tabSelected*/126|dirty[1]&/*$$scope*/32){util_changes.$$scope={dirty,ctx};}util.$set(util_changes);},i(local){if(current)return;transition_in(util.$$.fragment,local);current=true;},o(local){transition_out(util.$$.fragment,local);current=false;},d(detaching){destroy_component(util,detaching);}};}function instance$t($$self,$$props,$$invalidate){let $rangeInputConfig;let $panelValues;let $isActive,$$unsubscribe_isActive=noop$1,$$subscribe_isActive=()=>($$unsubscribe_isActive(),$$unsubscribe_isActive=subscribe(isActive,$$value=>$$invalidate(21,$isActive=$$value)),isActive);let $footerOffset;$$self.$$.on_destroy.push(()=>$$unsubscribe_isActive());const name=\"finetune\";let{stores}=$$props;let{isActive}=$$props;$$subscribe_isActive();let{locale={}}=$$props;let{finetuneControlConfiguration}=$$props;let{finetuneOptions}=$$props;const{history,scrollElasticity,elasticityMultiplier,rangeInputElasticity,imageColorMatrix,imageConvolutionMatrix,imageGamma,imageVignette,imageNoise}=stores;const imageEffectStores={imageColorMatrix,imageConvolutionMatrix,imageGamma,imageVignette,imageNoise};//\n// Tabs\n//\nconst uid=`doka-finetune-${getUniqueId()}`;//\n// Range inputs\n//\nconst panelValues=writable({});component_subscribe($$self,panelValues,value=>$$invalidate(20,$panelValues=value));const rangeInputConfig=writable({});component_subscribe($$self,rangeInputConfig,value=>$$invalidate(5,$rangeInputConfig=value));const updateRangeInputState=()=>{set_store_value(rangeInputConfig,$rangeInputConfig=Object.keys($panelValues).reduce((config,id)=>{const{base,min,max,getLabel,getStore,setValue=(store,v)=>store.set(v)}=finetuneControlConfiguration[id];const store=getStore(imageEffectStores);const value=$panelValues[id]!=null?$panelValues[id]:base;config[id]={base,min,max,value,valueLabel:getLabel?getLabel(value,min,max,max-min):Math.round(100*value),oninputmove:v=>{setValue(store,v);},oninputend:v=>{setValue(store,v);history.write();},elasticity:elasticityMultiplier*rangeInputElasticity,labelReset:locale.labelReset};return config;},{}),$rangeInputConfig);};// need to unsubscribe when redrawing vie\nlet unsubs=[];const subscribePanelStores=config=>{if(unsubs)unsubs.forEach(unsub=>unsub());unsubs=panels.map(id=>{const{getStore,getValue=passthrough}=config[id];const store=getStore(imageEffectStores);return store.subscribe(value=>{const currentValue=value!=null?getValue(value):value;set_store_value(panelValues,$panelValues=_objectSpread(_objectSpread({},$panelValues),{},{[id]:currentValue}),$panelValues);});});};//\n// Footer\n//\nconst footerOffset=spring(0);component_subscribe($$self,footerOffset,value=>$$invalidate(22,$footerOffset=value));const select_handler=({detail})=>$$invalidate(2,tabSelected=detail);function measure_handler(event){bubble($$self,event);}$$self.$$set=$$props=>{if(\"stores\"in $$props)$$invalidate(13,stores=$$props.stores);if(\"isActive\"in $$props)$$subscribe_isActive($$invalidate(0,isActive=$$props.isActive));if(\"locale\"in $$props)$$invalidate(14,locale=$$props.locale);if(\"finetuneControlConfiguration\"in $$props)$$invalidate(15,finetuneControlConfiguration=$$props.finetuneControlConfiguration);if(\"finetuneOptions\"in $$props)$$invalidate(16,finetuneOptions=$$props.finetuneOptions);};let tabs;let tabSelected;let tabsConfig;let panels;let footerStyle;$$self.$$.update=()=>{if($$self.$$.dirty[0]&/*finetuneOptions, locale*/81920){$$invalidate(1,tabs=finetuneOptions?finetuneOptions.map(([id,label])=>({id,label:isFunction(label)?label(locale):label})):[]);}if($$self.$$.dirty[0]&/*tabs*/2){$$invalidate(2,tabSelected=tabs.length&&tabs[0].id);}if($$self.$$.dirty[0]&/*tabSelected*/4){$$invalidate(3,tabsConfig={name:uid,selected:tabSelected});}if($$self.$$.dirty[0]&/*tabs*/2){$$invalidate(4,panels=tabs.map(tab=>tab.id));}if($$self.$$.dirty[0]&/*finetuneControlConfiguration*/32768){finetuneControlConfiguration&&subscribePanelStores(finetuneControlConfiguration);}if($$self.$$.dirty[0]&/*finetuneControlConfiguration, $panelValues*/1081344){finetuneControlConfiguration&&$panelValues&&updateRangeInputState();}if($$self.$$.dirty[0]&/*$isActive*/2097152){footerOffset.set($isActive?0:20);}if($$self.$$.dirty[0]&/*$footerOffset*/4194304){$$invalidate(6,footerStyle=$footerOffset?`transform: translateY(${$footerOffset}px)`:undefined);}};return[isActive,tabs,tabSelected,tabsConfig,panels,$rangeInputConfig,footerStyle,scrollElasticity,elasticityMultiplier,panelValues,rangeInputConfig,footerOffset,name,stores,locale,finetuneControlConfiguration,finetuneOptions,select_handler,measure_handler];}class Finetune extends SvelteComponent{constructor(options){super();init(this,options,instance$t,create_fragment$t,safe_not_equal,{name:12,stores:13,isActive:0,locale:14,finetuneControlConfiguration:15,finetuneOptions:16},[-1,-1]);}get name(){return this.$$.ctx[12];}get stores(){return this.$$.ctx[13];}set stores(stores){this.$set({stores});flush();}get isActive(){return this.$$.ctx[0];}set isActive(isActive){this.$set({isActive});flush();}get locale(){return this.$$.ctx[14];}set locale(locale){this.$set({locale});flush();}get finetuneControlConfiguration(){return this.$$.ctx[15];}set finetuneControlConfiguration(finetuneControlConfiguration){this.$set({finetuneControlConfiguration});flush();}get finetuneOptions(){return this.$$.ctx[16];}set finetuneOptions(finetuneOptions){this.$set({finetuneOptions});flush();}}// @ts-ignore\nvar index$2={util:['finetune',Finetune]};/* src/core/ui/components/ShapeManipulator.svelte generated by Svelte v3.29.4 */function get_each_context$5(ctx,list,i){const child_ctx=ctx.slice();child_ctx[47]=list[i].key;child_ctx[48]=list[i].index;child_ctx[49]=list[i].translate;child_ctx[50]=list[i].scale;child_ctx[14]=list[i].rotate;child_ctx[51]=list[i].dir;child_ctx[52]=list[i].center;child_ctx[53]=list[i].type;return child_ctx;}// (304:0) {#if type ==='edge' && resizeAxis !== 'both'}\nfunction create_if_block_1$8(ctx){let div;let div_style_value;return{c(){div=element(\"div\");attr(div,\"class\",\"DokaShapeManipulator\");attr(div,\"data-control\",\"point\");attr(div,\"style\",div_style_value=`pointer-events:none;transform: translate3d(${/*center*/ctx[52].x}px, ${/*center*/ctx[52].y}px, 0) scale(${/*$selectionScale*/ctx[5]}, ${/*$selectionScale*/ctx[5]}); opacity: ${/*$selectionOpacity*/ctx[6]}`);},m(target,anchor){insert(target,div,anchor);},p(ctx,dirty){if(dirty[0]&/*resizeControls, $selectionScale, $selectionOpacity*/104&&div_style_value!==(div_style_value=`pointer-events:none;transform: translate3d(${/*center*/ctx[52].x}px, ${/*center*/ctx[52].y}px, 0) scale(${/*$selectionScale*/ctx[5]}, ${/*$selectionScale*/ctx[5]}); opacity: ${/*$selectionOpacity*/ctx[6]}`)){attr(div,\"style\",div_style_value);}},d(detaching){if(detaching)detach(div);}};}// (289:0) {#each resizeControls as { key, index, translate, scale, rotate, dir, center, type }\nfunction create_each_block$5(key_1,ctx){let div;let div_tabindex_value;let div_data_control_value;let div_style_value;let nudgeable_action;let interactable_action;let t;let if_block_anchor;let mounted;let dispose;function nudge_handler(...args){return(/*nudge_handler*/ctx[18](/*index*/ctx[48],...args));}let if_block=/*type*/ctx[53]===\"edge\"&&/*resizeAxis*/ctx[2]!==\"both\"&&create_if_block_1$8(ctx);return{key:key_1,first:null,c(){div=element(\"div\");t=space();if(if_block)if_block.c();if_block_anchor=empty();attr(div,\"role\",\"button\");attr(div,\"tabindex\",div_tabindex_value=/*type*/ctx[53]===\"edge\"?-1:0);attr(div,\"class\",\"DokaShapeManipulator\");attr(div,\"data-control\",div_data_control_value=/*type*/ctx[53]);attr(div,\"style\",div_style_value=`cursor: ${/*dir*/ctx[51]?/*dir*/ctx[51]+\"-resize\":\"move\"}; transform: translate3d(${/*translate*/ctx[49].x}px, ${/*translate*/ctx[49].y}px, 0) rotate(${/*rotate*/ctx[14]}rad) scale(${/*type*/ctx[53]===\"point\"?/*$selectionScale*/ctx[5]:/*scale*/ctx[50].x}, ${/*type*/ctx[53]===\"point\"?/*$selectionScale*/ctx[5]:/*scale*/ctx[50].y}); opacity: ${/*$selectionOpacity*/ctx[6]}`);this.first=div;},m(target,anchor){insert(target,div,anchor);insert(target,t,anchor);if(if_block)if_block.m(target,anchor);insert(target,if_block_anchor,anchor);if(!mounted){dispose=[listen(div,\"keydown\",/*handleKeyDown*/ctx[7]),listen(div,\"keyup\",/*handleKeyUp*/ctx[8]),listen(div,\"nudge\",nudge_handler),action_destroyer(nudgeable_action=nudgeable.call(null,div)),listen(div,\"interactionstart\",function(){if(is_function(/*resize*/ctx[11](\"start\",/*index*/ctx[48])))/*resize*/ctx[11](\"start\",/*index*/ctx[48]).apply(this,arguments);}),listen(div,\"interactionupdate\",function(){if(is_function(/*resize*/ctx[11](\"move\",/*index*/ctx[48])))/*resize*/ctx[11](\"move\",/*index*/ctx[48]).apply(this,arguments);}),listen(div,\"interactionend\",function(){if(is_function(/*resize*/ctx[11](\"end\",/*index*/ctx[48])))/*resize*/ctx[11](\"end\",/*index*/ctx[48]).apply(this,arguments);}),action_destroyer(interactable_action=interactable.call(null,div))];mounted=true;}},p(new_ctx,dirty){ctx=new_ctx;if(dirty[0]&/*resizeControls*/8&&div_tabindex_value!==(div_tabindex_value=/*type*/ctx[53]===\"edge\"?-1:0)){attr(div,\"tabindex\",div_tabindex_value);}if(dirty[0]&/*resizeControls*/8&&div_data_control_value!==(div_data_control_value=/*type*/ctx[53])){attr(div,\"data-control\",div_data_control_value);}if(dirty[0]&/*resizeControls, $selectionScale, $selectionOpacity*/104&&div_style_value!==(div_style_value=`cursor: ${/*dir*/ctx[51]?/*dir*/ctx[51]+\"-resize\":\"move\"}; transform: translate3d(${/*translate*/ctx[49].x}px, ${/*translate*/ctx[49].y}px, 0) rotate(${/*rotate*/ctx[14]}rad) scale(${/*type*/ctx[53]===\"point\"?/*$selectionScale*/ctx[5]:/*scale*/ctx[50].x}, ${/*type*/ctx[53]===\"point\"?/*$selectionScale*/ctx[5]:/*scale*/ctx[50].y}); opacity: ${/*$selectionOpacity*/ctx[6]}`)){attr(div,\"style\",div_style_value);}if(/*type*/ctx[53]===\"edge\"&&/*resizeAxis*/ctx[2]!==\"both\"){if(if_block){if_block.p(ctx,dirty);}else{if_block=create_if_block_1$8(ctx);if_block.c();if_block.m(if_block_anchor.parentNode,if_block_anchor);}}else if(if_block){if_block.d(1);if_block=null;}},d(detaching){if(detaching)detach(div);if(detaching)detach(t);if(if_block)if_block.d(detaching);if(detaching)detach(if_block_anchor);mounted=false;run_all(dispose);}};}// (308:0) {#if enableRotating && rotationControlActive}\nfunction create_if_block$7(ctx){let div;let div_style_value;let nudgeable_action;let interactable_action;let mounted;let dispose;return{c(){div=element(\"div\");attr(div,\"role\",\"button\");attr(div,\"tabindex\",\"0\");attr(div,\"class\",\"DokaShapeManipulator\");attr(div,\"data-control\",\"rotate\");attr(div,\"style\",div_style_value=`transform: translate3d(${/*rotatorPoint*/ctx[0].x}px, ${/*rotatorPoint*/ctx[0].y}px, 0) scale(${/*$selectionScale*/ctx[5]}, ${/*$selectionScale*/ctx[5]}); opacity: ${/*$selectionOpacity*/ctx[6]}`);},m(target,anchor){insert(target,div,anchor);if(!mounted){dispose=[listen(div,\"keydown\",/*handleKeyDown*/ctx[7]),listen(div,\"keyup\",/*handleKeyUp*/ctx[8]),listen(div,\"nudge\",/*handleRotateNudge*/ctx[13]),action_destroyer(nudgeable_action=nudgeable.call(null,div)),listen(div,\"interactionstart\",/*rotate*/ctx[14](\"start\")),listen(div,\"interactionupdate\",/*rotate*/ctx[14](\"move\")),listen(div,\"interactionend\",/*rotate*/ctx[14](\"end\")),action_destroyer(interactable_action=interactable.call(null,div))];mounted=true;}},p(ctx,dirty){if(dirty[0]&/*rotatorPoint, $selectionScale, $selectionOpacity*/97&&div_style_value!==(div_style_value=`transform: translate3d(${/*rotatorPoint*/ctx[0].x}px, ${/*rotatorPoint*/ctx[0].y}px, 0) scale(${/*$selectionScale*/ctx[5]}, ${/*$selectionScale*/ctx[5]}); opacity: ${/*$selectionOpacity*/ctx[6]}`)){attr(div,\"style\",div_style_value);}},d(detaching){if(detaching)detach(div);mounted=false;run_all(dispose);}};}function create_fragment$u(ctx){let each_blocks=[];let each_1_lookup=new Map();let t;let if_block_anchor;let each_value=/*resizeControls*/ctx[3];const get_key=ctx=>/*key*/ctx[47];for(let i=0;i<each_value.length;i+=1){let child_ctx=get_each_context$5(ctx,each_value,i);let key=get_key(child_ctx);each_1_lookup.set(key,each_blocks[i]=create_each_block$5(key,child_ctx));}let if_block=/*enableRotating*/ctx[1]&&/*rotationControlActive*/ctx[4]&&create_if_block$7(ctx);return{c(){for(let i=0;i<each_blocks.length;i+=1){each_blocks[i].c();}t=space();if(if_block)if_block.c();if_block_anchor=empty();},m(target,anchor){for(let i=0;i<each_blocks.length;i+=1){each_blocks[i].m(target,anchor);}insert(target,t,anchor);if(if_block)if_block.m(target,anchor);insert(target,if_block_anchor,anchor);},p(ctx,dirty){if(dirty[0]&/*resizeControls, $selectionScale, $selectionOpacity, resizeAxis, handleKeyDown, handleKeyUp, handleResizeNudge, resize*/6636){const each_value=/*resizeControls*/ctx[3];each_blocks=update_keyed_each(each_blocks,dirty,get_key,1,ctx,each_value,each_1_lookup,t.parentNode,destroy_block,create_each_block$5,t,get_each_context$5);}if(/*enableRotating*/ctx[1]&&/*rotationControlActive*/ctx[4]){if(if_block){if_block.p(ctx,dirty);}else{if_block=create_if_block$7(ctx);if_block.c();if_block.m(if_block_anchor.parentNode,if_block_anchor);}}else if(if_block){if_block.d(1);if_block=null;}},i:noop$1,o:noop$1,d(detaching){for(let i=0;i<each_blocks.length;i+=1){each_blocks[i].d(detaching);}if(detaching)detach(t);if(if_block)if_block.d(detaching);if(detaching)detach(if_block_anchor);}};}function instance$u($$self,$$props,$$invalidate){let $selectionScale;let $selectionOpacity;const dispatch=createEventDispatcher();// which cursor to render\nconst EIGTH_PI=QUART_PI*0.5;const N=HALF_PI;const N0=N-EIGTH_PI;const N1=N+EIGTH_PI;const S=-HALF_PI;const S0=S-EIGTH_PI;const S1=S+EIGTH_PI;const E=PI;const E0=E-EIGTH_PI;const E1=-PI+EIGTH_PI;const W0=EIGTH_PI;const W1=-EIGTH_PI;const NW=N-QUART_PI;const NW0=NW-EIGTH_PI;const NW1=NW+EIGTH_PI;const NE=PI-QUART_PI;const NE0=NE-EIGTH_PI;const NE1=NE+EIGTH_PI;const SE=S-QUART_PI;const SE0=SE+EIGTH_PI;const SE1=SE-EIGTH_PI;const SW=S+QUART_PI;const SW0=SW+EIGTH_PI;const SW1=SW-EIGTH_PI;let{points=[]}=$$props;let{rotatorPoint=undefined}=$$props;let{visible=false}=$$props;let{enableResizing=true}=$$props;let{enableRotating=true}=$$props;// // internal\nlet shiftKey=false;const handleKeyDown=e=>shiftKey=e.shiftKey;const handleKeyUp=e=>shiftKey=false;// state\nconst selectionScale=spring(0.5,{precision:0.0001,stiffness:0.3,damping:0.7});component_subscribe($$self,selectionScale,value=>$$invalidate(5,$selectionScale=value));const selectionOpacity=spring(0,{precision:0.001});component_subscribe($$self,selectionOpacity,value=>$$invalidate(6,$selectionOpacity=value));const rotate=type=>({detail})=>{// always make sure we have a translation to work with\nconst translation=detail&&detail.translation?detail.translation:vectorCreate(0,0);dispatch(`rotate${type}`,{translation,shiftKey});};const resize=(type,indexes)=>({detail})=>{// always make sure we have a translation to work with\nconst translation=detail&&detail.translation?detail.translation:vectorCreate(0,0);// done transforming the points\ndispatch(`resize${type}`,{indexes,translation,shiftKey});};// https://en.wikipedia.org/wiki/Radian#/media/File:Degree-Radian_Conversion.svg\nconst getDirectionByAngle=angle=>{let dir=\"\";const isNorth=angle<=N1&&angle>=N0;const isSouth=angle>=S0&&angle<=S1;const isEast=angle<=E1||angle>=E0;const isWest=angle>=W1&&angle<=W0;const isNorthEast=angle>=NE0&&angle<=NE1;const isNorthWest=angle>=NW0&&angle<=NW1;const isSouthEast=angle<=SE0&&angle>=SE1;const isSouthWest=angle<=SW0&&angle>=SW1;if(isNorth||isSouth)dir=\"ns\";if(isEast||isWest)dir=\"ew\";if(isNorthEast||isSouthWest)dir=\"nesw\";if(isNorthWest||isSouthEast)dir=\"nwse\";return dir;};// 2 points -> [corner, corner]\n// 3 points => [corner, edge, corner, edge, corner, edge],\n// 4 points => [corner, edge, corner, edge, corner, edge, corner, edge]\nconst mapPointsToControls=(points,axis)=>{let i=0;const center=vectorCenter(points);const out=[];const l=points.length;const isLine=l===2;const isAxisLimited=axis!==\"both\";for(;i<l;i++){const p0=points[i-1]||points[points.length-1];const p1=points[i];const p2=points[i+1]||points[0];const dir=Math.atan2(p2.y-p1.y,p2.x-p1.x);// create corner, only allowed if axis equal 'both'\nif(!isAxisLimited){const a=vectorNormalize(vectorCreate(p0.x-p1.x,p0.y-p1.y));const b=vectorNormalize(vectorCreate(p2.x-p1.x,p2.y-p1.y));const cornerVector=vectorCreate(a.x+b.x,a.y+b.y);out.push({index:[i],key:`point-${i}`,type:\"point\",scale:{x:1,y:1},translate:{x:p1.x,y:p1.y},angle:undefined,rotate:isLine?0:dir,center:p1,dir:isLine?undefined:getDirectionByAngle(Math.atan2(cornerVector.y,cornerVector.x))});}// if only two points, skip edge\nif(isLine)continue;const mid=vectorCreate(p1.x+(p2.x-p1.x)*0.5,p1.y+(p2.y-p1.y)*0.5);// only allow horizontal controls\nif(axis===\"horizontal\"&&i%2===0)continue;// only allow vertical controls\nif(axis===\"vertical\"&&i%2!==0)continue;// create edge\nout.push({index:[i,i+1===l?0:i+1],key:`edge-${i}`,type:\"edge\",scale:{x:vectorDistance(p1,p2),y:1},translate:{x:p1.x,y:p1.y},angle:dir,rotate:dir,center:mid,dir:getDirectionByAngle(Math.atan2(center.y-mid.y,center.x-mid.x))});}return out;};const handleResizeNudge=(indexes,translation)=>{dispatch(`resizestart`,{indexes,translation:vectorCreateEmpty()});dispatch(`resizemove`,{indexes,translation});dispatch(`resizeend`,{indexes,translation:vectorCreateEmpty()});};const handleRotateNudge=({detail})=>{dispatch(`rotatestart`,{translation:vectorCreateEmpty()});dispatch(`rotatemove`,{translation:detail});dispatch(`rotateend`,{translation:vectorCreateEmpty()});};const nudge_handler=(index,{detail})=>handleResizeNudge(index,detail);$$self.$$set=$$props=>{if(\"points\"in $$props)$$invalidate(15,points=$$props.points);if(\"rotatorPoint\"in $$props)$$invalidate(0,rotatorPoint=$$props.rotatorPoint);if(\"visible\"in $$props)$$invalidate(16,visible=$$props.visible);if(\"enableResizing\"in $$props)$$invalidate(17,enableResizing=$$props.enableResizing);if(\"enableRotating\"in $$props)$$invalidate(1,enableRotating=$$props.enableRotating);};let resizeAxis;let resizeControls;let rotationControlActive;$$self.$$.update=()=>{if($$self.$$.dirty[0]&/*visible*/65536){selectionScale.set(visible?1:0.5);}if($$self.$$.dirty[0]&/*visible*/65536){selectionOpacity.set(visible?1:0);}if($$self.$$.dirty[0]&/*enableResizing*/131072){$$invalidate(2,resizeAxis=!enableResizing?false:isString(enableResizing)?enableResizing:\"both\");}if($$self.$$.dirty[0]&/*resizeAxis, points*/32772){$$invalidate(3,resizeControls=resizeAxis&&mapPointsToControls(points,resizeAxis)||[]);}if($$self.$$.dirty[0]&/*points*/32768){$$invalidate(4,rotationControlActive=points.length>2);}};return[rotatorPoint,enableRotating,resizeAxis,resizeControls,rotationControlActive,$selectionScale,$selectionOpacity,handleKeyDown,handleKeyUp,selectionScale,selectionOpacity,resize,handleResizeNudge,handleRotateNudge,rotate,points,visible,enableResizing,nudge_handler];}class ShapeManipulator extends SvelteComponent{constructor(options){super();init(this,options,instance$u,create_fragment$u,safe_not_equal,{points:15,rotatorPoint:0,visible:16,enableResizing:17,enableRotating:1},[-1,-1]);}}var getEventPositionInEditor=(e,viewOffset)=>{const positionInViewport=getEventPositionInViewport(e);return vectorSubtract(positionInViewport,viewOffset);};var cursorMoveToEnd=field=>field.selectionStart=field.selectionEnd=field.value.length;let result$b=null;var supportsVisualViewport=()=>{if(result$b===null){result$b=isBrowser()&&'visualViewport'in window;}return result$b;};var createSoftKeyboardObserver=cb=>{if(!supportsVisualViewport())return false;const heightNormal=visualViewport.height;const testState=()=>{cb(visualViewport.height<heightNormal?'visible':'hidden');};visualViewport.addEventListener('resize',testState);return()=>visualViewport.removeEventListener('resize',testState);};/* src/core/ui/components/InputForm.svelte generated by Svelte v3.29.4 */function create_fragment$v(ctx){let div2;let div1;let button0;let t0;let div0;let t1;let button1;let measurable_action;let current;let mounted;let dispose;button0=new Button({props:{onclick:/*oncancel*/ctx[1],label:/*labelCancel*/ctx[5],icon:/*iconCancel*/ctx[7],hideLabel:!/*labelCancelShow*/ctx[6]}});const default_slot_template=/*#slots*/ctx[17].default;const default_slot=create_slot(default_slot_template,ctx,/*$$scope*/ctx[16],null);button1=new Button({props:{onclick:/*onconfirm*/ctx[0],label:/*labelConfirm*/ctx[2],icon:/*iconConfirm*/ctx[4],hideLabel:!/*labelConfirmShow*/ctx[3],class:\"DokaInputFormButtonConfirm\"}});return{c(){div2=element(\"div\");div1=element(\"div\");create_component(button0.$$.fragment);t0=space();div0=element(\"div\");if(default_slot)default_slot.c();t1=space();create_component(button1.$$.fragment);attr(div0,\"class\",\"DokaInputFormFields\");attr(div1,\"class\",\"DokaInputFormInner\");attr(div2,\"class\",\"DokaInputForm\");attr(div2,\"style\",/*style*/ctx[9]);},m(target,anchor){insert(target,div2,anchor);append(div2,div1);mount_component(button0,div1,null);append(div1,t0);append(div1,div0);if(default_slot){default_slot.m(div0,null);}append(div1,t1);mount_component(button1,div1,null);/*div2_binding*/ctx[18](div2);current=true;if(!mounted){dispose=[listen(div2,\"focusin\",/*handleFocusIn*/ctx[10]),listen(div2,\"focusout\",/*handleFocusOut*/ctx[11]),listen(div2,\"measure\",/*handleMeasure*/ctx[12]),action_destroyer(measurable_action=measurable.call(null,div2))];mounted=true;}},p(ctx,dirty){const button0_changes={};if(dirty[0]&/*oncancel*/2)button0_changes.onclick=/*oncancel*/ctx[1];if(dirty[0]&/*labelCancel*/32)button0_changes.label=/*labelCancel*/ctx[5];if(dirty[0]&/*iconCancel*/128)button0_changes.icon=/*iconCancel*/ctx[7];if(dirty[0]&/*labelCancelShow*/64)button0_changes.hideLabel=!/*labelCancelShow*/ctx[6];button0.$set(button0_changes);if(default_slot){if(default_slot.p&&dirty[0]&/*$$scope*/65536){update_slot(default_slot,default_slot_template,ctx,/*$$scope*/ctx[16],dirty,null,null);}}const button1_changes={};if(dirty[0]&/*onconfirm*/1)button1_changes.onclick=/*onconfirm*/ctx[0];if(dirty[0]&/*labelConfirm*/4)button1_changes.label=/*labelConfirm*/ctx[2];if(dirty[0]&/*iconConfirm*/16)button1_changes.icon=/*iconConfirm*/ctx[4];if(dirty[0]&/*labelConfirmShow*/8)button1_changes.hideLabel=!/*labelConfirmShow*/ctx[3];button1.$set(button1_changes);if(!current||dirty[0]&/*style*/512){attr(div2,\"style\",/*style*/ctx[9]);}},i(local){if(current)return;transition_in(button0.$$.fragment,local);transition_in(default_slot,local);transition_in(button1.$$.fragment,local);current=true;},o(local){transition_out(button0.$$.fragment,local);transition_out(default_slot,local);transition_out(button1.$$.fragment,local);current=false;},d(detaching){if(detaching)detach(div2);destroy_component(button0);if(default_slot)default_slot.d(detaching);destroy_component(button1);/*div2_binding*/ctx[18](null);mounted=false;run_all(dispose);}};}const panelDelay=200;function instance$v($$self,$$props,$$invalidate){let{$$slots:slots={},$$scope}=$$props;let{onconfirm}=$$props;let{oncancel}=$$props;let{autoFocus=true}=$$props;let{autoPositionCursor=true}=$$props;let{labelConfirm}=$$props;let{labelConfirmShow=true}=$$props;let{iconConfirm}=$$props;let{labelCancel}=$$props;let{labelCancelShow=false}=$$props;let{iconCancel}=$$props;let{panelOffset=vectorCreateEmpty()}=$$props;let panelVisible=false;let panelHeight=undefined;let panelRevealTimeout=undefined;let panelPosition=\"\";let panelOpacity=0;let root;const preventTextAreaScrollingOnIOS=element=>{// preventsDefault on textarea events when can no longer scroll up or down in textarea\nlet lastScreenY;const handleTouchStart=e=>lastScreenY=e.touches[0].screenY;const handleTouchMove=e=>{const currentScreenY=e.touches[0].screenY;const target=e.target;if(/textarea/i.test(target.nodeName)){// moving down\nif(currentScreenY>lastScreenY){if(target.scrollTop==0){e.preventDefault();}}else// moving up\nif(currentScreenY<lastScreenY){if(target.scrollTop+target.offsetHeight==target.scrollHeight){e.preventDefault();}}else{e.preventDefault();}lastScreenY=currentScreenY;}else{e.preventDefault();}};element.addEventListener(\"touchstart\",handleTouchStart);element.addEventListener(\"touchmove\",handleTouchMove);return()=>{element.removeEventListener(\"touchstart\",handleTouchStart);element.removeEventListener(\"touchmove\",handleTouchMove);};};const focus=()=>{const field=root.querySelector(\"input, textarea\");field.focus();};const show=()=>{panelVisible=true;// browser does not support keyboard listener, place modal at top of view\nif(!unsubSoftKeyboardListener&&(isIOS()||isAndroid())){$$invalidate(22,panelPosition=\"top:1em;bottom:auto;\");}// prevent interacting with the root element\nif(isIOS())preventTextAreaScrollingOnIOS(root);// reveal\n$$invalidate(23,panelOpacity=1);};const hide=()=>{panelVisible=false;$$invalidate(23,panelOpacity=0);};const handleSoftKeyboard=keyboardState=>{if(!shouldStickToKeyboard)return;// no need to continue, already hidden\nif(keyboardState===\"hidden\"&&!panelVisible){focus();return;}// gonna update position here\nclearTimeout(panelRevealTimeout);panelRevealTimeout=undefined;// position\n$$invalidate(22,panelPosition=`top:${visualViewport.height-panelHeight-panelOffset.y}px`);// if a soft keyboard is detected, turn into modal mode\nif(keyboardState===\"visible\"){// stick to keyboard\n$$invalidate(8,root.dataset.layout=\"stick\",root);// need to refocus\nfocus();// place above keyboard\nshow();}else// keyboard is hidden\n{hide();}};let focusDateTime;const handleFocusIn=e=>{// we need to remember focus time so we can detect unrealistic blur event caused by soft keyboard shenanigans\nfocusDateTime=Date.now();// move cursor\nif(autoPositionCursor)cursorMoveToEnd(e.target);// wait a couple milliseconds\npanelRevealTimeout=setTimeout(show,panelDelay);};const handleFocusOut=e=>{const focusDuration=Date.now()-focusDateTime;if(focusDuration>50)return;// unrealistic blur, refocus\ne.stopPropagation();focus();};const unsubSoftKeyboardListener=createSoftKeyboardObserver(handleSoftKeyboard);const handleMeasure=({detail})=>{panelHeight=detail.height;};onMount(()=>{if(!autoFocus)return;focus();});onDestroy(()=>{unsubSoftKeyboardListener&&unsubSoftKeyboardListener();});function div2_binding($$value){binding_callbacks[$$value?\"unshift\":\"push\"](()=>{root=$$value;$$invalidate(8,root);});}$$self.$$set=$$props=>{if(\"onconfirm\"in $$props)$$invalidate(0,onconfirm=$$props.onconfirm);if(\"oncancel\"in $$props)$$invalidate(1,oncancel=$$props.oncancel);if(\"autoFocus\"in $$props)$$invalidate(13,autoFocus=$$props.autoFocus);if(\"autoPositionCursor\"in $$props)$$invalidate(14,autoPositionCursor=$$props.autoPositionCursor);if(\"labelConfirm\"in $$props)$$invalidate(2,labelConfirm=$$props.labelConfirm);if(\"labelConfirmShow\"in $$props)$$invalidate(3,labelConfirmShow=$$props.labelConfirmShow);if(\"iconConfirm\"in $$props)$$invalidate(4,iconConfirm=$$props.iconConfirm);if(\"labelCancel\"in $$props)$$invalidate(5,labelCancel=$$props.labelCancel);if(\"labelCancelShow\"in $$props)$$invalidate(6,labelCancelShow=$$props.labelCancelShow);if(\"iconCancel\"in $$props)$$invalidate(7,iconCancel=$$props.iconCancel);if(\"panelOffset\"in $$props)$$invalidate(15,panelOffset=$$props.panelOffset);if(\"$$scope\"in $$props)$$invalidate(16,$$scope=$$props.$$scope);};let computedStyle;let shouldStickToKeyboard;let style;$$self.$$.update=()=>{if($$self.$$.dirty[0]&/*root*/256){$$invalidate(25,computedStyle=root&&getComputedStyle(root));}if($$self.$$.dirty[0]&/*computedStyle*/33554432){shouldStickToKeyboard=computedStyle&&computedStyle.getPropertyValue(\"--editor-modal\")===\"1\";}if($$self.$$.dirty[0]&/*panelOpacity, panelPosition*/12582912){$$invalidate(9,style=`opacity:${panelOpacity};${panelPosition}`);}};return[onconfirm,oncancel,labelConfirm,labelConfirmShow,iconConfirm,labelCancel,labelCancelShow,iconCancel,root,style,handleFocusIn,handleFocusOut,handleMeasure,autoFocus,autoPositionCursor,panelOffset,$$scope,slots,div2_binding];}class InputForm extends SvelteComponent{constructor(options){super();init(this,options,instance$v,create_fragment$v,safe_not_equal,{onconfirm:0,oncancel:1,autoFocus:13,autoPositionCursor:14,labelConfirm:2,labelConfirmShow:3,iconConfirm:4,labelCancel:5,labelCancelShow:6,iconCancel:7,panelOffset:15},[-1,-1]);}}/* src/core/ui/components/ShapeLayoutEditor.svelte generated by Svelte v3.29.4 */function get_each_context$6(ctx,list,i){const child_ctx=ctx.slice();child_ctx[153]=list[i];child_ctx[155]=i;return child_ctx;}// (1887:8) {#each shapeNavList as item, index (item.id) }\nfunction create_each_block$6(key_1,ctx){let li;let button;let colorpreview;let t0;let span;let t1_value=/*item*/ctx[153].name+\"\";let t1;let button_aria_label_value;let t2;let current;let mounted;let dispose;colorpreview=new ColorPreview({props:{color:/*item*/ctx[153].color}});function click_handler(...args){return(/*click_handler*/ctx[94](/*index*/ctx[155],...args));}return{key:key_1,first:null,c(){li=element(\"li\");button=element(\"button\");create_component(colorpreview.$$.fragment);t0=space();span=element(\"span\");t1=text(t1_value);t2=space();attr(button,\"class\",\"DokaShapeListItem\");attr(button,\"type\",\"button\");attr(button,\"aria-label\",button_aria_label_value=\"Select shape \"+/*item*/ctx[153].name);this.first=li;},m(target,anchor){insert(target,li,anchor);append(li,button);mount_component(colorpreview,button,null);append(button,t0);append(button,span);append(span,t1);append(li,t2);current=true;if(!mounted){dispose=listen(button,\"click\",click_handler);mounted=true;}},p(new_ctx,dirty){ctx=new_ctx;const colorpreview_changes={};if(dirty[0]&/*shapeNavList*/524288)colorpreview_changes.color=/*item*/ctx[153].color;colorpreview.$set(colorpreview_changes);if((!current||dirty[0]&/*shapeNavList*/524288)&&t1_value!==(t1_value=/*item*/ctx[153].name+\"\"))set_data(t1,t1_value);if(!current||dirty[0]&/*shapeNavList*/524288&&button_aria_label_value!==(button_aria_label_value=\"Select shape \"+/*item*/ctx[153].name)){attr(button,\"aria-label\",button_aria_label_value);}},i(local){if(current)return;transition_in(colorpreview.$$.fragment,local);current=true;},o(local){transition_out(colorpreview.$$.fragment,local);current=false;},d(detaching){if(detaching)detach(li);destroy_component(colorpreview);mounted=false;dispose();}};}// (1898:4) {#if shouldRenderShapeManipulator}\nfunction create_if_block_2$6(ctx){let shapemanipulator;let current;shapemanipulator=new ShapeManipulator({props:{visible:true,points:/*shapeManipulatorPoints*/ctx[11],rotatorPoint:/*shapeManipulatorRotationPointPosition*/ctx[12],enableResizing:/*allowedResizeControls*/ctx[9],enableRotating:/*allowRotateControls*/ctx[8]}});shapemanipulator.$on(\"resizestart\",/*handleManipulatorResizeGrab*/ctx[26]);shapemanipulator.$on(\"resizemove\",/*handleManipulatorResizeDrag*/ctx[27]);shapemanipulator.$on(\"resizeend\",/*handleManipulatorResizeEnd*/ctx[28]);shapemanipulator.$on(\"rotatestart\",/*handleManipulatorRotateGrab*/ctx[29]);shapemanipulator.$on(\"rotatemove\",/*handleManipulatorRotateDrag*/ctx[30]);shapemanipulator.$on(\"rotateend\",/*handleManipulatorRotateEnd*/ctx[31]);return{c(){create_component(shapemanipulator.$$.fragment);},m(target,anchor){mount_component(shapemanipulator,target,anchor);current=true;},p(ctx,dirty){const shapemanipulator_changes={};if(dirty[0]&/*shapeManipulatorPoints*/2048)shapemanipulator_changes.points=/*shapeManipulatorPoints*/ctx[11];if(dirty[0]&/*shapeManipulatorRotationPointPosition*/4096)shapemanipulator_changes.rotatorPoint=/*shapeManipulatorRotationPointPosition*/ctx[12];if(dirty[0]&/*allowedResizeControls*/512)shapemanipulator_changes.enableResizing=/*allowedResizeControls*/ctx[9];if(dirty[0]&/*allowRotateControls*/256)shapemanipulator_changes.enableRotating=/*allowRotateControls*/ctx[8];shapemanipulator.$set(shapemanipulator_changes);},i(local){if(current)return;transition_in(shapemanipulator.$$.fragment,local);current=true;},o(local){transition_out(shapemanipulator.$$.fragment,local);current=false;},d(detaching){destroy_component(shapemanipulator,detaching);}};}// (1913:4) {#if shouldRenderTextInput}\nfunction create_if_block_1$9(ctx){let inputform;let current;inputform=new InputForm({props:{panelOffset:/*offset*/ctx[1],onconfirm:/*handleTextConfirm*/ctx[37],oncancel:/*handleTextCancel*/ctx[38],labelCancel:/*locale*/ctx[3].shapeLabelInputCancel,iconCancel:/*locale*/ctx[3].shapeIconInputCancel,labelConfirm:/*locale*/ctx[3].shapeLabelInputConfirm,iconConfirm:/*locale*/ctx[3].shapeIconInputConfirm,$$slots:{default:[create_default_slot$7]},$$scope:{ctx}}});return{c(){create_component(inputform.$$.fragment);},m(target,anchor){mount_component(inputform,target,anchor);current=true;},p(ctx,dirty){const inputform_changes={};if(dirty[0]&/*offset*/2)inputform_changes.panelOffset=/*offset*/ctx[1];if(dirty[0]&/*locale*/8)inputform_changes.labelCancel=/*locale*/ctx[3].shapeLabelInputCancel;if(dirty[0]&/*locale*/8)inputform_changes.iconCancel=/*locale*/ctx[3].shapeIconInputCancel;if(dirty[0]&/*locale*/8)inputform_changes.labelConfirm=/*locale*/ctx[3].shapeLabelInputConfirm;if(dirty[0]&/*locale*/8)inputform_changes.iconConfirm=/*locale*/ctx[3].shapeIconInputConfirm;if(dirty[0]&/*markupTextInputStyle, textInputText, textInput*/49184|dirty[5]&/*$$scope*/2){inputform_changes.$$scope={dirty,ctx};}inputform.$set(inputform_changes);},i(local){if(current)return;transition_in(inputform.$$.fragment,local);current=true;},o(local){transition_out(inputform.$$.fragment,local);current=false;},d(detaching){destroy_component(inputform,detaching);}};}// (1914:4) <InputForm          panelOffset={offset}         onconfirm={handleTextConfirm}          oncancel={handleTextCancel}         labelCancel={locale.shapeLabelInputCancel}         iconCancel={locale.shapeIconInputCancel}         labelConfirm={locale.shapeLabelInputConfirm}         iconConfirm={locale.shapeIconInputConfirm}>\nfunction create_default_slot$7(ctx){let textarea;let mounted;let dispose;return{c(){textarea=element(\"textarea\");attr(textarea,\"style\",/*markupTextInputStyle*/ctx[15]);attr(textarea,\"spellcheck\",\"false\");attr(textarea,\"autocorrect\",\"off\");attr(textarea,\"autocapitalize\",\"off\");textarea.value=/*textInputText*/ctx[14];},m(target,anchor){insert(target,textarea,anchor);/*textarea_binding*/ctx[95](textarea);if(!mounted){dispose=[listen(textarea,\"keydown\",/*handleTextInputKeyDown*/ctx[35]),listen(textarea,\"keypress\",/*handleTextInputAttempt*/ctx[34]),listen(textarea,\"keyup\",/*handleTextInputKeyUp*/ctx[36]),listen(textarea,\"input\",/*handleTextInput*/ctx[33])];mounted=true;}},p(ctx,dirty){if(dirty[0]&/*markupTextInputStyle*/32768){attr(textarea,\"style\",/*markupTextInputStyle*/ctx[15]);}if(dirty[0]&/*textInputText*/16384){textarea.value=/*textInputText*/ctx[14];}},d(detaching){if(detaching)detach(textarea);/*textarea_binding*/ctx[95](null);mounted=false;run_all(dispose);}};}// (1932:4) {#if $markupControlsOpacity > 0}\nfunction create_if_block$8(ctx){let div;let dynamiccomponenttree;let measurable_action;let current;let mounted;let dispose;dynamiccomponenttree=new DynamicComponentTree_1({props:{items:/*shapeControls*/ctx[18]}});return{c(){div=element(\"div\");create_component(dynamiccomponenttree.$$.fragment);attr(div,\"class\",\"DokaShapeControls\");attr(div,\"style\",/*markupControlsStyle*/ctx[16]);},m(target,anchor){insert(target,div,anchor);mount_component(dynamiccomponenttree,div,null);current=true;if(!mounted){dispose=[listen(div,\"measure\",/*measure_handler_1*/ctx[96]),action_destroyer(measurable_action=measurable.call(null,div))];mounted=true;}},p(ctx,dirty){const dynamiccomponenttree_changes={};if(dirty[0]&/*shapeControls*/262144)dynamiccomponenttree_changes.items=/*shapeControls*/ctx[18];dynamiccomponenttree.$set(dynamiccomponenttree_changes);if(!current||dirty[0]&/*markupControlsStyle*/65536){attr(div,\"style\",/*markupControlsStyle*/ctx[16]);}},i(local){if(current)return;transition_in(dynamiccomponenttree.$$.fragment,local);current=true;},o(local){transition_out(dynamiccomponenttree.$$.fragment,local);current=false;},d(detaching){if(detaching)detach(div);destroy_component(dynamiccomponenttree);mounted=false;run_all(dispose);}};}function create_fragment$w(ctx){let div;let nav;let ul;let each_blocks=[];let each_1_lookup=new Map();let t0;let t1;let t2;let measurable_action;let nudgeable_action;let interactable_action;let current;let mounted;let dispose;let each_value=/*shapeNavList*/ctx[19];const get_key=ctx=>/*item*/ctx[153].id;for(let i=0;i<each_value.length;i+=1){let child_ctx=get_each_context$6(ctx,each_value,i);let key=get_key(child_ctx);each_1_lookup.set(key,each_blocks[i]=create_each_block$6(key,child_ctx));}let if_block0=/*shouldRenderShapeManipulator*/ctx[10]&&create_if_block_2$6(ctx);let if_block1=/*shouldRenderTextInput*/ctx[13]&&create_if_block_1$9(ctx);let if_block2=/*$markupControlsOpacity*/ctx[17]>0&&create_if_block$8(ctx);return{c(){div=element(\"div\");nav=element(\"nav\");ul=element(\"ul\");for(let i=0;i<each_blocks.length;i+=1){each_blocks[i].c();}t0=space();if(if_block0)if_block0.c();t1=space();if(if_block1)if_block1.c();t2=space();if(if_block2)if_block2.c();attr(nav,\"class\",\"DokaShapeList\");attr(nav,\"data-visible\",/*showShapeList*/ctx[7]);attr(div,\"class\",\"DokaShapeEditor\");attr(div,\"tabindex\",\"0\");},m(target,anchor){insert(target,div,anchor);append(div,nav);append(nav,ul);for(let i=0;i<each_blocks.length;i+=1){each_blocks[i].m(ul,null);}append(div,t0);if(if_block0)if_block0.m(div,null);append(div,t1);if(if_block1)if_block1.m(div,null);append(div,t2);if(if_block2)if_block2.m(div,null);current=true;if(!mounted){dispose=[listen(nav,\"focusin\",/*handleFocusIn*/ctx[41]),listen(nav,\"focusout\",/*handleFocusOut*/ctx[42]),listen(div,\"keydown\",/*handleKey*/ctx[32]),listen(div,\"nudge\",/*handleNudge*/ctx[40]),listen(div,\"measure\",/*measure_handler*/ctx[93]),action_destroyer(measurable_action=measurable.call(null,div)),action_destroyer(nudgeable_action=nudgeable.call(null,div)),listen(div,\"wheel\",/*handleWheel*/ctx[21]),listen(div,\"interactionstart\",/*handleInteractionStart*/ctx[22]),listen(div,\"interactionupdate\",/*handleInteractionUpdate*/ctx[23]),listen(div,\"interactionrelease\",/*handleInteractionRelease*/ctx[24]),listen(div,\"interactionend\",/*handleInteractionEnd*/ctx[25]),action_destroyer(interactable_action=interactable.call(null,div,{drag:true,pinch:true,inertia:true,matchTarget:true,getEventPosition:/*interactable_function*/ctx[97]}))];mounted=true;}},p(ctx,dirty){if(dirty[0]&/*shapeNavList, selectShape, markup*/524305){const each_value=/*shapeNavList*/ctx[19];group_outros();each_blocks=update_keyed_each(each_blocks,dirty,get_key,1,ctx,each_value,each_1_lookup,ul,outro_and_destroy_block,create_each_block$6,null,get_each_context$6);check_outros();}if(!current||dirty[0]&/*showShapeList*/128){attr(nav,\"data-visible\",/*showShapeList*/ctx[7]);}if(/*shouldRenderShapeManipulator*/ctx[10]){if(if_block0){if_block0.p(ctx,dirty);if(dirty[0]&/*shouldRenderShapeManipulator*/1024){transition_in(if_block0,1);}}else{if_block0=create_if_block_2$6(ctx);if_block0.c();transition_in(if_block0,1);if_block0.m(div,t1);}}else if(if_block0){group_outros();transition_out(if_block0,1,1,()=>{if_block0=null;});check_outros();}if(/*shouldRenderTextInput*/ctx[13]){if(if_block1){if_block1.p(ctx,dirty);if(dirty[0]&/*shouldRenderTextInput*/8192){transition_in(if_block1,1);}}else{if_block1=create_if_block_1$9(ctx);if_block1.c();transition_in(if_block1,1);if_block1.m(div,t2);}}else if(if_block1){group_outros();transition_out(if_block1,1,1,()=>{if_block1=null;});check_outros();}if(/*$markupControlsOpacity*/ctx[17]>0){if(if_block2){if_block2.p(ctx,dirty);if(dirty[0]&/*$markupControlsOpacity*/131072){transition_in(if_block2,1);}}else{if_block2=create_if_block$8(ctx);if_block2.c();transition_in(if_block2,1);if_block2.m(div,null);}}else if(if_block2){group_outros();transition_out(if_block2,1,1,()=>{if_block2=null;});check_outros();}if(interactable_action&&is_function(interactable_action.update)&&dirty[0]&/*rootRect*/4)interactable_action.update.call(null,{drag:true,pinch:true,inertia:true,matchTarget:true,getEventPosition:/*interactable_function*/ctx[97]});},i(local){if(current)return;for(let i=0;i<each_value.length;i+=1){transition_in(each_blocks[i]);}transition_in(if_block0);transition_in(if_block1);transition_in(if_block2);current=true;},o(local){for(let i=0;i<each_blocks.length;i+=1){transition_out(each_blocks[i]);}transition_out(if_block0);transition_out(if_block1);transition_out(if_block2);current=false;},d(detaching){if(detaching)detach(div);for(let i=0;i<each_blocks.length;i+=1){each_blocks[i].d();}if(if_block0)if_block0.d();if(if_block1)if_block1.d();if(if_block2)if_block2.d();mounted=false;run_all(dispose);}};}const ROTATION_CONTROL_OFFSET=20;const MIN_TEXT_MARKUP_WIDTH=10;const shapeControlDist=16;function instance$w($$self,$$props,$$invalidate){let $keysPressedStored;let $markupControlsOpacity;let{markup}=$$props;let{offset}=$$props;let{rotation=0}=$$props;let{scale}=$$props;let{ui}=$$props;let{opacity=1}=$$props;let{parentRect}=$$props;let{rootRect}=$$props;let{stageRect}=$$props;let{utilRect}=$$props;let{oninteractionstart=noop}=$$props;let{oninteractionupdate=noop}=$$props;let{oninteractionrelease=noop}=$$props;let{oninteractionend=noop}=$$props;let{onaddshape=noop}=$$props;let{onupdateshape=noop}=$$props;let{onselectshape=noop}=$$props;let{onremoveshape=noop}=$$props;let{beforeSelectShape=()=>true}=$$props;let{beforeDeselectShape=()=>true}=$$props;let{beforeAddShape=()=>true}=$$props;// unused for now\nlet{beforeRemoveShape=()=>true}=$$props;let{beforeUpdateShape=(shape,props)=>props}=$$props;let{willRenderShapeControls=passthrough}=$$props;let{mapEditorPointToImagePoint}=$$props;let{mapImagePointToEditorPoint}=$$props;let{enableButtonFlipVertical=false}=$$props;let{locale}=$$props;//\n// Cache\n//\nconst updateShape=(shape,props,parentRect)=>{let propsToUpdate=beforeUpdateShape(_objectSpread({},shape),props,_objectSpread({},parentRect));shapeUpdateProps(shape,propsToUpdate,parentRect);};//\n// Helpers\n//\nconst isPositionInRect=(position,rect,rotation,pivot)=>{if(rotation)return!!polyPointIntersectionConvex(position,rectRotate(rect,rotation,pivot||rectCenter(rect)));const[t,r,b,l]=rectToBounds(rect);return position.x>=l&&position.x<=r&&position.y>=t&&position.y<=b;};const isPositionInEllipse=(position,ellipse,rotation)=>{const rx=ellipse.rx;const ry=ellipse.ry;const x=ellipse.x;const y=ellipse.y;const angle=rotation||0;const c=Math.cos(angle);const s=Math.sin(angle);const rx2=rx*rx;const ry2=ry*ry;const a=c*(position.x-x)+s*(position.y-y);const b=s*(position.x-x)-c*(position.y-y);const aa=a*a;const bb=b*b;return aa/rx2+bb/ry2<=1;};const isPositionNearLine=(position,begin,end,treshold)=>{const ba=Math.atan2(position.y-begin.y,position.x-begin.x);const ea=Math.atan2(position.y-end.y,position.x-end.x);if(ba>0&&ea>0||ba<0&&ea<0)return false;const r=treshold*treshold;const d=vectorCreate(end.x-begin.x,end.y-begin.y);const f=vectorCreate(begin.x-position.x,begin.y-position.y);const a=vectorDot(d,d);const b=2*vectorDot(f,d);const c=vectorDot(f,f)-r;const discriminant=b*b-4*a*c;return discriminant>=0;};//\n// Shape creator\n//\nconst keysPressedStored=getContext(\"keysPressed\");component_subscribe($$self,keysPressedStored,value=>$$invalidate(105,$keysPressedStored=value));const createShape=(shapeDefault,options={})=>{// state\nlet interactionOrigin;let interactionRadius;let interactionPosition;let isEllipse=shapeIsEllipse(shapeDefault);let isText=shapeIsText(shapeDefault);let isRelative=options.position===\"relative\";if(shapeIsPath(shapeDefault)){return{start:e=>{const{origin}=e.detail;interactionRadius=4;interactionOrigin=vectorClone(origin);interactionPosition=vectorClone(origin);const originPoint=mapEditorPointToImagePoint(origin);if(isRelative){originPoint.x=isRelative?toPercentage(originPoint.x,parentRect.width):originPoint.x;originPoint.y=isRelative?toPercentage(originPoint.y,parentRect.height):originPoint.y;}// add to markup so it's drawn\naddMarkupItemDraft(_objectSpread(_objectSpread({},shapeDefault),{},{points:[originPoint]}));},update:e=>{const draft=getMarkupItemDraft();const{translation}=e.detail;// position\nconst pointerPosition=vectorCreate(interactionOrigin.x+translation.x,interactionOrigin.y+translation.y);// distance between interaction and pointer if it's too close, we don't draw this point\nconst dist=vectorDistance(interactionPosition,pointerPosition);if(fixPrecision(dist,5)<=interactionRadius)return;// get angle between interaction and pointer\nconst angle=vectorAngleBetween(pointerPosition,interactionPosition);// move brush towards pointer at angle\nconst moveDist=interactionRadius-dist;interactionPosition.x+=moveDist*Math.cos(angle);interactionPosition.y+=moveDist*Math.sin(angle);// create point\nconst point=mapEditorPointToImagePoint(interactionPosition);if(point){point.x=isRelative?toPercentage(point.x,parentRect.width):point.x;point.y=isRelative?toPercentage(point.y,parentRect.height):point.y;}draft.points=draft.points.concat(point);syncShapes();},release:e=>e.detail.preventInertia(),end:e=>{const draft=getMarkupItemDraft();if(e.detail.isTap)return discardMarkupItemDraft();const shape=confirmMarkupItemDraft();onaddshape(shape);}};}else if(isEllipse||isText||shapeIsRect(shapeDefault)){return{start:e=>{const{origin}=e.detail;// need to remember origin so we can correctly apply interaction translation\ninteractionOrigin=vectorClone(origin);const mappedOriginPosition=mapEditorPointToImagePoint(interactionOrigin);// add to markup so it's drawn\nconst draft=_objectSpread(_objectSpread({},shapeDefault),{},{rotation:-rotation,x:isRelative?toPercentage(mappedOriginPosition.x,parentRect.width):mappedOriginPosition.x,y:isRelative?toPercentage(mappedOriginPosition.y,parentRect.height):mappedOriginPosition.y});// remove position\ndelete draft.position;// hide initially\ndraft.opacity=0;// \nif(isEllipse){draft.rx=isRelative?toPercentage(0):0;draft.ry=isRelative?toPercentage(0):0;}else{draft.width=isRelative?toPercentage(0):0;draft.height=isRelative?toPercentage(0):0;}addMarkupItemDraft(draft);},update:e=>{const draft=getMarkupItemDraft();draft.opacity=1;const{aspectRatio}=draft;let{translation}=e.detail;// limit to aspect ratio\nif(aspectRatio){const t=Math.abs(translation.x)*aspectRatio;translation.x=translation.x;translation.y=t*Math.sign(translation.y);}// position\nconst pointerPosition=vectorCreate(interactionOrigin.x+translation.x,interactionOrigin.y+translation.y);const mappedOriginPosition=mapEditorPointToImagePoint(interactionOrigin);const mappedPointerPosition=mapEditorPointToImagePoint(pointerPosition);const pivot={x:mappedOriginPosition.x+(mappedPointerPosition.x-mappedOriginPosition.x)*0.5,y:mappedOriginPosition.y+(mappedPointerPosition.y-mappedOriginPosition.y)*0.5};vectorRotate(mappedOriginPosition,rotation,pivot);vectorRotate(mappedPointerPosition,rotation,pivot);const l=Math.min(mappedOriginPosition.x,mappedPointerPosition.x);const t=Math.min(mappedOriginPosition.y,mappedPointerPosition.y);const r=Math.max(mappedOriginPosition.x,mappedPointerPosition.x);const b=Math.max(mappedOriginPosition.y,mappedPointerPosition.y);let width=r-l;let height=b-t;let props={};if(isEllipse){props.x=l+width*0.5;props.y=t+height*0.5;props.rx=width*0.5;props.ry=height*0.5;}else{props.x=l;props.y=t;props.width=width;props.height=height;}updateShape(draft,props,parentRect);// shapeUpdateProps(draft, props, parentRect);\nsyncShapes();},release:e=>{e.detail.preventInertia();},end:e=>{const draft=getMarkupItemDraft();if(e.detail.isTap)return discardMarkupItemDraft();draft.opacity=1;// finish markup\nif(!shapeIsText(draft)){const shape=confirmMarkupItemDraft();onaddshape(shape);}// select the draft\nselectShape(draft);// also enable editing the text\nif(shapeIsText(draft))editMarkupItem(draft);}};}else if(shapeIsLine(shapeDefault)){return{start:e=>{const{origin}=e.detail;const originMapped=mapEditorPointToImagePoint(origin);const originSnapped=vectorApply(originMapped,snapToPixel);interactionOrigin=vectorClone(origin);// add to markup so it's drawn\naddMarkupItemDraft(_objectSpread(_objectSpread({},shapeDefault),{},{x1:isRelative?toPercentage(originSnapped.x,parentRect.width):originSnapped.x,y1:isRelative?toPercentage(originSnapped.y,parentRect.height):originSnapped.y,x2:isRelative?toPercentage(originSnapped.x,parentRect.width):originSnapped.x,y2:isRelative?toPercentage(originSnapped.y,parentRect.height):originSnapped.y,opacity:0}));},update:e=>{const draft=getMarkupItemDraft();const{translation}=e.detail;const interactionTarget=vectorAdd(vectorClone(interactionOrigin),translation);// shift pressed\nif($keysPressedStored.includes(16)){const length=vectorDistance(interactionOrigin,interactionTarget);const angle=vectorAngleBetween(interactionOrigin,interactionTarget);const angleSnapInterval=Math.PI/4;const angleSnapped=angleSnapInterval*Math.round(angle/angleSnapInterval);interactionTarget.x=interactionOrigin.x+length*Math.cos(angleSnapped);interactionTarget.y=interactionOrigin.y+length*Math.sin(angleSnapped);}// update line end position\nconst point=mapEditorPointToImagePoint(interactionTarget);updateMarkupShape(draft,{x2:isRelative?toPercentage(point.x,parentRect.width):point.x,y2:isRelative?toPercentage(point.y,parentRect.height):point.y,opacity:1});syncShapes();},release:e=>e.detail.preventInertia(),end:e=>{const draft=getMarkupItemDraft();if(e.detail.isTap)return discardMarkupItemDraft();// get draft\ndraft.opacity=1;// finish markup\nconfirmMarkupItemDraft();// select the draft\nselectShape(draft);}};}};const eraseShape=()=>{let origin;let positionPrevious;return{start:e=>{origin=e.detail.origin;positionPrevious=origin;},update:e=>{const{translation}=e.detail;const positionCurrent=vectorCreate(origin.x+translation.x,origin.y+translation.y);const shapesFound=getMarkupBetweenPoints(mapEditorPointToImagePoint(positionPrevious),mapEditorPointToImagePoint(positionCurrent));const shapesRemoved=removeMarkupItems(shapesFound);shapesRemoved.forEach(onremoveshape);positionPrevious=vectorClone(positionCurrent);},release:e=>e.detail.preventInertia(),end:()=>{}};};//\n// Mapping coordinates\n//\nconst getImagePointWithScreenTranslation=(point,translation)=>{const pointInScreenSpace=mapImagePointToEditorPoint(point);return mapEditorPointToImagePoint(vectorAdd(pointInScreenSpace,translation));};//\n// Interaction\n//\n// image zoom\nconst handleWheel=e=>{};// TODO: ZOOM image\n// markup manipulate\nconst translateShape=(shapeCurrent,shapeOriginComputed,translation)=>{if(shapeIsLine(shapeCurrent)){const beginImageOffset=getImagePointWithScreenTranslation(shapeLineGetStartPoint(shapeOriginComputed),translation);const endImageOffset=getImagePointWithScreenTranslation(shapeLineGetEndPoint(shapeOriginComputed),translation);updateShape(shapeCurrent,{x1:beginImageOffset.x,y1:beginImageOffset.y,x2:endImageOffset.x,y2:endImageOffset.y},parentRect);}else if(shapeIsRect(shapeCurrent)||shapeIsText(shapeCurrent)||shapeIsEllipse(shapeCurrent)){const imagePoint=getImagePointWithScreenTranslation(shapeOriginComputed,translation);updateShape(shapeCurrent,imagePoint,parentRect);}syncShapes();};const resizeMarkup=(shapeCurrent,shapeOriginComputed,indexes,translation,options)=>{if(shapeIsLine(shapeCurrent)){const[targetIndex]=indexes;const snap=$keysPressedStored.includes(16)?(origin,target)=>{const length=vectorDistance(origin,target);const angle=vectorAngleBetween(origin,target);const angleSnapInterval=Math.PI/4;const angleSnapped=angleSnapInterval*Math.round(angle/angleSnapInterval)-rotation%angleSnapInterval;target.x=origin.x+length*Math.cos(angleSnapped);target.y=origin.y+length*Math.sin(angleSnapped);}:(origin,target)=>target;if(targetIndex===0){const point=getImagePointWithScreenTranslation(shapeLineGetStartPoint(shapeOriginComputed),translation);snap(vectorCreate(shapeOriginComputed.x2,shapeOriginComputed.y2),point);updateShape(shapeCurrent,{x1:point.x,y1:point.y},parentRect);}else if(targetIndex===1){const point=getImagePointWithScreenTranslation(shapeLineGetEndPoint(shapeOriginComputed),translation);snap(vectorCreate(shapeOriginComputed.x1,shapeOriginComputed.y1),point);updateShape(shapeCurrent,{x2:point.x,y2:point.y},parentRect);}}else if(shapeHasSize(shapeCurrent)||shapeIsEllipse(shapeCurrent)||shapeIsTextBox(shapeCurrent)){let hasAutoHeight=false;let shapeOriginRect;if(shapeIsEllipse(shapeCurrent)){shapeOriginRect=rectCreateFromEllipse(shapeOriginComputed);}else if(shapeHasSize(shapeCurrent)){shapeOriginRect=rectCreateFromAny(shapeOriginComputed);}else{// is text with 'width' only\nhasAutoHeight=true;shapeOriginRect=rectCreateFromAny(shapeOriginComputed);const size=textSize(shapeOriginComputed.text,shapeOriginComputed);shapeOriginRect.height=size.height;}let shapeAspectRatio;if(shapeCurrent.aspectRatio){shapeAspectRatio=shapeCurrent.aspectRatio;}else if(options.shiftKey&&!hasAutoHeight){shapeAspectRatio=shapeOriginRect.width/shapeOriginRect.height;}// current shape\nconst rectAligned=rectCreateFromAny(shapeOriginRect);const rectAlignedCenterPosition=rectCenter(rectAligned);const rectRotation=shapeCurrent.rotation;const rectAlignedCorners=rectGetCorners(rectAligned);const rectCorners=rectRotate(rectAligned,rectRotation);// is translating one corner\nif(indexes.length===1){// corner\nlet cornerIndex=indexes[0];const[tl,tr,br,bl]=rectAlignedCorners;const screenTargetPosition=mapImagePointToEditorPoint(rectCorners[cornerIndex]);vectorAdd(screenTargetPosition,translation);const imageTargetPosition=mapEditorPointToImagePoint(screenTargetPosition);const imageTargetTranslation=vectorCreate(imageTargetPosition.x-rectCorners[cornerIndex].x,imageTargetPosition.y-rectCorners[cornerIndex].y);if(shapeCurrent.flipX)imageTargetTranslation.x=-imageTargetTranslation.x;if(shapeCurrent.flipY)imageTargetTranslation.y=-imageTargetTranslation.y;const imageTargetTranslationAligned=vectorRotate(vectorClone(imageTargetTranslation),-rectRotation);const imageTargetPositionAligned=vectorCreate(rectAlignedCorners[cornerIndex].x+imageTargetTranslationAligned.x,rectAlignedCorners[cornerIndex].y+imageTargetTranslationAligned.y);let anchor;if(cornerIndex===0)anchor=br;if(cornerIndex===1)anchor=bl;if(cornerIndex===2)anchor=tl;if(cornerIndex===3)anchor=tr;// create an aligned and updated rectangle\nconst rectAlignedResized=rectCreateFromPoints(anchor,imageTargetPositionAligned);// limit rect\nif(shapeAspectRatio){// get size that adheres to aspect ratio but still fits current rectangle\nconst{width,height}=rectContainRect(rectAlignedResized,shapeAspectRatio);const[t,r,b,l]=rectToBounds(rectAlignedResized);// update size\nrectAlignedResized.width=width;rectAlignedResized.height=height;// align to anchor\nif(imageTargetPositionAligned.y<anchor.y){rectAlignedResized.y=b-height;}if(imageTargetPositionAligned.x<anchor.x){rectAlignedResized.x=r-width;}}// rotate the aligned rectangle around it's original pivot point\nconst rr=rectRotate(rectAlignedResized,rectRotation,rectAlignedCenterPosition);// now calculate the new center and then rotate the tl and br corners around that center to find their new positions\nconst rrc=vectorCenter(rr);const p1=vectorRotate(rr[0],-rectRotation,rrc);const p2=vectorRotate(rr[2],-rectRotation,rrc);if(shapeCurrent.flipX||shapeCurrent.flipY){vectorsFlip([p1,p2],shapeCurrent.flipX,shapeCurrent.flipY,rectAlignedCenterPosition.x,rectAlignedCenterPosition.y);}const rectUpdated=rectCreateFromPoints(p1,p2);updateShape(shapeCurrent,shapeIsEllipse(shapeCurrent)?ellipseCreateFromRect(rectUpdated):rectUpdated,parentRect);}else// is translating two corner points\n{// 0-1 -> 2-3\n// 1-2 -> 3-0\n// 2-3 -> 0-1\n// 3-0 -> 1-2\nconst[cornerA,cornerB]=indexes.map(index=>rectCorners[index]);const mid={x:cornerA.x+(cornerB.x-cornerA.x)*0.5,y:cornerA.y+(cornerB.y-cornerA.y)*0.5};const[cornerAlignedA,cornerAlignedB]=indexes.map(index=>rectAlignedCorners[index]);const[cornerAlignedC,cornerAlignedD]=indexes.map(index=>{const mappedIndex=index+2;if(mappedIndex<4)return rectAlignedCorners[mappedIndex];return rectAlignedCorners[mappedIndex-4];});const midAligned={x:cornerAlignedA.x+(cornerAlignedB.x-cornerAlignedA.x)*0.5,y:cornerAlignedA.y+(cornerAlignedB.y-cornerAlignedA.y)*0.5};const midAnchorAligned={x:cornerAlignedC.x+(cornerAlignedD.x-cornerAlignedC.x)*0.5,y:cornerAlignedC.y+(cornerAlignedD.y-cornerAlignedC.y)*0.5};const screenTargetPosition=mapImagePointToEditorPoint(mid);vectorAdd(screenTargetPosition,translation);const imageTargetPosition=mapEditorPointToImagePoint(screenTargetPosition);const imageTargetTranslation=vectorCreate(imageTargetPosition.x-mid.x,imageTargetPosition.y-mid.y);if(shapeCurrent.flipX)imageTargetTranslation.x=-imageTargetTranslation.x;if(shapeCurrent.flipY)imageTargetTranslation.y=-imageTargetTranslation.y;const imageTargetTranslationAligned=vectorRotate(vectorClone(imageTargetTranslation),-rectRotation);// const imageTargetPositionAligned = vectorCreate(\n//     midAligned.x + imageTargetTranslationAligned.x,\n//     midAligned.y + imageTargetTranslationAligned.y,\n// );\nconst d=vectorSubtract(vectorClone(cornerAlignedA),cornerAlignedB);const f=vectorApply(d,v=>1-Math.abs(Math.sign(v)));const t=vectorCreate(imageTargetTranslationAligned.x*f.x,imageTargetTranslationAligned.y*f.y);vectorAdd(cornerAlignedA,t);vectorAdd(cornerAlignedB,t);const rectAlignedResized=rectCreateFromPoints(rectAlignedCorners);// limit rect\nif(shapeAspectRatio){let width=rectAlignedResized.width;let height=rectAlignedResized.height;if(f.y===0){height=width/shapeAspectRatio;}else{width=height*shapeAspectRatio;}// update size\nrectAlignedResized.width=width;rectAlignedResized.height=height;// align to anchor\nif(f.y===0){rectAlignedResized.y=midAnchorAligned.y-height*0.5;}else{rectAlignedResized.x=midAnchorAligned.x-width*0.5;}}// rotate the aligned rectangle around it's original pivot point\nconst rr=rectRotate(rectAlignedResized,rectRotation,rectAlignedCenterPosition);// now calculate the new center and then rotate the tl and br corners around that center to find their new positions\nconst rrc=vectorCenter(rr);const p1=vectorRotate(rr[0],-rectRotation,rrc);const p2=vectorRotate(rr[2],-rectRotation,rrc);if(shapeCurrent.flipX||shapeCurrent.flipY){vectorsFlip([p1,p2],shapeCurrent.flipX,shapeCurrent.flipY,rectAlignedCenterPosition.x,rectAlignedCenterPosition.y);}const rectUpdated=rectCreateFromPoints(p1,p2);let props;if(shapeIsEllipse(shapeCurrent)){props=ellipseCreateFromRect(rectUpdated);}else if(shapeHasSize(shapeCurrent)){props=rectUpdated;}else if(hasAutoHeight){props={x:rectUpdated.x,y:rectUpdated.y,width:rectUpdated.width};}updateShape(shapeCurrent,props,parentRect);}}syncShapes();};let rotatorInitialPosition;const rotateMarkup=(shapeCurrent,shapeOriginComputed,translation,options)=>{// calculate angle between translated rotation control and origin\nconst shapeRect=getMarkupShapeRect(shapeComputeDisplay(shapeDeepCopy(shapeCurrent),parentRect));const shapeCenter=rectCenter(shapeRect);const p=getImagePointWithScreenTranslation(rotatorInitialPosition,translation);let shapeRotation=vectorAngleBetween(p,shapeCenter)+Math.PI/2;if(options.shiftKey){const rotatorSnapInterval=Math.PI/16;shapeRotation=rotatorSnapInterval*Math.round(shapeRotation/rotatorSnapInterval)-rotation%rotatorSnapInterval;}updateShape(shapeCurrent,{rotation:shapeRotation},parentRect);syncShapes();};const getMarkupItemDraft=()=>{if(!markup.length)return;const lastMarkupItem=markup[markup.length-1];return lastMarkupItem.isDraft?lastMarkupItem:undefined;};const addMarkupItemDraft=(shape,sync=true)=>{if(getMarkupItemDraft())return;shape=Object.assign(shape,{isDraft:true});return addShape(shape,sync);};const confirmMarkupItemDraft=()=>{const markupItem=getMarkupItemDraft();if(!markupItem)return;updateMarkupShapeProperty(markupItem,\"isDraft\",false);return markupItem;};const discardMarkupItemDraft=()=>{if(!getMarkupItemDraft())return;$$invalidate(0,markup=markup.slice(0,-1));};const createMarkupItem=(props={})=>_objectSpread({id:getUniqueId()},props);const syncShapes=()=>$$invalidate(0,markup);const addShape=(shape,sync=true)=>{markup.push(shape);// sync markup array\nif(sync)syncShapes();return shape;};const updateMarkupShape=(shape,props,sync=true)=>{// update markup\nshape=Object.assign(shape,props);// sync markup array\nif(!sync)return;syncShapes();};const updateMarkupShapeProperty=(shape,name,value,sync=true)=>{shape[name]=value;// sync markup array\nif(!sync)return;syncShapes();};const updateMarkupItemsShapeProperty=(name,value,sync=true)=>{markup.forEach(shape=>updateMarkupShapeProperty(shape,name,value,false));// sync markup array\nif(!sync)return;syncShapes();};const updateMarkupShapeItems=(props,sync=true)=>{markup.forEach(markupItem=>updateMarkupShape(markupItem,props,false));// sync markup array\nif(!sync)return;syncShapes();};const getActiveMarkupItem=()=>[...markup].reverse().find(shapeIsSelected);const hasActiveMarkupItem=()=>!!getActiveMarkupItem();const removeShape=(shapeToRemove,sync=true)=>{if(!beforeRemoveShape(shapeToRemove))return false;const markupWithoutShape=markup.filter(shape=>shape!==shapeToRemove);onremoveshape(shapeToRemove);if(!sync)return;$$invalidate(0,markup=markupWithoutShape);};const removeActiveMarkupItem=()=>{const activeShape=getActiveMarkupItem();if(!activeShape)return;// get removable markup items, \nconst removableShapes=markup.filter(shape=>shapeCanRemove(shape)&&shapeCanSelect(shape));// find index of active shape so we can select the next active shape on removal\nconst index=removableShapes.findIndex(shape=>shape===activeShape);// remove the active ship from the shape array\nconst didRemove=removeShape(activeShape);if(didRemove===false)return;// remember selection\npreviousSelectedShape=activeShape;// if no more markup items, release active shape\nif(removableShapes.length-1===0)return blurShapes();// select next active markup item\nconst indexNext=index-1<0?removableShapes.length-1:index-1;selectShape(removableShapes[indexNext]);};let previousSelectedShape=undefined;const blurShapes=()=>{previousSelectedShape=getSelectedShape();updateMarkupShapeItems({isSelected:false,isEditing:false});};const getSelectedShape=()=>markup.find(shapeIsSelected);const selectShape=(shape,sync=true)=>{// can't select draft\nif(shape.isDraft)return;// get currently selected shape\nconst selectedShape=getSelectedShape()||previousSelectedShape;// reset previous selected shape\npreviousSelectedShape=undefined;// if is returned false will cancel select operation\nif(!beforeSelectShape(selectedShape,shape))return;// remove selected state from other markup\nblurShapes();// select\nshapeSelect(shape);// selected this shape\nonselectshape(shape);// sync\nif(!sync)return;syncShapes();};const deselectMarkupItem=markupItem=>{updateMarkupShape(markupItem,{isSelected:false,isEditing:false});};const editMarkupItem=markupItem=>{updateMarkupShape(markupItem,{isSelected:true,isEditing:true});};const finishEditMarkupItem=markupItem=>{updateMarkupShape(markupItem,{isSelected:true,isEditing:false});};const removeMarkupItems=shapesToRemove=>{const shapesToRemoveFiltered=shapesToRemove.filter(beforeRemoveShape);$$invalidate(0,markup=markup.filter(shape=>!shapesToRemoveFiltered.includes(shape)));return shapesToRemoveFiltered;};const getTextShapeRect=shape=>{const size=textSize(shape.text,shape);return rectCreate(shape.x,shape.y,shape.width?Math.min(shape.width,size.width):size.width,shape.height?Math.min(shape.height,size.height):size.height);};const getMarkupShapeRect=shape=>{// has own rect\nif(shapeHasSize(shape))return rectCreateFromAny(shape);if(shapeIsEllipse(shape))return rectCreateFromEllipse(shape);// calculate the size on canvas\nconst rect=getTextShapeRect(shape);rect.width=Math.max(MIN_TEXT_MARKUP_WIDTH,shape.width||rect.width);return rect;};const getShapesAtPosition=position=>[...markup].// reverse the array, want to select from top to bottom\nreverse().map(shape=>({shape,priority:1})).// can't select paths\nfilter(result=>shapeCanSelect(result.shape)).// find markup near pointer\nfilter(result=>{// get shape\nconst{shape}=result;// we need to know where the shape will end up\nconst computedShape=shapeComputeDisplay(shapeDeepCopy(shape),parentRect);// test if clicked in rect\nif(shapeIsRect(computedShape)){return isPositionInRect(position,computedShape,shape.rotation);}else if(shapeIsText(computedShape)){const shapeRect=getMarkupShapeRect(computedShape);const isPositionInBounds=isPositionInRect(position,shapeRect,shape.rotation);let isPositionInVisual=false;if(isPositionInBounds&&!shapeIsSelected(shape)){const visualRect=getTextShapeRect(computedShape);if(shape.textAlign===\"right\"&&!shape.flipX){visualRect.x=shapeRect.x+shapeRect.width-visualRect.width;}if(shape.textAlign===\"center\"){visualRect.x=shapeRect.x+shapeRect.width*0.5-visualRect.width*0.5;}isPositionInVisual=isPositionInRect(position,visualRect,shape.rotation,rectCenter(shapeRect));if(!isPositionInVisual)result.priority=-1;}return isPositionInBounds;}else// test if is ellipse\nif(shapeIsEllipse(computedShape)){return isPositionInEllipse(position,computedShape,shape.rotation);}else// test if clicked on line\nif(shapeIsLine(computedShape)){// radius around click position, test if line intersects\nreturn isPositionNearLine(position,shapeLineGetStartPoint(computedShape),shapeLineGetEndPoint(computedShape),16);}return false;}).sort((a,b)=>{if(a.priority<b.priority){return 1;}if(a.priority>b.priority){return-1;}return 0;});const getMarkupBetweenPoints=(a,b)=>{// eraseLine should be in image space\nconst eraseLine=lineCreate(a,b);// loop over shapes and find intersecting shapes\nreturn markup.filter(shapeCanErase).filter(shape=>!!linePointsIntersection(eraseLine,getMarkupShapePoints(shapeComputeDisplay(shapeDeepCopy(shape),parentRect))));};//\n// Generic interaction\n//\nlet interactionTimer=undefined;let interactionTarget=undefined;let interactionShape=undefined;let interactionShapeOriginComputed=undefined;let isInteracting=false;const handleInteractionStart=e=>{const{origin}=e.detail;interactionShape=undefined;interactionShapeOriginComputed=undefined;interactionTarget=undefined;clearTimeout(interactionTimer);interactionTimer=setTimeout(()=>$$invalidate(104,isInteracting=true),250);// test if target is a shape, if not, run interaction handler\nconst point=mapEditorPointToImagePoint(vectorClone(origin));const foundShapes=getShapesAtPosition(point);const targettedMarkupItem=foundShapes.length&&foundShapes.shift().shape;// check if markup was targetted\nif(targettedMarkupItem&&shapeIsSelected(targettedMarkupItem)){// clone shape we're interacting with so we can update it properly\ninteractionShape=targettedMarkupItem;interactionShapeOriginComputed=shapeComputeDisplay(shapeDeepCopy(interactionShape),parentRect);return;}// set target\ninteractionTarget=targettedMarkupItem;// started interacting\noninteractionstart(e);};const handleInteractionUpdate=e=>{// is interacting with shape\nif(interactionShape){// prevent moving if not allowed\nif(!shapeCanMove(interactionShape))return;// prevent moving if is editing text\nif(shapeIsTextEditing(interactionShape))return;return translateShape(interactionShape,interactionShapeOriginComputed,e.detail.translation);}oninteractionupdate(e);};const handleInteractionRelease=e=>{clearTimeout(interactionTimer);$$invalidate(104,isInteracting=false);// test if is text and if we double tapped, if so, switch to text edit mode\nif(interactionShape){if(interactionShape.isEditing){handleTextCancel();}else if(e.detail.isDoubleTap&&shapeIsText(interactionShape)&&shapeCanInput(interactionShape)!==false){editMarkupItem(interactionShape);}return;}oninteractionrelease(e);};const handleInteractionEnd=e=>{// shape remains active so user can resize, rotate\nif(interactionShape){onupdateshape(interactionShape);interactionShape=undefined;return;}// can we deselect the current shape?\nconst currentSelectedShape=getSelectedShape();const isSelectInteraction=interactionTarget&&e.detail.isTap;const allowDeselectShape=currentSelectedShape?beforeDeselectShape(currentSelectedShape,interactionTarget):true;if(allowDeselectShape){blurShapes();}oninteractionend(e);if(allowDeselectShape&&isSelectInteraction){selectShape(interactionTarget);}};//\n// Shape manipulation\n//\nconst getMarkupShapePoints=shape=>{let center;let points;if(shapeIsRect(shape)){center=rectCenter(shape);points=rectGetCorners(shape);if(shape.flipX||shape.flipY)vectorsFlip(points,shape.flipX,shape.flipY,center.x,center.y);points=vectorsRotate(points,shape.rotation,center.x,center.y);}else if(shapeIsEllipse(shape)){center=shape;points=rectGetCorners(rectCreateFromEllipse(shape));if(shape.flipX||shape.flipY)vectorsFlip(points,shape.flipX,shape.flipY,center.x,center.y);points=vectorsRotate(points,shape.rotation,center.x,center.y);}else if(shapeIsLine(shape)){points=[shapeLineGetStartPoint(shape),shapeLineGetEndPoint(shape)];center=vectorCenter(points);}else if(shapeIsPath(shape)){points=[...shape.points];center=vectorCenter(points);}else if(shapeIsText(shape)){const rect=getMarkupShapeRect(shape);rect.width=Math.max(MIN_TEXT_MARKUP_WIDTH,rect.width);center=rectCenter(rect);points=rectGetCorners(rect);if(shape.flipX||shape.flipY)vectorsFlip(points,shape.flipX,shape.flipY,center.x,center.y);points=vectorsRotate(points,shape.rotation,center.x,center.y);}return points;};const getShapeRotationPoint=shape=>{const points=getMarkupShapePoints(shape);let origin;let dir;if(shape.flipY){origin=vectorCenter([points[0],points[1]]);dir=vectorNormalize(vectorCreate(points[1].x-points[2].x,points[1].y-points[2].y));}else{origin=vectorCenter([points[2],points[3]]);dir=vectorNormalize(vectorCreate(points[2].x-points[1].x,points[2].y-points[1].y));}vectorMultiply(dir,ROTATION_CONTROL_OFFSET/scale);return{origin,dir};};const getShapeRotationPointOnScreen=shape=>{const markupPoint=getShapeRotationPoint(shape);const screenPosition=mapImagePointToEditorPoint({x:markupPoint.origin.x+markupPoint.dir.x,y:markupPoint.origin.y+markupPoint.dir.y});const screenOrigin=mapImagePointToEditorPoint(markupPoint.origin);return{origin:screenOrigin,position:screenPosition};};// draw shape manipulator edges\nlet shapeManipulatorUid=`markup-manipulator-segment`;onDestroy(()=>{// clean up UI elements created by editor\n$$invalidate(43,ui=ui.filter(guide=>guide.id!==shapeManipulatorUid));});const handleManipulatorResizeGrab=e=>{$$invalidate(104,isInteracting=true);interactionShape=activeMarkup;interactionShapeOriginComputed=activeMarkupComputed;};const handleManipulatorResizeDrag=e=>{const{translation,indexes,shiftKey}=e.detail;resizeMarkup(interactionShape,interactionShapeOriginComputed,indexes,translation,{shiftKey});};const handleManipulatorResizeEnd=e=>{selectShape(interactionShape);interactionShape=undefined;$$invalidate(104,isInteracting=false);onupdateshape(activeMarkup);};const handleManipulatorRotateGrab=e=>{rotatorInitialPosition=getShapeRotationPoint(activeMarkupComputed).origin;$$invalidate(104,isInteracting=true);interactionShape=activeMarkup;interactionShapeOriginComputed=activeMarkupComputed;};const handleManipulatorRotateDrag=e=>{const{translation,shiftKey}=e.detail;rotateMarkup(interactionShape,interactionShapeOriginComputed,translation,{shiftKey});};const handleManipulatorRotateEnd=()=>{selectShape(interactionShape);interactionShape=undefined;$$invalidate(104,isInteracting=false);onupdateshape(activeMarkup);};//\n// Keyboard\n//\nconst handleKey=e=>{// only handle key input if a shape has been selected\nif(!hasActiveMarkupItem())return;// get key type\nconst{key}=e;// if is escape deselect active item\nif(/escape/i.test(key)){return deselectMarkupItem(activeMarkup);}// if is tab, select next markup item\n/*\nif (/arrow/i.test(key)) {\n    const success = e.shiftKey \n        ? selectPreviousMarkupItem(activeMarkup)\n        : selectNextMarkupItem(activeMarkup);\n    \n    if (success) {\n        e.preventDefault();\n        e.stopPropagation();\n    }\n}\n*/ // if is remove active\nif(/backspace/i.test(key)&&!/input|textarea/i.test(e.target.nodeName)){// prevent back navigation on Firefox\ne.preventDefault();// remove the item\nremoveActiveMarkupItem();}};//\n// Text input\n//\nlet textInput;const getTextShapeOriginSnapshot=()=>_objectSpread({},activeMarkup);const handleTextInput=()=>{const value=shapeIsTextLine(activeMarkup)?filterNewlines(textInput.value):textInput.value;const canInput=shapeCanInput(activeMarkup,value);const text=canInput===true?value:canInput;let x=textShapeOrigin.x;let y=textShapeOrigin.y;// if does not have height we need to adjust offset if is rotated\nif(!activeMarkup.height&&activeMarkup.rotation!==0){const textSizeCurrent=textSize(text,activeMarkup);const textRectCurrent=rectCreate(textShapeOrigin.x,textShapeOrigin.y,textSizeCurrent.width,textSizeCurrent.height);const[currentTopLeft]=rectRotate(textRectCurrent,textShapeOrigin.rotation);const[originTopLeft]=rectRotate(textRectOrigin,textShapeOrigin.rotation);x+=originTopLeft.x-currentTopLeft.x;y+=originTopLeft.y-currentTopLeft.y;}updateMarkupShape(activeMarkup,{x,y,text});};const handleEditTextActiveMarkup=()=>editMarkupItem(activeMarkup);const handleTextInputAttempt=e=>{const currentValue=e.target.value;const selectionStart=e.target.selectionStart;const selectionEnd=e.target.selectionEnd;const currentValueStart=currentValue.substring(0,selectionStart);const currentValueEnd=currentValue.substring(selectionEnd);const intendedValue=currentValueStart+e.key+currentValueEnd;const filteredValue=shapeCanInput(activeMarkup,intendedValue);if(filteredValue!==intendedValue)return e.preventDefault();};const filterNewlines=value=>value.// split on lines so we can create compressed normal line of text\nsplit(/[\\n\\r]/g).// rempve spaces around lines\nmap(str=>str.trim()).// remove empty strings\nfilter(str=>str.length).// create new line\njoin(\" \");// prevent moving shape when focusing text field, and close field if escape pressed\nconst handleTextInputKeyDown=e=>{if(shapeIsTextLine(activeMarkup)&&/enter/i.test(e.code))return e.preventDefault();if(/arrow/i.test(e.code))return e.stopPropagation();if(/escape/i.test(e.key))return handleTextCancel();};// handle alt/ctrl/cmd + return\nconst handleTextInputKeyUp=e=>{// get key type\nconst{key,ctrlKey,altKey}=e;// confirm multi line text elements\nif(/enter/i.test(key)&&ctrlKey|altKey)return handleTextConfirm();};const handleTextConfirm=()=>{// if was draft, now need to confirm\nlet wasDraft=activeMarkup.isDraft;if(activeMarkup.isDraft)confirmMarkupItemDraft();// final text input check\nhandleTextInput();// done\nfinishEditMarkupItem(activeMarkup);if(wasDraft)onaddshape(activeMarkup);else onupdateshape(activeMarkup);};const handleTextCancel=()=>{// revert text\nupdateMarkupShape(activeMarkup,{text:textShapeOrigin.text,x:textShapeOrigin.x,y:textShapeOrigin.y});if(activeMarkup.isDraft)discardMarkupItemDraft();finishEditMarkupItem(activeMarkup);};//\n// Controls\n//\nconst handleFlipX=e=>{e.stopPropagation();const flipX=activeMarkup.flipX||false;updateMarkupShapeProperty(activeMarkup,\"flipX\",!flipX);onupdateshape(activeMarkup);};const handleFlipY=e=>{e.stopPropagation();const flipY=activeMarkup.flipY||false;updateMarkupShapeProperty(activeMarkup,\"flipY\",!flipY);onupdateshape(activeMarkup);};const handleRemoveActiveMarkup=e=>{e.stopPropagation();e.target.blur();// cancels focus of remove button\nremoveActiveMarkupItem();};const handleMoveToFrontActiveMarkup=e=>{e.stopPropagation();// test if is not already at top of stack, if so, exit\nconst index=markup.findIndex(shape=>shape===activeMarkup);if(index===markup.length-1)return;// add to last index\n$$invalidate(0,markup=markup.filter(markupItem=>markupItem!==activeMarkup).concat([activeMarkup]));onupdateshape(activeMarkup);};const handleDuplicateActiveMarkup=e=>{e.stopPropagation();// create clone\nconst clone=shapeDeepCopy(activeMarkup);clone.id=getUniqueId();const duplicationOffset=vectorCreate(50,-50);// offset\nif(shapeIsLine(clone)){const linePosition=shapeGetPropsPixelValues(clone,[\"x1\",\"y1\",\"x2\",\"y2\"],parentRect);linePosition.x1+=duplicationOffset.x;linePosition.y1+=duplicationOffset.y;linePosition.x2+=duplicationOffset.x;linePosition.y2+=duplicationOffset.y;shapeUpdateProps(clone,linePosition,parentRect);}else{const currentPosition=shapeGetPropsPixelValues(clone,[\"x\",\"y\"],parentRect);currentPosition.x+=50;currentPosition.y-=50;shapeUpdateProps(clone,currentPosition,parentRect);}// add clone\nmarkup.push(clone);// added\nonaddshape(clone);// select clone\nselectShape(clone);};const getMarkupControlsAnchorPosition=rect=>vectorApply(vectorCreate(rect.x+rect.width*0.5,rect.y),snapToPixel);//\n// show & position markup controls panel\n//\nconst markupControlsOpacity=spring(0,{stiffness:0.2,damping:0.7});component_subscribe($$self,markupControlsOpacity,value=>$$invalidate(17,$markupControlsOpacity=value));let shapeControlsSize;const getShapeControlPositionOnCanvas=position=>{const left=utilRect.x;const top=utilRect.y;const right=left+utilRect.width;let x=Math.max(position.x-shapeControlsSize.width*0.5,left);let y=Math.max(position.y-shapeControlsSize.height-shapeControlDist,top);if(x+shapeControlsSize.width>right)x=right-shapeControlsSize.width;return vectorCreate(x,y);};const handleNudge=e=>{const shape=getActiveMarkupItem();if(!shape)return;if(!shapeCanMove(shape))return;interactionShape=shape;interactionShapeOriginComputed=shapeComputeDisplay(shapeDeepCopy(interactionShape),parentRect);translateShape(interactionShape,interactionShapeOriginComputed,e.detail);};const handleViewResize=()=>{if(isTextMarkupSelected)return;blurShapes();};// shape navigator\nlet showShapeList=false;const handleFocusIn=e=>{$$invalidate(7,showShapeList=true);};const handleFocusOut=({relatedTarget})=>{// still in list\nif(relatedTarget.classList.contains(\"shape-selector__button\"))return;$$invalidate(7,showShapeList=false);};function measure_handler(event){bubble($$self,event);}const click_handler=(index,e)=>selectShape(markup[index]);function textarea_binding($$value){binding_callbacks[$$value?\"unshift\":\"push\"](()=>{textInput=$$value;$$invalidate(5,textInput);});}const measure_handler_1=e=>$$invalidate(6,shapeControlsSize=e.detail);const interactable_function=e=>getEventPositionInEditor(e,rootRect);$$self.$$set=$$props=>{if(\"markup\"in $$props)$$invalidate(0,markup=$$props.markup);if(\"offset\"in $$props)$$invalidate(1,offset=$$props.offset);if(\"rotation\"in $$props)$$invalidate(44,rotation=$$props.rotation);if(\"scale\"in $$props)$$invalidate(45,scale=$$props.scale);if(\"ui\"in $$props)$$invalidate(43,ui=$$props.ui);if(\"opacity\"in $$props)$$invalidate(46,opacity=$$props.opacity);if(\"parentRect\"in $$props)$$invalidate(47,parentRect=$$props.parentRect);if(\"rootRect\"in $$props)$$invalidate(2,rootRect=$$props.rootRect);if(\"stageRect\"in $$props)$$invalidate(48,stageRect=$$props.stageRect);if(\"utilRect\"in $$props)$$invalidate(49,utilRect=$$props.utilRect);if(\"oninteractionstart\"in $$props)$$invalidate(50,oninteractionstart=$$props.oninteractionstart);if(\"oninteractionupdate\"in $$props)$$invalidate(51,oninteractionupdate=$$props.oninteractionupdate);if(\"oninteractionrelease\"in $$props)$$invalidate(52,oninteractionrelease=$$props.oninteractionrelease);if(\"oninteractionend\"in $$props)$$invalidate(53,oninteractionend=$$props.oninteractionend);if(\"onaddshape\"in $$props)$$invalidate(54,onaddshape=$$props.onaddshape);if(\"onupdateshape\"in $$props)$$invalidate(55,onupdateshape=$$props.onupdateshape);if(\"onselectshape\"in $$props)$$invalidate(56,onselectshape=$$props.onselectshape);if(\"onremoveshape\"in $$props)$$invalidate(57,onremoveshape=$$props.onremoveshape);if(\"beforeSelectShape\"in $$props)$$invalidate(58,beforeSelectShape=$$props.beforeSelectShape);if(\"beforeDeselectShape\"in $$props)$$invalidate(59,beforeDeselectShape=$$props.beforeDeselectShape);if(\"beforeAddShape\"in $$props)$$invalidate(60,beforeAddShape=$$props.beforeAddShape);if(\"beforeRemoveShape\"in $$props)$$invalidate(61,beforeRemoveShape=$$props.beforeRemoveShape);if(\"beforeUpdateShape\"in $$props)$$invalidate(62,beforeUpdateShape=$$props.beforeUpdateShape);if(\"willRenderShapeControls\"in $$props)$$invalidate(63,willRenderShapeControls=$$props.willRenderShapeControls);if(\"mapEditorPointToImagePoint\"in $$props)$$invalidate(64,mapEditorPointToImagePoint=$$props.mapEditorPointToImagePoint);if(\"mapImagePointToEditorPoint\"in $$props)$$invalidate(65,mapImagePointToEditorPoint=$$props.mapImagePointToEditorPoint);if(\"enableButtonFlipVertical\"in $$props)$$invalidate(66,enableButtonFlipVertical=$$props.enableButtonFlipVertical);if(\"locale\"in $$props)$$invalidate(3,locale=$$props.locale);};let activeMarkup;let activeShapeId;let activeMarkupComputed;let activeMarkupItemIsDraft;let shapeProps;let shapeActivePoints;let allowResizeControls;let allowRotateControls;let allowedResizeControls;let shouldRenderShapeManipulator;let shapeActiveScreenPoints;let shapeManipulatorPoints;let shapeManipulatorRotationPoint;let shapeManipulatorRotationPointPosition;let shapeOpacity;let isTextMarkupSelected;let shouldRenderTextInput;let textShapeOrigin;let textSizeOrigin;let textRectOrigin;let textInputText;let markupTextInputStyle;let controlledMarkupItem;let allowShapeFlip;let allowShapeDuplicate;let allowShapeRemove;let allowShapeReorder;let allowShapeInput;let markupControlsAnchorPosition;let shapeControlsPosition;let markupControlsStyle;let shapeControls;let shapeNavList;$$self.$$.update=()=>{if($$self.$$.dirty[0]&/*markup*/1){$$invalidate(106,activeMarkup=markup&&(getMarkupItemDraft()||getActiveMarkupItem()));}if($$self.$$.dirty[3]&/*activeMarkup*/8192){$$invalidate(107,activeShapeId=activeMarkup&&!shapeIsDraft(activeMarkup)?activeMarkup.id:undefined);}if($$self.$$.dirty[1]&/*parentRect*/65536|$$self.$$.dirty[3]&/*activeMarkup*/8192){$$invalidate(108,activeMarkupComputed=activeMarkup&&shapeComputeDisplay(shapeDeepCopy(activeMarkup),parentRect));}if($$self.$$.dirty[3]&/*activeMarkup*/8192){$$invalidate(109,activeMarkupItemIsDraft=!!(activeMarkup&&shapeIsDraft(activeMarkup)));}if($$self.$$.dirty[3]&/*activeMarkup*/8192){$$invalidate(110,shapeProps=activeMarkup||undefined);}if($$self.$$.dirty[3]&/*activeMarkup, activeMarkupComputed*/40960){$$invalidate(111,shapeActivePoints=activeMarkup&&!shapeIsPath(activeMarkupComputed)&&getMarkupShapePoints(activeMarkupComputed)||[]);}if($$self.$$.dirty[3]&/*activeMarkup*/8192){$$invalidate(112,allowResizeControls=activeMarkup&&shapeCanResize(activeMarkup)&&!shapeIsTextEditing(activeMarkup));}if($$self.$$.dirty[3]&/*activeMarkup*/8192){$$invalidate(8,allowRotateControls=activeMarkup&&shapeCanRotate(activeMarkup)&&!shapeIsTextEditing(activeMarkup));}if($$self.$$.dirty[3]&/*allowResizeControls, activeMarkup*/532480){$$invalidate(9,allowedResizeControls=allowResizeControls&&hasProp(activeMarkup,\"text\")&&!activeMarkup.height?\"horizontal\":allowResizeControls);}if($$self.$$.dirty[3]&/*activeMarkup, shapeActivePoints*/270336){$$invalidate(10,shouldRenderShapeManipulator=activeMarkup&&shapeActivePoints.length>1);}if($$self.$$.dirty[2]&/*mapImagePointToEditorPoint*/8|$$self.$$.dirty[3]&/*shapeActivePoints*/262144){$$invalidate(113,shapeActiveScreenPoints=shapeActivePoints.map(mapImagePointToEditorPoint));}if($$self.$$.dirty[0]&/*offset*/2|$$self.$$.dirty[3]&/*shapeActiveScreenPoints*/1048576){$$invalidate(11,shapeManipulatorPoints=shapeActiveScreenPoints.map(point=>vectorCreate(point.x-offset.x,point.y-offset.y)));}if($$self.$$.dirty[0]&/*shouldRenderShapeManipulator, allowRotateControls*/1280|$$self.$$.dirty[3]&/*activeMarkupComputed*/32768){$$invalidate(114,shapeManipulatorRotationPoint=shouldRenderShapeManipulator&&allowRotateControls&&getShapeRotationPointOnScreen(activeMarkupComputed));}if($$self.$$.dirty[0]&/*offset*/2|$$self.$$.dirty[3]&/*shapeManipulatorRotationPoint*/2097152){$$invalidate(12,shapeManipulatorRotationPointPosition=shapeManipulatorRotationPoint&&vectorCreate(shapeManipulatorRotationPoint.position.x-offset.x,shapeManipulatorRotationPoint.position.y-offset.y));}if($$self.$$.dirty[1]&/*opacity*/32768){$$invalidate(115,shapeOpacity=opacity);// 1.0; // shapeManipulatorOpacity * opacity;\n}if($$self.$$.dirty[0]&/*shapeManipulatorPoints*/2048|$$self.$$.dirty[1]&/*opacity, ui*/36864|$$self.$$.dirty[3]&/*shapeActiveScreenPoints, shapeOpacity, shapeManipulatorRotationPoint*/7340032){if(opacity>0&&shapeManipulatorPoints.length>2){// create manipulator outline segments\nconst points=[...shapeActiveScreenPoints,shapeActiveScreenPoints[0]];const l=points.length;const segments=[];const strokeColor=[1,1,1,shapeOpacity];const strokeWidth=1;for(let i=0;i<l-1;i++){segments[i]={id:shapeManipulatorUid,points:[points[i],points[i+1]],opacity:1,strokeColor,strokeWidth};}if(shapeManipulatorRotationPoint){// add rotator line\nsegments[segments.length]={id:shapeManipulatorUid,opacity:1,points:[{x:shapeManipulatorRotationPoint.origin.x,y:shapeManipulatorRotationPoint.origin.y},{x:shapeManipulatorRotationPoint.position.x,y:shapeManipulatorRotationPoint.position.y}],strokeColor,strokeWidth};}// remove existing segments, and set new ones\n$$invalidate(43,ui=[...ui.filter(guide=>guide.id!==shapeManipulatorUid),...segments]);}else{// remove the guides when shape manipulator is no longer visible\n$$invalidate(43,ui=ui.filter(guide=>guide.id!==shapeManipulatorUid));}}if($$self.$$.dirty[3]&/*activeMarkup*/8192){$$invalidate(116,isTextMarkupSelected=activeMarkup&&shapeIsText(activeMarkup));}if($$self.$$.dirty[3]&/*isTextMarkupSelected, activeMarkup*/8396800){$$invalidate(13,shouldRenderTextInput=isTextMarkupSelected&&shapeCanInput(activeMarkup)!==false&&activeMarkup.isEditing);}if($$self.$$.dirty[0]&/*shouldRenderTextInput*/8192){$$invalidate(117,textShapeOrigin=shouldRenderTextInput?getTextShapeOriginSnapshot():undefined);}if($$self.$$.dirty[3]&/*textShapeOrigin*/16777216){$$invalidate(118,textSizeOrigin=textShapeOrigin&&textSize(textShapeOrigin.text,textShapeOrigin));}if($$self.$$.dirty[3]&/*textShapeOrigin, textSizeOrigin*/50331648){textRectOrigin=textShapeOrigin&&rectCreate(textShapeOrigin.x,textShapeOrigin.y,textSizeOrigin.width,textSizeOrigin.height);}if($$self.$$.dirty[0]&/*shouldRenderTextInput*/8192|$$self.$$.dirty[3]&/*activeMarkup*/8192){$$invalidate(14,textInputText=shouldRenderTextInput?activeMarkup.text:\"\");}if($$self.$$.dirty[0]&/*shouldRenderTextInput*/8192|$$self.$$.dirty[3]&/*shapeProps*/131072){$$invalidate(15,markupTextInputStyle=shouldRenderTextInput&&`\n    text-align: ${shapeProps.textAlign||\"left\"};\n    font-family: ${shapeProps.fontFamily||\"sans-serif\"};\n`);}if($$self.$$.dirty[3]&/*activeMarkup, activeMarkupItemIsDraft, controlledMarkupItem*/134291456){$$invalidate(120,controlledMarkupItem=activeMarkup&&!activeMarkupItemIsDraft?activeMarkup:controlledMarkupItem);}if($$self.$$.dirty[3]&/*controlledMarkupItem*/134217728){$$invalidate(121,allowShapeFlip=controlledMarkupItem&&shapeCanFlip(controlledMarkupItem));}if($$self.$$.dirty[3]&/*controlledMarkupItem*/134217728){$$invalidate(122,allowShapeDuplicate=controlledMarkupItem&&shapeCanDuplicate(controlledMarkupItem));}if($$self.$$.dirty[3]&/*controlledMarkupItem*/134217728){$$invalidate(123,allowShapeRemove=controlledMarkupItem&&shapeCanRemove(controlledMarkupItem));}if($$self.$$.dirty[3]&/*controlledMarkupItem*/134217728){$$invalidate(124,allowShapeReorder=controlledMarkupItem&&shapeCanReorder(controlledMarkupItem));}if($$self.$$.dirty[3]&/*controlledMarkupItem*/134217728){$$invalidate(125,allowShapeInput=controlledMarkupItem&&shapeCanInput(controlledMarkupItem)!==false);}if($$self.$$.dirty[0]&/*shouldRenderTextInput*/8192|$$self.$$.dirty[3]&/*activeMarkup, activeMarkupItemIsDraft, isInteracting*/75776){markupControlsOpacity.set(activeMarkup&&!activeMarkupItemIsDraft&&!isInteracting&&!shouldRenderTextInput?1:0);}if($$self.$$.dirty[0]&/*shapeManipulatorPoints*/2048|$$self.$$.dirty[3]&/*activeMarkup, activeMarkupItemIsDraft*/73728|$$self.$$.dirty[4]&/*markupControlsAnchorPosition*/4){$$invalidate(126,markupControlsAnchorPosition=activeMarkup&&!activeMarkupItemIsDraft?getMarkupControlsAnchorPosition(rectCreateFromPoints(shapeManipulatorPoints)):markupControlsAnchorPosition);}if($$self.$$.dirty[0]&/*shapeControlsSize*/64|$$self.$$.dirty[1]&/*utilRect*/262144|$$self.$$.dirty[4]&/*markupControlsAnchorPosition*/4){$$invalidate(127,shapeControlsPosition=markupControlsAnchorPosition&&shapeControlsSize&&utilRect&&getShapeControlPositionOnCanvas(markupControlsAnchorPosition));}if($$self.$$.dirty[0]&/*$markupControlsOpacity*/131072|$$self.$$.dirty[4]&/*shapeControlsPosition*/8){$$invalidate(16,markupControlsStyle=shapeControlsPosition&&`transform: translate(${shapeControlsPosition.x}px, ${shapeControlsPosition.y}px);opacity:${$markupControlsOpacity}`);}if($$self.$$.dirty[0]&/*locale*/8|$$self.$$.dirty[2]&/*willRenderShapeControls, enableButtonFlipVertical*/18|$$self.$$.dirty[3]&/*activeShapeId, allowShapeFlip, allowShapeDuplicate, allowShapeRemove*/1879064576|$$self.$$.dirty[4]&/*allowShapeReorder, allowShapeInput*/3){$$invalidate(18,shapeControls=activeShapeId&&willRenderShapeControls([[\"div\",\"alpha\",{class:\"DokaShapeControlsGroup\"},[allowShapeFlip&&[Button,\"flip-horizontal\",{onclick:handleFlipX,label:locale.shapeTitleButtonFlipHorizontal,icon:locale.shapeIconButtonFlipHorizontal,hideLabel:true}],allowShapeFlip&&enableButtonFlipVertical&&[Button,\"flip-vertical\",{onclick:handleFlipY,label:locale.shapeTitleButtonFlipVertical,icon:locale.shapeIconButtonFlipVertical,hideLabel:true}],allowShapeReorder&&[Button,\"to-front\",{onclick:handleMoveToFrontActiveMarkup,label:locale.shapeTitleButtonMoveToFront,icon:locale.shapeIconButtonMoveToFront,hideLabel:true}],allowShapeDuplicate&&[Button,\"duplicate\",{onclick:handleDuplicateActiveMarkup,label:locale.shapeTitleButtonDuplicate,icon:locale.shapeIconButtonDuplicate,hideLabel:true}],allowShapeRemove&&[Button,\"remove\",{onclick:handleRemoveActiveMarkup,label:locale.shapeTitleButtonRemove,icon:locale.shapeIconButtonRemove,hideLabel:true}]]],allowShapeInput&&[\"div\",\"beta\",{class:\"DokaShapeControlsGroup\"},[[Button,\"edit-text\",{label:locale.shapeLabelInputText,onclick:handleEditTextActiveMarkup}]]]],activeShapeId));}if($$self.$$.dirty[0]&/*rootRect*/4){// if view is resized\nif(rootRect){handleViewResize();}}if($$self.$$.dirty[0]&/*markup, locale*/9){$$invalidate(19,shapeNavList=markup.filter(shapeCanSelect).filter(shape=>!shapeIsDraft(shape)).map(shape=>({id:shape.id,color:shapeIsText(shape)?shape.color:shapeIsLine(shape)?shape.strokeColor:shape.backgroundColor,name:shape.name||locale[`shapeLabelTool${capitalizeFirstLetter(shapeGetDescription(shape))}`]})));}};return[markup,offset,rootRect,locale,selectShape,textInput,shapeControlsSize,showShapeList,allowRotateControls,allowedResizeControls,shouldRenderShapeManipulator,shapeManipulatorPoints,shapeManipulatorRotationPointPosition,shouldRenderTextInput,textInputText,markupTextInputStyle,markupControlsStyle,$markupControlsOpacity,shapeControls,shapeNavList,keysPressedStored,handleWheel,handleInteractionStart,handleInteractionUpdate,handleInteractionRelease,handleInteractionEnd,handleManipulatorResizeGrab,handleManipulatorResizeDrag,handleManipulatorResizeEnd,handleManipulatorRotateGrab,handleManipulatorRotateDrag,handleManipulatorRotateEnd,handleKey,handleTextInput,handleTextInputAttempt,handleTextInputKeyDown,handleTextInputKeyUp,handleTextConfirm,handleTextCancel,markupControlsOpacity,handleNudge,handleFocusIn,handleFocusOut,ui,rotation,scale,opacity,parentRect,stageRect,utilRect,oninteractionstart,oninteractionupdate,oninteractionrelease,oninteractionend,onaddshape,onupdateshape,onselectshape,onremoveshape,beforeSelectShape,beforeDeselectShape,beforeAddShape,beforeRemoveShape,beforeUpdateShape,willRenderShapeControls,mapEditorPointToImagePoint,mapImagePointToEditorPoint,enableButtonFlipVertical,createShape,eraseShape,getMarkupItemDraft,addMarkupItemDraft,confirmMarkupItemDraft,discardMarkupItemDraft,createMarkupItem,syncShapes,addShape,updateMarkupShape,updateMarkupShapeProperty,updateMarkupItemsShapeProperty,updateMarkupShapeItems,getActiveMarkupItem,hasActiveMarkupItem,removeShape,removeActiveMarkupItem,blurShapes,deselectMarkupItem,editMarkupItem,finishEditMarkupItem,removeMarkupItems,getTextShapeRect,getMarkupShapeRect,getShapesAtPosition,getMarkupBetweenPoints,measure_handler,click_handler,textarea_binding,measure_handler_1,interactable_function];}class ShapeLayoutEditor extends SvelteComponent{constructor(options){super();init(this,options,instance$w,create_fragment$w,safe_not_equal,{markup:0,offset:1,rotation:44,scale:45,ui:43,opacity:46,parentRect:47,rootRect:2,stageRect:48,utilRect:49,oninteractionstart:50,oninteractionupdate:51,oninteractionrelease:52,oninteractionend:53,onaddshape:54,onupdateshape:55,onselectshape:56,onremoveshape:57,beforeSelectShape:58,beforeDeselectShape:59,beforeAddShape:60,beforeRemoveShape:61,beforeUpdateShape:62,willRenderShapeControls:63,mapEditorPointToImagePoint:64,mapImagePointToEditorPoint:65,enableButtonFlipVertical:66,locale:3,createShape:67,eraseShape:68,getMarkupItemDraft:69,addMarkupItemDraft:70,confirmMarkupItemDraft:71,discardMarkupItemDraft:72,createMarkupItem:73,syncShapes:74,addShape:75,updateMarkupShape:76,updateMarkupShapeProperty:77,updateMarkupItemsShapeProperty:78,updateMarkupShapeItems:79,getActiveMarkupItem:80,hasActiveMarkupItem:81,removeShape:82,removeActiveMarkupItem:83,blurShapes:84,selectShape:4,deselectMarkupItem:85,editMarkupItem:86,finishEditMarkupItem:87,removeMarkupItems:88,getTextShapeRect:89,getMarkupShapeRect:90,getShapesAtPosition:91,getMarkupBetweenPoints:92},[-1,-1,-1,-1,-1,-1]);}get createShape(){return this.$$.ctx[67];}get eraseShape(){return this.$$.ctx[68];}get getMarkupItemDraft(){return this.$$.ctx[69];}get addMarkupItemDraft(){return this.$$.ctx[70];}get confirmMarkupItemDraft(){return this.$$.ctx[71];}get discardMarkupItemDraft(){return this.$$.ctx[72];}get createMarkupItem(){return this.$$.ctx[73];}get syncShapes(){return this.$$.ctx[74];}get addShape(){return this.$$.ctx[75];}get updateMarkupShape(){return this.$$.ctx[76];}get updateMarkupShapeProperty(){return this.$$.ctx[77];}get updateMarkupItemsShapeProperty(){return this.$$.ctx[78];}get updateMarkupShapeItems(){return this.$$.ctx[79];}get getActiveMarkupItem(){return this.$$.ctx[80];}get hasActiveMarkupItem(){return this.$$.ctx[81];}get removeShape(){return this.$$.ctx[82];}get removeActiveMarkupItem(){return this.$$.ctx[83];}get blurShapes(){return this.$$.ctx[84];}get selectShape(){return this.$$.ctx[4];}get deselectMarkupItem(){return this.$$.ctx[85];}get editMarkupItem(){return this.$$.ctx[86];}get finishEditMarkupItem(){return this.$$.ctx[87];}get removeMarkupItems(){return this.$$.ctx[88];}get getTextShapeRect(){return this.$$.ctx[89];}get getMarkupShapeRect(){return this.$$.ctx[90];}get getShapesAtPosition(){return this.$$.ctx[91];}get getMarkupBetweenPoints(){return this.$$.ctx[92];}}/* src/core/ui/components/ShapeStyleEditor.svelte generated by Svelte v3.29.4 */function get_each_context$7(ctx,list,i){const child_ctx=ctx.slice();child_ctx[10]=list[i];return child_ctx;}// (300:4) {#if activeShapeHash}\nfunction create_if_block$9(ctx){let previous_key=/*activeShapeHash*/ctx[2];let key_block_anchor;let current;let key_block=create_key_block(ctx);return{c(){key_block.c();key_block_anchor=empty();},m(target,anchor){key_block.m(target,anchor);insert(target,key_block_anchor,anchor);current=true;},p(ctx,dirty){if(dirty&/*activeShapeHash*/4&&safe_not_equal(previous_key,previous_key=/*activeShapeHash*/ctx[2])){group_outros();transition_out(key_block,1,1,noop$1);check_outros();key_block=create_key_block(ctx);key_block.c();transition_in(key_block);key_block.m(key_block_anchor.parentNode,key_block_anchor);}else{key_block.p(ctx,dirty);}},i(local){if(current)return;transition_in(key_block);current=true;},o(local){transition_out(key_block);current=false;},d(detaching){if(detaching)detach(key_block_anchor);key_block.d(detaching);}};}// (304:16) {#each activeControls as styleControl (styleControl.id) }\nfunction create_each_block$7(key_1,ctx){let li;let span;let t0_value=localize(/*styleControl*/ctx[10].componentProps.title,/*locale*/ctx[0])+\"\";let t0;let t1;let switch_instance;let t2;let current;const switch_instance_spread_levels=[/*styleControl*/ctx[10].componentProps];var switch_value=/*styleControl*/ctx[10].component;function switch_props(ctx){let switch_instance_props={};for(let i=0;i<switch_instance_spread_levels.length;i+=1){switch_instance_props=assign(switch_instance_props,switch_instance_spread_levels[i]);}return{props:switch_instance_props};}if(switch_value){switch_instance=new switch_value(switch_props());}return{key:key_1,first:null,c(){li=element(\"li\");span=element(\"span\");t0=text(t0_value);t1=space();if(switch_instance)create_component(switch_instance.$$.fragment);t2=space();attr(span,\"class\",\"DokaShapeStyleLabel\");attr(li,\"class\",\"DokaShapeStyle\");this.first=li;},m(target,anchor){insert(target,li,anchor);append(li,span);append(span,t0);append(li,t1);if(switch_instance){mount_component(switch_instance,li,null);}append(li,t2);current=true;},p(ctx,dirty){if((!current||dirty&/*activeControls, locale*/9)&&t0_value!==(t0_value=localize(/*styleControl*/ctx[10].componentProps.title,/*locale*/ctx[0])+\"\"))set_data(t0,t0_value);const switch_instance_changes=dirty&/*activeControls*/8?get_spread_update(switch_instance_spread_levels,[get_spread_object(/*styleControl*/ctx[10].componentProps)]):{};if(switch_value!==(switch_value=/*styleControl*/ctx[10].component)){if(switch_instance){group_outros();const old_component=switch_instance;transition_out(old_component.$$.fragment,1,0,()=>{destroy_component(old_component,1);});check_outros();}if(switch_value){switch_instance=new switch_value(switch_props());create_component(switch_instance.$$.fragment);transition_in(switch_instance.$$.fragment,1);mount_component(switch_instance,li,t2);}else{switch_instance=null;}}else if(switch_value){switch_instance.$set(switch_instance_changes);}},i(local){if(current)return;if(switch_instance)transition_in(switch_instance.$$.fragment,local);current=true;},o(local){if(switch_instance)transition_out(switch_instance.$$.fragment,local);current=false;},d(detaching){if(detaching)detach(li);if(switch_instance)destroy_component(switch_instance);}};}// (302:8) <Scrollable class=\"DokaShapeStyles\" elasticity={scrollElasticity}>\nfunction create_default_slot$8(ctx){let ul;let each_blocks=[];let each_1_lookup=new Map();let ul_transition;let current;let each_value=/*activeControls*/ctx[3];const get_key=ctx=>/*styleControl*/ctx[10].id;for(let i=0;i<each_value.length;i+=1){let child_ctx=get_each_context$7(ctx,each_value,i);let key=get_key(child_ctx);each_1_lookup.set(key,each_blocks[i]=create_each_block$7(key,child_ctx));}return{c(){ul=element(\"ul\");for(let i=0;i<each_blocks.length;i+=1){each_blocks[i].c();}attr(ul,\"class\",\"DokaShapeStyleList\");},m(target,anchor){insert(target,ul,anchor);for(let i=0;i<each_blocks.length;i+=1){each_blocks[i].m(ul,null);}current=true;},p(ctx,dirty){if(dirty&/*activeControls, localize, locale*/9){const each_value=/*activeControls*/ctx[3];group_outros();each_blocks=update_keyed_each(each_blocks,dirty,get_key,1,ctx,each_value,each_1_lookup,ul,outro_and_destroy_block,create_each_block$7,null,get_each_context$7);check_outros();}},i(local){if(current)return;for(let i=0;i<each_value.length;i+=1){transition_in(each_blocks[i]);}add_render_callback(()=>{if(!ul_transition)ul_transition=create_bidirectional_transition(ul,fade,{duration:250},true);ul_transition.run(1);});current=true;},o(local){for(let i=0;i<each_blocks.length;i+=1){transition_out(each_blocks[i]);}if(!ul_transition)ul_transition=create_bidirectional_transition(ul,fade,{duration:250},false);ul_transition.run(0);current=false;},d(detaching){if(detaching)detach(ul);for(let i=0;i<each_blocks.length;i+=1){each_blocks[i].d();}if(detaching&&ul_transition)ul_transition.end();}};}// (301:8) {#key activeShapeHash}\nfunction create_key_block(ctx){let scrollable;let current;scrollable=new Scrollable({props:{class:\"DokaShapeStyles\",elasticity:/*scrollElasticity*/ctx[1],$$slots:{default:[create_default_slot$8]},$$scope:{ctx}}});return{c(){create_component(scrollable.$$.fragment);},m(target,anchor){mount_component(scrollable,target,anchor);current=true;},p(ctx,dirty){const scrollable_changes={};if(dirty&/*scrollElasticity*/2)scrollable_changes.elasticity=/*scrollElasticity*/ctx[1];if(dirty&/*$$scope, activeControls, locale*/8201){scrollable_changes.$$scope={dirty,ctx};}scrollable.$set(scrollable_changes);},i(local){if(current)return;transition_in(scrollable.$$.fragment,local);current=true;},o(local){transition_out(scrollable.$$.fragment,local);current=false;},d(detaching){destroy_component(scrollable,detaching);}};}function create_fragment$x(ctx){let div;let current;let if_block=/*activeShapeHash*/ctx[2]&&create_if_block$9(ctx);return{c(){div=element(\"div\");if(if_block)if_block.c();attr(div,\"class\",\"DokaShapeStyleEditor\");},m(target,anchor){insert(target,div,anchor);if(if_block)if_block.m(div,null);current=true;},p(ctx,[dirty]){if(/*activeShapeHash*/ctx[2]){if(if_block){if_block.p(ctx,dirty);if(dirty&/*activeShapeHash*/4){transition_in(if_block,1);}}else{if_block=create_if_block$9(ctx);if_block.c();transition_in(if_block,1);if_block.m(div,null);}}else if(if_block){group_outros();transition_out(if_block,1,1,()=>{if_block=null;});check_outros();}},i(local){if(current)return;transition_in(if_block);current=true;},o(local){transition_out(if_block);current=false;},d(detaching){if(detaching)detach(div);if(if_block)if_block.d();}};}function instance$x($$self,$$props,$$invalidate){let{controls={}}=$$props;let{shape=undefined}=$$props;let{onchange}=$$props;let{locale}=$$props;let{scrollElasticity}=$$props;const getShapeControls=shape=>{const shapeId=shape.id||\"tool\";const activeControls=controlKeys.filter(styleKey=>styleKey.split(\"_\").every(styleKey=>shape.hasOwnProperty(styleKey)&&shapeCanStyle(shape,styleKey))).map(styleKey=>{const styleKeys=styleKey.split(\"_\");const currentValue=styleKeys.length>1?styleKeys.map(key=>shape[key]):shape[styleKey];const[component,componentProps]=controls[styleKey];const options=isFunction(componentProps.options)?componentProps.options(shape):componentProps.options;return{id:`${shapeId}_${styleKey}`,component,componentProps:_objectSpread(_objectSpread({},componentProps),{},{// set the options prop\noptions,// defaults\nlocale,value:currentValue,optionLabelClass:\"DokaButtonLabel\",onchange:detail=>{const value=isObject(detail)&&!isArray(detail)?detail.value:detail;// allow custom changes\nif(componentProps.onchange)componentProps.onchange(value,shape);// internal change                        \nconst props=styleKeys.length>1?styleKeys.reduce((prev,key,index)=>{return _objectSpread(_objectSpread({},prev),{},{[key]:Array.isArray(value)?value[index]:value});},{}):{[styleKey]:value};onchange(props);}})};});return activeControls;};// animate\nlet activeShapeHash;let activeShapeHashPrev;$$self.$$set=$$props=>{if(\"controls\"in $$props)$$invalidate(4,controls=$$props.controls);if(\"shape\"in $$props)$$invalidate(5,shape=$$props.shape);if(\"onchange\"in $$props)$$invalidate(6,onchange=$$props.onchange);if(\"locale\"in $$props)$$invalidate(0,locale=$$props.locale);if(\"scrollElasticity\"in $$props)$$invalidate(1,scrollElasticity=$$props.scrollElasticity);};let controlKeys;let activeControls;$$self.$$.update=()=>{if($$self.$$.dirty&/*controls*/16){// finds the controls needed to style the selected shape\n$$invalidate(8,controlKeys=Object.keys(controls).filter(key=>controls[key]));}if($$self.$$.dirty&/*shape, controlKeys*/288){$$invalidate(3,activeControls=shape&&controlKeys&&shapeCanStyle(shape)?getShapeControls(shape):[]);}if($$self.$$.dirty&/*shape, activeShapeHashPrev*/160){if(shape){const hash=Object.keys(shape).join(\"_\");if(hash!=activeShapeHashPrev){$$invalidate(7,activeShapeHashPrev=hash);$$invalidate(2,activeShapeHash=hash);}}}};return[locale,scrollElasticity,activeShapeHash,activeControls,controls,shape,onchange];}class ShapeStyleEditor extends SvelteComponent{constructor(options){super();init(this,options,instance$x,create_fragment$x,safe_not_equal,{controls:4,shape:5,onchange:6,locale:0,scrollElasticity:1});}}/* src/core/ui/components/ShapePresetSelect.svelte generated by Svelte v3.29.4 */function create_if_block_1$a(ctx){let icon;let current;icon=new Icon({props:{width:16,height:16,$$slots:{default:[create_default_slot$9]},$$scope:{ctx}}});return{c(){create_component(icon.$$.fragment);},m(target,anchor){mount_component(icon,target,anchor);current=true;},p(ctx,dirty){const icon_changes={};if(dirty&/*$$scope, locale*/65){icon_changes.$$scope={dirty,ctx};}icon.$set(icon_changes);},i(local){if(current)return;transition_in(icon.$$.fragment,local);current=true;},o(local){transition_out(icon.$$.fragment,local);current=false;},d(detaching){destroy_component(icon,detaching);}};}// (77:8) <Icon width={16} height={16}>\nfunction create_default_slot$9(ctx){let g;let raw_value=/*locale*/ctx[0].shapeIconButtonSelectSticker+\"\";return{c(){g=svg_element(\"g\");},m(target,anchor){insert(target,g,anchor);g.innerHTML=raw_value;},p(ctx,dirty){if(dirty&/*locale*/1&&raw_value!==(raw_value=/*locale*/ctx[0].shapeIconButtonSelectSticker+\"\"))g.innerHTML=raw_value;},d(detaching){if(detaching)detach(g);}};}// (79:8) {#if locale.shapeLabelButtonSelectSticker}\nfunction create_if_block$a(ctx){let span;let t_value=/*locale*/ctx[0].shapeLabelButtonSelectSticker+\"\";let t;return{c(){span=element(\"span\");t=text(t_value);},m(target,anchor){insert(target,span,anchor);append(span,t);},p(ctx,dirty){if(dirty&/*locale*/1&&t_value!==(t_value=/*locale*/ctx[0].shapeLabelButtonSelectSticker+\"\"))set_data(t,t_value);},d(detaching){if(detaching)detach(span);}};}function create_fragment$y(ctx){let form;let input;let t0;let label;let t1;let current;let mounted;let dispose;let if_block0=/*locale*/ctx[0].shapeIconButtonSelectSticker&&create_if_block_1$a(ctx);let if_block1=/*locale*/ctx[0].shapeLabelButtonSelectSticker&&create_if_block$a(ctx);return{c(){form=element(\"form\");input=element(\"input\");t0=space();label=element(\"label\");if(if_block0)if_block0.c();t1=space();if(if_block1)if_block1.c();attr(input,\"id\",/*name*/ctx[2]);attr(input,\"type\",\"file\");attr(input,\"accept\",\"image/*\");attr(label,\"for\",/*name*/ctx[2]);attr(form,\"class\",\"DokaShapePresetSelect\");},m(target,anchor){insert(target,form,anchor);append(form,input);append(form,t0);append(form,label);if(if_block0)if_block0.m(label,null);append(label,t1);if(if_block1)if_block1.m(label,null);/*form_binding*/ctx[5](form);current=true;if(!mounted){dispose=listen(input,\"input\",/*handleFileInput*/ctx[3]);mounted=true;}},p(ctx,[dirty]){if(/*locale*/ctx[0].shapeIconButtonSelectSticker){if(if_block0){if_block0.p(ctx,dirty);if(dirty&/*locale*/1){transition_in(if_block0,1);}}else{if_block0=create_if_block_1$a(ctx);if_block0.c();transition_in(if_block0,1);if_block0.m(label,t1);}}else if(if_block0){group_outros();transition_out(if_block0,1,1,()=>{if_block0=null;});check_outros();}if(/*locale*/ctx[0].shapeLabelButtonSelectSticker){if(if_block1){if_block1.p(ctx,dirty);}else{if_block1=create_if_block$a(ctx);if_block1.c();if_block1.m(label,null);}}else if(if_block1){if_block1.d(1);if_block1=null;}},i(local){if(current)return;transition_in(if_block0);current=true;},o(local){transition_out(if_block0);current=false;},d(detaching){if(detaching)detach(form);if(if_block0)if_block0.d();if(if_block1)if_block1.d();/*form_binding*/ctx[5](null);mounted=false;dispose();}};}function instance$y($$self,$$props,$$invalidate){let{locale}=$$props;let{oninput}=$$props;const name=`doka-preset-select-${getUniqueId()}`;let formFileInput;const handleFileInput=e=>{// only deal with image files\nArray.from(e.target.files).filter(isImage).forEach(oninput);// reset input when done\nformFileInput.reset();};function form_binding($$value){binding_callbacks[$$value?\"unshift\":\"push\"](()=>{formFileInput=$$value;$$invalidate(1,formFileInput);});}$$self.$$set=$$props=>{if(\"locale\"in $$props)$$invalidate(0,locale=$$props.locale);if(\"oninput\"in $$props)$$invalidate(4,oninput=$$props.oninput);};return[locale,formFileInput,name,handleFileInput,oninput,form_binding];}class ShapePresetSelect extends SvelteComponent{constructor(options){super();init(this,options,instance$y,create_fragment$y,safe_not_equal,{locale:0,oninput:4});}}/* src/core/ui/components/DragButton.svelte generated by Svelte v3.29.4 */function create_fragment$z(ctx){let button;let mounted;let dispose;return{c(){button=element(\"button\");attr(button,\"class\",\"DokaDragButton\");attr(button,\"title\",/*title*/ctx[1]);button.disabled=/*disabled*/ctx[2];},m(target,anchor){insert(target,button,anchor);button.innerHTML=/*html*/ctx[0];/*button_binding*/ctx[9](button);if(!mounted){dispose=listen(button,\"pointerdown\",/*handleDown*/ctx[4]);mounted=true;}},p(ctx,[dirty]){if(dirty&/*html*/1)button.innerHTML=/*html*/ctx[0];if(dirty&/*title*/2){attr(button,\"title\",/*title*/ctx[1]);}if(dirty&/*disabled*/4){button.disabled=/*disabled*/ctx[2];}},i:noop$1,o:noop$1,d(detaching){if(detaching)detach(button);/*button_binding*/ctx[9](null);mounted=false;dispose();}};}function instance$z($$self,$$props,$$invalidate){let{html}=$$props;let{title}=$$props;let{onclick}=$$props;let{disabled=false}=$$props;let{ongrab=noop}=$$props;let{ondrag=noop}=$$props;let{ondrop=noop}=$$props;let element;const isOverButton=e=>vectorDistanceSquared(downPosition,vectorCreate(e.pageX,e.pageY))<256;let downPosition;const handleDown=e=>{downPosition=vectorCreate(e.pageX,e.pageY);ongrab(e);document.documentElement.addEventListener(\"pointermove\",handleMove);document.documentElement.addEventListener(\"pointerup\",handleUp);};const handleUp=e=>{document.documentElement.removeEventListener(\"pointermove\",handleMove);document.documentElement.removeEventListener(\"pointerup\",handleUp);const upPosition=vectorCreate(e.pageX,e.pageY);// must have moved enough distance to drop\nif(vectorDistanceSquared(downPosition,upPosition)<32)return onclick(e);// cant drop in button\nif(isOverButton(e))return;// was dragging\nondrop(e);};const handleMove=e=>{// must have moved enough distance from button\nif(isOverButton(e))return;// dragging out of button\nondrag(e);};function button_binding($$value){binding_callbacks[$$value?\"unshift\":\"push\"](()=>{element=$$value;$$invalidate(3,element);});}$$self.$$set=$$props=>{if(\"html\"in $$props)$$invalidate(0,html=$$props.html);if(\"title\"in $$props)$$invalidate(1,title=$$props.title);if(\"onclick\"in $$props)$$invalidate(5,onclick=$$props.onclick);if(\"disabled\"in $$props)$$invalidate(2,disabled=$$props.disabled);if(\"ongrab\"in $$props)$$invalidate(6,ongrab=$$props.ongrab);if(\"ondrag\"in $$props)$$invalidate(7,ondrag=$$props.ondrag);if(\"ondrop\"in $$props)$$invalidate(8,ondrop=$$props.ondrop);};return[html,title,disabled,element,handleDown,onclick,ongrab,ondrag,ondrop,button_binding];}class DragButton extends SvelteComponent{constructor(options){super();init(this,options,instance$z,create_fragment$z,safe_not_equal,{html:0,title:1,onclick:5,disabled:2,ongrab:6,ondrag:7,ondrop:8});}}/* src/core/ui/components/ShapePresetsList.svelte generated by Svelte v3.29.4 */function get_each_context$8(ctx,list,i){const child_ctx=ctx.slice();child_ctx[14]=list[i];return child_ctx;}// (56:4) {#each presets as preset (preset.id)}\nfunction create_each_block$8(key_1,ctx){let li;let dragbutton;let t;let didMountPresetThumb_action;let current;let mounted;let dispose;function func(...args){return(/*func*/ctx[9](/*preset*/ctx[14],...args));}function func_1(...args){return(/*func_1*/ctx[10](/*preset*/ctx[14],...args));}function func_2(...args){return(/*func_2*/ctx[11](/*preset*/ctx[14],...args));}function func_3(...args){return(/*func_3*/ctx[12](/*preset*/ctx[14],...args));}dragbutton=new DragButton({props:{onclick:func,ongrab:func_1,ondrag:func_2,ondrop:func_3,disabled:/*disabled*/ctx[1]||/*preset*/ctx[14].disabled,title:/*preset*/ctx[14].title,html:/*preset*/ctx[14].thumb}});return{key:key_1,first:null,c(){li=element(\"li\");create_component(dragbutton.$$.fragment);t=space();attr(li,\"class\",\"DokaShapePreset\");attr(li,\"style\",/*style*/ctx[6]);this.first=li;},m(target,anchor){insert(target,li,anchor);mount_component(dragbutton,li,null);append(li,t);current=true;if(!mounted){dispose=action_destroyer(didMountPresetThumb_action=/*didMountPresetThumb*/ctx[8].call(null,li,/*preset*/ctx[14]));mounted=true;}},p(new_ctx,dirty){ctx=new_ctx;const dragbutton_changes={};if(dirty&/*onclickpreset, presets*/5)dragbutton_changes.onclick=func;if(dirty&/*ongrabpreset, presets*/9)dragbutton_changes.ongrab=func_1;if(dirty&/*ondragpreset, presets*/17)dragbutton_changes.ondrag=func_2;if(dirty&/*ondroppreset, presets*/33)dragbutton_changes.ondrop=func_3;if(dirty&/*disabled, presets*/3)dragbutton_changes.disabled=/*disabled*/ctx[1]||/*preset*/ctx[14].disabled;if(dirty&/*presets*/1)dragbutton_changes.title=/*preset*/ctx[14].title;if(dirty&/*presets*/1)dragbutton_changes.html=/*preset*/ctx[14].thumb;dragbutton.$set(dragbutton_changes);if(!current||dirty&/*style*/64){attr(li,\"style\",/*style*/ctx[6]);}if(didMountPresetThumb_action&&is_function(didMountPresetThumb_action.update)&&dirty&/*presets*/1)didMountPresetThumb_action.update.call(null,/*preset*/ctx[14]);},i(local){if(current)return;transition_in(dragbutton.$$.fragment,local);current=true;},o(local){transition_out(dragbutton.$$.fragment,local);current=false;},d(detaching){if(detaching)detach(li);destroy_component(dragbutton);mounted=false;dispose();}};}function create_fragment$A(ctx){let ul;let each_blocks=[];let each_1_lookup=new Map();let current;let each_value=/*presets*/ctx[0];const get_key=ctx=>/*preset*/ctx[14].id;for(let i=0;i<each_value.length;i+=1){let child_ctx=get_each_context$8(ctx,each_value,i);let key=get_key(child_ctx);each_1_lookup.set(key,each_blocks[i]=create_each_block$8(key,child_ctx));}return{c(){ul=element(\"ul\");for(let i=0;i<each_blocks.length;i+=1){each_blocks[i].c();}attr(ul,\"class\",\"DokaShapePresetsList\");},m(target,anchor){insert(target,ul,anchor);for(let i=0;i<each_blocks.length;i+=1){each_blocks[i].m(ul,null);}current=true;},p(ctx,[dirty]){if(dirty&/*style, presets, onclickpreset, ongrabpreset, ondragpreset, ondroppreset, disabled*/127){const each_value=/*presets*/ctx[0];group_outros();each_blocks=update_keyed_each(each_blocks,dirty,get_key,1,ctx,each_value,each_1_lookup,ul,outro_and_destroy_block,create_each_block$8,null,get_each_context$8);check_outros();}},i(local){if(current)return;for(let i=0;i<each_value.length;i+=1){transition_in(each_blocks[i]);}current=true;},o(local){for(let i=0;i<each_blocks.length;i+=1){transition_out(each_blocks[i]);}current=false;},d(detaching){if(detaching)detach(ul);for(let i=0;i<each_blocks.length;i+=1){each_blocks[i].d();}}};}function instance$A($$self,$$props,$$invalidate){let $anim;let{presets}=$$props;let{disabled=undefined}=$$props;let{onclickpreset}=$$props;let{ongrabpreset}=$$props;let{ondragpreset}=$$props;let{ondroppreset}=$$props;const anim=tweened(0,{duration:300});component_subscribe($$self,anim,value=>$$invalidate(13,$anim=value));const didMountPresetThumb=(element,item)=>item.mount&&item.mount(element.firstChild,item);onMount(()=>anim.set(1));const func=preset=>onclickpreset(preset.id);const func_1=(preset,e)=>ongrabpreset(preset.id,e);const func_2=(preset,e)=>ondragpreset(preset.id,e);const func_3=(preset,e)=>ondroppreset(preset.id,e);$$self.$$set=$$props=>{if(\"presets\"in $$props)$$invalidate(0,presets=$$props.presets);if(\"disabled\"in $$props)$$invalidate(1,disabled=$$props.disabled);if(\"onclickpreset\"in $$props)$$invalidate(2,onclickpreset=$$props.onclickpreset);if(\"ongrabpreset\"in $$props)$$invalidate(3,ongrabpreset=$$props.ongrabpreset);if(\"ondragpreset\"in $$props)$$invalidate(4,ondragpreset=$$props.ondragpreset);if(\"ondroppreset\"in $$props)$$invalidate(5,ondroppreset=$$props.ondroppreset);};let style;$$self.$$.update=()=>{if($$self.$$.dirty&/*$anim*/8192){$$invalidate(6,style=`opacity:${$anim}`);}};return[presets,disabled,onclickpreset,ongrabpreset,ondragpreset,ondroppreset,style,anim,didMountPresetThumb,func,func_1,func_2,func_3];}class ShapePresetsList extends SvelteComponent{constructor(options){super();init(this,options,instance$A,create_fragment$A,safe_not_equal,{presets:0,disabled:1,onclickpreset:2,ongrabpreset:3,ondragpreset:4,ondroppreset:5});}}var isSVGMarkup=str=>/<svg /.test(str);/* src/core/ui/components/ShapePresetsPalette.svelte generated by Svelte v3.29.4 */function create_if_block_6$3(ctx){let shapepresetselect;let current;shapepresetselect=new ShapePresetSelect({props:{locale:/*locale*/ctx[0],oninput:/*onaddpreset*/ctx[3]}});return{c(){create_component(shapepresetselect.$$.fragment);},m(target,anchor){mount_component(shapepresetselect,target,anchor);current=true;},p(ctx,dirty){const shapepresetselect_changes={};if(dirty&/*locale*/1)shapepresetselect_changes.locale=/*locale*/ctx[0];if(dirty&/*onaddpreset*/8)shapepresetselect_changes.oninput=/*onaddpreset*/ctx[3];shapepresetselect.$set(shapepresetselect_changes);},i(local){if(current)return;transition_in(shapepresetselect.$$.fragment,local);current=true;},o(local){transition_out(shapepresetselect.$$.fragment,local);current=false;},d(detaching){destroy_component(shapepresetselect,detaching);}};}// (180:4) {#if shouldRenderPresets}\nfunction create_if_block$b(ctx){let current_block_type_index;let if_block;let if_block_anchor;let current;const if_block_creators=[create_if_block_1$b,create_else_block$3];const if_blocks=[];function select_block_type_1(ctx,dirty){if(/*shouldGroupPresets*/ctx[9])return 0;return 1;}current_block_type_index=select_block_type_1(ctx);if_block=if_blocks[current_block_type_index]=if_block_creators[current_block_type_index](ctx);return{c(){if_block.c();if_block_anchor=empty();},m(target,anchor){if_blocks[current_block_type_index].m(target,anchor);insert(target,if_block_anchor,anchor);current=true;},p(ctx,dirty){let previous_block_index=current_block_type_index;current_block_type_index=select_block_type_1(ctx);if(current_block_type_index===previous_block_index){if_blocks[current_block_type_index].p(ctx,dirty);}else{group_outros();transition_out(if_blocks[previous_block_index],1,1,()=>{if_blocks[previous_block_index]=null;});check_outros();if_block=if_blocks[current_block_type_index];if(!if_block){if_block=if_blocks[current_block_type_index]=if_block_creators[current_block_type_index](ctx);if_block.c();}transition_in(if_block,1);if_block.m(if_block_anchor.parentNode,if_block_anchor);}},i(local){if(current)return;transition_in(if_block);current=true;},o(local){transition_out(if_block);current=false;},d(detaching){if_blocks[current_block_type_index].d(detaching);if(detaching)detach(if_block_anchor);}};}// (234:8) {:else}\nfunction create_else_block$3(ctx){let div;let t;let scrollable;let current;let if_block=/*enableSelectImage*/ctx[2]&&create_if_block_5$3(ctx);scrollable=new Scrollable({props:{scrollAutoCancel:/*shouldRenderPresets*/ctx[8],elasticity:/*scrollElasticity*/ctx[1],$$slots:{default:[create_default_slot_4$1]},$$scope:{ctx}}});return{c(){div=element(\"div\");if(if_block)if_block.c();t=space();create_component(scrollable.$$.fragment);attr(div,\"class\",\"DokaShapePresetsFlat\");},m(target,anchor){insert(target,div,anchor);if(if_block)if_block.m(div,null);append(div,t);mount_component(scrollable,div,null);current=true;},p(ctx,dirty){if(/*enableSelectImage*/ctx[2]){if(if_block){if_block.p(ctx,dirty);if(dirty&/*enableSelectImage*/4){transition_in(if_block,1);}}else{if_block=create_if_block_5$3(ctx);if_block.c();transition_in(if_block,1);if_block.m(div,t);}}else if(if_block){group_outros();transition_out(if_block,1,1,()=>{if_block=null;});check_outros();}const scrollable_changes={};if(dirty&/*shouldRenderPresets*/256)scrollable_changes.scrollAutoCancel=/*shouldRenderPresets*/ctx[8];if(dirty&/*scrollElasticity*/2)scrollable_changes.elasticity=/*scrollElasticity*/ctx[1];if(dirty&/*$$scope, presetsMapped, onaddpreset, ongrabpreset, ondragpreset, ondroppreset*/268435704){scrollable_changes.$$scope={dirty,ctx};}scrollable.$set(scrollable_changes);},i(local){if(current)return;transition_in(if_block);transition_in(scrollable.$$.fragment,local);current=true;},o(local){transition_out(if_block);transition_out(scrollable.$$.fragment,local);current=false;},d(detaching){if(detaching)detach(div);if(if_block)if_block.d();destroy_component(scrollable);}};}// (183:8) {#if shouldGroupPresets}\nfunction create_if_block_1$b(ctx){let div1;let div0;let t0;let tablist;let t1;let tabpanels;let current;let if_block=/*enableSelectImage*/ctx[2]&&create_if_block_4$4(ctx);const tablist_spread_levels=[{class:\"DokaControlList\"},{tabs:/*tabs*/ctx[10]},/*tabsConfig*/ctx[13],{layout:\"compact\"}];let tablist_props={$$slots:{default:[create_default_slot_2$5,({tab})=>({27:tab}),({tab})=>tab?134217728:0]},$$scope:{ctx}};for(let i=0;i<tablist_spread_levels.length;i+=1){tablist_props=assign(tablist_props,tablist_spread_levels[i]);}tablist=new TabList({props:tablist_props});tablist.$on(\"select\",/*select_handler*/ctx[16]);const tabpanels_spread_levels=[{class:\"DokaControlPanels\"},{panelClass:\"DokaControlPanel\"},{panels:/*panels*/ctx[14]},/*tabsConfig*/ctx[13]];let tabpanels_props={$$slots:{default:[create_default_slot$a,({panel,panelIsActive})=>({25:panel,26:panelIsActive}),({panel,panelIsActive})=>(panel?33554432:0)|(panelIsActive?67108864:0)]},$$scope:{ctx}};for(let i=0;i<tabpanels_spread_levels.length;i+=1){tabpanels_props=assign(tabpanels_props,tabpanels_spread_levels[i]);}tabpanels=new TabPanels({props:tabpanels_props});return{c(){div1=element(\"div\");div0=element(\"div\");if(if_block)if_block.c();t0=space();create_component(tablist.$$.fragment);t1=space();create_component(tabpanels.$$.fragment);attr(div0,\"class\",\"DokaShapePresetsGroups\");attr(div1,\"class\",\"DokaShapePresetsGrouped\");},m(target,anchor){insert(target,div1,anchor);append(div1,div0);if(if_block)if_block.m(div0,null);append(div0,t0);mount_component(tablist,div0,null);append(div1,t1);mount_component(tabpanels,div1,null);current=true;},p(ctx,dirty){if(/*enableSelectImage*/ctx[2]){if(if_block){if_block.p(ctx,dirty);if(dirty&/*enableSelectImage*/4){transition_in(if_block,1);}}else{if_block=create_if_block_4$4(ctx);if_block.c();transition_in(if_block,1);if_block.m(div0,t0);}}else if(if_block){group_outros();transition_out(if_block,1,1,()=>{if_block=null;});check_outros();}const tablist_changes=dirty&/*tabs, tabsConfig*/9216?get_spread_update(tablist_spread_levels,[tablist_spread_levels[0],dirty&/*tabs*/1024&&{tabs:/*tabs*/ctx[10]},dirty&/*tabsConfig*/8192&&get_spread_object(/*tabsConfig*/ctx[13]),tablist_spread_levels[3]]):{};if(dirty&/*$$scope, tab*/402653184){tablist_changes.$$scope={dirty,ctx};}tablist.$set(tablist_changes);const tabpanels_changes=dirty&/*panels, tabsConfig*/24576?get_spread_update(tabpanels_spread_levels,[tabpanels_spread_levels[0],tabpanels_spread_levels[1],dirty&/*panels*/16384&&{panels:/*panels*/ctx[14]},dirty&/*tabsConfig*/8192&&get_spread_object(/*tabsConfig*/ctx[13])]):{};if(dirty&/*$$scope, panelIsActive, shouldRenderPresets, scrollElasticity, presetTabs, panel, onaddpreset, ongrabpreset, ondragpreset, ondroppreset*/369101178){tabpanels_changes.$$scope={dirty,ctx};}tabpanels.$set(tabpanels_changes);},i(local){if(current)return;transition_in(if_block);transition_in(tablist.$$.fragment,local);transition_in(tabpanels.$$.fragment,local);current=true;},o(local){transition_out(if_block);transition_out(tablist.$$.fragment,local);transition_out(tabpanels.$$.fragment,local);current=false;},d(detaching){if(detaching)detach(div1);if(if_block)if_block.d();destroy_component(tablist);destroy_component(tabpanels);}};}// (238:12) {#if enableSelectImage}\nfunction create_if_block_5$3(ctx){let shapepresetselect;let current;shapepresetselect=new ShapePresetSelect({props:{locale:/*locale*/ctx[0],oninput:/*onaddpreset*/ctx[3]}});return{c(){create_component(shapepresetselect.$$.fragment);},m(target,anchor){mount_component(shapepresetselect,target,anchor);current=true;},p(ctx,dirty){const shapepresetselect_changes={};if(dirty&/*locale*/1)shapepresetselect_changes.locale=/*locale*/ctx[0];if(dirty&/*onaddpreset*/8)shapepresetselect_changes.oninput=/*onaddpreset*/ctx[3];shapepresetselect.$set(shapepresetselect_changes);},i(local){if(current)return;transition_in(shapepresetselect.$$.fragment,local);current=true;},o(local){transition_out(shapepresetselect.$$.fragment,local);current=false;},d(detaching){destroy_component(shapepresetselect,detaching);}};}// (241:12) <Scrollable scrollAutoCancel={shouldRenderPresets} elasticity={scrollElasticity}>\nfunction create_default_slot_4$1(ctx){let shapepresetslist;let current;shapepresetslist=new ShapePresetsList({props:{presets:/*presetsMapped*/ctx[7],onclickpreset:/*onaddpreset*/ctx[3],ongrabpreset:/*ongrabpreset*/ctx[4],ondragpreset:/*ondragpreset*/ctx[5],ondroppreset:/*ondroppreset*/ctx[6]}});return{c(){create_component(shapepresetslist.$$.fragment);},m(target,anchor){mount_component(shapepresetslist,target,anchor);current=true;},p(ctx,dirty){const shapepresetslist_changes={};if(dirty&/*presetsMapped*/128)shapepresetslist_changes.presets=/*presetsMapped*/ctx[7];if(dirty&/*onaddpreset*/8)shapepresetslist_changes.onclickpreset=/*onaddpreset*/ctx[3];if(dirty&/*ongrabpreset*/16)shapepresetslist_changes.ongrabpreset=/*ongrabpreset*/ctx[4];if(dirty&/*ondragpreset*/32)shapepresetslist_changes.ondragpreset=/*ondragpreset*/ctx[5];if(dirty&/*ondroppreset*/64)shapepresetslist_changes.ondroppreset=/*ondroppreset*/ctx[6];shapepresetslist.$set(shapepresetslist_changes);},i(local){if(current)return;transition_in(shapepresetslist.$$.fragment,local);current=true;},o(local){transition_out(shapepresetslist.$$.fragment,local);current=false;},d(detaching){destroy_component(shapepresetslist,detaching);}};}// (188:20) {#if enableSelectImage}\nfunction create_if_block_4$4(ctx){let shapepresetselect;let current;shapepresetselect=new ShapePresetSelect({props:{locale:/*locale*/ctx[0],oninput:/*onaddpreset*/ctx[3]}});return{c(){create_component(shapepresetselect.$$.fragment);},m(target,anchor){mount_component(shapepresetselect,target,anchor);current=true;},p(ctx,dirty){const shapepresetselect_changes={};if(dirty&/*locale*/1)shapepresetselect_changes.locale=/*locale*/ctx[0];if(dirty&/*onaddpreset*/8)shapepresetselect_changes.oninput=/*onaddpreset*/ctx[3];shapepresetselect.$set(shapepresetselect_changes);},i(local){if(current)return;transition_in(shapepresetselect.$$.fragment,local);current=true;},o(local){transition_out(shapepresetselect.$$.fragment,local);current=false;},d(detaching){destroy_component(shapepresetselect,detaching);}};}// (196:24) {#if tab.icon }\nfunction create_if_block_3$4(ctx){let icon;let current;icon=new Icon({props:{$$slots:{default:[create_default_slot_3$5]},$$scope:{ctx}}});return{c(){create_component(icon.$$.fragment);},m(target,anchor){mount_component(icon,target,anchor);current=true;},p(ctx,dirty){const icon_changes={};if(dirty&/*$$scope, tab*/402653184){icon_changes.$$scope={dirty,ctx};}icon.$set(icon_changes);},i(local){if(current)return;transition_in(icon.$$.fragment,local);current=true;},o(local){transition_out(icon.$$.fragment,local);current=false;},d(detaching){destroy_component(icon,detaching);}};}// (197:24) <Icon>\nfunction create_default_slot_3$5(ctx){let g;let raw_value=/*tab*/ctx[27].icon+\"\";return{c(){g=svg_element(\"g\");},m(target,anchor){insert(target,g,anchor);g.innerHTML=raw_value;},p(ctx,dirty){if(dirty&/*tab*/134217728&&raw_value!==(raw_value=/*tab*/ctx[27].icon+\"\"))g.innerHTML=raw_value;},d(detaching){if(detaching)detach(g);}};}// (199:24) {#if !tab.hideLabel}\nfunction create_if_block_2$7(ctx){let span;let t_value=/*tab*/ctx[27].label+\"\";let t;return{c(){span=element(\"span\");t=text(t_value);},m(target,anchor){insert(target,span,anchor);append(span,t);},p(ctx,dirty){if(dirty&/*tab*/134217728&&t_value!==(t_value=/*tab*/ctx[27].label+\"\"))set_data(t,t_value);},d(detaching){if(detaching)detach(span);}};}// (192:20) <TabList class=\"DokaControlList\"                          {tabs} {...tabsConfig}                          layout=\"compact\"                         on:select={({ detail }) => tabSelected = detail} let:tab={tab}>\nfunction create_default_slot_2$5(ctx){let t;let if_block1_anchor;let current;let if_block0=/*tab*/ctx[27].icon&&create_if_block_3$4(ctx);let if_block1=!/*tab*/ctx[27].hideLabel&&create_if_block_2$7(ctx);return{c(){if(if_block0)if_block0.c();t=space();if(if_block1)if_block1.c();if_block1_anchor=empty();},m(target,anchor){if(if_block0)if_block0.m(target,anchor);insert(target,t,anchor);if(if_block1)if_block1.m(target,anchor);insert(target,if_block1_anchor,anchor);current=true;},p(ctx,dirty){if(/*tab*/ctx[27].icon){if(if_block0){if_block0.p(ctx,dirty);if(dirty&/*tab*/134217728){transition_in(if_block0,1);}}else{if_block0=create_if_block_3$4(ctx);if_block0.c();transition_in(if_block0,1);if_block0.m(t.parentNode,t);}}else if(if_block0){group_outros();transition_out(if_block0,1,1,()=>{if_block0=null;});check_outros();}if(!/*tab*/ctx[27].hideLabel){if(if_block1){if_block1.p(ctx,dirty);}else{if_block1=create_if_block_2$7(ctx);if_block1.c();if_block1.m(if_block1_anchor.parentNode,if_block1_anchor);}}else if(if_block1){if_block1.d(1);if_block1=null;}},i(local){if(current)return;transition_in(if_block0);current=true;},o(local){transition_out(if_block0);current=false;},d(detaching){if(if_block0)if_block0.d(detaching);if(detaching)detach(t);if(if_block1)if_block1.d(detaching);if(detaching)detach(if_block1_anchor);}};}// (214:16) <Scrollable                      scroll={panelIsActive ? { scrollOffset: 0, animate: false } : undefined}                     scrollAutoCancel={shouldRenderPresets}                      elasticity={scrollElasticity}>\nfunction create_default_slot_1$7(ctx){let shapepresetslist;let current;shapepresetslist=new ShapePresetsList({props:{presets:/*presetTabs*/ctx[11][/*panel*/ctx[25]].items,disabled:/*presetTabs*/ctx[11][/*panel*/ctx[25]].disabled,onclickpreset:/*onaddpreset*/ctx[3],ongrabpreset:/*ongrabpreset*/ctx[4],ondragpreset:/*ondragpreset*/ctx[5],ondroppreset:/*ondroppreset*/ctx[6]}});return{c(){create_component(shapepresetslist.$$.fragment);},m(target,anchor){mount_component(shapepresetslist,target,anchor);current=true;},p(ctx,dirty){const shapepresetslist_changes={};if(dirty&/*presetTabs, panel*/33556480)shapepresetslist_changes.presets=/*presetTabs*/ctx[11][/*panel*/ctx[25]].items;if(dirty&/*presetTabs, panel*/33556480)shapepresetslist_changes.disabled=/*presetTabs*/ctx[11][/*panel*/ctx[25]].disabled;if(dirty&/*onaddpreset*/8)shapepresetslist_changes.onclickpreset=/*onaddpreset*/ctx[3];if(dirty&/*ongrabpreset*/16)shapepresetslist_changes.ongrabpreset=/*ongrabpreset*/ctx[4];if(dirty&/*ondragpreset*/32)shapepresetslist_changes.ondragpreset=/*ondragpreset*/ctx[5];if(dirty&/*ondroppreset*/64)shapepresetslist_changes.ondroppreset=/*ondroppreset*/ctx[6];shapepresetslist.$set(shapepresetslist_changes);},i(local){if(current)return;transition_in(shapepresetslist.$$.fragment,local);current=true;},o(local){transition_out(shapepresetslist.$$.fragment,local);current=false;},d(detaching){destroy_component(shapepresetslist,detaching);}};}// (206:12) <TabPanels                  class=\"DokaControlPanels\"                  panelClass=\"DokaControlPanel\"                  {panels}                  {...tabsConfig}                  let:panel                  let:panelIsActive>\nfunction create_default_slot$a(ctx){let scrollable;let current;scrollable=new Scrollable({props:{scroll:/*panelIsActive*/ctx[26]?{scrollOffset:0,animate:false}:undefined,scrollAutoCancel:/*shouldRenderPresets*/ctx[8],elasticity:/*scrollElasticity*/ctx[1],$$slots:{default:[create_default_slot_1$7]},$$scope:{ctx}}});return{c(){create_component(scrollable.$$.fragment);},m(target,anchor){mount_component(scrollable,target,anchor);current=true;},p(ctx,dirty){const scrollable_changes={};if(dirty&/*panelIsActive*/67108864)scrollable_changes.scroll=/*panelIsActive*/ctx[26]?{scrollOffset:0,animate:false}:undefined;if(dirty&/*shouldRenderPresets*/256)scrollable_changes.scrollAutoCancel=/*shouldRenderPresets*/ctx[8];if(dirty&/*scrollElasticity*/2)scrollable_changes.elasticity=/*scrollElasticity*/ctx[1];if(dirty&/*$$scope, presetTabs, panel, onaddpreset, ongrabpreset, ondragpreset, ondroppreset*/301992056){scrollable_changes.$$scope={dirty,ctx};}scrollable.$set(scrollable_changes);},i(local){if(current)return;transition_in(scrollable.$$.fragment,local);current=true;},o(local){transition_out(scrollable.$$.fragment,local);current=false;},d(detaching){destroy_component(scrollable,detaching);}};}function create_fragment$B(ctx){let div;let current_block_type_index;let if_block;let current;const if_block_creators=[create_if_block$b,create_if_block_6$3];const if_blocks=[];function select_block_type(ctx,dirty){if(/*shouldRenderPresets*/ctx[8])return 0;if(/*enableSelectImage*/ctx[2])return 1;return-1;}if(~(current_block_type_index=select_block_type(ctx))){if_block=if_blocks[current_block_type_index]=if_block_creators[current_block_type_index](ctx);}return{c(){div=element(\"div\");if(if_block)if_block.c();attr(div,\"class\",\"DokaShapePresetsPalette\");},m(target,anchor){insert(target,div,anchor);if(~current_block_type_index){if_blocks[current_block_type_index].m(div,null);}current=true;},p(ctx,[dirty]){let previous_block_index=current_block_type_index;current_block_type_index=select_block_type(ctx);if(current_block_type_index===previous_block_index){if(~current_block_type_index){if_blocks[current_block_type_index].p(ctx,dirty);}}else{if(if_block){group_outros();transition_out(if_blocks[previous_block_index],1,1,()=>{if_blocks[previous_block_index]=null;});check_outros();}if(~current_block_type_index){if_block=if_blocks[current_block_type_index];if(!if_block){if_block=if_blocks[current_block_type_index]=if_block_creators[current_block_type_index](ctx);if_block.c();}transition_in(if_block,1);if_block.m(div,null);}else{if_block=null;}}},i(local){if(current)return;transition_in(if_block);current=true;},o(local){transition_out(if_block);current=false;},d(detaching){if(detaching)detach(div);if(~current_block_type_index){if_blocks[current_block_type_index].d();}}};}function instance$B($$self,$$props,$$invalidate){let{locale}=$$props;let{presets}=$$props;let{scrollElasticity}=$$props;let{enableSelectImage=true}=$$props;let{onaddpreset=noop}=$$props;let{ongrabpreset=noop}=$$props;let{ondragpreset=noop}=$$props;let{ondroppreset=noop}=$$props;const uid=`doka-presets-${getUniqueId()}`;const isPresetGroup=item=>isArray(item)&&isString(item[0])&&isArray(item[1]);const getPresetThumb=(value,alt=\"\")=>{// could be svg\nif(isSVGMarkup(value))return value;// test if is emoji\nif(isEmoji(value))return getEmojiSVG(value,alt);// must be URL\nreturn`<img src=\"${value}\" alt=\"${alt}\"/>`;};const getAltFromSrc=src=>getFilenameWithoutExtension(getFilenameFromURL(src));const excludedStickerItemProps=[\"src\",\"alt\",\"thumb\",\"shape\",\"id\",\"mount\",\"disabled\"];const mapPreset=item=>{let id=item;let src;let shape;let shapeProps;let thumb;let alt;let mount;let disabled;// if item is a string, it's either an emoji or a URL\nif(isString(item)){// is emoji\nif(isEmoji(item)){src=item;alt=item;thumb=getPresetThumb(src,alt);}else// must be URL\n{src=item;alt=getAltFromSrc(src);thumb=getPresetThumb(src,alt);}}else{// set custom thumbnail if defined\nsrc=item.src;alt=item.alt||(isString(src)?getAltFromSrc(src):isString(item.thumb)?getAltFromSrc(item.thumb):undefined);thumb=getPresetThumb(item.thumb||src,alt);shape=item.shape;mount=item.mount;disabled=item.disabled;shapeProps=Object.keys(item).reduce((prev,curr)=>{if(excludedStickerItemProps.includes(curr))return prev;prev[curr]=item[curr];return prev;},{});}return{id,src,thumb,shape,shapeProps,alt,title:alt,mount,disabled};};const mapPresets=items=>items.map(item=>{if(isPresetGroup(item)){return _objectSpread(_objectSpread({},item[2]),{},{id:`${uid}-${item[0].toLowerCase()}`,label:item[0],items:mapPresets(item[1])});}return mapPreset(item);});const select_handler=({detail})=>$$invalidate(12,tabSelected=detail);$$self.$$set=$$props=>{if(\"locale\"in $$props)$$invalidate(0,locale=$$props.locale);if(\"presets\"in $$props)$$invalidate(15,presets=$$props.presets);if(\"scrollElasticity\"in $$props)$$invalidate(1,scrollElasticity=$$props.scrollElasticity);if(\"enableSelectImage\"in $$props)$$invalidate(2,enableSelectImage=$$props.enableSelectImage);if(\"onaddpreset\"in $$props)$$invalidate(3,onaddpreset=$$props.onaddpreset);if(\"ongrabpreset\"in $$props)$$invalidate(4,ongrabpreset=$$props.ongrabpreset);if(\"ondragpreset\"in $$props)$$invalidate(5,ondragpreset=$$props.ondragpreset);if(\"ondroppreset\"in $$props)$$invalidate(6,ondroppreset=$$props.ondroppreset);};let presetsMapped;let shouldRenderPresets;let shouldGroupPresets;let tabs;let presetTabs;let tabSelected;let tabsConfig;let panels;$$self.$$.update=()=>{if($$self.$$.dirty&/*presets*/32768){$$invalidate(7,presetsMapped=mapPresets(presets));}if($$self.$$.dirty&/*presetsMapped*/128){// const handlePresetClick = (preset, e) => onaddpreset(preset);\n// const handlePresetGrab = (preset, e) => ongrabpreset(preset, e);\n// const handlePresetDrag = (preset, e) => ondragpreset(preset, e);\n// const handlePresetDrop = (preset, e) => ondroppreset(preset, e);\n//\n// handle file input\n//\n$$invalidate(8,shouldRenderPresets=presetsMapped.length);}if($$self.$$.dirty&/*shouldRenderPresets, presetsMapped*/384){$$invalidate(9,shouldGroupPresets=shouldRenderPresets&&presetsMapped.some(preset=>!!preset.items));}if($$self.$$.dirty&/*shouldGroupPresets, presetsMapped*/640){$$invalidate(10,tabs=shouldGroupPresets&&presetsMapped);}if($$self.$$.dirty&/*shouldGroupPresets, presetsMapped*/640){$$invalidate(11,presetTabs=shouldGroupPresets&&presetsMapped.reduce((prev,curr)=>{prev[curr.id]=curr;return prev;},{}));}if($$self.$$.dirty&/*tabSelected, tabs*/5120){$$invalidate(12,tabSelected=tabSelected||tabs&&(tabs.find(tab=>!tab.disabled)||{}).id);}if($$self.$$.dirty&/*tabSelected*/4096){$$invalidate(13,tabsConfig={name:uid,selected:tabSelected});}if($$self.$$.dirty&/*tabs*/1024){$$invalidate(14,panels=tabs&&tabs.map(tab=>tab.id));}};return[locale,scrollElasticity,enableSelectImage,onaddpreset,ongrabpreset,ondragpreset,ondroppreset,presetsMapped,shouldRenderPresets,shouldGroupPresets,tabs,presetTabs,tabSelected,tabsConfig,panels,presets,select_handler];}class ShapePresetsPalette extends SvelteComponent{constructor(options){super();init(this,options,instance$B,create_fragment$B,safe_not_equal,{locale:0,presets:15,scrollElasticity:1,enableSelectImage:2,onaddpreset:3,ongrabpreset:4,ondragpreset:5,ondroppreset:6});}}var createPingDispatcher=node=>(type,data)=>{node.dispatchEvent(new CustomEvent('ping',{detail:{type,data},cancelable:true,bubbles:true}));};/* src/core/ui/components/ShapeUtil.svelte generated by Svelte v3.29.4 */function create_if_block_4$5(ctx){let shapelayouteditor;let updating_markup;let updating_ui;let current;const shapelayouteditor_spread_levels=[{locale:/*locale*/ctx[4]},{parentRect:/*$parentRect*/ctx[27]},{rootRect:/*$rootRect*/ctx[18]},{stageRect:/*$stageRect*/ctx[22]},{utilRect:/*$utilRect*/ctx[21]},{offset:/*markupOffset*/ctx[20]},{scale:/*$presentationScalar*/ctx[32]},{rotation:/*imageRotation*/ctx[12]},{opacity:/*$isActiveFraction*/ctx[26]},{enableButtonFlipVertical:/*enableButtonFlipVertical*/ctx[7]},{mapEditorPointToImagePoint:/*mapScreenPointToImagePoint*/ctx[10]},{mapImagePointToEditorPoint:/*mapImagePointToScreenPoint*/ctx[11]},{oninteractionstart:/*handleInteractionStart*/ctx[41]},{oninteractionupdate:/*handleInteractionUpdate*/ctx[42]},{oninteractionrelease:/*handleInteractionRelease*/ctx[43]},{oninteractionend:/*handleInteractionEnd*/ctx[44]},{onaddshape:/*func*/ctx[59]},{onselectshape:/*func_1*/ctx[60]},{onupdateshape:/*func_2*/ctx[61]},{onremoveshape:/*func_3*/ctx[62]},/*hooks*/ctx[14]];function shapelayouteditor_markup_binding(value){/*shapelayouteditor_markup_binding*/ctx[64].call(null,value);}function shapelayouteditor_ui_binding(value){/*shapelayouteditor_ui_binding*/ctx[65].call(null,value);}let shapelayouteditor_props={};for(let i=0;i<shapelayouteditor_spread_levels.length;i+=1){shapelayouteditor_props=assign(shapelayouteditor_props,shapelayouteditor_spread_levels[i]);}if(/*$shapes*/ctx[23]!==void 0){shapelayouteditor_props.markup=/*$shapes*/ctx[23];}if(/*$imageOverlayMarkup*/ctx[31]!==void 0){shapelayouteditor_props.ui=/*$imageOverlayMarkup*/ctx[31];}shapelayouteditor=new ShapeLayoutEditor({props:shapelayouteditor_props});/*shapelayouteditor_binding*/ctx[63](shapelayouteditor);binding_callbacks.push(()=>bind(shapelayouteditor,\"markup\",shapelayouteditor_markup_binding));binding_callbacks.push(()=>bind(shapelayouteditor,\"ui\",shapelayouteditor_ui_binding));shapelayouteditor.$on(\"measure\",/*measure_handler_1*/ctx[66]);return{c(){create_component(shapelayouteditor.$$.fragment);},m(target,anchor){mount_component(shapelayouteditor,target,anchor);current=true;},p(ctx,dirty){const shapelayouteditor_changes=dirty[0]&/*locale, $parentRect, $rootRect, $stageRect, $utilRect, markupOffset, imageRotation, $isActiveFraction, enableButtonFlipVertical, mapScreenPointToImagePoint, mapImagePointToScreenPoint, ping, hooks*/477387920|dirty[1]&/*$presentationScalar, handleInteractionStart, handleInteractionUpdate, handleInteractionRelease, handleInteractionEnd, handleMarkupUpdate*/1063938?get_spread_update(shapelayouteditor_spread_levels,[dirty[0]&/*locale*/16&&{locale:/*locale*/ctx[4]},dirty[0]&/*$parentRect*/134217728&&{parentRect:/*$parentRect*/ctx[27]},dirty[0]&/*$rootRect*/262144&&{rootRect:/*$rootRect*/ctx[18]},dirty[0]&/*$stageRect*/4194304&&{stageRect:/*$stageRect*/ctx[22]},dirty[0]&/*$utilRect*/2097152&&{utilRect:/*$utilRect*/ctx[21]},dirty[0]&/*markupOffset*/1048576&&{offset:/*markupOffset*/ctx[20]},dirty[1]&/*$presentationScalar*/2&&{scale:/*$presentationScalar*/ctx[32]},dirty[0]&/*imageRotation*/4096&&{rotation:/*imageRotation*/ctx[12]},dirty[0]&/*$isActiveFraction*/67108864&&{opacity:/*$isActiveFraction*/ctx[26]},dirty[0]&/*enableButtonFlipVertical*/128&&{enableButtonFlipVertical:/*enableButtonFlipVertical*/ctx[7]},dirty[0]&/*mapScreenPointToImagePoint*/1024&&{mapEditorPointToImagePoint:/*mapScreenPointToImagePoint*/ctx[10]},dirty[0]&/*mapImagePointToScreenPoint*/2048&&{mapImagePointToEditorPoint:/*mapImagePointToScreenPoint*/ctx[11]},dirty[1]&/*handleInteractionStart*/1024&&{oninteractionstart:/*handleInteractionStart*/ctx[41]},dirty[1]&/*handleInteractionUpdate*/2048&&{oninteractionupdate:/*handleInteractionUpdate*/ctx[42]},dirty[1]&/*handleInteractionRelease*/4096&&{oninteractionrelease:/*handleInteractionRelease*/ctx[43]},dirty[1]&/*handleInteractionEnd*/8192&&{oninteractionend:/*handleInteractionEnd*/ctx[44]},dirty[0]&/*ping*/268435456|dirty[1]&/*handleMarkupUpdate*/1048576&&{onaddshape:/*func*/ctx[59]},dirty[0]&/*ping*/268435456&&{onselectshape:/*func_1*/ctx[60]},dirty[0]&/*ping*/268435456|dirty[1]&/*handleMarkupUpdate*/1048576&&{onupdateshape:/*func_2*/ctx[61]},dirty[0]&/*ping*/268435456|dirty[1]&/*handleMarkupUpdate*/1048576&&{onremoveshape:/*func_3*/ctx[62]},dirty[0]&/*hooks*/16384&&get_spread_object(/*hooks*/ctx[14])]):{};if(!updating_markup&&dirty[0]&/*$shapes*/8388608){updating_markup=true;shapelayouteditor_changes.markup=/*$shapes*/ctx[23];add_flush_callback(()=>updating_markup=false);}if(!updating_ui&&dirty[1]&/*$imageOverlayMarkup*/1){updating_ui=true;shapelayouteditor_changes.ui=/*$imageOverlayMarkup*/ctx[31];add_flush_callback(()=>updating_ui=false);}shapelayouteditor.$set(shapelayouteditor_changes);},i(local){if(current)return;transition_in(shapelayouteditor.$$.fragment,local);current=true;},o(local){transition_out(shapelayouteditor.$$.fragment,local);current=false;},d(detaching){/*shapelayouteditor_binding*/ctx[63](null);destroy_component(shapelayouteditor,detaching);}};}// (376:4) <div bind:this={pingHub} slot=\"main\" style=\"cursor: crosshair\" use:dropable on:dropfiles={handleDropFiles}>\nfunction create_main_slot$1(ctx){let div;let dropable_action;let current;let mounted;let dispose;let if_block=/*shouldRenderShapeEditor*/ctx[19]&&create_if_block_4$5(ctx);return{c(){div=element(\"div\");if(if_block)if_block.c();attr(div,\"slot\",\"main\");set_style(div,\"cursor\",\"crosshair\");},m(target,anchor){insert(target,div,anchor);if(if_block)if_block.m(div,null);/*div_binding*/ctx[67](div);current=true;if(!mounted){dispose=[action_destroyer(dropable_action=dropable.call(null,div)),listen(div,\"dropfiles\",/*handleDropFiles*/ctx[50])];mounted=true;}},p(ctx,dirty){if(/*shouldRenderShapeEditor*/ctx[19]){if(if_block){if_block.p(ctx,dirty);if(dirty[0]&/*shouldRenderShapeEditor*/524288){transition_in(if_block,1);}}else{if_block=create_if_block_4$5(ctx);if_block.c();transition_in(if_block,1);if_block.m(div,null);}}else if(if_block){group_outros();transition_out(if_block,1,1,()=>{if_block=null;});check_outros();}},i(local){if(current)return;transition_in(if_block);current=true;},o(local){transition_out(if_block);current=false;},d(detaching){if(detaching)detach(div);if(if_block)if_block.d();/*div_binding*/ctx[67](null);mounted=false;run_all(dispose);}};}// (463:38) \nfunction create_if_block_3$5(ctx){let shapepresetspalette;let current;shapepresetspalette=new ShapePresetsPalette({props:{locale:/*locale*/ctx[4],presets:/*shapePresets*/ctx[9],enableSelectImage:/*enablePresetSelectImage*/ctx[8],onaddpreset:/*handleAddPreset*/ctx[49],ongrabpreset:/*handleGrabPreset*/ctx[46],ondragpreset:/*handleDragPreset*/ctx[47],ondroppreset:/*handleDropPreset*/ctx[48],scrollElasticity:/*computedScrollElasticity*/ctx[29]}});return{c(){create_component(shapepresetspalette.$$.fragment);},m(target,anchor){mount_component(shapepresetspalette,target,anchor);current=true;},p(ctx,dirty){const shapepresetspalette_changes={};if(dirty[0]&/*locale*/16)shapepresetspalette_changes.locale=/*locale*/ctx[4];if(dirty[0]&/*shapePresets*/512)shapepresetspalette_changes.presets=/*shapePresets*/ctx[9];if(dirty[0]&/*enablePresetSelectImage*/256)shapepresetspalette_changes.enableSelectImage=/*enablePresetSelectImage*/ctx[8];if(dirty[0]&/*computedScrollElasticity*/536870912)shapepresetspalette_changes.scrollElasticity=/*computedScrollElasticity*/ctx[29];shapepresetspalette.$set(shapepresetspalette_changes);},i(local){if(current)return;transition_in(shapepresetspalette.$$.fragment,local);current=true;},o(local){transition_out(shapepresetspalette.$$.fragment,local);current=false;},d(detaching){destroy_component(shapepresetspalette,detaching);}};}// (419:8) {#if toolsFiltered.length}\nfunction create_if_block$c(ctx){let div;let current_block_type_index;let if_block;let t;let scrollable;let current;const if_block_creators=[create_if_block_2$8,create_else_block$4];const if_blocks=[];function select_block_type_1(ctx,dirty){if(/*shouldRenderPresets*/ctx[25])return 0;return 1;}current_block_type_index=select_block_type_1(ctx);if_block=if_blocks[current_block_type_index]=if_block_creators[current_block_type_index](ctx);scrollable=new Scrollable({props:{class:\"DokaControlListScroller\",elasticity:/*computedScrollElasticity*/ctx[29],$$slots:{default:[create_default_slot_1$8]},$$scope:{ctx}}});return{c(){div=element(\"div\");if_block.c();t=space();create_component(scrollable.$$.fragment);attr(div,\"class\",\"DokaControlPanels\");},m(target,anchor){insert(target,div,anchor);if_blocks[current_block_type_index].m(div,null);insert(target,t,anchor);mount_component(scrollable,target,anchor);current=true;},p(ctx,dirty){let previous_block_index=current_block_type_index;current_block_type_index=select_block_type_1(ctx);if(current_block_type_index===previous_block_index){if_blocks[current_block_type_index].p(ctx,dirty);}else{group_outros();transition_out(if_blocks[previous_block_index],1,1,()=>{if_blocks[previous_block_index]=null;});check_outros();if_block=if_blocks[current_block_type_index];if(!if_block){if_block=if_blocks[current_block_type_index]=if_block_creators[current_block_type_index](ctx);if_block.c();}transition_in(if_block,1);if_block.m(div,null);}const scrollable_changes={};if(dirty[0]&/*computedScrollElasticity*/536870912)scrollable_changes.elasticity=/*computedScrollElasticity*/ctx[29];if(dirty[0]&/*locale, toolsFiltered, toolActive*/131089|dirty[2]&/*$$scope*/268435456){scrollable_changes.$$scope={dirty,ctx};}scrollable.$set(scrollable_changes);},i(local){if(current)return;transition_in(if_block);transition_in(scrollable.$$.fragment,local);current=true;},o(local){transition_out(if_block);transition_out(scrollable.$$.fragment,local);current=false;},d(detaching){if(detaching)detach(div);if_blocks[current_block_type_index].d();if(detaching)detach(t);destroy_component(scrollable,detaching);}};}// (433:16) {:else}\nfunction create_else_block$4(ctx){let div;let shapestyleeditor;let current;shapestyleeditor=new ShapeStyleEditor({props:{locale:/*locale*/ctx[4],shape:/*markupShapeSelected*/ctx[24],onchange:/*handleUpdateSelectedMarkupShape*/ctx[45],controls:/*shapeControls*/ctx[6],scrollElasticity:/*computedScrollElasticity*/ctx[29]}});return{c(){div=element(\"div\");create_component(shapestyleeditor.$$.fragment);attr(div,\"class\",\"DokaControlPanel\");},m(target,anchor){insert(target,div,anchor);mount_component(shapestyleeditor,div,null);current=true;},p(ctx,dirty){const shapestyleeditor_changes={};if(dirty[0]&/*locale*/16)shapestyleeditor_changes.locale=/*locale*/ctx[4];if(dirty[0]&/*markupShapeSelected*/16777216)shapestyleeditor_changes.shape=/*markupShapeSelected*/ctx[24];if(dirty[0]&/*shapeControls*/64)shapestyleeditor_changes.controls=/*shapeControls*/ctx[6];if(dirty[0]&/*computedScrollElasticity*/536870912)shapestyleeditor_changes.scrollElasticity=/*computedScrollElasticity*/ctx[29];shapestyleeditor.$set(shapestyleeditor_changes);},i(local){if(current)return;transition_in(shapestyleeditor.$$.fragment,local);current=true;},o(local){transition_out(shapestyleeditor.$$.fragment,local);current=false;},d(detaching){if(detaching)detach(div);destroy_component(shapestyleeditor);}};}// (422:16) {#if shouldRenderPresets}\nfunction create_if_block_2$8(ctx){let div;let shapepresetspalette;let current;shapepresetspalette=new ShapePresetsPalette({props:{locale:/*locale*/ctx[4],presets:/*shapePresets*/ctx[9],enableSelectImage:/*enablePresetSelectImage*/ctx[8],onaddpreset:/*handleAddPreset*/ctx[49],ongrabpreset:/*handleGrabPreset*/ctx[46],ondragpreset:/*handleDragPreset*/ctx[47],ondroppreset:/*handleDropPreset*/ctx[48],scrollElasticity:/*computedScrollElasticity*/ctx[29]}});return{c(){div=element(\"div\");create_component(shapepresetspalette.$$.fragment);attr(div,\"class\",\"DokaControlPanel\");},m(target,anchor){insert(target,div,anchor);mount_component(shapepresetspalette,div,null);current=true;},p(ctx,dirty){const shapepresetspalette_changes={};if(dirty[0]&/*locale*/16)shapepresetspalette_changes.locale=/*locale*/ctx[4];if(dirty[0]&/*shapePresets*/512)shapepresetspalette_changes.presets=/*shapePresets*/ctx[9];if(dirty[0]&/*enablePresetSelectImage*/256)shapepresetspalette_changes.enableSelectImage=/*enablePresetSelectImage*/ctx[8];if(dirty[0]&/*computedScrollElasticity*/536870912)shapepresetspalette_changes.scrollElasticity=/*computedScrollElasticity*/ctx[29];shapepresetspalette.$set(shapepresetspalette_changes);},i(local){if(current)return;transition_in(shapepresetspalette.$$.fragment,local);current=true;},o(local){transition_out(shapepresetspalette.$$.fragment,local);current=false;},d(detaching){if(detaching)detach(div);destroy_component(shapepresetspalette);}};}// (455:24) {#if option.icon}\nfunction create_if_block_1$c(ctx){let icon;let current;icon=new Icon({props:{$$slots:{default:[create_default_slot_3$6]},$$scope:{ctx}}});return{c(){create_component(icon.$$.fragment);},m(target,anchor){mount_component(icon,target,anchor);current=true;},p(ctx,dirty){const icon_changes={};if(dirty[0]&/*locale*/16|dirty[2]&/*$$scope, option*/402653184){icon_changes.$$scope={dirty,ctx};}icon.$set(icon_changes);},i(local){if(current)return;transition_in(icon.$$.fragment,local);current=true;},o(local){transition_out(icon.$$.fragment,local);current=false;},d(detaching){destroy_component(icon,detaching);}};}// (456:24) <Icon>\nfunction create_default_slot_3$6(ctx){let g;let raw_value=(isFunction(/*option*/ctx[89].icon)?/*option*/ctx[89].icon(/*locale*/ctx[4]):/*option*/ctx[89].icon)+\"\";return{c(){g=svg_element(\"g\");},m(target,anchor){insert(target,g,anchor);g.innerHTML=raw_value;},p(ctx,dirty){if(dirty[0]&/*locale*/16|dirty[2]&/*option*/134217728&&raw_value!==(raw_value=(isFunction(/*option*/ctx[89].icon)?/*option*/ctx[89].icon(/*locale*/ctx[4]):/*option*/ctx[89].icon)+\"\"))g.innerHTML=raw_value;},d(detaching){if(detaching)detach(g);}};}// (454:20) <div slot=\"option\">\nfunction create_option_slot$3(ctx){let div;let t0;let span;let t1_value=(isFunction(/*option*/ctx[89].label)?/*option*/ctx[89].label(/*locale*/ctx[4]):/*option*/ctx[89].label)+\"\";let t1;let current;let if_block=/*option*/ctx[89].icon&&create_if_block_1$c(ctx);return{c(){div=element(\"div\");if(if_block)if_block.c();t0=space();span=element(\"span\");t1=text(t1_value);attr(div,\"slot\",\"option\");},m(target,anchor){insert(target,div,anchor);if(if_block)if_block.m(div,null);append(div,t0);append(div,span);append(span,t1);current=true;},p(ctx,dirty){if(/*option*/ctx[89].icon){if(if_block){if_block.p(ctx,dirty);if(dirty[2]&/*option*/134217728){transition_in(if_block,1);}}else{if_block=create_if_block_1$c(ctx);if_block.c();transition_in(if_block,1);if_block.m(div,t0);}}else if(if_block){group_outros();transition_out(if_block,1,1,()=>{if_block=null;});check_outros();}if((!current||dirty[0]&/*locale*/16|dirty[2]&/*option*/134217728)&&t1_value!==(t1_value=(isFunction(/*option*/ctx[89].label)?/*option*/ctx[89].label(/*locale*/ctx[4]):/*option*/ctx[89].label)+\"\"))set_data(t1,t1_value);},i(local){if(current)return;transition_in(if_block);current=true;},o(local){transition_out(if_block);current=false;},d(detaching){if(detaching)detach(div);if(if_block)if_block.d();}};}// (444:12) <Scrollable class=\"DokaControlListScroller\" elasticity={computedScrollElasticity}>\nfunction create_default_slot_1$8(ctx){let radiogroup;let current;radiogroup=new RadioGroup({props:{locale:/*locale*/ctx[4],class:\"DokaControlList\",optionClass:\"DokaControlListOption\",layout:\"row\",options:/*toolsFiltered*/ctx[17],selectedIndex:/*toolsFiltered*/ctx[17].findIndex(/*func_4*/ctx[68]),onchange:/*updateActiveTool*/ctx[40],$$slots:{option:[create_option_slot$3,({option})=>({89:option}),({option})=>[0,0,option?134217728:0]]},$$scope:{ctx}}});return{c(){create_component(radiogroup.$$.fragment);},m(target,anchor){mount_component(radiogroup,target,anchor);current=true;},p(ctx,dirty){const radiogroup_changes={};if(dirty[0]&/*locale*/16)radiogroup_changes.locale=/*locale*/ctx[4];if(dirty[0]&/*toolsFiltered*/131072)radiogroup_changes.options=/*toolsFiltered*/ctx[17];if(dirty[0]&/*toolsFiltered, toolActive*/131073)radiogroup_changes.selectedIndex=/*toolsFiltered*/ctx[17].findIndex(/*func_4*/ctx[68]);if(dirty[0]&/*locale*/16|dirty[2]&/*$$scope, option*/402653184){radiogroup_changes.$$scope={dirty,ctx};}radiogroup.$set(radiogroup_changes);},i(local){if(current)return;transition_in(radiogroup.$$.fragment,local);current=true;},o(local){transition_out(radiogroup.$$.fragment,local);current=false;},d(detaching){destroy_component(radiogroup,detaching);}};}// (417:4) <div slot=\"footer\" style={footerStyle}>\nfunction create_footer_slot$3(ctx){let div;let current_block_type_index;let if_block;let current;const if_block_creators=[create_if_block$c,create_if_block_3$5];const if_blocks=[];function select_block_type(ctx,dirty){if(/*toolsFiltered*/ctx[17].length)return 0;if(/*shouldRenderPresets*/ctx[25])return 1;return-1;}if(~(current_block_type_index=select_block_type(ctx))){if_block=if_blocks[current_block_type_index]=if_block_creators[current_block_type_index](ctx);}return{c(){div=element(\"div\");if(if_block)if_block.c();attr(div,\"slot\",\"footer\");attr(div,\"style\",/*footerStyle*/ctx[30]);},m(target,anchor){insert(target,div,anchor);if(~current_block_type_index){if_blocks[current_block_type_index].m(div,null);}current=true;},p(ctx,dirty){let previous_block_index=current_block_type_index;current_block_type_index=select_block_type(ctx);if(current_block_type_index===previous_block_index){if(~current_block_type_index){if_blocks[current_block_type_index].p(ctx,dirty);}}else{if(if_block){group_outros();transition_out(if_blocks[previous_block_index],1,1,()=>{if_blocks[previous_block_index]=null;});check_outros();}if(~current_block_type_index){if_block=if_blocks[current_block_type_index];if(!if_block){if_block=if_blocks[current_block_type_index]=if_block_creators[current_block_type_index](ctx);if_block.c();}transition_in(if_block,1);if_block.m(div,null);}else{if_block=null;}}if(!current||dirty[0]&/*footerStyle*/1073741824){attr(div,\"style\",/*footerStyle*/ctx[30]);}},i(local){if(current)return;transition_in(if_block);current=true;},o(local){transition_out(if_block);current=false;},d(detaching){if(detaching)detach(div);if(~current_block_type_index){if_blocks[current_block_type_index].d();}}};}// (374:0) <Util on:measure>\nfunction create_default_slot$b(ctx){let t;return{c(){t=space();},m(target,anchor){insert(target,t,anchor);},p:noop$1,i:noop$1,o:noop$1,d(detaching){if(detaching)detach(t);}};}function create_fragment$C(ctx){let util;let current;util=new Util({props:{$$slots:{default:[create_default_slot$b],footer:[create_footer_slot$3],main:[create_main_slot$1]},$$scope:{ctx}}});util.$on(\"measure\",/*measure_handler*/ctx[69]);return{c(){create_component(util.$$.fragment);},m(target,anchor){mount_component(util,target,anchor);current=true;},p(ctx,dirty){const util_changes={};if(dirty[0]&/*footerStyle, computedScrollElasticity, locale, toolsFiltered, toolActive, shapePresets, enablePresetSelectImage, shouldRenderPresets, markupShapeSelected, shapeControls, pingHub, $parentRect, $rootRect, $stageRect, $utilRect, markupOffset, imageRotation, $isActiveFraction, enableButtonFlipVertical, mapScreenPointToImagePoint, mapImagePointToScreenPoint, ping, hooks, markupEditor, $shapes, shouldRenderShapeEditor*/2147475409|dirty[1]&/*$presentationScalar, $imageOverlayMarkup*/3|dirty[2]&/*$$scope*/268435456){util_changes.$$scope={dirty,ctx};}util.$set(util_changes);},i(local){if(current)return;transition_in(util.$$.fragment,local);current=true;},o(local){transition_out(util.$$.fragment,local);current=false;},d(detaching){destroy_component(util,detaching);}};}function instance$C($$self,$$props,$$invalidate){let $rootRect;let $isActive,$$unsubscribe_isActive=noop$1,$$subscribe_isActive=()=>($$unsubscribe_isActive(),$$unsubscribe_isActive=subscribe(isActive,$$value=>$$invalidate(73,$isActive=$$value)),isActive);let $imagePreviewModifiers;let $isVisible,$$unsubscribe_isVisible=noop$1,$$subscribe_isVisible=()=>($$unsubscribe_isVisible(),$$unsubscribe_isVisible=subscribe(isVisible,$$value=>$$invalidate(76,$isVisible=$$value)),isVisible);let $utilRect;let $stageRect;let $shapes,$$unsubscribe_shapes=noop$1,$$subscribe_shapes=()=>($$unsubscribe_shapes(),$$unsubscribe_shapes=subscribe(shapes,$$value=>$$invalidate(23,$shapes=$$value)),shapes);let $isActiveFraction,$$unsubscribe_isActiveFraction=noop$1,$$subscribe_isActiveFraction=()=>($$unsubscribe_isActiveFraction(),$$unsubscribe_isActiveFraction=subscribe(isActiveFraction,$$value=>$$invalidate(26,$isActiveFraction=$$value)),isActiveFraction);let $imageCropRect;let $parentRect,$$unsubscribe_parentRect=noop$1,$$subscribe_parentRect=()=>($$unsubscribe_parentRect(),$$unsubscribe_parentRect=subscribe(parentRect,$$value=>$$invalidate(27,$parentRect=$$value)),parentRect);let $footerOffset;let $imageOverlayMarkup;let $presentationScalar;$$self.$$.on_destroy.push(()=>$$unsubscribe_isActive());$$self.$$.on_destroy.push(()=>$$unsubscribe_isVisible());$$self.$$.on_destroy.push(()=>$$unsubscribe_shapes());$$self.$$.on_destroy.push(()=>$$unsubscribe_isActiveFraction());$$self.$$.on_destroy.push(()=>$$unsubscribe_parentRect());let{isActive}=$$props;$$subscribe_isActive();let{isActiveFraction}=$$props;$$subscribe_isActiveFraction();let{isVisible}=$$props;$$subscribe_isVisible();let{stores}=$$props;let{locale={}}=$$props;let{shapes=[]}=$$props;$$subscribe_shapes();let{tools=[]}=$$props;let{toolShapes=[]}=$$props;let{toolActive=\"sharpie\"}=$$props;let{shapeControls=[]}=$$props;let{enableButtonFlipVertical=false}=$$props;let{enablePresetSelectImage=true}=$$props;let{shapePresets=[]}=$$props;let{utilKey}=$$props;let{mapScreenPointToImagePoint}=$$props;let{mapImagePointToScreenPoint}=$$props;let{imageRotation=0}=$$props;let{imageFlipX=false}=$$props;let{imageFlipY=false}=$$props;let{parentRect}=$$props;$$subscribe_parentRect();let{hooks={}}=$$props;const{history,rootRect,stageRect,utilRect,elasticityMultiplier,scrollElasticity,imageOverlayMarkup,imagePreviewModifiers,imageCropRect,presentationScalar}=stores;component_subscribe($$self,rootRect,value=>$$invalidate(18,$rootRect=value));component_subscribe($$self,stageRect,value=>$$invalidate(22,$stageRect=value));component_subscribe($$self,utilRect,value=>$$invalidate(21,$utilRect=value));component_subscribe($$self,imageOverlayMarkup,value=>$$invalidate(31,$imageOverlayMarkup=value));component_subscribe($$self,imagePreviewModifiers,value=>$$invalidate(74,$imagePreviewModifiers=value));component_subscribe($$self,imageCropRect,value=>$$invalidate(80,$imageCropRect=value));component_subscribe($$self,presentationScalar,value=>$$invalidate(32,$presentationScalar=value));const updateActiveTool=({value})=>$$invalidate(0,toolActive=value);const mapScreenEventToImagePoint=e=>mapScreenPointToImagePoint(getEventPositionInEditor(e,$rootRect));// A reference to the markup editor, we need this so we can call exported functions\nlet markupEditor;// the current tool styles\nlet markupToolStyles={};//\n// Create new shape\n//\nlet interactionHandler;const handleInteractionStart=e=>{if(toolShapes[toolActive]){const[shape,options]=toolShapes[toolActive];interactionHandler=markupEditor.createShape(_objectSpread(_objectSpread({},shape),markupToolStylesComputed),options);}else if(toolActive===\"eraser\"){interactionHandler=markupEditor.eraseShape();}else{interactionHandler=undefined;}if(!interactionHandler)return;interactionHandler.start(e);};const handleInteractionUpdate=e=>{if(!interactionHandler)return;interactionHandler.update(e);};const handleInteractionRelease=e=>{if(!interactionHandler)return;interactionHandler.release(e);};const handleInteractionEnd=e=>{if(!interactionHandler)return;interactionHandler.end(e);interactionHandler=undefined;};function handleUpdateSelectedMarkupShape(props){// remember style for when creating or styling other element\nObject.keys(props).forEach(key=>$$invalidate(70,markupToolStyles[key]=props[key],markupToolStyles));// it's possible we're only updating default styles\nif(!markupSelected)return;// update element\nmarkupEditor.updateMarkupShape(markupSelected,props);// update markup style\nhandleMarkupUpdate();}const createPreset=(preset,position)=>{// position defaults to crop center\nlet positionIsCenter=false;if(!position){positionIsCenter=true;position=rectCenter($imageCropRect);}// adjust offset if parent rect is image crop rect\nposition.x-=$parentRect.x||0;position.y-=$parentRect.y||0;// calculate new center if image is rotated\nif(imageRotation!==0){const size={width:$parentRect.width,height:$parentRect.height};sizeRotate(size,imageRotation);const dx=($parentRect.width-Math.abs(size.width))*0.5;const dy=($parentRect.height-Math.abs(size.height))*0.5;position.x+=dx;position.y+=dy;}// create shape\nconst shape=shapeCreateFromPreset(preset,$imageCropRect,(error,shape)=>{// has shape not been added?\nif(!$shapes.find(s=>s.id===shape.id))return;// something went wrong, exit!\nif(error){markupEditor.removeShape(shape);return console.error(error);}// reposition shape\nshapeContain(shape,$imageCropRect);shapeCenter(shape,position);// select if is last shape\nif($shapes[$shapes.length-1]===shape){markupEditor.selectShape(shape);}});// de-flip shape\nshape.flipX=imageFlipX;shape.flipY=imageFlipY;// de-rotate shape\nshape.rotation=imageRotation!==0?-imageRotation:0;// reposition if there's already shapes at position and shape isn't full screen\nconst shapesAlreadyAtPosition=markupEditor.getShapesAtPosition(position);const cropWidth=$imageCropRect.width;const cropHeight=$imageCropRect.height;if(positionIsCenter&&shapesAlreadyAtPosition.length&&shape.width<cropWidth&&shape.height<cropHeight){const size=Math.min(cropWidth,cropHeight)*0.1;position.x+=Math.round(-size+Math.random()*size*2);position.y+=Math.round(-size+Math.random()*size*2);}// shape update position\nif(shape.width&&shape.height){shapeContain(shape,$imageCropRect);shapeCenter(shape,position);}return shape;};const addPreset=(preset,position)=>{const{beforeAddShape=()=>true}=hooks;const shape=createPreset(preset,position);if(!beforeAddShape(shape))return;markupEditor.addShape(shape);history.write();return shape;};let dragCancelled=false;const handleGrabPreset=(preset,e)=>{dragCancelled=false;};const handleDragPreset=(preset,e)=>{if(dragCancelled)return;const{beforeAddShape=()=>true}=hooks;const position=mapScreenEventToImagePoint(e);// create or update if is inside image\nconst draft=markupEditor.getMarkupItemDraft();const inCropRect=rectContainsPoint($imageCropRect,{// adjust offset if parent rect is image crop rect\nx:position.x+($parentRect.x||0),y:position.y+($parentRect.y||0)});// remove draft if not dragging inside image\nif(draft&&!inCropRect)markupEditor.discardMarkupItemDraft();// stop here if we're not in the crop rect\nif(!inCropRect)return;// create draft shape\nif(!draft){const shape=createPreset(preset,position);if(!beforeAddShape(shape)){dragCancelled=true;e.preventDefault();return;}shapeMakeDraft(shape);markupEditor.addShape(shape);return;}// update existing draft\nmarkupEditor.updateMarkupShape(draft,{x:position.x-draft.width*0.5,y:position.y-draft.height*0.5});};const handleDropPreset=(preset,e)=>{if(dragCancelled)return;const position=mapScreenEventToImagePoint(e);// adjust offset if parent rect is image crop rect\nif(!rectContainsPoint($imageCropRect,{x:position.x+($parentRect.x||0),y:position.y+($parentRect.y||0)})){markupEditor.discardMarkupItemDraft();}else{const shape=markupEditor.confirmMarkupItemDraft();markupEditor.selectShape(shape);// update history\nhistory.write();}};const handleAddPreset=preset=>addPreset(preset);const handleAddFiles=(files,position)=>files.forEach(file=>addPreset(file,position));const handleDropFiles=e=>handleAddFiles(e.detail.files,mapScreenEventToImagePoint(e.detail.event));//\n// History\n//\nconst handleMarkupUpdate=()=>history.write();// used to fire ping events from\nlet pingHub;//\n// Footer style\n//\nconst footerOffset=spring(0);component_subscribe($$self,footerOffset,value=>$$invalidate(81,$footerOffset=value));const func=shape=>{ping(\"addshape\",shape);handleMarkupUpdate();};const func_1=shape=>{ping(\"selectshape\",shape);};const func_2=shape=>{ping(\"updateshape\",shape);handleMarkupUpdate();};const func_3=shape=>{ping(\"removeshape\",shape);handleMarkupUpdate();};function shapelayouteditor_binding($$value){binding_callbacks[$$value?\"unshift\":\"push\"](()=>{markupEditor=$$value;$$invalidate(15,markupEditor);});}function shapelayouteditor_markup_binding(value){$shapes=value;shapes.set($shapes);}function shapelayouteditor_ui_binding(value){$imageOverlayMarkup=value;imageOverlayMarkup.set($imageOverlayMarkup);}function measure_handler_1(event){bubble($$self,event);}function div_binding($$value){binding_callbacks[$$value?\"unshift\":\"push\"](()=>{pingHub=$$value;$$invalidate(16,pingHub);});}const func_4=option=>option[0]===toolActive;function measure_handler(event){bubble($$self,event);}$$self.$$set=$$props=>{if(\"isActive\"in $$props)$$subscribe_isActive($$invalidate(1,isActive=$$props.isActive));if(\"isActiveFraction\"in $$props)$$subscribe_isActiveFraction($$invalidate(2,isActiveFraction=$$props.isActiveFraction));if(\"isVisible\"in $$props)$$subscribe_isVisible($$invalidate(3,isVisible=$$props.isVisible));if(\"stores\"in $$props)$$invalidate(53,stores=$$props.stores);if(\"locale\"in $$props)$$invalidate(4,locale=$$props.locale);if(\"shapes\"in $$props)$$subscribe_shapes($$invalidate(5,shapes=$$props.shapes));if(\"tools\"in $$props)$$invalidate(54,tools=$$props.tools);if(\"toolShapes\"in $$props)$$invalidate(55,toolShapes=$$props.toolShapes);if(\"toolActive\"in $$props)$$invalidate(0,toolActive=$$props.toolActive);if(\"shapeControls\"in $$props)$$invalidate(6,shapeControls=$$props.shapeControls);if(\"enableButtonFlipVertical\"in $$props)$$invalidate(7,enableButtonFlipVertical=$$props.enableButtonFlipVertical);if(\"enablePresetSelectImage\"in $$props)$$invalidate(8,enablePresetSelectImage=$$props.enablePresetSelectImage);if(\"shapePresets\"in $$props)$$invalidate(9,shapePresets=$$props.shapePresets);if(\"utilKey\"in $$props)$$invalidate(56,utilKey=$$props.utilKey);if(\"mapScreenPointToImagePoint\"in $$props)$$invalidate(10,mapScreenPointToImagePoint=$$props.mapScreenPointToImagePoint);if(\"mapImagePointToScreenPoint\"in $$props)$$invalidate(11,mapImagePointToScreenPoint=$$props.mapImagePointToScreenPoint);if(\"imageRotation\"in $$props)$$invalidate(12,imageRotation=$$props.imageRotation);if(\"imageFlipX\"in $$props)$$invalidate(57,imageFlipX=$$props.imageFlipX);if(\"imageFlipY\"in $$props)$$invalidate(58,imageFlipY=$$props.imageFlipY);if(\"parentRect\"in $$props)$$subscribe_parentRect($$invalidate(13,parentRect=$$props.parentRect));if(\"hooks\"in $$props)$$invalidate(14,hooks=$$props.hooks);};let toolsFiltered;let shouldRenderShapeEditor;let markupOffset;let markupShapeKeys;let markupSelected;let markupToolShape;let markupToolStylesComputed;let markupShapeSelected;let shouldRenderPresets;let ping;let computedScrollElasticity;let footerStyle;$$self.$$.update=()=>{if($$self.$$.dirty[0]&/*shapePresets*/512|$$self.$$.dirty[1]&/*tools*/8388608){// remove presets tool if no shape presets defined\n$$invalidate(17,toolsFiltered=shapePresets.length===0?tools.filter(tool=>tool[0]!==\"preset\"):tools);}if($$self.$$.dirty[1]&/*utilKey*/33554432|$$self.$$.dirty[2]&/*$isActive, $imagePreviewModifiers*/6144){//\n// enable seeing the markup outlines outside of the crop area\n// \nif($isActive){set_store_value(imagePreviewModifiers,$imagePreviewModifiers[utilKey]={maskMarkupOpacity:0.85},$imagePreviewModifiers);}else{delete $imagePreviewModifiers[utilKey];}}if($$self.$$.dirty[2]&/*$isVisible*/16384){$$invalidate(19,shouldRenderShapeEditor=$isVisible);}if($$self.$$.dirty[0]&/*$utilRect, $stageRect*/6291456){$$invalidate(20,markupOffset=$utilRect&&vectorCreate($stageRect.x-$utilRect.x,$stageRect.y-$utilRect.y));}if($$self.$$.dirty[0]&/*toolActive, markupEditor*/32769){// if tool is changed, deselect markup items\nif(toolActive&&markupEditor)markupEditor.blurShapes();}if($$self.$$.dirty[0]&/*shapeControls*/64){$$invalidate(77,markupShapeKeys=Object.keys(shapeControls));}if($$self.$$.dirty[0]&/*$shapes*/8388608){$$invalidate(78,markupSelected=($shapes.filter(shapeIsSelected)||[])[0]);}if($$self.$$.dirty[0]&/*toolActive*/1|$$self.$$.dirty[1]&/*toolShapes*/16777216|$$self.$$.dirty[2]&/*$isActive*/2048){$$invalidate(79,markupToolShape=$isActive&&(toolShapes[toolActive]?shapeFormat(shapeDeepCopy(toolShapes[toolActive][0])):{}));}if($$self.$$.dirty[2]&/*markupToolShape, markupShapeKeys, markupToolStyles*/164096){$$invalidate(75,markupToolStylesComputed=markupToolShape&&Object.keys(markupToolShape).reduce((prev,key)=>{const isDisableStyleProp=key===\"disableStyle\";const isStylableProp=markupShapeKeys.find(shapeKey=>shapeKey.split(\"_\").includes(key));// skip props that can't be styled, but keep all `disable` props\nif(!isDisableStyleProp&&!isStylableProp)return prev;// apply this style\nprev[key]=markupToolStyles[key]||markupToolShape[key];return prev;},{}));}if($$self.$$.dirty[2]&/*markupSelected, markupToolStylesComputed*/73728){$$invalidate(24,markupShapeSelected=markupSelected||markupToolStylesComputed);}if($$self.$$.dirty[0]&/*$isActiveFraction, toolActive, shapePresets, enablePresetSelectImage*/67109633){//\n// presets\n//\n$$invalidate(25,shouldRenderPresets=$isActiveFraction>0&&toolActive===\"preset\"&&(shapePresets.length>0||enablePresetSelectImage));}if($$self.$$.dirty[0]&/*pingHub*/65536){$$invalidate(28,ping=pingHub&&createPingDispatcher(pingHub));}if($$self.$$.dirty[2]&/*$isActive*/2048){footerOffset.set($isActive?0:20);}if($$self.$$.dirty[2]&/*$footerOffset*/524288){$$invalidate(30,footerStyle=$footerOffset?`transform: translateY(${$footerOffset}px)`:undefined);}};$$invalidate(29,computedScrollElasticity=elasticityMultiplier*scrollElasticity);return[toolActive,isActive,isActiveFraction,isVisible,locale,shapes,shapeControls,enableButtonFlipVertical,enablePresetSelectImage,shapePresets,mapScreenPointToImagePoint,mapImagePointToScreenPoint,imageRotation,parentRect,hooks,markupEditor,pingHub,toolsFiltered,$rootRect,shouldRenderShapeEditor,markupOffset,$utilRect,$stageRect,$shapes,markupShapeSelected,shouldRenderPresets,$isActiveFraction,$parentRect,ping,computedScrollElasticity,footerStyle,$imageOverlayMarkup,$presentationScalar,rootRect,stageRect,utilRect,imageOverlayMarkup,imagePreviewModifiers,imageCropRect,presentationScalar,updateActiveTool,handleInteractionStart,handleInteractionUpdate,handleInteractionRelease,handleInteractionEnd,handleUpdateSelectedMarkupShape,handleGrabPreset,handleDragPreset,handleDropPreset,handleAddPreset,handleDropFiles,handleMarkupUpdate,footerOffset,stores,tools,toolShapes,utilKey,imageFlipX,imageFlipY,func,func_1,func_2,func_3,shapelayouteditor_binding,shapelayouteditor_markup_binding,shapelayouteditor_ui_binding,measure_handler_1,div_binding,func_4,measure_handler];}class ShapeUtil extends SvelteComponent{constructor(options){super();init(this,options,instance$C,create_fragment$C,safe_not_equal,{isActive:1,isActiveFraction:2,isVisible:3,stores:53,locale:4,shapes:5,tools:54,toolShapes:55,toolActive:0,shapeControls:6,enableButtonFlipVertical:7,enablePresetSelectImage:8,shapePresets:9,utilKey:56,mapScreenPointToImagePoint:10,mapImagePointToScreenPoint:11,imageRotation:12,imageFlipX:57,imageFlipY:58,parentRect:13,hooks:14},[-1,-1,-1]);}get isActive(){return this.$$.ctx[1];}set isActive(isActive){this.$set({isActive});flush();}get isActiveFraction(){return this.$$.ctx[2];}set isActiveFraction(isActiveFraction){this.$set({isActiveFraction});flush();}get isVisible(){return this.$$.ctx[3];}set isVisible(isVisible){this.$set({isVisible});flush();}get stores(){return this.$$.ctx[53];}set stores(stores){this.$set({stores});flush();}get locale(){return this.$$.ctx[4];}set locale(locale){this.$set({locale});flush();}get shapes(){return this.$$.ctx[5];}set shapes(shapes){this.$set({shapes});flush();}get tools(){return this.$$.ctx[54];}set tools(tools){this.$set({tools});flush();}get toolShapes(){return this.$$.ctx[55];}set toolShapes(toolShapes){this.$set({toolShapes});flush();}get toolActive(){return this.$$.ctx[0];}set toolActive(toolActive){this.$set({toolActive});flush();}get shapeControls(){return this.$$.ctx[6];}set shapeControls(shapeControls){this.$set({shapeControls});flush();}get enableButtonFlipVertical(){return this.$$.ctx[7];}set enableButtonFlipVertical(enableButtonFlipVertical){this.$set({enableButtonFlipVertical});flush();}get enablePresetSelectImage(){return this.$$.ctx[8];}set enablePresetSelectImage(enablePresetSelectImage){this.$set({enablePresetSelectImage});flush();}get shapePresets(){return this.$$.ctx[9];}set shapePresets(shapePresets){this.$set({shapePresets});flush();}get utilKey(){return this.$$.ctx[56];}set utilKey(utilKey){this.$set({utilKey});flush();}get mapScreenPointToImagePoint(){return this.$$.ctx[10];}set mapScreenPointToImagePoint(mapScreenPointToImagePoint){this.$set({mapScreenPointToImagePoint});flush();}get mapImagePointToScreenPoint(){return this.$$.ctx[11];}set mapImagePointToScreenPoint(mapImagePointToScreenPoint){this.$set({mapImagePointToScreenPoint});flush();}get imageRotation(){return this.$$.ctx[12];}set imageRotation(imageRotation){this.$set({imageRotation});flush();}get imageFlipX(){return this.$$.ctx[57];}set imageFlipX(imageFlipX){this.$set({imageFlipX});flush();}get imageFlipY(){return this.$$.ctx[58];}set imageFlipY(imageFlipY){this.$set({imageFlipY});flush();}get parentRect(){return this.$$.ctx[13];}set parentRect(parentRect){this.$set({parentRect});flush();}get hooks(){return this.$$.ctx[14];}set hooks(hooks){this.$set({hooks});flush();}}var _mapImagePointToScreenPoint=(imagePoint,canvasSize,imageSize,imageOrigin,imageTranslation,imageRotation,imageScalar,imageFlipX,imageFlipY)=>{const mappedPoint=vectorClone(imagePoint);const imageCenterX=imageSize.width*0.5;const imageCenterY=imageSize.height*0.5;const canvasCenterX=canvasSize.width*0.5;const canvasCenterY=canvasSize.height*0.5;const imageOffsetX=imageTranslation.x+imageOrigin.x;const imageOffsetY=imageTranslation.y+imageOrigin.y;if(imageFlipX)mappedPoint.x=imageSize.width-mappedPoint.x;if(imageFlipY)mappedPoint.y=imageSize.height-mappedPoint.y;// rotate around image center based on if image is rotated\nconst c=Math.cos(imageRotation);const s=Math.sin(imageRotation);mappedPoint.x-=imageCenterX;mappedPoint.y-=imageCenterY;const rx=mappedPoint.x*c-mappedPoint.y*s;const ry=mappedPoint.x*s+mappedPoint.y*c;mappedPoint.x=imageCenterX+rx;mappedPoint.y=imageCenterY+ry;// position based on screen transforms\nmappedPoint.x*=imageScalar;mappedPoint.y*=imageScalar;mappedPoint.x+=canvasCenterX;mappedPoint.y+=canvasCenterY;mappedPoint.x+=imageOffsetX;mappedPoint.y+=imageOffsetY;mappedPoint.x-=imageCenterX*imageScalar;mappedPoint.y-=imageCenterY*imageScalar;const tx=(imageTranslation.x-imageOffsetX)*imageScalar;const ty=(imageTranslation.y-imageOffsetY)*imageScalar;const rtx=tx*c-ty*s;const rty=tx*s+ty*c;mappedPoint.x+=rtx;mappedPoint.y+=rty;return mappedPoint;};var _mapScreenPointToImagePoint=(screenPoint,canvasSize,imageSize,imageOrigin,imageTranslation,imageRotation,imageScalar,imageFlipX,imageFlipY)=>{const mappedPoint=vectorClone(screenPoint);const imageCenter=sizeCenter(imageSize);const canvasCenter=sizeCenter(canvasSize);const imageOffset=vectorCreate(imageTranslation.x+imageOrigin.x,imageTranslation.y+imageOrigin.y);const c=Math.cos(imageRotation);const s=Math.sin(imageRotation);mappedPoint.x-=canvasCenter.x;mappedPoint.y-=canvasCenter.y;const tx=(imageTranslation.x-imageOffset.x)*imageScalar;const ty=(imageTranslation.y-imageOffset.y)*imageScalar;const rtx=tx*c-ty*s;const rty=tx*s+ty*c;mappedPoint.x-=rtx;mappedPoint.y-=rty;mappedPoint.x-=imageOffset.x;mappedPoint.y-=imageOffset.y;mappedPoint.x/=imageScalar;mappedPoint.y/=imageScalar;const rx=mappedPoint.x*c+mappedPoint.y*s;const ry=mappedPoint.x*s-mappedPoint.y*c;mappedPoint.x=rx;mappedPoint.y=-ry;mappedPoint.x+=imageCenter.x;mappedPoint.y+=imageCenter.y;if(imageFlipX)mappedPoint.x=imageSize.width-mappedPoint.x;if(imageFlipY)mappedPoint.y=imageSize.height-mappedPoint.y;return mappedPoint;};/* src/core/ui/plugins/annotate/index.svelte generated by Svelte v3.29.4 */function create_fragment$D(ctx){let shapeutil;let current;shapeutil=new ShapeUtil({props:{stores:/*stores*/ctx[3],locale:/*locale*/ctx[4],isActive:/*isActive*/ctx[0],isActiveFraction:/*isActiveFraction*/ctx[1],isVisible:/*isVisible*/ctx[2],mapScreenPointToImagePoint:/*mapScreenPointToImagePoint*/ctx[31],mapImagePointToScreenPoint:/*mapImagePointToScreenPoint*/ctx[32],utilKey:\"annotate\",imageRotation:/*$imageRotation*/ctx[23],imageFlipX:/*$imageFlipX*/ctx[21],imageFlipY:/*$imageFlipY*/ctx[22],shapes:/*imageAnnotation*/ctx[25],tools:/*annotateTools*/ctx[8]||/*markupEditorToolbar*/ctx[5],toolShapes:/*annotateToolShapes*/ctx[9]||/*markupEditorToolStyles*/ctx[6],toolActive:/*annotateActiveTool*/ctx[11],shapeControls:/*annotateShapeControls*/ctx[10]||/*markupEditorShapeStyleControls*/ctx[7],shapePresets:/*annotatePresets*/ctx[14],enableButtonFlipVertical:/*annotateEnableButtonFlipVertical*/ctx[12],parentRect:/*imageSize*/ctx[26],enablePresetSelectImage:/*annotateEnableSelectImagePreset*/ctx[13],hooks:{willRenderShapeControls:/*willRenderShapeControls*/ctx[15],beforeAddShape:/*beforeAddShape*/ctx[16],beforeRemoveShape:/*beforeRemoveShape*/ctx[17],beforeDeselectShape:/*beforeDeselectShape*/ctx[18],beforeSelectShape:/*beforeSelectShape*/ctx[19],beforeUpdateShape:/*beforeUpdateShape*/ctx[20]}}});shapeutil.$on(\"measure\",/*measure_handler*/ctx[34]);return{c(){create_component(shapeutil.$$.fragment);},m(target,anchor){mount_component(shapeutil,target,anchor);current=true;},p(ctx,dirty){const shapeutil_changes={};if(dirty[0]&/*stores*/8)shapeutil_changes.stores=/*stores*/ctx[3];if(dirty[0]&/*locale*/16)shapeutil_changes.locale=/*locale*/ctx[4];if(dirty[0]&/*isActive*/1)shapeutil_changes.isActive=/*isActive*/ctx[0];if(dirty[0]&/*isActiveFraction*/2)shapeutil_changes.isActiveFraction=/*isActiveFraction*/ctx[1];if(dirty[0]&/*isVisible*/4)shapeutil_changes.isVisible=/*isVisible*/ctx[2];if(dirty[0]&/*$imageRotation*/8388608)shapeutil_changes.imageRotation=/*$imageRotation*/ctx[23];if(dirty[0]&/*$imageFlipX*/2097152)shapeutil_changes.imageFlipX=/*$imageFlipX*/ctx[21];if(dirty[0]&/*$imageFlipY*/4194304)shapeutil_changes.imageFlipY=/*$imageFlipY*/ctx[22];if(dirty[0]&/*annotateTools, markupEditorToolbar*/288)shapeutil_changes.tools=/*annotateTools*/ctx[8]||/*markupEditorToolbar*/ctx[5];if(dirty[0]&/*annotateToolShapes, markupEditorToolStyles*/576)shapeutil_changes.toolShapes=/*annotateToolShapes*/ctx[9]||/*markupEditorToolStyles*/ctx[6];if(dirty[0]&/*annotateActiveTool*/2048)shapeutil_changes.toolActive=/*annotateActiveTool*/ctx[11];if(dirty[0]&/*annotateShapeControls, markupEditorShapeStyleControls*/1152)shapeutil_changes.shapeControls=/*annotateShapeControls*/ctx[10]||/*markupEditorShapeStyleControls*/ctx[7];if(dirty[0]&/*annotatePresets*/16384)shapeutil_changes.shapePresets=/*annotatePresets*/ctx[14];if(dirty[0]&/*annotateEnableButtonFlipVertical*/4096)shapeutil_changes.enableButtonFlipVertical=/*annotateEnableButtonFlipVertical*/ctx[12];if(dirty[0]&/*annotateEnableSelectImagePreset*/8192)shapeutil_changes.enablePresetSelectImage=/*annotateEnableSelectImagePreset*/ctx[13];if(dirty[0]&/*willRenderShapeControls, beforeAddShape, beforeRemoveShape, beforeDeselectShape, beforeSelectShape, beforeUpdateShape*/2064384)shapeutil_changes.hooks={willRenderShapeControls:/*willRenderShapeControls*/ctx[15],beforeAddShape:/*beforeAddShape*/ctx[16],beforeRemoveShape:/*beforeRemoveShape*/ctx[17],beforeDeselectShape:/*beforeDeselectShape*/ctx[18],beforeSelectShape:/*beforeSelectShape*/ctx[19],beforeUpdateShape:/*beforeUpdateShape*/ctx[20]};shapeutil.$set(shapeutil_changes);},i(local){if(current)return;transition_in(shapeutil.$$.fragment,local);current=true;},o(local){transition_out(shapeutil.$$.fragment,local);current=false;},d(detaching){destroy_component(shapeutil,detaching);}};}function instance$D($$self,$$props,$$invalidate){let $rootRect;let $imageSize;let $imageTransforms;let $imageFlipX;let $imageFlipY;let $imageRotation;const name=\"annotate\";let{isActive}=$$props;let{isActiveFraction}=$$props;let{isVisible}=$$props;let{stores}=$$props;let{locale={}}=$$props;let{markupEditorToolbar=undefined}=$$props;let{markupEditorToolStyles=undefined}=$$props;let{markupEditorShapeStyleControls=undefined}=$$props;let{annotateTools=undefined}=$$props;let{annotateToolShapes=undefined}=$$props;let{annotateShapeControls=undefined}=$$props;let{annotateActiveTool=\"sharpie\"}=$$props;let{annotateEnableButtonFlipVertical=false}=$$props;let{annotateEnableSelectImagePreset=false}=$$props;let{annotatePresets=[]}=$$props;let{willRenderShapeControls=undefined}=$$props;let{beforeAddShape=undefined}=$$props;let{beforeRemoveShape=undefined}=$$props;let{beforeDeselectShape=undefined}=$$props;let{beforeSelectShape=undefined}=$$props;let{beforeUpdateShape=undefined}=$$props;// connect filter choice to stores\nconst{rootRect,imageAnnotation,imageSize,imageTransforms,imageRotation,imageFlipX,imageFlipY}=stores;component_subscribe($$self,rootRect,value=>$$invalidate(35,$rootRect=value));component_subscribe($$self,imageSize,value=>$$invalidate(36,$imageSize=value));component_subscribe($$self,imageTransforms,value=>$$invalidate(37,$imageTransforms=value));component_subscribe($$self,imageRotation,value=>$$invalidate(23,$imageRotation=value));component_subscribe($$self,imageFlipX,value=>$$invalidate(21,$imageFlipX=value));component_subscribe($$self,imageFlipY,value=>$$invalidate(22,$imageFlipY=value));//\n// Mapping coordinates\n//\nconst mapScreenPointToImagePoint=point=>_mapScreenPointToImagePoint(point,$rootRect,$imageSize,$imageTransforms.origin,$imageTransforms.translation,$imageTransforms.rotation.z,$imageTransforms.scale,$imageFlipX,$imageFlipY);const mapImagePointToScreenPoint=point=>_mapImagePointToScreenPoint(point,$rootRect,$imageSize,$imageTransforms.origin,$imageTransforms.translation,$imageTransforms.rotation.z,$imageTransforms.scale,$imageFlipX,$imageFlipY);function measure_handler(event){bubble($$self,event);}$$self.$$set=$$props=>{if(\"isActive\"in $$props)$$invalidate(0,isActive=$$props.isActive);if(\"isActiveFraction\"in $$props)$$invalidate(1,isActiveFraction=$$props.isActiveFraction);if(\"isVisible\"in $$props)$$invalidate(2,isVisible=$$props.isVisible);if(\"stores\"in $$props)$$invalidate(3,stores=$$props.stores);if(\"locale\"in $$props)$$invalidate(4,locale=$$props.locale);if(\"markupEditorToolbar\"in $$props)$$invalidate(5,markupEditorToolbar=$$props.markupEditorToolbar);if(\"markupEditorToolStyles\"in $$props)$$invalidate(6,markupEditorToolStyles=$$props.markupEditorToolStyles);if(\"markupEditorShapeStyleControls\"in $$props)$$invalidate(7,markupEditorShapeStyleControls=$$props.markupEditorShapeStyleControls);if(\"annotateTools\"in $$props)$$invalidate(8,annotateTools=$$props.annotateTools);if(\"annotateToolShapes\"in $$props)$$invalidate(9,annotateToolShapes=$$props.annotateToolShapes);if(\"annotateShapeControls\"in $$props)$$invalidate(10,annotateShapeControls=$$props.annotateShapeControls);if(\"annotateActiveTool\"in $$props)$$invalidate(11,annotateActiveTool=$$props.annotateActiveTool);if(\"annotateEnableButtonFlipVertical\"in $$props)$$invalidate(12,annotateEnableButtonFlipVertical=$$props.annotateEnableButtonFlipVertical);if(\"annotateEnableSelectImagePreset\"in $$props)$$invalidate(13,annotateEnableSelectImagePreset=$$props.annotateEnableSelectImagePreset);if(\"annotatePresets\"in $$props)$$invalidate(14,annotatePresets=$$props.annotatePresets);if(\"willRenderShapeControls\"in $$props)$$invalidate(15,willRenderShapeControls=$$props.willRenderShapeControls);if(\"beforeAddShape\"in $$props)$$invalidate(16,beforeAddShape=$$props.beforeAddShape);if(\"beforeRemoveShape\"in $$props)$$invalidate(17,beforeRemoveShape=$$props.beforeRemoveShape);if(\"beforeDeselectShape\"in $$props)$$invalidate(18,beforeDeselectShape=$$props.beforeDeselectShape);if(\"beforeSelectShape\"in $$props)$$invalidate(19,beforeSelectShape=$$props.beforeSelectShape);if(\"beforeUpdateShape\"in $$props)$$invalidate(20,beforeUpdateShape=$$props.beforeUpdateShape);};return[isActive,isActiveFraction,isVisible,stores,locale,markupEditorToolbar,markupEditorToolStyles,markupEditorShapeStyleControls,annotateTools,annotateToolShapes,annotateShapeControls,annotateActiveTool,annotateEnableButtonFlipVertical,annotateEnableSelectImagePreset,annotatePresets,willRenderShapeControls,beforeAddShape,beforeRemoveShape,beforeDeselectShape,beforeSelectShape,beforeUpdateShape,$imageFlipX,$imageFlipY,$imageRotation,rootRect,imageAnnotation,imageSize,imageTransforms,imageRotation,imageFlipX,imageFlipY,mapScreenPointToImagePoint,mapImagePointToScreenPoint,name,measure_handler];}class Annotate extends SvelteComponent{constructor(options){super();init(this,options,instance$D,create_fragment$D,safe_not_equal,{name:33,isActive:0,isActiveFraction:1,isVisible:2,stores:3,locale:4,markupEditorToolbar:5,markupEditorToolStyles:6,markupEditorShapeStyleControls:7,annotateTools:8,annotateToolShapes:9,annotateShapeControls:10,annotateActiveTool:11,annotateEnableButtonFlipVertical:12,annotateEnableSelectImagePreset:13,annotatePresets:14,willRenderShapeControls:15,beforeAddShape:16,beforeRemoveShape:17,beforeDeselectShape:18,beforeSelectShape:19,beforeUpdateShape:20},[-1,-1]);}get name(){return this.$$.ctx[33];}get isActive(){return this.$$.ctx[0];}set isActive(isActive){this.$set({isActive});flush();}get isActiveFraction(){return this.$$.ctx[1];}set isActiveFraction(isActiveFraction){this.$set({isActiveFraction});flush();}get isVisible(){return this.$$.ctx[2];}set isVisible(isVisible){this.$set({isVisible});flush();}get stores(){return this.$$.ctx[3];}set stores(stores){this.$set({stores});flush();}get locale(){return this.$$.ctx[4];}set locale(locale){this.$set({locale});flush();}get markupEditorToolbar(){return this.$$.ctx[5];}set markupEditorToolbar(markupEditorToolbar){this.$set({markupEditorToolbar});flush();}get markupEditorToolStyles(){return this.$$.ctx[6];}set markupEditorToolStyles(markupEditorToolStyles){this.$set({markupEditorToolStyles});flush();}get markupEditorShapeStyleControls(){return this.$$.ctx[7];}set markupEditorShapeStyleControls(markupEditorShapeStyleControls){this.$set({markupEditorShapeStyleControls});flush();}get annotateTools(){return this.$$.ctx[8];}set annotateTools(annotateTools){this.$set({annotateTools});flush();}get annotateToolShapes(){return this.$$.ctx[9];}set annotateToolShapes(annotateToolShapes){this.$set({annotateToolShapes});flush();}get annotateShapeControls(){return this.$$.ctx[10];}set annotateShapeControls(annotateShapeControls){this.$set({annotateShapeControls});flush();}get annotateActiveTool(){return this.$$.ctx[11];}set annotateActiveTool(annotateActiveTool){this.$set({annotateActiveTool});flush();}get annotateEnableButtonFlipVertical(){return this.$$.ctx[12];}set annotateEnableButtonFlipVertical(annotateEnableButtonFlipVertical){this.$set({annotateEnableButtonFlipVertical});flush();}get annotateEnableSelectImagePreset(){return this.$$.ctx[13];}set annotateEnableSelectImagePreset(annotateEnableSelectImagePreset){this.$set({annotateEnableSelectImagePreset});flush();}get annotatePresets(){return this.$$.ctx[14];}set annotatePresets(annotatePresets){this.$set({annotatePresets});flush();}get willRenderShapeControls(){return this.$$.ctx[15];}set willRenderShapeControls(willRenderShapeControls){this.$set({willRenderShapeControls});flush();}get beforeAddShape(){return this.$$.ctx[16];}set beforeAddShape(beforeAddShape){this.$set({beforeAddShape});flush();}get beforeRemoveShape(){return this.$$.ctx[17];}set beforeRemoveShape(beforeRemoveShape){this.$set({beforeRemoveShape});flush();}get beforeDeselectShape(){return this.$$.ctx[18];}set beforeDeselectShape(beforeDeselectShape){this.$set({beforeDeselectShape});flush();}get beforeSelectShape(){return this.$$.ctx[19];}set beforeSelectShape(beforeSelectShape){this.$set({beforeSelectShape});flush();}get beforeUpdateShape(){return this.$$.ctx[20];}set beforeUpdateShape(beforeUpdateShape){this.$set({beforeUpdateShape});flush();}}// @ts-ignore\nvar index$3={util:['annotate',Annotate]};/* src/core/ui/plugins/decorate/index.svelte generated by Svelte v3.29.4 */function create_fragment$E(ctx){let shapeutil;let current;shapeutil=new ShapeUtil({props:{stores:/*stores*/ctx[3],locale:/*locale*/ctx[4],isActive:/*isActive*/ctx[0],isActiveFraction:/*isActiveFraction*/ctx[1],isVisible:/*isVisible*/ctx[2],mapScreenPointToImagePoint:/*mapScreenPointToImagePoint*/ctx[24],mapImagePointToScreenPoint:/*mapImagePointToScreenPoint*/ctx[25],utilKey:\"decorate\",shapes:/*imageDecoration*/ctx[21],tools:/*decorateTools*/ctx[8]||/*markupEditorToolbar*/ctx[5],toolShapes:/*decorateToolShapes*/ctx[9]||/*markupEditorToolStyles*/ctx[6],toolActive:/*decorateActiveTool*/ctx[11],shapeControls:/*decorateShapeControls*/ctx[10]||/*markupEditorShapeStyleControls*/ctx[7],shapePresets:/*decoratePresets*/ctx[13],enableButtonFlipVertical:/*decorateEnableButtonFlipVertical*/ctx[12],parentRect:/*imageCropRect*/ctx[20],hooks:{willRenderShapeControls:/*willRenderShapeControls*/ctx[14],beforeAddShape:/*beforeAddShape*/ctx[15],beforeRemoveShape:/*beforeRemoveShape*/ctx[16],beforeDeselectShape:/*beforeDeselectShape*/ctx[17],beforeSelectShape:/*beforeSelectShape*/ctx[18],beforeUpdateShape:/*beforeUpdateShape*/ctx[19]}}});shapeutil.$on(\"measure\",/*measure_handler*/ctx[28]);return{c(){create_component(shapeutil.$$.fragment);},m(target,anchor){mount_component(shapeutil,target,anchor);current=true;},p(ctx,[dirty]){const shapeutil_changes={};if(dirty&/*stores*/8)shapeutil_changes.stores=/*stores*/ctx[3];if(dirty&/*locale*/16)shapeutil_changes.locale=/*locale*/ctx[4];if(dirty&/*isActive*/1)shapeutil_changes.isActive=/*isActive*/ctx[0];if(dirty&/*isActiveFraction*/2)shapeutil_changes.isActiveFraction=/*isActiveFraction*/ctx[1];if(dirty&/*isVisible*/4)shapeutil_changes.isVisible=/*isVisible*/ctx[2];if(dirty&/*decorateTools, markupEditorToolbar*/288)shapeutil_changes.tools=/*decorateTools*/ctx[8]||/*markupEditorToolbar*/ctx[5];if(dirty&/*decorateToolShapes, markupEditorToolStyles*/576)shapeutil_changes.toolShapes=/*decorateToolShapes*/ctx[9]||/*markupEditorToolStyles*/ctx[6];if(dirty&/*decorateActiveTool*/2048)shapeutil_changes.toolActive=/*decorateActiveTool*/ctx[11];if(dirty&/*decorateShapeControls, markupEditorShapeStyleControls*/1152)shapeutil_changes.shapeControls=/*decorateShapeControls*/ctx[10]||/*markupEditorShapeStyleControls*/ctx[7];if(dirty&/*decoratePresets*/8192)shapeutil_changes.shapePresets=/*decoratePresets*/ctx[13];if(dirty&/*decorateEnableButtonFlipVertical*/4096)shapeutil_changes.enableButtonFlipVertical=/*decorateEnableButtonFlipVertical*/ctx[12];if(dirty&/*willRenderShapeControls, beforeAddShape, beforeRemoveShape, beforeDeselectShape, beforeSelectShape, beforeUpdateShape*/1032192)shapeutil_changes.hooks={willRenderShapeControls:/*willRenderShapeControls*/ctx[14],beforeAddShape:/*beforeAddShape*/ctx[15],beforeRemoveShape:/*beforeRemoveShape*/ctx[16],beforeDeselectShape:/*beforeDeselectShape*/ctx[17],beforeSelectShape:/*beforeSelectShape*/ctx[18],beforeUpdateShape:/*beforeUpdateShape*/ctx[19]};shapeutil.$set(shapeutil_changes);},i(local){if(current)return;transition_in(shapeutil.$$.fragment,local);current=true;},o(local){transition_out(shapeutil.$$.fragment,local);current=false;},d(detaching){destroy_component(shapeutil,detaching);}};}function instance$E($$self,$$props,$$invalidate){let $imageSelectionRectPresentation;let $presentationScalar;const name=\"decorate\";let{isActive}=$$props;let{isActiveFraction}=$$props;let{isVisible}=$$props;let{stores}=$$props;let{locale={}}=$$props;let{markupEditorToolbar=undefined}=$$props;let{markupEditorToolStyles=undefined}=$$props;let{markupEditorShapeStyleControls=undefined}=$$props;let{decorateTools=undefined}=$$props;let{decorateToolShapes=undefined}=$$props;let{decorateShapeControls=undefined}=$$props;let{decorateActiveTool=\"sharpie\"}=$$props;let{decorateEnableButtonFlipVertical=false}=$$props;let{decorateEnableSelectImagePreset=false}=$$props;let{decoratePresets=[]}=$$props;let{willRenderShapeControls=undefined}=$$props;let{beforeAddShape=undefined}=$$props;let{beforeRemoveShape=undefined}=$$props;let{beforeDeselectShape=undefined}=$$props;let{beforeSelectShape=undefined}=$$props;let{beforeUpdateShape=undefined}=$$props;const{imageCropRect,imageDecoration,imageSelectionRectPresentation,presentationScalar}=stores;component_subscribe($$self,imageSelectionRectPresentation,value=>$$invalidate(29,$imageSelectionRectPresentation=value));component_subscribe($$self,presentationScalar,value=>$$invalidate(30,$presentationScalar=value));const mapScreenPointToImagePoint=screenPoint=>{const mappedPoint=vectorClone(screenPoint);mappedPoint.x-=$imageSelectionRectPresentation.x;mappedPoint.y-=$imageSelectionRectPresentation.y;mappedPoint.x/=$presentationScalar;mappedPoint.y/=$presentationScalar;return mappedPoint;};const mapImagePointToScreenPoint=imagePoint=>{const mappedPoint=vectorClone(imagePoint);mappedPoint.x*=$presentationScalar;mappedPoint.y*=$presentationScalar;mappedPoint.x+=$imageSelectionRectPresentation.x;mappedPoint.y+=$imageSelectionRectPresentation.y;return mappedPoint;};function measure_handler(event){bubble($$self,event);}$$self.$$set=$$props=>{if(\"isActive\"in $$props)$$invalidate(0,isActive=$$props.isActive);if(\"isActiveFraction\"in $$props)$$invalidate(1,isActiveFraction=$$props.isActiveFraction);if(\"isVisible\"in $$props)$$invalidate(2,isVisible=$$props.isVisible);if(\"stores\"in $$props)$$invalidate(3,stores=$$props.stores);if(\"locale\"in $$props)$$invalidate(4,locale=$$props.locale);if(\"markupEditorToolbar\"in $$props)$$invalidate(5,markupEditorToolbar=$$props.markupEditorToolbar);if(\"markupEditorToolStyles\"in $$props)$$invalidate(6,markupEditorToolStyles=$$props.markupEditorToolStyles);if(\"markupEditorShapeStyleControls\"in $$props)$$invalidate(7,markupEditorShapeStyleControls=$$props.markupEditorShapeStyleControls);if(\"decorateTools\"in $$props)$$invalidate(8,decorateTools=$$props.decorateTools);if(\"decorateToolShapes\"in $$props)$$invalidate(9,decorateToolShapes=$$props.decorateToolShapes);if(\"decorateShapeControls\"in $$props)$$invalidate(10,decorateShapeControls=$$props.decorateShapeControls);if(\"decorateActiveTool\"in $$props)$$invalidate(11,decorateActiveTool=$$props.decorateActiveTool);if(\"decorateEnableButtonFlipVertical\"in $$props)$$invalidate(12,decorateEnableButtonFlipVertical=$$props.decorateEnableButtonFlipVertical);if(\"decorateEnableSelectImagePreset\"in $$props)$$invalidate(27,decorateEnableSelectImagePreset=$$props.decorateEnableSelectImagePreset);if(\"decoratePresets\"in $$props)$$invalidate(13,decoratePresets=$$props.decoratePresets);if(\"willRenderShapeControls\"in $$props)$$invalidate(14,willRenderShapeControls=$$props.willRenderShapeControls);if(\"beforeAddShape\"in $$props)$$invalidate(15,beforeAddShape=$$props.beforeAddShape);if(\"beforeRemoveShape\"in $$props)$$invalidate(16,beforeRemoveShape=$$props.beforeRemoveShape);if(\"beforeDeselectShape\"in $$props)$$invalidate(17,beforeDeselectShape=$$props.beforeDeselectShape);if(\"beforeSelectShape\"in $$props)$$invalidate(18,beforeSelectShape=$$props.beforeSelectShape);if(\"beforeUpdateShape\"in $$props)$$invalidate(19,beforeUpdateShape=$$props.beforeUpdateShape);};return[isActive,isActiveFraction,isVisible,stores,locale,markupEditorToolbar,markupEditorToolStyles,markupEditorShapeStyleControls,decorateTools,decorateToolShapes,decorateShapeControls,decorateActiveTool,decorateEnableButtonFlipVertical,decoratePresets,willRenderShapeControls,beforeAddShape,beforeRemoveShape,beforeDeselectShape,beforeSelectShape,beforeUpdateShape,imageCropRect,imageDecoration,imageSelectionRectPresentation,presentationScalar,mapScreenPointToImagePoint,mapImagePointToScreenPoint,name,decorateEnableSelectImagePreset,measure_handler];}class Decorate extends SvelteComponent{constructor(options){super();init(this,options,instance$E,create_fragment$E,safe_not_equal,{name:26,isActive:0,isActiveFraction:1,isVisible:2,stores:3,locale:4,markupEditorToolbar:5,markupEditorToolStyles:6,markupEditorShapeStyleControls:7,decorateTools:8,decorateToolShapes:9,decorateShapeControls:10,decorateActiveTool:11,decorateEnableButtonFlipVertical:12,decorateEnableSelectImagePreset:27,decoratePresets:13,willRenderShapeControls:14,beforeAddShape:15,beforeRemoveShape:16,beforeDeselectShape:17,beforeSelectShape:18,beforeUpdateShape:19});}get name(){return this.$$.ctx[26];}get isActive(){return this.$$.ctx[0];}set isActive(isActive){this.$set({isActive});flush();}get isActiveFraction(){return this.$$.ctx[1];}set isActiveFraction(isActiveFraction){this.$set({isActiveFraction});flush();}get isVisible(){return this.$$.ctx[2];}set isVisible(isVisible){this.$set({isVisible});flush();}get stores(){return this.$$.ctx[3];}set stores(stores){this.$set({stores});flush();}get locale(){return this.$$.ctx[4];}set locale(locale){this.$set({locale});flush();}get markupEditorToolbar(){return this.$$.ctx[5];}set markupEditorToolbar(markupEditorToolbar){this.$set({markupEditorToolbar});flush();}get markupEditorToolStyles(){return this.$$.ctx[6];}set markupEditorToolStyles(markupEditorToolStyles){this.$set({markupEditorToolStyles});flush();}get markupEditorShapeStyleControls(){return this.$$.ctx[7];}set markupEditorShapeStyleControls(markupEditorShapeStyleControls){this.$set({markupEditorShapeStyleControls});flush();}get decorateTools(){return this.$$.ctx[8];}set decorateTools(decorateTools){this.$set({decorateTools});flush();}get decorateToolShapes(){return this.$$.ctx[9];}set decorateToolShapes(decorateToolShapes){this.$set({decorateToolShapes});flush();}get decorateShapeControls(){return this.$$.ctx[10];}set decorateShapeControls(decorateShapeControls){this.$set({decorateShapeControls});flush();}get decorateActiveTool(){return this.$$.ctx[11];}set decorateActiveTool(decorateActiveTool){this.$set({decorateActiveTool});flush();}get decorateEnableButtonFlipVertical(){return this.$$.ctx[12];}set decorateEnableButtonFlipVertical(decorateEnableButtonFlipVertical){this.$set({decorateEnableButtonFlipVertical});flush();}get decorateEnableSelectImagePreset(){return this.$$.ctx[27];}set decorateEnableSelectImagePreset(decorateEnableSelectImagePreset){this.$set({decorateEnableSelectImagePreset});flush();}get decoratePresets(){return this.$$.ctx[13];}set decoratePresets(decoratePresets){this.$set({decoratePresets});flush();}get willRenderShapeControls(){return this.$$.ctx[14];}set willRenderShapeControls(willRenderShapeControls){this.$set({willRenderShapeControls});flush();}get beforeAddShape(){return this.$$.ctx[15];}set beforeAddShape(beforeAddShape){this.$set({beforeAddShape});flush();}get beforeRemoveShape(){return this.$$.ctx[16];}set beforeRemoveShape(beforeRemoveShape){this.$set({beforeRemoveShape});flush();}get beforeDeselectShape(){return this.$$.ctx[17];}set beforeDeselectShape(beforeDeselectShape){this.$set({beforeDeselectShape});flush();}get beforeSelectShape(){return this.$$.ctx[18];}set beforeSelectShape(beforeSelectShape){this.$set({beforeSelectShape});flush();}get beforeUpdateShape(){return this.$$.ctx[19];}set beforeUpdateShape(beforeUpdateShape){this.$set({beforeUpdateShape});flush();}}// @ts-ignore\nvar index$4={util:['decorate',Decorate]};/* src/core/ui/plugins/sticker/index.svelte generated by Svelte v3.29.4 */function create_fragment$F(ctx){let shapeutil;let current;shapeutil=new ShapeUtil({props:{stores:/*stores*/ctx[3],locale:/*locale*/ctx[4],isActive:/*isActive*/ctx[0],isActiveFraction:/*isActiveFraction*/ctx[1],isVisible:/*isVisible*/ctx[2],mapScreenPointToImagePoint:/*mapScreenPointToImagePoint*/ctx[29],mapImagePointToScreenPoint:/*mapImagePointToScreenPoint*/ctx[30],utilKey:\"sticker\",shapePresets:/*stickers*/ctx[5],shapes:/*stickerStickToImage*/ctx[6]?/*imageAnnotation*/ctx[22]:/*imageDecoration*/ctx[23],toolActive:\"preset\",imageFlipX:/*stickerStickToImage*/ctx[6]?/*$imageFlipX*/ctx[15]:false,imageFlipY:/*stickerStickToImage*/ctx[6]?/*$imageFlipY*/ctx[16]:false,imageRotation:/*stickerStickToImage*/ctx[6]?/*$imageRotation*/ctx[17]:0,parentRect:/*stickerStickToImage*/ctx[6]?/*imageSize*/ctx[24]:/*imageCropRect*/ctx[20],enablePresetSelectImage:/*stickerEnableSelectImage*/ctx[7],enableButtonFlipVertical:/*stickersEnableButtonFlipVertical*/ctx[8],hooks:{willRenderShapeControls:/*willRenderShapeControls*/ctx[9],beforeAddShape:/*beforeAddShape*/ctx[10],beforeRemoveShape:/*beforeRemoveShape*/ctx[11],beforeDeselectShape:/*beforeDeselectShape*/ctx[12],beforeSelectShape:/*beforeSelectShape*/ctx[13],beforeUpdateShape:/*beforeUpdateShape*/ctx[14]}}});shapeutil.$on(\"measure\",/*measure_handler*/ctx[32]);return{c(){create_component(shapeutil.$$.fragment);},m(target,anchor){mount_component(shapeutil,target,anchor);current=true;},p(ctx,dirty){const shapeutil_changes={};if(dirty[0]&/*stores*/8)shapeutil_changes.stores=/*stores*/ctx[3];if(dirty[0]&/*locale*/16)shapeutil_changes.locale=/*locale*/ctx[4];if(dirty[0]&/*isActive*/1)shapeutil_changes.isActive=/*isActive*/ctx[0];if(dirty[0]&/*isActiveFraction*/2)shapeutil_changes.isActiveFraction=/*isActiveFraction*/ctx[1];if(dirty[0]&/*isVisible*/4)shapeutil_changes.isVisible=/*isVisible*/ctx[2];if(dirty[0]&/*stickers*/32)shapeutil_changes.shapePresets=/*stickers*/ctx[5];if(dirty[0]&/*stickerStickToImage*/64)shapeutil_changes.shapes=/*stickerStickToImage*/ctx[6]?/*imageAnnotation*/ctx[22]:/*imageDecoration*/ctx[23];if(dirty[0]&/*stickerStickToImage, $imageFlipX*/32832)shapeutil_changes.imageFlipX=/*stickerStickToImage*/ctx[6]?/*$imageFlipX*/ctx[15]:false;if(dirty[0]&/*stickerStickToImage, $imageFlipY*/65600)shapeutil_changes.imageFlipY=/*stickerStickToImage*/ctx[6]?/*$imageFlipY*/ctx[16]:false;if(dirty[0]&/*stickerStickToImage, $imageRotation*/131136)shapeutil_changes.imageRotation=/*stickerStickToImage*/ctx[6]?/*$imageRotation*/ctx[17]:0;if(dirty[0]&/*stickerStickToImage*/64)shapeutil_changes.parentRect=/*stickerStickToImage*/ctx[6]?/*imageSize*/ctx[24]:/*imageCropRect*/ctx[20];if(dirty[0]&/*stickerEnableSelectImage*/128)shapeutil_changes.enablePresetSelectImage=/*stickerEnableSelectImage*/ctx[7];if(dirty[0]&/*stickersEnableButtonFlipVertical*/256)shapeutil_changes.enableButtonFlipVertical=/*stickersEnableButtonFlipVertical*/ctx[8];if(dirty[0]&/*willRenderShapeControls, beforeAddShape, beforeRemoveShape, beforeDeselectShape, beforeSelectShape, beforeUpdateShape*/32256)shapeutil_changes.hooks={willRenderShapeControls:/*willRenderShapeControls*/ctx[9],beforeAddShape:/*beforeAddShape*/ctx[10],beforeRemoveShape:/*beforeRemoveShape*/ctx[11],beforeDeselectShape:/*beforeDeselectShape*/ctx[12],beforeSelectShape:/*beforeSelectShape*/ctx[13],beforeUpdateShape:/*beforeUpdateShape*/ctx[14]};shapeutil.$set(shapeutil_changes);},i(local){if(current)return;transition_in(shapeutil.$$.fragment,local);current=true;},o(local){transition_out(shapeutil.$$.fragment,local);current=false;},d(detaching){destroy_component(shapeutil,detaching);}};}function instance$F($$self,$$props,$$invalidate){let $rootRect;let $imageSize;let $imageTransforms;let $imageFlipX;let $imageFlipY;let $imageSelectionRectPresentation;let $presentationScalar;let $imageRotation;const name=\"sticker\";let{isActive}=$$props;let{isActiveFraction}=$$props;let{isVisible}=$$props;let{stores}=$$props;let{locale={}}=$$props;let{stickers=[]}=$$props;let{stickerStickToImage=false}=$$props;let{stickerEnableSelectImage=true}=$$props;let{stickersEnableButtonFlipVertical=false}=$$props;let{willRenderShapeControls=undefined}=$$props;let{beforeAddShape=undefined}=$$props;let{beforeRemoveShape=undefined}=$$props;let{beforeDeselectShape=undefined}=$$props;let{beforeSelectShape=undefined}=$$props;let{beforeUpdateShape=undefined}=$$props;// connect filter choice to stores\nconst{presentationScalar,rootRect,imageCropRect,imageSelectionRectPresentation,imageAnnotation,imageDecoration,imageSize,imageTransforms,imageRotation,imageFlipX,imageFlipY}=stores;component_subscribe($$self,presentationScalar,value=>$$invalidate(37,$presentationScalar=value));component_subscribe($$self,rootRect,value=>$$invalidate(33,$rootRect=value));component_subscribe($$self,imageSelectionRectPresentation,value=>$$invalidate(36,$imageSelectionRectPresentation=value));component_subscribe($$self,imageSize,value=>$$invalidate(34,$imageSize=value));component_subscribe($$self,imageTransforms,value=>$$invalidate(35,$imageTransforms=value));component_subscribe($$self,imageRotation,value=>$$invalidate(17,$imageRotation=value));component_subscribe($$self,imageFlipX,value=>$$invalidate(15,$imageFlipX=value));component_subscribe($$self,imageFlipY,value=>$$invalidate(16,$imageFlipY=value));//\n// Mapping coordinates\n//\nconst mapScreenPointToImagePoint=stickerStickToImage?point=>_mapScreenPointToImagePoint(point,$rootRect,$imageSize,$imageTransforms.origin,$imageTransforms.translation,$imageTransforms.rotation.z,$imageTransforms.scale,$imageFlipX,$imageFlipY):point=>{const mappedPoint=vectorClone(point);mappedPoint.x-=$imageSelectionRectPresentation.x;mappedPoint.y-=$imageSelectionRectPresentation.y;mappedPoint.x/=$presentationScalar;mappedPoint.y/=$presentationScalar;return mappedPoint;};const mapImagePointToScreenPoint=stickerStickToImage?point=>_mapImagePointToScreenPoint(point,$rootRect,$imageSize,$imageTransforms.origin,$imageTransforms.translation,$imageTransforms.rotation.z,$imageTransforms.scale,$imageFlipX,$imageFlipY):point=>{const mappedPoint=vectorClone(point);mappedPoint.x*=$presentationScalar;mappedPoint.y*=$presentationScalar;mappedPoint.x+=$imageSelectionRectPresentation.x;mappedPoint.y+=$imageSelectionRectPresentation.y;return mappedPoint;};function measure_handler(event){bubble($$self,event);}$$self.$$set=$$props=>{if(\"isActive\"in $$props)$$invalidate(0,isActive=$$props.isActive);if(\"isActiveFraction\"in $$props)$$invalidate(1,isActiveFraction=$$props.isActiveFraction);if(\"isVisible\"in $$props)$$invalidate(2,isVisible=$$props.isVisible);if(\"stores\"in $$props)$$invalidate(3,stores=$$props.stores);if(\"locale\"in $$props)$$invalidate(4,locale=$$props.locale);if(\"stickers\"in $$props)$$invalidate(5,stickers=$$props.stickers);if(\"stickerStickToImage\"in $$props)$$invalidate(6,stickerStickToImage=$$props.stickerStickToImage);if(\"stickerEnableSelectImage\"in $$props)$$invalidate(7,stickerEnableSelectImage=$$props.stickerEnableSelectImage);if(\"stickersEnableButtonFlipVertical\"in $$props)$$invalidate(8,stickersEnableButtonFlipVertical=$$props.stickersEnableButtonFlipVertical);if(\"willRenderShapeControls\"in $$props)$$invalidate(9,willRenderShapeControls=$$props.willRenderShapeControls);if(\"beforeAddShape\"in $$props)$$invalidate(10,beforeAddShape=$$props.beforeAddShape);if(\"beforeRemoveShape\"in $$props)$$invalidate(11,beforeRemoveShape=$$props.beforeRemoveShape);if(\"beforeDeselectShape\"in $$props)$$invalidate(12,beforeDeselectShape=$$props.beforeDeselectShape);if(\"beforeSelectShape\"in $$props)$$invalidate(13,beforeSelectShape=$$props.beforeSelectShape);if(\"beforeUpdateShape\"in $$props)$$invalidate(14,beforeUpdateShape=$$props.beforeUpdateShape);};return[isActive,isActiveFraction,isVisible,stores,locale,stickers,stickerStickToImage,stickerEnableSelectImage,stickersEnableButtonFlipVertical,willRenderShapeControls,beforeAddShape,beforeRemoveShape,beforeDeselectShape,beforeSelectShape,beforeUpdateShape,$imageFlipX,$imageFlipY,$imageRotation,presentationScalar,rootRect,imageCropRect,imageSelectionRectPresentation,imageAnnotation,imageDecoration,imageSize,imageTransforms,imageRotation,imageFlipX,imageFlipY,mapScreenPointToImagePoint,mapImagePointToScreenPoint,name,measure_handler];}class Sticker extends SvelteComponent{constructor(options){super();init(this,options,instance$F,create_fragment$F,safe_not_equal,{name:31,isActive:0,isActiveFraction:1,isVisible:2,stores:3,locale:4,stickers:5,stickerStickToImage:6,stickerEnableSelectImage:7,stickersEnableButtonFlipVertical:8,willRenderShapeControls:9,beforeAddShape:10,beforeRemoveShape:11,beforeDeselectShape:12,beforeSelectShape:13,beforeUpdateShape:14},[-1,-1]);}get name(){return this.$$.ctx[31];}get isActive(){return this.$$.ctx[0];}set isActive(isActive){this.$set({isActive});flush();}get isActiveFraction(){return this.$$.ctx[1];}set isActiveFraction(isActiveFraction){this.$set({isActiveFraction});flush();}get isVisible(){return this.$$.ctx[2];}set isVisible(isVisible){this.$set({isVisible});flush();}get stores(){return this.$$.ctx[3];}set stores(stores){this.$set({stores});flush();}get locale(){return this.$$.ctx[4];}set locale(locale){this.$set({locale});flush();}get stickers(){return this.$$.ctx[5];}set stickers(stickers){this.$set({stickers});flush();}get stickerStickToImage(){return this.$$.ctx[6];}set stickerStickToImage(stickerStickToImage){this.$set({stickerStickToImage});flush();}get stickerEnableSelectImage(){return this.$$.ctx[7];}set stickerEnableSelectImage(stickerEnableSelectImage){this.$set({stickerEnableSelectImage});flush();}get stickersEnableButtonFlipVertical(){return this.$$.ctx[8];}set stickersEnableButtonFlipVertical(stickersEnableButtonFlipVertical){this.$set({stickersEnableButtonFlipVertical});flush();}get willRenderShapeControls(){return this.$$.ctx[9];}set willRenderShapeControls(willRenderShapeControls){this.$set({willRenderShapeControls});flush();}get beforeAddShape(){return this.$$.ctx[10];}set beforeAddShape(beforeAddShape){this.$set({beforeAddShape});flush();}get beforeRemoveShape(){return this.$$.ctx[11];}set beforeRemoveShape(beforeRemoveShape){this.$set({beforeRemoveShape});flush();}get beforeDeselectShape(){return this.$$.ctx[12];}set beforeDeselectShape(beforeDeselectShape){this.$set({beforeDeselectShape});flush();}get beforeSelectShape(){return this.$$.ctx[13];}set beforeSelectShape(beforeSelectShape){this.$set({beforeSelectShape});flush();}get beforeUpdateShape(){return this.$$.ctx[14];}set beforeUpdateShape(beforeUpdateShape){this.$set({beforeUpdateShape});flush();}}// @ts-ignore\nvar index$5={util:['sticker',Sticker]};/* src/core/ui/plugins/resize/index.svelte generated by Svelte v3.29.4 */function create_default_slot_2$6(ctx){let g;let raw_value=(isString(/*locale*/ctx[1].resizeIconButtonMaintainAspectRatio)?/*locale*/ctx[1].resizeIconButtonMaintainAspectRatio:/*locale*/ctx[1].resizeIconButtonMaintainAspectRatio(/*maintainAspectRatio*/ctx[3],/*$iconActiveFraction*/ctx[11]))+\"\";return{c(){g=svg_element(\"g\");},m(target,anchor){insert(target,g,anchor);g.innerHTML=raw_value;},p(ctx,dirty){if(dirty[0]&/*locale, maintainAspectRatio, $iconActiveFraction*/2058&&raw_value!==(raw_value=(isString(/*locale*/ctx[1].resizeIconButtonMaintainAspectRatio)?/*locale*/ctx[1].resizeIconButtonMaintainAspectRatio:/*locale*/ctx[1].resizeIconButtonMaintainAspectRatio(/*maintainAspectRatio*/ctx[3],/*$iconActiveFraction*/ctx[11]))+\"\"))g.innerHTML=raw_value;},d(detaching){if(detaching)detach(g);}};}// (389:12) <Button type=\"submit\" class=\"implicit\">\nfunction create_default_slot_1$9(ctx){let t;return{c(){t=text(\"Save\");},m(target,anchor){insert(target,t,anchor);},d(detaching){if(detaching)detach(t);}};}// (362:4) <form slot=\"footer\" style={footerStyle} on:submit|preventDefault={handleSubmit}>\nfunction create_footer_slot$4(ctx){let form;let div4;let fieldset;let legend;let t0_value=/*locale*/ctx[1].resizeLabelFormCaption+\"\";let t0;let t1;let div3;let div0;let label0;let t2_value=/*locale*/ctx[1].resizeLabelInputWidth+\"\";let t2;let label0_for_value;let label0_title_value;let label0_aria_label_value;let t3;let input0;let input0_id_value;let t4;let div1;let input1;let input1_id_value;let t5;let label1;let icon;let label1_for_value;let label1_title_value;let t6;let div2;let label2;let t7_value=/*locale*/ctx[1].resizeLabelInputHeight+\"\";let t7;let label2_for_value;let label2_title_value;let label2_aria_label_value;let t8;let input2;let input2_id_value;let t9;let button;let current;let mounted;let dispose;icon=new Icon({props:{$$slots:{default:[create_default_slot_2$6]},$$scope:{ctx}}});button=new Button({props:{type:\"submit\",class:\"implicit\",$$slots:{default:[create_default_slot_1$9]},$$scope:{ctx}}});return{c(){form=element(\"form\");div4=element(\"div\");fieldset=element(\"fieldset\");legend=element(\"legend\");t0=text(t0_value);t1=space();div3=element(\"div\");div0=element(\"div\");label0=element(\"label\");t2=text(t2_value);t3=space();input0=element(\"input\");t4=space();div1=element(\"div\");input1=element(\"input\");t5=space();label1=element(\"label\");create_component(icon.$$.fragment);t6=space();div2=element(\"div\");label2=element(\"label\");t7=text(t7_value);t8=space();input2=element(\"input\");t9=space();create_component(button.$$.fragment);attr(legend,\"class\",\"implicit\");attr(label0,\"for\",label0_for_value=\"doka-width-\"+/*formId*/ctx[18]);attr(label0,\"title\",label0_title_value=/*locale*/ctx[1].resizeTitleInputWidth);attr(label0,\"aria-label\",label0_aria_label_value=/*locale*/ctx[1].resizeTitleInputWidth);attr(input0,\"id\",input0_id_value=\"doka-width-\"+/*formId*/ctx[18]);attr(input0,\"type\",\"text\");attr(input0,\"inputmode\",\"numeric\");attr(input0,\"pattern\",\"[0-9]*\");attr(input0,\"data-state\",/*widthState*/ctx[8]);attr(input0,\"autocomplete\",\"off\");attr(input0,\"placeholder\",/*widthPlaceholder*/ctx[6]);attr(div0,\"class\",\"DokaInputDimension\");attr(input1,\"class\",\"implicit\");attr(input1,\"id\",input1_id_value=\"doka-maintainAspectRatio-\"+/*formId*/ctx[18]);attr(input1,\"type\",\"checkbox\");attr(label1,\"for\",label1_for_value=\"doka-maintainAspectRatio-\"+/*formId*/ctx[18]);attr(label1,\"title\",label1_title_value=/*locale*/ctx[1].resizeTitleButtonMaintainAspectRatio);attr(label2,\"for\",label2_for_value=\"doka-height-\"+/*formId*/ctx[18]);attr(label2,\"title\",label2_title_value=/*locale*/ctx[1].resizeTitleInputHeight);attr(label2,\"aria-label\",label2_aria_label_value=/*locale*/ctx[1].resizeTitleInputHeight);attr(input2,\"id\",input2_id_value=\"doka-height-\"+/*formId*/ctx[18]);attr(input2,\"type\",\"text\");attr(input2,\"inputmode\",\"numeric\");attr(input2,\"pattern\",\"[0-9]*\");attr(input2,\"autocomplete\",\"off\");attr(input2,\"data-state\",/*heightState*/ctx[9]);attr(input2,\"placeholder\",/*heightPlaceholder*/ctx[7]);attr(div2,\"class\",\"DokaInputDimension\");attr(div3,\"class\",\"DokaFieldsetInner\");attr(div4,\"class\",\"DokaFormInner\");attr(form,\"slot\",\"footer\");attr(form,\"style\",/*footerStyle*/ctx[10]);},m(target,anchor){insert(target,form,anchor);append(form,div4);append(div4,fieldset);append(fieldset,legend);append(legend,t0);append(fieldset,t1);append(fieldset,div3);append(div3,div0);append(div0,label0);append(label0,t2);append(div0,t3);append(div0,input0);set_input_value(input0,/*width*/ctx[4]);append(div3,t4);append(div3,div1);append(div1,input1);input1.checked=/*maintainAspectRatio*/ctx[3];append(div1,t5);append(div1,label1);mount_component(icon,label1,null);append(div3,t6);append(div3,div2);append(div2,label2);append(label2,t7);append(div2,t8);append(div2,input2);set_input_value(input2,/*height*/ctx[5]);/*div3_binding*/ctx[30](div3);append(div4,t9);mount_component(button,div4,null);current=true;if(!mounted){dispose=[listen(input0,\"input\",/*input0_input_handler*/ctx[27]),listen(input1,\"change\",/*input1_change_handler*/ctx[28]),listen(input2,\"input\",/*input2_input_handler*/ctx[29]),listen(div3,\"focusin\",/*handleFocusIn*/ctx[19]),listen(div3,\"focusout\",/*handleFocusOut*/ctx[20]),listen(form,\"submit\",prevent_default(/*handleSubmit*/ctx[21]))];mounted=true;}},p(ctx,dirty){if((!current||dirty[0]&/*locale*/2)&&t0_value!==(t0_value=/*locale*/ctx[1].resizeLabelFormCaption+\"\"))set_data(t0,t0_value);if((!current||dirty[0]&/*locale*/2)&&t2_value!==(t2_value=/*locale*/ctx[1].resizeLabelInputWidth+\"\"))set_data(t2,t2_value);if(!current||dirty[0]&/*locale*/2&&label0_title_value!==(label0_title_value=/*locale*/ctx[1].resizeTitleInputWidth)){attr(label0,\"title\",label0_title_value);}if(!current||dirty[0]&/*locale*/2&&label0_aria_label_value!==(label0_aria_label_value=/*locale*/ctx[1].resizeTitleInputWidth)){attr(label0,\"aria-label\",label0_aria_label_value);}if(!current||dirty[0]&/*widthState*/256){attr(input0,\"data-state\",/*widthState*/ctx[8]);}if(!current||dirty[0]&/*widthPlaceholder*/64){attr(input0,\"placeholder\",/*widthPlaceholder*/ctx[6]);}if(dirty[0]&/*width*/16&&input0.value!==/*width*/ctx[4]){set_input_value(input0,/*width*/ctx[4]);}if(dirty[0]&/*maintainAspectRatio*/8){input1.checked=/*maintainAspectRatio*/ctx[3];}const icon_changes={};if(dirty[0]&/*locale, maintainAspectRatio, $iconActiveFraction*/2058|dirty[1]&/*$$scope*/65536){icon_changes.$$scope={dirty,ctx};}icon.$set(icon_changes);if(!current||dirty[0]&/*locale*/2&&label1_title_value!==(label1_title_value=/*locale*/ctx[1].resizeTitleButtonMaintainAspectRatio)){attr(label1,\"title\",label1_title_value);}if((!current||dirty[0]&/*locale*/2)&&t7_value!==(t7_value=/*locale*/ctx[1].resizeLabelInputHeight+\"\"))set_data(t7,t7_value);if(!current||dirty[0]&/*locale*/2&&label2_title_value!==(label2_title_value=/*locale*/ctx[1].resizeTitleInputHeight)){attr(label2,\"title\",label2_title_value);}if(!current||dirty[0]&/*locale*/2&&label2_aria_label_value!==(label2_aria_label_value=/*locale*/ctx[1].resizeTitleInputHeight)){attr(label2,\"aria-label\",label2_aria_label_value);}if(!current||dirty[0]&/*heightState*/512){attr(input2,\"data-state\",/*heightState*/ctx[9]);}if(!current||dirty[0]&/*heightPlaceholder*/128){attr(input2,\"placeholder\",/*heightPlaceholder*/ctx[7]);}if(dirty[0]&/*height*/32&&input2.value!==/*height*/ctx[5]){set_input_value(input2,/*height*/ctx[5]);}const button_changes={};if(dirty[1]&/*$$scope*/65536){button_changes.$$scope={dirty,ctx};}button.$set(button_changes);if(!current||dirty[0]&/*footerStyle*/1024){attr(form,\"style\",/*footerStyle*/ctx[10]);}},i(local){if(current)return;transition_in(icon.$$.fragment,local);transition_in(button.$$.fragment,local);current=true;},o(local){transition_out(icon.$$.fragment,local);transition_out(button.$$.fragment,local);current=false;},d(detaching){if(detaching)detach(form);destroy_component(icon);/*div3_binding*/ctx[30](null);destroy_component(button);mounted=false;run_all(dispose);}};}function create_fragment$G(ctx){let util;let current;util=new Util({props:{$$slots:{footer:[create_footer_slot$4]},$$scope:{ctx}}});util.$on(\"measure\",/*measure_handler*/ctx[31]);return{c(){create_component(util.$$.fragment);},m(target,anchor){mount_component(util,target,anchor);current=true;},p(ctx,dirty){const util_changes={};if(dirty[0]&/*footerStyle, fieldsGroup, heightState, heightPlaceholder, height, locale, maintainAspectRatio, $iconActiveFraction, widthState, widthPlaceholder, width*/4094|dirty[1]&/*$$scope*/65536){util_changes.$$scope={dirty,ctx};}util.$set(util_changes);},i(local){if(current)return;transition_in(util.$$.fragment,local);current=true;},o(local){transition_out(util.$$.fragment,local);current=false;},d(detaching){destroy_component(util,detaching);}};}function instance$G($$self,$$props,$$invalidate){let $imageCropRectAspectRatio;let $imageCropRect;let $imageOutputSize;let $imageCropAspectRatio;let $imageSize;let $isActive,$$unsubscribe_isActive=noop$1,$$subscribe_isActive=()=>($$unsubscribe_isActive(),$$unsubscribe_isActive=subscribe(isActive,$$value=>$$invalidate(41,$isActive=$$value)),isActive);let $footerOffset;let $iconActiveFraction;$$self.$$.on_destroy.push(()=>$$unsubscribe_isActive());const formatValue=(value,min=0,max=9999)=>{if(isString(value)){value=value.replace(/\\D/g,\"\");if(!value.length)return;}const v=Math.round(value);if(Number.isNaN(v))return;return clamp(v,min,max);};const name=\"resize\";let{isActive}=$$props;$$subscribe_isActive();let{stores}=$$props;let{locale={}}=$$props;let{resizeMinSize=sizeCreate(1,1)}=$$props;let{resizeMaxSize=sizeCreate(9999,9999)}=$$props;// offset\nconst iconActiveFraction=spring(0,{stiffness:0.15,damping:0.3});component_subscribe($$self,iconActiveFraction,value=>$$invalidate(11,$iconActiveFraction=value));const{imageSize,imageCropRect,imageCropRectAspectRatio,imageCropAspectRatio,imageOutputSize,history}=stores;component_subscribe($$self,imageSize,value=>$$invalidate(40,$imageSize=value));component_subscribe($$self,imageCropRect,value=>$$invalidate(37,$imageCropRect=value));component_subscribe($$self,imageCropRectAspectRatio,value=>$$invalidate(36,$imageCropRectAspectRatio=value));component_subscribe($$self,imageCropAspectRatio,value=>$$invalidate(39,$imageCropAspectRatio=value));component_subscribe($$self,imageOutputSize,value=>$$invalidate(38,$imageOutputSize=value));const formId=getUniqueId();let fieldsGroup;let maintainAspectRatio=false;let width;let height;let widthFormatted;let heightFormatted;let widthPlaceholder;let heightPlaceholder;let activeField;let lastActiveField;// populate active field\nconst handleFocusIn=e=>{const id=e.target.id;if(/width/.test(id)){$$invalidate(34,activeField=\"width\");}else if(/height/.test(id)){$$invalidate(34,activeField=\"height\");}else if(/aspectRatio/i.test(id)){$$invalidate(34,activeField=\"lock\");}else{$$invalidate(34,activeField=undefined);}};const handleFocusOut=e=>{if(!fieldsGroup.contains(e.relatedTarget))handleSubmit();$$invalidate(34,activeField=undefined);};// sync fields if one has a value and aspect ratio should be maintained\nconst syncFields=()=>{if(activeField===\"width\"){// sync height field\n$$invalidate(5,height=Math.round(width/$imageCropRectAspectRatio));}else if(activeField===\"height\"){// sync width field\n$$invalidate(4,width=Math.round(height*$imageCropRectAspectRatio));}else{if(lastActiveField===\"width\"){$$invalidate(5,height=Math.round(width/$imageCropRectAspectRatio));}else if(lastActiveField===\"height\"){$$invalidate(4,width=Math.round(height*$imageCropRectAspectRatio));}consolidateSize();}};const consolidateSize=forcedAspectRatio=>{// first need to limit values\nlet inputWidth=formatValue(width);let inputHeight=formatValue(height);let currentWidth=inputWidth;let currentHeight=inputHeight;let bothAxisDefined=currentWidth&&currentHeight;let aspectRatio=forcedAspectRatio||$imageCropRectAspectRatio;// done, no consolidation needed\nif(!currentWidth&&!currentHeight)return;// need to fill in missing values\nif(currentWidth&&!currentHeight){currentHeight=Math.round(currentWidth/aspectRatio);}else if(currentHeight&&!currentWidth){currentWidth=Math.round(currentHeight*aspectRatio);}aspectRatio=forcedAspectRatio||bothAxisDefined?getAspectRatio(currentWidth,currentHeight):$imageCropRectAspectRatio;// now we have both width and height let's re-fit the min max size\nlet currentSize=sizeCreate(currentWidth,currentHeight);if(!sizeContains(resizeMaxSize,currentSize)){// too big\ncurrentSize=rectContainRect(resizeMaxSize,aspectRatio);}if(!sizeContains(currentSize,resizeMinSize)){// too small\ncurrentSize=rectCoverRect(resizeMinSize,aspectRatio);}$$invalidate(4,width=inputWidth!=null?Math.round(currentSize.width):undefined);$$invalidate(5,height=inputHeight!=null?Math.round(currentSize.height):undefined);};const handleSubmit=()=>{// calculate correct values\nconsolidateSize();// get curent values so we can check if they were changed (if not, no need to write history or update)\nconst{width:currentWidth,height:currentHeight}=$imageOutputSize||{};// no need to update\nif(currentWidth===width&&currentHeight===height)return;// update state\nif(!width&&!height){// reset image crop\nset_store_value(imageCropAspectRatio,$imageCropAspectRatio=$imageSize.width/$imageSize.height,$imageCropAspectRatio);set_store_value(imageCropAspectRatio,$imageCropAspectRatio=undefined,$imageCropAspectRatio);// reset output size\nset_store_value(imageOutputSize,$imageOutputSize=undefined,$imageOutputSize);}else{if(width&&height)set_store_value(imageCropAspectRatio,$imageCropAspectRatio=width/height,$imageCropAspectRatio);set_store_value(imageOutputSize,$imageOutputSize=sizeCreate(width,height),$imageOutputSize);}history.write();};// handle external updates to outputSize\nimageOutputSize.subscribe(size=>{if(!size){$$invalidate(4,width=undefined);$$invalidate(5,height=undefined);return;}$$invalidate(4,width=size.width);$$invalidate(5,height=size.height);// make sure the size conforms to min max\nconsolidateSize();});// if the crop aspect ratio is changed we need to align width/height\nimageCropAspectRatio.subscribe(cropAspectRatio=>{// exit if no dimensions supplied\nif(!width&&!height)return;// no crop aspect ratio has been selected, so all is fine\nif(!cropAspectRatio)return;// fix size to match new aspect ratio of the crop\nif(width&&height&&getAspectRatio(width,height)!==cropAspectRatio){$$invalidate(5,height=width/cropAspectRatio);consolidateSize(cropAspectRatio);}else{consolidateSize();}});//\n// Footer\n//\nconst footerOffset=spring(0);component_subscribe($$self,footerOffset,value=>$$invalidate(42,$footerOffset=value));function input0_input_handler(){width=this.value;$$invalidate(4,width);}function input1_change_handler(){maintainAspectRatio=this.checked;$$invalidate(3,maintainAspectRatio);}function input2_input_handler(){height=this.value;$$invalidate(5,height);}function div3_binding($$value){binding_callbacks[$$value?\"unshift\":\"push\"](()=>{fieldsGroup=$$value;$$invalidate(2,fieldsGroup);});}function measure_handler(event){bubble($$self,event);}$$self.$$set=$$props=>{if(\"isActive\"in $$props)$$subscribe_isActive($$invalidate(0,isActive=$$props.isActive));if(\"stores\"in $$props)$$invalidate(24,stores=$$props.stores);if(\"locale\"in $$props)$$invalidate(1,locale=$$props.locale);if(\"resizeMinSize\"in $$props)$$invalidate(25,resizeMinSize=$$props.resizeMinSize);if(\"resizeMaxSize\"in $$props)$$invalidate(26,resizeMaxSize=$$props.resizeMaxSize);};let widthState;let heightState;let footerStyle;$$self.$$.update=()=>{if($$self.$$.dirty[0]&/*maintainAspectRatio*/8){iconActiveFraction.set(maintainAspectRatio?1:0);}if($$self.$$.dirty[1]&/*activeField*/8){if(activeField)lastActiveField=activeField;}if($$self.$$.dirty[0]&/*width*/16){$$invalidate(32,widthFormatted=formatValue(width));}if($$self.$$.dirty[0]&/*height*/32){$$invalidate(33,heightFormatted=formatValue(height));}if($$self.$$.dirty[0]&/*resizeMinSize, resizeMaxSize*/100663296|$$self.$$.dirty[1]&/*widthFormatted, activeField*/10){$$invalidate(8,widthState=widthFormatted!=null&&activeField!==\"width\"?widthFormatted>=resizeMinSize.width&&widthFormatted<=resizeMaxSize.width?\"valid\":\"invalid\":\"undetermined\");}if($$self.$$.dirty[0]&/*resizeMinSize, resizeMaxSize*/100663296|$$self.$$.dirty[1]&/*heightFormatted, activeField*/12){$$invalidate(9,heightState=heightFormatted!=null&&activeField!==\"height\"?heightFormatted>=resizeMinSize.height&&heightFormatted<=resizeMaxSize.height?\"valid\":\"invalid\":\"undetermined\");}if($$self.$$.dirty[1]&/*heightFormatted, $imageCropRectAspectRatio, $imageCropRect*/100){$$invalidate(6,widthPlaceholder=Math.round(heightFormatted!=null?heightFormatted*$imageCropRectAspectRatio:$imageCropRect.width));}if($$self.$$.dirty[1]&/*widthFormatted, $imageCropRectAspectRatio, $imageCropRect*/98){$$invalidate(7,heightPlaceholder=Math.round(widthFormatted!=null?widthFormatted/$imageCropRectAspectRatio:$imageCropRect.height));}if($$self.$$.dirty[0]&/*maintainAspectRatio, width, height*/56){if(maintainAspectRatio&&width&&height)syncFields();}if($$self.$$.dirty[1]&/*$isActive*/1024){footerOffset.set($isActive?0:20);}if($$self.$$.dirty[1]&/*$footerOffset*/2048){$$invalidate(10,footerStyle=$footerOffset?`transform: translateY(${$footerOffset}px)`:undefined);}};return[isActive,locale,fieldsGroup,maintainAspectRatio,width,height,widthPlaceholder,heightPlaceholder,widthState,heightState,footerStyle,$iconActiveFraction,iconActiveFraction,imageSize,imageCropRect,imageCropRectAspectRatio,imageCropAspectRatio,imageOutputSize,formId,handleFocusIn,handleFocusOut,handleSubmit,footerOffset,name,stores,resizeMinSize,resizeMaxSize,input0_input_handler,input1_change_handler,input2_input_handler,div3_binding,measure_handler];}class Resize extends SvelteComponent{constructor(options){super();init(this,options,instance$G,create_fragment$G,safe_not_equal,{name:23,isActive:0,stores:24,locale:1,resizeMinSize:25,resizeMaxSize:26},[-1,-1]);}get name(){return this.$$.ctx[23];}get isActive(){return this.$$.ctx[0];}set isActive(isActive){this.$set({isActive});flush();}get stores(){return this.$$.ctx[24];}set stores(stores){this.$set({stores});flush();}get locale(){return this.$$.ctx[1];}set locale(locale){this.$set({locale});flush();}get resizeMinSize(){return this.$$.ctx[25];}set resizeMinSize(resizeMinSize){this.$set({resizeMinSize});flush();}get resizeMaxSize(){return this.$$.ctx[26];}set resizeMaxSize(resizeMaxSize){this.$set({resizeMaxSize});flush();}}// @ts-ignore\nvar index$6={util:['resize',Resize]};const cropSelectPresetOptionsDefault=[['Crop',[[undefined,'Custom'],[1,'Square'],[4/3,'Landscape'],[3/4,'Portrait']]],['Size',[[[180,180],'Profile Picture'],[[1200,600],'Header Image'],[[800,400],'Timeline Photo']]]];var defaults$2={cropSelectPresetOptions:cropSelectPresetOptionsDefault};const IconCross='<g fill=\"none\" fill-rule=\"evenodd\" stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke=\"currentColor\" stroke-width=\".125em\"><path d=\"M18 6L6 18M6 6l12 12\"></path></path></g>';var en_gb={// generic\nlabelReset:'Reset',labelDefault:'Default',labelAuto:'Auto',labelNone:'None',labelEdit:'Edit',labelClose:'Close',labelSupportError:features=>`${features.join(', ')} not supported on this browser`,// sizes\nlabelSizeExtraSmall:'Extra small',labelSizeSmall:'Small',labelSizeMediumSmall:'Medium small',labelSizeMedium:'Medium',labelSizeMediumLarge:'Medium large',labelSizeLarge:'Large',labelSizeExtraLarge:'Extra large',// unused?\nlabelButtonRevert:'Revert',labelButtonCancel:'Cancel',labelButtonUndo:'Undo',labelButtonRedo:'Redo',labelButtonExport:'Done',iconSupportError:`<g fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\"><path d=\"M10.29 3.86L1.82 18a2 2 0 0 0 1.71 3h16.94a2 2 0 0 0 1.71-3L13.71 3.86a2 2 0 0 0-3.42 0z\"/><g><line x1=\"12\" y1=\"9\" x2=\"12\" y2=\"13\"/><line x1=\"12\" y1=\"17\" x2=\"12.01\" y2=\"17\"/></g>`,iconButtonClose:IconCross,iconButtonRevert:`<g fill=\"none\" fill-rule=\"evenodd\" stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke=\"currentColor\" stroke-width=\".125em\"><path d=\"M7.388 18.538a8 8 0 10-2.992-9.03\"/><path fill=\"currentColor\" d=\"M2.794 11.696L2.37 6.714l5.088 3.18z\"/><path d=\"M12 8v4M12 12l4 2\"/></g>`,iconButtonUndo:`<g fill=\"none\" fill-rule=\"evenodd\" stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke=\"currentColor\" stroke-width=\".125em\"><path d=\"M10 8h4c2.485 0 5 2 5 5s-2.515 5-5 5h-4\"/><path fill=\"currentColor\" d=\"M5 8l4-3v6z\"/></g>`,iconButtonRedo:`<g fill=\"none\" fill-rule=\"evenodd\" stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke=\"currentColor\" stroke-width=\".125em\"><path d=\"M14 8h-4c-2.485 0-5 2-5 5s2.515 5 5 5h4\"/><path fill=\"currentColor\" d=\"M19 8l-4-3v6z\"/></g>`,iconButtonExport:`<polyline points=\"20 6 9 17 4 12\" fill=\"none\" stroke=\"currentColor\" stroke-width=\".125em\"></polyline>`,// status\nstatusLabelButtonClose:'Close',statusIconButtonClose:IconCross,statusLabelLoadImage:state=>{if(!state||!state.task)return'Waiting for image';if(state.error)return state.error.code==='IMAGE_TOO_SMALL'?'Minimum image size is {minWidth} × {minHeight}':'Error loading image';if(state.task==='blob-to-bitmap')return'Creating preview…';return'Loading image…';},// processing status message\nstatusLabelProcessImage:state=>{if(!state||!state.task)return undefined;if(state.task==='store'){if(state.error)return'Error uploading image';return'Uploading image…';}if(state.error)return'Error processing image';return'Processing image…';}};const MarkupEditor={shapeLabelButtonSelectSticker:'Select image',shapeIconButtonSelectSticker:`<g><circle fill=\"currentColor\" cx=\"5\" cy=\"6\" r=\"1.333\"/><g fill=\"none\" stroke=\"currentColor\" stroke-width=\"0.0625em\" stroke-linecap=\"round\" stroke-linejoin=\"round\"><rect x=\"1\" y=\"1\" width=\"14\" height=\"14\" rx=\"2\"/><path d=\"M15 13l-5-6-5 8\"/></g></g>`,shapeIconButtonFlipHorizontal:`<svg width=\"24\" height=\"24\" xmlns=\"http://www.w3.org/2000/svg\"><g stroke=\"#FFF\" stroke-width=\"2\" fill=\"none\" fill-rule=\"evenodd\"><path d=\"M6 6.5h5v11H6z\"/><path fill=\"#FFF\" d=\"M15 6.5h3v11h-3z\"/><path d=\"M11 4v16\" fill=\"#fff\"/></g></svg>`,shapeIconButtonFlipVertical:`<g stroke=\"currentColor\" stroke-width=\".125em\"><rect x=\"7\" y=\"8\" width=\"11\" height=\"5\" fill=\"none\"/><rect x=\"7\" y=\"17\" width=\"11\" height=\"2\" fill=\"currentColor\"/><line x1=\"5\" y1=\"13\" x2=\"20\" y2=\"13\"/></g>`,shapeIconButtonRemove:`<g fill=\"none\" fill-rule=\"evenodd\"><path stroke=\"#FFF\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\" d=\"M7.5 7h9z\"/><path d=\"M7.916 9h8.168a1 1 0 01.99 1.14l-.972 6.862a2 2 0 01-1.473 1.653c-.877.23-1.753.345-2.629.345-.876 0-1.752-.115-2.628-.345a2 2 0 01-1.473-1.653l-.973-6.862A1 1 0 017.916 9z\" fill=\"#FFF\"/><rect fill=\"#FFF\" x=\"10\" y=\"5\" width=\"4\" height=\"3\" rx=\"1\"/></g>`,shapeIconButtonDuplicate:`<g fill=\"none\" fill-rule=\"evenodd\"><path d=\"M15 13.994V16a2 2 0 01-2 2H8a2 2 0 01-2-2v-5a2 2 0 012-2h2.142\" stroke=\"currentColor\" stroke-width=\".125em\"/><path d=\"M15 9V8a1 1 0 00-2 0v1h-1a1 1 0 000 2h1v1a1 1 0 002 0v-1h1a1 1 0 000-2h-1zm-4-4h6a2 2 0 012 2v6a2 2 0 01-2 2h-6a2 2 0 01-2-2V7a2 2 0 012-2z\" fill=\"currentColor\"/></g>`,shapeIconButtonMoveToFront:`<g fill=\"none\" fill-rule=\"evenodd\"><rect fill=\"currentColor\" x=\"11\" y=\"13\" width=\"8\" height=\"2\" rx=\"1\"/><rect fill=\"currentColor\" x=\"9\" y=\"17\" width=\"10\" height=\"2\" rx=\"1\"/><path d=\"M11.364 8H10a5 5 0 000 10M12 6.5L14.5 8 12 9.5z\" stroke=\"currentColor\" stroke-width=\".125em\" stroke-linecap=\"round\"/></g>`,shapeTitleButtonFlipHorizontal:'Flip Horizontal',shapeTitleButtonFlipVertical:'Flip Vertical',shapeTitleButtonRemove:'Remove',shapeTitleButtonDuplicate:'Duplicate',shapeTitleButtonMoveToFront:'Move to front',shapeLabelInputText:'Edit text',shapeIconInputCancel:`<g fill=\"none\" fill-rule=\"evenodd\" stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke=\"currentColor\" stroke-width=\".125em\"><path d=\"M18 6L6 18M6 6l12 12\"/></g>`,shapeIconInputConfirm:`<g fill=\"none\" fill-rule=\"evenodd\" stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke=\"currentColor\" stroke-width=\".125em\"><polyline points=\"20 6 9 17 4 12\"/></g>`,shapeLabelInputCancel:'Cancel',shapeLabelInputConfirm:'Confirm',shapeLabelStrokeNone:'No outline',shapeLabelFontStyleNormal:'Normal',shapeLabelFontStyleBold:'Bold',shapeLabelFontStyleItalic:'Italic',shapeLabelFontStyleItalicBold:'Italic Bold',shapeTitleBackgroundColor:'Fill color',shapeTitleFontFamily:'Font',shapeTitleFontSize:'Font size',shapeTitleFontStyle:'Font style',shapeTitleLineHeight:'Leading',shapeTitleLineStart:'Start',shapeTitleLineEnd:'End',shapeTitleStrokeWidth:'Line width',shapeTitleStrokeColor:'Line color',shapeTitleLineDecorationBar:'Bar',shapeTitleLineDecorationCircle:'Circle',shapeTitleLineDecorationSquare:'Square',shapeTitleLineDecorationArrow:'Arrow',shapeTitleLineDecorationCircleSolid:'Circle solid',shapeTitleLineDecorationSquareSolid:'Square solid',shapeTitleLineDecorationArrowSolid:'Arrow solid',shapeIconLineDecorationBar:`<g stroke=\"currentColor\" stroke-linecap=\"round\" stroke-width=\".125em\"><path d=\"M5,12 H16\"/><path d=\"M16,8 V16\"/></g>`,shapeIconLineDecorationCircle:`<g stroke=\"currentColor\" stroke-linecap=\"round\"><path stroke-width=\".125em\" d=\"M5,12 H12\"/><circle fill=\"none\" stroke-width=\".125em\" cx=\"16\" cy=\"12\" r=\"4\"/></g>`,shapeIconLineDecorationSquare:`<g stroke=\"currentColor\" stroke-linecap=\"round\" stroke-width=\".125em\"><path d=\"M5,12 H16\"/><path d=\"M13,7 l6,5 l-6,5z\" fill=\"currentColor\"/></g>`,shapeIconLineDecorationArrow:`<g stroke=\"currentColor\" stroke-linecap=\"round\" stroke-width=\".125em\"><path d=\"M5,12 H16 M13,7 l6,5 l-6,5\" fill=\"none\"/></g>`,shapeIconLineDecorationCircleSolid:`<g stroke=\"currentColor\" stroke-linecap=\"round\"><path stroke-width=\".125em\" d=\"M5,12 H12\"/><circle fill=\"currentColor\" cx=\"16\" cy=\"12\" r=\"4\"/></g>`,shapeIconLineDecorationSquareSolid:`<g stroke=\"currentColor\" stroke-linecap=\"round\"><path stroke-width=\".125em\" d=\"M5,12 H12\"/><rect fill=\"currentColor\" x=\"12\" y=\"8\" width=\"8\" height=\"8\"/></g>`,shapeIconLineDecorationArrowSolid:`<g stroke=\"currentColor\" stroke-linecap=\"round\" stroke-width=\".125em\"><path d=\"M5,12 H16\"/><path d=\"M13,7 l6,5 l-6,5z\" fill=\"currentColor\"/></g>`,shapeTitleColorTransparent:'Transparent',shapeTitleColorWhite:'White',shapeTitleColorSilver:'Silver',shapeTitleColorGray:'Gray',shapeTitleColorBlack:'Black',shapeTitleColorNavy:'Navy',shapeTitleColorBlue:'Blue',shapeTitleColorAqua:'Aqua',shapeTitleColorTeal:'Teal',shapeTitleColorOlive:'Olive',shapeTitleColorGreen:'Green',shapeTitleColorYellow:'Yellow',shapeTitleColorOrange:'Orange',shapeTitleColorRed:'Red',shapeTitleColorMaroon:'Maroon',shapeTitleColorFuchsia:'Fuchsia',shapeTitleColorPurple:'Purple',shapeTitleTextColor:'Font color',shapeTitleTextAlign:'Text align',shapeTitleTextAlignLeft:'Left align text',shapeTitleTextAlignCenter:'Center align text',shapeTitleTextAlignRight:'Right align text',shapeIconTextAlignLeft:`<g stroke-width=\".125em\" stroke=\"currentColor\"><line x1=\"5\" y1=\"8\" x2=\"15\" y2=\"8\"/><line x1=\"5\" y1=\"12\" x2=\"19\" y2=\"12\"/><line x1=\"5\" y1=\"16\" x2=\"14\" y2=\"16\"/></g>`,shapeIconTextAlignCenter:`<g stroke-width=\".125em\" stroke=\"currentColor\"><line x1=\"7\" y1=\"8\" x2=\"17\" y2=\"8\"/><line x1=\"5\" y1=\"12\" x2=\"19\" y2=\"12\"/><line x1=\"8\" y1=\"16\" x2=\"16\" y2=\"16\"/></g>`,shapeIconTextAlignRight:`<g stroke-width=\".125em\" stroke=\"currentColor\"><line x1=\"9\" y1=\"8\" x2=\"19\" y2=\"8\"/><line x1=\"5\" y1=\"12\" x2=\"19\" y2=\"12\"/><line x1=\"11\" y1=\"16\" x2=\"19\" y2=\"16\"/></g>`,shapeLabelToolSharpie:'Sharpie',shapeLabelToolEraser:'Eraser',shapeLabelToolRectangle:'Rectangle',shapeLabelToolEllipse:'Ellipse',shapeLabelToolArrow:'Arrow',shapeLabelToolLine:'Line',shapeLabelToolText:'Text',shapeLabelToolPreset:'Stickers',shapeIconToolSharpie:`<g stroke-width=\".125em\" stroke=\"currentColor\" fill=\"none\"><path d=\"M2.025 5c5.616-2.732 8.833-3.857 9.65-3.374C12.903 2.351.518 12.666 2.026 14 3.534 15.334 16.536.566 17.73 2.566 18.924 4.566 3.98 17.187 4.831 18c.851.813 9.848-6 11.643-6 1.087 0-2.53 5.11-2.92 7-.086.41 3.323-1.498 4.773-1 .494.17.64 2.317 1.319 3 .439.443 1.332.776 2.679 1\" stroke=\"currentColor\" stroke-width=\".125em\" fill=\"none\" fill-rule=\"evenodd\" stroke-linejoin=\"round\"/></g>`,shapeIconToolEraser:`<g stroke-width=\".125em\" stroke=\"currentColor\" stroke-linecap=\"round\" fill=\"none\"><g transform=\"translate(3, 15) rotate(-45)\"><rect x=\"0\" y=\"0\" width=\"18\" height=\"10\" rx=\"3\"/></g><line x1=\"11\" y1=\"21\" x2=\"18\" y2=\"21\"/><line x1=\"20\" y1=\"21\" x2=\"22\" y2=\"21\"/></g>`,shapeIconToolRectangle:`<g stroke-width=\".125em\" stroke=\"currentColor\" fill=\"none\"><rect x=\"2\" y=\"2\" width=\"20\" height=\"20\" rx=\"3\"/></g>`,shapeIconToolEllipse:`<g stroke-width=\".125em\" stroke=\"currentColor\" fill=\"none\"><circle cx=\"12\" cy=\"12\" r=\"11\"/></g>`,shapeIconToolArrow:`<g stroke-width=\".125em\" stroke=\"currentColor\" fill=\"none\"><line x1=\"20\" y1=\"3\" x2=\"6\" y2=\"21\"/><path d=\"m10 5 L22 1 L21 13\" fill=\"currentColor\" stroke=\"none\"/></g>`,shapeIconToolLine:`<g stroke-width=\".125em\" stroke=\"currentColor\" fill=\"none\"><line x1=\"20\" y1=\"3\" x2=\"6\" y2=\"21\"/></g>`,shapeIconToolText:`<g stroke=\"none\" fill=\"currentColor\" transform=\"translate(6,0)\"><path d=\"M8.14 20.085c.459 0 .901-.034 1.329-.102a8.597 8.597 0 001.015-.21v1.984c-.281.135-.695.247-1.242.336a9.328 9.328 0 01-1.477.133c-3.312 0-4.968-1.745-4.968-5.235V6.804H.344v-1.25l2.453-1.078L3.89.819h1.5v3.97h4.97v2.015H5.39v10.078c0 1.031.245 1.823.735 2.375s1.161.828 2.015.828z\"/>`,shapeIconToolPreset:`<g fill=\"none\" stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke=\"currentColor\" stroke-width=\".125em\"><path d=\"M12 22c2.773 0 1.189-5.177 3-7 1.796-1.808 7-.25 7-3 0-5.523-4.477-10-10-10S2 6.477 2 12s4.477 10 10 10z\"></path><path d=\"M20 17c-3 3-5 5-8 5\"></path></g>`};var en_gb$1={cropLabel:'Crop',cropIcon:'<g stroke-width=\".125em\" stroke=\"currentColor\" fill=\"none\"><path d=\"M23 17H9a2 2 0 0 1-2-2v-5m0-3V1\"/><path d=\"M1 7h14a2 2 0 0 1 2 2v7m0 4v3\"/></g>',cropIconButtonRecenter:`<path stroke=\"currentColor\" fill=\"none\" stroke-width=\"2\" stroke-linejoin=\"bevel\" d=\"M1.5 7.5v-6h6M1.5 16.5v6h6M22.5 16.5v6h-6M22.5 7.5v-6h-6\"/><circle cx=\"12\" cy=\"12\" r=\"3.5\" fill=\"currentColor\" stroke=\"none\"/>`,cropIconButtonRotateLeft:'<g stroke=\"none\" fill=\"currentColor\"><path fill=\"none\" d=\"M-1-1h582v402H-1z\"/><rect x=\"3\" rx=\"1\" height=\"12\" width=\"12\" y=\"9\"/><path d=\"M15 5h-1a5 5 0 015 5 1 1 0 002 0 7 7 0 00-7-7h-1.374l.747-.747A1 1 0 0011.958.84L9.603 3.194a1 1 0 000 1.415l2.355 2.355a1 1 0 001.415-1.414l-.55-.55H15z\"/></g>',cropIconButtonRotateRight:'<g stroke=\"none\" fill=\"currentColor\"><path fill=\"none\" d=\"M-1-1h582v402H-1z\"/><path d=\"M11.177 5H10a5 5 0 00-5 5 1 1 0 01-2 0 7 7 0 017-7h1.374l-.747-.747A1 1 0 0112.042.84l2.355 2.355a1 1 0 010 1.415l-2.355 2.354a1 1 0 01-1.415-1.414l.55-.55z\"/><rect rx=\"1\" height=\"12\" width=\"12\" y=\"9\" x=\"9\"/></g>',cropIconButtonFlipVertical:'<g stroke=\"none\" fill=\"currentColor\"><path d=\"M19.993 12.143H7a1 1 0 0 1-1-1V5.994a1 1 0 0 1 1.368-.93l12.993 5.15a1 1 0 0 1-.368 1.93z\"/><path d=\"M19.993 14a1 1 0 0 1 .368 1.93L7.368 21.078A1 1 0 0 1 6 20.148V15a1 1 0 0 1 1-1h12.993z\" opacity=\".6\"/></g>',cropIconButtonFlipHorizontal:'<g stroke=\"none\" fill=\"currentColor\"><path d=\"M11.93 7.007V20a1 1 0 0 1-1 1H5.78a1 1 0 0 1-.93-1.368l5.15-12.993a1 1 0 0 1 1.929.368z\"/><path d=\"M14 7.007V20a1 1 0 0 0 1 1h5.149a1 1 0 0 0 .93-1.368l-5.15-12.993A1 1 0 0 0 14 7.007z\" opacity=\".6\"/></g>',cropLabelButtonRecenter:'Recenter',cropLabelButtonRotateLeft:'Rotate left',cropLabelButtonRotateRight:'Rotate right',cropLabelButtonFlipHorizontal:'Flip horizontal',cropLabelButtonFlipVertical:'Flip vertical',cropLabelSelectPreset:'Crop shape',cropLabelCropBoundary:'Crop boundary',cropLabelCropBoundaryEdge:'Edge of image',cropLabelCropBoundaryNone:'None',cropLabelTabRotation:'Rotation',cropLabelTabZoom:'Zoom'};var en_gb$2={filterLabel:'Filter',filterIcon:'<g stroke-width=\".125em\" stroke=\"currentColor\" fill=\"none\"><path d=\"M18.347 9.907a6.5 6.5 0 1 0-1.872 3.306M3.26 11.574a6.5 6.5 0 1 0 2.815-1.417\"/><path d=\"M10.15 17.897A6.503 6.503 0 0 0 16.5 23a6.5 6.5 0 1 0-6.183-8.51\"/></g>',filterLabelChrome:'Chrome',filterLabelFade:'Fade',filterLabelCold:'Cold',filterLabelWarm:'Warm',filterLabelPastel:'Pastel',filterLabelMonoDefault:'Mono',filterLabelMonoNoir:'Noir',filterLabelMonoWash:'Wash',filterLabelMonoStark:'Stark',filterLabelSepiaDefault:'Sepia',filterLabelSepiaBlues:'Blues',filterLabelSepiaRust:'Rust',filterLabelSepiaColor:'Color'};var en_gb$3={finetuneLabel:'Finetune',finetuneIcon:'<g stroke-width=\".125em\" stroke=\"currentColor\" fill=\"none\"><path d=\"M4 1v5.5m0 3.503V23M12 1v10.5m0 3.5v8M20 1v15.5m0 3.5v3M2 7h4M10 12h4M18 17h4\"/></g>',finetuneLabelBrightness:'Brightness',finetuneLabelContrast:'Contrast',finetuneLabelSaturation:'Saturation',finetuneLabelExposure:'Exposure',finetuneLabelTemperature:'Temperature',finetuneLabelGamma:'Gamma',finetuneLabelClarity:'Clarity',finetuneLabelVignette:'Vignette'};var en_gb$4={resizeLabel:'Resize',resizeIcon:'<g stroke-width=\".125em\" stroke=\"currentColor\" fill=\"none\"><rect x=\"2\" y=\"12\" width=\"10\" height=\"10\" rx=\"2\"/><path d=\"M4 11.5V4a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2h-5.5\"/><path d=\"M14 10l3.365-3.365M14 6h4v4\"/></g>',resizeLabelFormCaption:'Image output size',resizeLabelInputWidth:'w',resizeTitleInputWidth:'Width',resizeLabelInputHeight:'h',resizeTitleInputHeight:'Height',resizeTitleButtonMaintainAspectRatio:'Maintain aspectratio',resizeIconButtonMaintainAspectRatio:(active,activeFraction)=>`\n        <defs>\n            <mask id=\"mask1\" x=\"0\" y=\"0\" width=\"24\" height=\"24\" >\n                <rect x=\"0\" y=\"0\" width=\"24\" height=\"10\" fill=\"#fff\" stroke=\"none\"/>\n            </mask>\n        </defs>\n        <g fill=\"none\" fill-rule=\"evenodd\">\n            <g  mask=\"url(#mask1)\">\n                <path transform=\"translate(0 ${(activeFraction-1)*3})\" stroke=\"currentColor\" stroke-width=\"1.5\" stroke-linecap=\"round\" d=\"M9.401 10.205v-.804a2.599 2.599 0 0 1 5.198 0V17\"/>\n            </g>\n            <rect fill=\"currentColor\" x=\"7\" y=\"10\" width=\"10\" height=\"7\" rx=\"1.5\"/>\n        </g>\n    `};var en_gb$5={decorateLabel:'Decorate',decorateIcon:'<g fill=\"none\" fill-rule=\"evenodd\"><path stroke=\"currentColor\" stroke-width=\".125em\" stroke-linecap=\"round\" stroke-linejoin=\"round\" d=\"M12 18.5l-6.466 3.4 1.235-7.2-5.23-5.1 7.228-1.05L12 2l3.233 6.55 7.229 1.05-5.231 5.1 1.235 7.2z\"/></g>'};var en_gb$6={annotateLabel:'Annotate',annotateIcon:'<g stroke-width=\".125em\" stroke=\"currentColor\" fill=\"none\"><path d=\"M17.086 2.914a2.828 2.828 0 1 1 4 4l-14.5 14.5-5.5 1.5 1.5-5.5 14.5-14.5z\"/></g>'};var en_gb$7={stickerLabel:'Sticker',stickerIcon:'<g fill=\"none\" stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke=\"currentColor\" stroke-width=\".125em\"><path d=\"M12 22c2.773 0 1.189-5.177 3-7 1.796-1.808 7-.25 7-3 0-5.523-4.477-10-10-10S2 6.477 2 12s4.477 10 10 10z\"/><path d=\"M20 17c-3 3-5 5-8 5\"/></g>'};/* Deprecated, remove in v8, use `createDefaultImageOrienter` instead */const imageOrienter={read:getImageOrientationFromFile,apply:orientImageData};const createDefaultImageOrienter=()=>({read:getImageOrientationFromFile,apply:orientImageData});const createEditor=createImageEditor;const getEditorProps$1=()=>getEditorProps().concat(getEditorViewProps());const processImage=(src,options)=>{const{processImage}=createImageEditor();return processImage(src,options);};const createMarkupEditorToolbar=createToolbar;const createMarkupEditorToolStyles=createToolStyles;// markup editor style controls\nconst createMarkupEditorShapeStyleControls=createShapeStyleControls;const markup_editor_defaults={markupEditorToolbar:createToolbar(),markupEditorToolStyles:createToolStyles(),markupEditorShapeStyleControls:createShapeStyleControls()};//\n// deprecated exports\n//\nconst plugin_annotate_defaults=_objectSpread(_objectSpread({},markup_editor_defaults),{},{annotateTools:createToolbar(),annotateToolShapes:createToolStyles(),annotateShapeControls:createShapeStyleControls()});const plugin_decorate_defaults=_objectSpread(_objectSpread({},markup_editor_defaults),{},{decorateTools:createToolbar(),decorateToolShapes:createToolStyles(),decorateShapeControls:createShapeStyleControls()});const plugin_resize_defaults={};const plugin_sticker_defaults={};export{appendEditor,appendEditors,appendNode,blobToFile,colorStringToColorArray,MarkupEditor as component_shape_editor_locale_en_gb,createDefaultColorOptions,createDefaultFontFamilyOptions,createDefaultFontScaleOptions,createDefaultFontSizeOptions,createDefaultFontStyleOptions,createDefaultImageOrienter,createDefaultImageReader,createDefaultImageWriter,createDefaultLineEndStyleOptions,createDefaultStrokeScaleOptions,createDefaultStrokeWidthOptions,createDefaultTextAlignOptions,createEditor,createBackgroundColorControl as createMarkupEditorBackgroundColorControl,createColorOptions as createMarkupEditorColorOptions,createFontColorControl as createMarkupEditorFontColorControl,createFontFamilyControl as createMarkupEditorFontFamilyControl,createFontFamilyOptions as createMarkupEditorFontFamilyOptions,createFontScaleOptions as createMarkupEditorFontScaleOptions,createFontSizeControl as createMarkupEditorFontSizeControl,createFontSizeOptions as createMarkupEditorFontSizeOptions,createFontStyleControl as createMarkupEditorFontStyleControl,createFontStyleOptions as createMarkupEditorFontStyleOptions,createLineEndStyleControl as createMarkupEditorLineEndStyleControl,createLineEndStyleOptions as createMarkupEditorLineEndStyleOptions,createLineHeightControl as createMarkupEditorLineHeightControl,createLineStartStyleControl as createMarkupEditorLineStartStyleControl,createMarkupEditorShapeStyleControls,createStrokeColorControl as createMarkupEditorStrokeColorControl,createStrokeScaleOptions as createMarkupEditorStrokeScaleOptions,createStrokeWidthControl as createMarkupEditorStrokeWidthControl,createStrokeWidthOptions as createMarkupEditorStrokeWidthOptions,createTextAlignControl as createMarkupEditorTextAlignControl,createToolStyle as createMarkupEditorToolStyle,createMarkupEditorToolStyles,createMarkupEditorToolbar,createNode,customElement as defineCustomElements,degToRad,dispatchEditorEvents,brightness as effectBrightness,clarity as effectClarity,contrast as effectContrast,exposure as effectExposure,gamma as effectGamma,saturation as effectSaturation,temperature as effectTemperature,vignette as effectVignette,chrome as filterChrome,cold as filterCold,fade$1 as filterFade,invert as filterInvert,monoDefault as filterMonoDefault,monoNoir as filterMonoNoir,monoStark as filterMonoStark,monoWash as filterMonoWash,pastel as filterPastel,sepiaBlues as filterSepiaBlues,sepiaColor as filterSepiaColor,sepiaDefault as filterSepiaDefault,sepiaRust as filterSepiaRust,warm as filterWarm,findNode,getEditorProps$1 as getEditorProps,imageOrienter,insertNodeAfter,insertNodeBefore,isModernBrowser as isSupported,legacyDataToImageState,en_gb as locale_en_gb,markup_editor_defaults,MarkupEditor as markup_editor_locale_en_gb,openEditor,overlayEditor,index$3 as plugin_annotate,plugin_annotate_defaults,en_gb$6 as plugin_annotate_locale_en_gb,index as plugin_crop,defaults$2 as plugin_crop_defaults,en_gb$1 as plugin_crop_locale_en_gb,index$4 as plugin_decorate,plugin_decorate_defaults,en_gb$5 as plugin_decorate_locale_en_gb,index$1 as plugin_filter,defaults$1 as plugin_filter_defaults,en_gb$2 as plugin_filter_locale_en_gb,index$2 as plugin_finetune,defaults as plugin_finetune_defaults,en_gb$3 as plugin_finetune_locale_en_gb,index$6 as plugin_resize,plugin_resize_defaults,en_gb$4 as plugin_resize_locale_en_gb,index$5 as plugin_sticker,plugin_sticker_defaults,en_gb$7 as plugin_sticker_locale_en_gb,processImage,removeNode,setEditorViewPlugins as setPlugins};","map":null,"metadata":{},"sourceType":"module"}