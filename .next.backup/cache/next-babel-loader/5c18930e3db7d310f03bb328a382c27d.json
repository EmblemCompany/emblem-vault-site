{"ast":null,"code":"import useSWR from 'swr';\nimport { Token, TokenAmount, Pair, JSBI, ChainId } from '@uniswap/sdk';\nimport { useWeb3React } from '@web3-react/core';\nimport { parseBytes32String } from '@ethersproject/strings';\nimport { getAddress } from '@ethersproject/address';\nimport IERC20 from '@uniswap/v2-core/build/IERC20.json';\nimport IUniswapV2Pair from '@uniswap/v2-core/build/IUniswapV2Pair.json';\nimport { ZERO, ADDRESS_ZERO, ERC20_BYTES32 } from './constants';\nimport { useContract, useKeepSWRDataLiveAsBlocksArrive } from './hooks';\nexport let DataType;\n\n(function (DataType) {\n  DataType[DataType[\"BlockNumber\"] = 0] = \"BlockNumber\";\n  DataType[DataType[\"ETHBalance\"] = 1] = \"ETHBalance\";\n  DataType[DataType[\"TokenBalance\"] = 2] = \"TokenBalance\";\n  DataType[DataType[\"TokenAllowance\"] = 3] = \"TokenAllowance\";\n  DataType[DataType[\"Reserves\"] = 4] = \"Reserves\";\n  DataType[DataType[\"Token\"] = 5] = \"Token\";\n  DataType[DataType[\"RemoteTokens\"] = 6] = \"RemoteTokens\";\n})(DataType || (DataType = {}));\n\nfunction getBlockNumber(library) {\n  return async () => {\n    return library.getBlockNumber();\n  };\n} // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n\nexport function useBlockNumber() {\n  const {\n    library\n  } = useWeb3React();\n  const shouldFetch = !!library;\n  return useSWR(shouldFetch ? [DataType.BlockNumber] : null, getBlockNumber(library), {\n    refreshInterval: 10 * 1000\n  });\n}\n\nfunction getETHBalance(library) {\n  return async (chainId, address) => {\n    const ETH = new Token(chainId, ADDRESS_ZERO, 18);\n    return library.getBalance(address).then(balance => new TokenAmount(ETH, balance.toString()));\n  };\n} // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n\nexport function useETHBalance(address, suspense = false) {\n  const {\n    chainId,\n    library\n  } = useWeb3React();\n  const shouldFetch = typeof chainId === 'number' && typeof address === 'string' && !!library;\n  const result = useSWR(shouldFetch ? [chainId, address, DataType.ETHBalance] : null, getETHBalance(library), {\n    suspense\n  });\n  useKeepSWRDataLiveAsBlocksArrive(result.mutate);\n  return result;\n}\n\nfunction getTokenBalance(contract, token) {\n  return async address => contract.balanceOf(address).then(balance => new TokenAmount(token, balance.toString()));\n}\n\nexport function useTokenBalance(token, address, suspense = false // eslint-disable-next-line @typescript-eslint/no-explicit-any\n) {\n  const contract = useContract(token === null || token === void 0 ? void 0 : token.address, IERC20.abi);\n  const result = useSWR(typeof address === 'string' && token && contract ? [address, token.chainId, token.address, DataType.TokenBalance] : null, getTokenBalance(contract, token), {\n    suspense\n  });\n  useKeepSWRDataLiveAsBlocksArrive(result.mutate);\n  return result;\n}\n\nfunction getTokenAllowance(contract, token) {\n  return async (owner, spender) => contract.allowance(owner, spender).then(balance => new TokenAmount(token, balance.toString()));\n}\n\nexport function useTokenAllowance(token, owner, spender) {\n  const contract = useContract(token === null || token === void 0 ? void 0 : token.address, IERC20.abi);\n  const result = useSWR(typeof owner === 'string' && typeof spender === 'string' && token && contract ? [owner, spender, token.chainId, token.address, DataType.TokenAllowance] : null, getTokenAllowance(contract, token));\n  useKeepSWRDataLiveAsBlocksArrive(result.mutate);\n  return result;\n}\n\nfunction getReserves(contract, token0, token1) {\n  return async () => contract.getReserves().then(({\n    reserve0,\n    reserve1\n  }) => {\n    const pair = new Pair(new TokenAmount(token0, reserve0.toString()), new TokenAmount(token1, reserve1.toString()));\n    return JSBI.equal(pair.reserve0.raw, ZERO) || JSBI.equal(pair.reserve1.raw, ZERO) ? null : pair;\n  }).catch(() => null);\n} // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n\nexport function useReserves(tokenA, tokenB) {\n  const invalid = !!tokenA && !!tokenB && tokenA.equals(tokenB);\n  const [token0, token1] = !!tokenA && !!tokenB && !invalid ? tokenA.sortsBefore(tokenB) ? [tokenA, tokenB] : [tokenB, tokenA] : [];\n  const pairAddress = !!token0 && !!token1 ? Pair.getAddress(token0, token1) : undefined;\n  const contract = useContract(pairAddress, IUniswapV2Pair.abi);\n  const result = useSWR(token0 && pairAddress && contract && token1 ? [token0.chainId, pairAddress, DataType.Reserves] : null, getReserves(contract, token0, token1));\n  useKeepSWRDataLiveAsBlocksArrive(result.mutate);\n  return result;\n}\n\nfunction getOnchainToken(contract, contractBytes32) {\n  return async (chainId, address) => {\n    const [decimals, symbol, name] = await Promise.all([contract.decimals().catch(() => null), contract.symbol().catch(() => contractBytes32.symbol().then(parseBytes32String).catch(() => 'UNKNOWN')), contract.name().catch(() => contractBytes32.name().then(parseBytes32String).catch(() => 'Unknown'))]);\n    return decimals === null ? null : new Token(chainId, address, decimals, symbol, name);\n  };\n} // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n\nexport function useOnchainToken(address, suspense = false) {\n  const {\n    chainId\n  } = useWeb3React();\n  const contract = useContract(address, IERC20.abi);\n  const contractBytes32 = useContract(address, ERC20_BYTES32);\n  return useSWR(typeof chainId === 'number' && typeof address === 'string' && contract && contractBytes32 ? [chainId, address, DataType.Token] : null, getOnchainToken(contract, contractBytes32), {\n    dedupingInterval: 60 * 1000,\n    refreshInterval: 60 * 1000,\n    suspense\n  });\n}\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nasync function getRemoteTokens(searchQuery) {\n  const {\n    request\n  } = await import('graphql-request');\n  return request('https://api.thegraph.com/subgraphs/name/uniswap/uniswap-v2', `\nquery getRemoteTokens($searchQuery: String!) {\n  tokens(where: { symbol_contains: $searchQuery }) {\n    id\n    symbol\n    name\n  }\n}`, {\n    searchQuery\n  }).then(result => result.tokens.map(token => {\n    var _token$symbol, _token$name;\n\n    return {\n      address: getAddress(token.id),\n      symbol: (_token$symbol = token.symbol) !== null && _token$symbol !== void 0 ? _token$symbol : 'UNKNOWN',\n      name: (_token$name = token.name) !== null && _token$name !== void 0 ? _token$name : 'Unknown'\n    };\n  }));\n} // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n\nexport function useRemoteTokens(query = '', suspense = false) {\n  const {\n    chainId\n  } = useWeb3React();\n  const shouldFetch = chainId === ChainId.MAINNET && query.length > 0;\n  return useSWR(shouldFetch ? [query, DataType.RemoteTokens] : null, getRemoteTokens, {\n    dedupingInterval: 60 * 5 * 1000,\n    refreshInterval: 60 * 5 * 1000,\n    suspense\n  });\n}","map":null,"metadata":{},"sourceType":"module"}