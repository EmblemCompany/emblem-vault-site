{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport { useCallback, useEffect, useState, useMemo, useRef } from 'react';\nimport { useWeb3React } from '@web3-react/core';\nimport { Route, WETH, ChainId, TradeType, Trade, Fraction, JSBI } from '@uniswap/sdk';\nimport { injected } from './connectors';\nimport { useReserves, useBlockNumber } from './data';\nimport { Contract } from '@ethersproject/contracts';\nimport { useRouter } from 'next/router';\nimport { QueryParameters } from './constants';\nimport { getAddress } from '@ethersproject/address';\nimport { DAI, USDC } from './tokens';\nexport function useWindowSize() {\n  function getSize() {\n    var isClient = true;\n    return {\n      width: isClient ? window.innerWidth : undefined,\n      height: isClient ? window.innerHeight : undefined\n    };\n  }\n\n  var _useState = useState(getSize()),\n      windowSize = _useState[0],\n      setWindowSize = _useState[1];\n\n  useEffect(function () {\n    var handleResize = function handleResize() {\n      setWindowSize(getSize());\n    };\n\n    window.addEventListener('resize', handleResize);\n    return function () {\n      window.removeEventListener('resize', handleResize);\n    };\n  }, []);\n  return windowSize;\n} // https://usehooks.com/useDebounce/\n\nexport function useDefaultedDebounce(value, initialValue, delay) {\n  var _useState2 = useState(initialValue),\n      defaultedDebounce = _useState2[0],\n      setDefaultedDebounce = _useState2[1];\n\n  useEffect(function () {\n    var handler = setTimeout(function () {\n      setDefaultedDebounce(value);\n    }, delay);\n    return function () {\n      clearTimeout(handler);\n      setDefaultedDebounce(initialValue);\n    };\n  }, [value, initialValue, delay]);\n  return defaultedDebounce;\n} // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\nexport function useBodyKeyDown(targetKey, onKeyDown) {\n  var suppress = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  var downHandler = useCallback(function (event) {\n    if (!suppress && event.key === targetKey && event.target.tagName === 'BODY' && !event.altKey && !event.ctrlKey && !event.metaKey && !event.shiftKey) {\n      onKeyDown(event);\n    }\n  }, [suppress, targetKey, onKeyDown]);\n  useEffect(function () {\n    window.addEventListener('keydown', downHandler);\n    return function () {\n      window.removeEventListener('keydown', downHandler);\n    };\n  }, [suppress, targetKey, downHandler]);\n} // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\nexport function useKeepSWRDataLiveAsBlocksArrive(mutate) {\n  // because we don't care about the referential identity of mutate, just bind it to a ref\n  var mutateRef = useRef(mutate);\n  useEffect(function () {\n    mutateRef.current = mutate;\n  }); // then, whenever a new block arrives, trigger a mutation\n\n  var _useBlockNumber = useBlockNumber(),\n      data = _useBlockNumber.data;\n\n  useEffect(function () {\n    mutateRef.current();\n  }, [data]);\n}\nexport function useEagerConnect() {\n  var _useWeb3React = useWeb3React(),\n      activate = _useWeb3React.activate,\n      active = _useWeb3React.active;\n\n  var _useState3 = useState(false),\n      tried = _useState3[0],\n      setTried = _useState3[1];\n\n  useEffect(function () {\n    injected.isAuthorized().then(function (isAuthorized) {\n      if (isAuthorized) {\n        activate(injected, undefined, true)[\"catch\"](function () {\n          setTried(true);\n        });\n      } else {\n        setTried(true);\n      }\n    });\n  }, [activate]); // if the connection worked, wait until we get confirmation of that to flip the flag\n\n  useEffect(function () {\n    if (!tried && active) {\n      setTried(true);\n    }\n  }, [tried, active]);\n  return tried;\n}\nvar chainMappings = {\n  '1': 1,\n  mainnet: 1,\n  '3': 3,\n  ropsten: 3,\n  '4': 4,\n  rinkeby: 4,\n  '5': 5,\n  gÃ¶rli: 5,\n  goerli: 5,\n  '42': 42,\n  kovan: 42,\n  '80001': 80001,\n  mumbai: 80001,\n  matic: 137,\n  '137': 137,\n  '97': 97,\n  bnbsc: 97\n};\nexport function useQueryParameters() {\n  var _useRouter = useRouter(),\n      query = _useRouter.query;\n\n  var candidateChainId;\n\n  try {\n    candidateChainId = chainMappings[query[QueryParameters.CHAIN]];\n  } catch (_unused) {}\n\n  var chainId = !!injected.supportedChainIds && typeof candidateChainId === 'number' && injected.supportedChainIds.includes(candidateChainId) ? candidateChainId : undefined;\n  var input;\n\n  try {\n    if (typeof query[QueryParameters.INPUT] === 'string') input = getAddress(query[QueryParameters.INPUT]);\n  } catch (_unused2) {}\n\n  var output;\n\n  try {\n    if (typeof query[QueryParameters.OUTPUT] === 'string') output = getAddress(query[QueryParameters.OUTPUT]);\n  } catch (_unused3) {}\n\n  return useMemo(function () {\n    var _ref;\n\n    return _ref = {}, _defineProperty(_ref, QueryParameters.CHAIN, chainId), _defineProperty(_ref, QueryParameters.INPUT, input), _defineProperty(_ref, QueryParameters.OUTPUT, output), _ref;\n  }, [chainId, input, output]);\n}\n\nfunction useDirectPair(inputToken, outputToken) {\n  var _useReserves = useReserves(inputToken, outputToken),\n      pair = _useReserves.data;\n\n  if (!!inputToken && !!outputToken && inputToken.equals(outputToken)) {\n    return null;\n  }\n\n  return pair;\n}\n\nexport function useRoute(inputToken, outputToken) {\n  // direct pair\n  var directPair = useDirectPair(inputToken, outputToken); // WETH pairs\n\n  var WETHInputPair = useDirectPair(inputToken ? WETH[inputToken.chainId] : undefined, inputToken);\n  var WETHOutputPair = useDirectPair(outputToken ? WETH[outputToken.chainId] : undefined, outputToken); // DAI pairs\n\n  var DAIInputPair = useDirectPair((inputToken === null || inputToken === void 0 ? void 0 : inputToken.chainId) === ChainId.MAINNET ? DAI : undefined, inputToken);\n  var DAIOutputPair = useDirectPair((outputToken === null || outputToken === void 0 ? void 0 : outputToken.chainId) === ChainId.MAINNET ? DAI : undefined, outputToken); // USDC pairs\n\n  var USDCInputPair = useDirectPair((inputToken === null || inputToken === void 0 ? void 0 : inputToken.chainId) === ChainId.MAINNET ? USDC : undefined, inputToken);\n  var USDCOutputPair = useDirectPair((outputToken === null || outputToken === void 0 ? void 0 : outputToken.chainId) === ChainId.MAINNET ? USDC : undefined, outputToken); // connecting pairs\n\n  var DAIWETH = useDirectPair((inputToken === null || inputToken === void 0 ? void 0 : inputToken.chainId) === ChainId.MAINNET ? DAI : undefined, WETH[DAI.chainId]);\n  var USDCWETH = useDirectPair((inputToken === null || inputToken === void 0 ? void 0 : inputToken.chainId) === ChainId.MAINNET ? USDC : undefined, WETH[USDC.chainId]);\n  var DAIUSDC = useDirectPair((inputToken === null || inputToken === void 0 ? void 0 : inputToken.chainId) === ChainId.MAINNET ? DAI : undefined, (inputToken === null || inputToken === void 0 ? void 0 : inputToken.chainId) === ChainId.MAINNET ? USDC : undefined);\n  var pairs = [directPair, WETHInputPair, WETHOutputPair, DAIInputPair, DAIOutputPair, USDCInputPair, USDCOutputPair, DAIWETH, USDCWETH, DAIUSDC].filter(function (p, i, pairs) {\n    // filter out invalid pairs or pairs whose data hasn't been fetched yet\n    if (!!!p) {\n      return false;\n    } else {\n      return i === pairs.findIndex(function (pair) {\n        var _pair$liquidityToken;\n\n        return (pair === null || pair === void 0 ? void 0 : (_pair$liquidityToken = pair.liquidityToken) === null || _pair$liquidityToken === void 0 ? void 0 : _pair$liquidityToken.address) === p.liquidityToken.address;\n      });\n    }\n  });\n  var directRoute = useMemo(function () {\n    return directPair && inputToken ? new Route([directPair], inputToken) : directPair === null ? null : undefined;\n  }, [directPair, inputToken]);\n  var WETHRoute = useMemo(function () {\n    return WETHInputPair && WETHOutputPair && inputToken ? new Route([WETHInputPair, WETHOutputPair], inputToken) : WETHInputPair === null || WETHOutputPair === null ? null : undefined;\n  }, [WETHInputPair, WETHOutputPair, inputToken]);\n  var DAIRoute = useMemo(function () {\n    return DAIInputPair && DAIOutputPair && inputToken ? new Route([DAIInputPair, DAIOutputPair], inputToken) : DAIInputPair === null || DAIOutputPair === null ? null : undefined;\n  }, [DAIInputPair, DAIOutputPair, inputToken]);\n  var USDCRoute = useMemo(function () {\n    return USDCInputPair && USDCOutputPair && inputToken ? new Route([USDCInputPair, USDCOutputPair], inputToken) : USDCInputPair === null || USDCOutputPair === null ? null : undefined;\n  }, [USDCInputPair, USDCOutputPair, inputToken]);\n  var routes = [directRoute, WETHRoute, DAIRoute, USDCRoute];\n  return [routes.filter(function (route) {\n    return !!route;\n  }).length > 0 ? routes.filter(function (route) {\n    return !!route;\n  })[0] : routes.some(function (route) {\n    return route === undefined;\n  }) ? undefined : null, pairs];\n}\nexport function useTrade(inputToken, outputToken, pairs, independentAmount, tradeType) {\n  var canCompute = !!inputToken && !!outputToken && pairs.length > 0 && !!independentAmount;\n  var trade;\n\n  if (canCompute) {\n    if (tradeType === TradeType.EXACT_INPUT) {\n      trade = Trade.bestTradeExactIn(pairs, independentAmount, outputToken, {\n        maxNumResults: 1\n      })[0];\n    } else {\n      trade = Trade.bestTradeExactOut(pairs, inputToken, independentAmount, {\n        maxNumResults: 1\n      })[0];\n    }\n  }\n\n  return trade;\n}\nexport function useContract(address, ABI) {\n  var withSigner = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\n  var _useWeb3React2 = useWeb3React(),\n      library = _useWeb3React2.library,\n      account = _useWeb3React2.account;\n\n  return useMemo(function () {\n    return !!address && !!ABI && !!library ? new Contract(address, ABI, withSigner ? library.getSigner(account).connectUnchecked() : library) : undefined;\n  }, [address, ABI, withSigner, library, account]);\n}\nexport function useUSDETHPrice() {\n  var _useWeb3React3 = useWeb3React(),\n      chainId = _useWeb3React3.chainId;\n\n  var DAIWETH = useDirectPair(chainId === ChainId.MAINNET ? DAI : undefined, WETH[ChainId.MAINNET]);\n  var USDCWETH = useDirectPair(chainId === ChainId.MAINNET ? USDC : undefined, WETH[ChainId.MAINNET]);\n  var price = useMemo(function () {\n    var _Route, _Route$midPrice, _Route2, _Route2$midPrice;\n\n    var priceFractions = [DAIWETH && ((_Route = new Route([DAIWETH], WETH[ChainId.MAINNET])) === null || _Route === void 0 ? void 0 : (_Route$midPrice = _Route.midPrice) === null || _Route$midPrice === void 0 ? void 0 : _Route$midPrice.adjusted), USDCWETH && ((_Route2 = new Route([USDCWETH], WETH[ChainId.MAINNET])) === null || _Route2 === void 0 ? void 0 : (_Route2$midPrice = _Route2.midPrice) === null || _Route2$midPrice === void 0 ? void 0 : _Route2$midPrice.adjusted)].filter(function (price) {\n      return !!price;\n    });\n    return priceFractions.reduce(function (accumulator, priceFraction) {\n      return accumulator.add(priceFraction);\n    }, new Fraction('0')).divide(priceFractions.length.toString());\n  }, [DAIWETH, USDCWETH]);\n  return price.equalTo('0') ? undefined : price;\n}\nexport function useUSDTokenPrice(token) {\n  var USDETHPrice = useUSDETHPrice();\n  var DAIWETH = useDirectPair(USDETHPrice ? DAI : undefined, WETH[ChainId.MAINNET]);\n  var USDCWETH = useDirectPair(USDETHPrice ? USDC : undefined, WETH[ChainId.MAINNET]);\n  var tokenWETH = useDirectPair((token === null || token === void 0 ? void 0 : token.chainId) === ChainId.MAINNET ? token : undefined, WETH[ChainId.MAINNET]);\n  var tokenDAI = useDirectPair((token === null || token === void 0 ? void 0 : token.chainId) === ChainId.MAINNET ? token : undefined, DAI);\n  var tokenUSDC = useDirectPair((token === null || token === void 0 ? void 0 : token.chainId) === ChainId.MAINNET ? token : undefined, USDC);\n  var price = useMemo(function () {\n    // early return if the token is WETH\n    if (token && token.equals(WETH[ChainId.MAINNET])) {\n      return USDETHPrice || new Fraction('0');\n    }\n\n    var priceFractions = []; // if the token has a WETH pair with at least 5 ETH\n\n    if (token && USDETHPrice && tokenWETH && tokenWETH.reserveOf(WETH[ChainId.MAINNET]).greaterThan(JSBI.BigInt(5))) {\n      var ETHTokenPrice = new Route([tokenWETH], token).midPrice.adjusted;\n      priceFractions.push(USDETHPrice.multiply(ETHTokenPrice));\n    } // if DAIWETH pair exists and the token has a DAI pair with at least 1000 DAI\n\n\n    if (token && USDETHPrice && DAIWETH && tokenDAI && tokenDAI.reserveOf(DAI).greaterThan(JSBI.BigInt(1000))) {\n      var WETHDAIPrice = new Route([DAIWETH], DAI).midPrice.adjusted;\n      var DAITokenPrice = new Route([tokenDAI], token).midPrice.adjusted;\n      priceFractions.push(USDETHPrice.multiply(WETHDAIPrice).multiply(DAITokenPrice));\n    } // if USDCWETH pair exists and the token has a USDC pair with at least 1000 USDC\n\n\n    if (token && USDETHPrice && USDCWETH && tokenUSDC && tokenUSDC.reserveOf(USDC).greaterThan(JSBI.BigInt(1000))) {\n      var WETHUSDCPrice = new Route([USDCWETH], USDC).midPrice.adjusted;\n      var USDCTokenPrice = new Route([tokenUSDC], token).midPrice.adjusted;\n      priceFractions.push(USDETHPrice.multiply(WETHUSDCPrice).multiply(USDCTokenPrice));\n    }\n\n    priceFractions = priceFractions.filter(function (price) {\n      return !!price;\n    });\n    return priceFractions.reduce(function (accumulator, priceFraction) {\n      return accumulator.add(priceFraction);\n    }, new Fraction('0')).divide(priceFractions.length.toString());\n  }, [tokenWETH, token, USDETHPrice, DAIWETH, tokenDAI, USDCWETH, tokenUSDC]);\n  return price.equalTo('0') ? undefined : price;\n}","map":null,"metadata":{},"sourceType":"module"}