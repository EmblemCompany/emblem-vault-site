{"ast":null,"code":"import React from \"react\";\nvar __jsx = React.createElement;\nimport { FormControl, FormLabel, FormHelperText, Input, Stack, Box, Flex, Text, Textarea, Button, Link, Select } from '@chakra-ui/core';\nimport { useRouter } from 'next/router';\nimport { useEffect, useState } from 'react';\nimport { EMBLEM_API } from '../constants';\nimport Loader from 'react-loader';\nimport { usePapaParse } from 'react-papaparse';\nimport ReactMarkdown from 'react-markdown';\nimport gfm from 'remark-gfm';\nimport Embed from './Embed';\nexport default function Batch() {\n  const {\n    query\n  } = useRouter();\n  const {\n    0: running,\n    1: setRunning\n  } = useState(false);\n  const {\n    0: offset,\n    1: setOffset\n  } = useState(Number(query.offset) || 0);\n  const {\n    0: status,\n    1: setStatus\n  } = useState('configure');\n  const {\n    0: batches,\n    1: setBatches\n  } = useState([]);\n  const {\n    0: demoIndex,\n    1: setDemoIndex\n  } = useState(-1);\n  const {\n    0: action,\n    1: setAction\n  } = useState(query.action || 'list');\n  const {\n    0: batchVaults,\n    1: setBatchVaults\n  } = useState([]);\n  const {\n    0: updateCount,\n    1: setUpdateCount\n  } = useState(0);\n  const {\n    0: batchName,\n    1: setBatchName\n  } = useState(\"\");\n  const {\n    0: imageBaseUrl,\n    1: setImageBaseUrl\n  } = useState(\"\");\n  const {\n    0: inscriptionBaseUrl,\n    1: setInscriptionBaseUrl\n  } = useState(\"\");\n  const {\n    0: addressType,\n    1: setAddressType\n  } = useState(\"\");\n  const {\n    0: titleTemplate,\n    1: setTitleTemplate\n  } = useState(\"\");\n  const {\n    0: descriptionTemplate,\n    1: setDescriptionTemplate\n  } = useState(\"\");\n  const {\n    0: total,\n    1: setTotal\n  } = useState(\"\");\n  const {\n    0: batchData,\n    1: setBatchData\n  } = useState(\"\");\n  const {\n    0: batchDataJson,\n    1: setBatchDataJson\n  } = useState([]);\n  const {\n    0: batchId,\n    1: setBatchId\n  } = useState(query.batch_id || \"\");\n  const {\n    0: state,\n    1: setState\n  } = useState({\n    loaded: false\n  });\n  const {\n    0: vaultAddresses,\n    1: setVaultAddresses\n  } = useState([]);\n  const {\n    readString,\n    jsonToCSV\n  } = usePapaParse();\n  useEffect(() => {\n    if (!state.loaded && batchId && !batchName) {\n      getBatch();\n      getVaultsForBatch(batchId.toString(), () => {});\n    } else if (!state.loaded && !batchId && !batchName && action == 'list') {\n      getBatches();\n    } else {\n      setState({\n        loaded: true\n      });\n    }\n  }, []);\n\n  const getBatch = async () => {\n    var requestOptions = {\n      method: 'GET'\n    };\n    fetch(EMBLEM_API + `/batch?batchId=${batchId}`, requestOptions).then(async response => {\n      let record = await response.json();\n      setState({\n        loaded: true\n      });\n      setBatchName(record.batch_name);\n      setImageBaseUrl(record.image_base_url);\n      setInscriptionBaseUrl(record.inscription_base_url);\n      setAddressType(record.address_type);\n      setStatus(record.status);\n      setTitleTemplate(record.title_template);\n      setDescriptionTemplate(record.description_template);\n      let parsedJson = JSON.parse(record.data);\n      setBatchDataJson(parsedJson);\n      let csvData = jsonToCSV(parsedJson);\n      setBatchData(csvData);\n      setTotal((parsedJson.length - 1).toString());\n    }).catch(err => {\n      console.log(err);\n    });\n  };\n\n  const getVaultsForBatch = async (batchId, cb) => {\n    // alert(0)\n    var requestOptions = {\n      method: 'GET'\n    };\n    fetch(EMBLEM_API + \"/batchVaults/\" + batchId + \"?_vercel_no_cache=1\", requestOptions).then(async response => {\n      let records = await response.json();\n      setBatchVaults(records);\n      let exported_records = records.map(record => {\n        console.log(exported_records);\n        return {\n          to: record.to,\n          tokenId: record.tokenId,\n          address: record.addresses.filter(addy => {\n            return addy.coin == 'TAP';\n          })[0].address\n        };\n      }); // address: record.addresses.filter(addy=>{return addy.coin == 'LTC'})[0].address, tokenId: record.tokenId, owner: record.to\n      // let addresses = records.map(record=>{ return {tokenId: record.tokenId}})\n\n      let csvData = jsonToCSV(exported_records.reverse());\n      setVaultAddresses(csvData);\n      console.log(csvData);\n      return cb();\n    }).catch(err => {\n      console.log(err);\n    });\n  };\n\n  const goUpdateLoop = async () => {\n    var requestOptions = {\n      method: 'GET'\n    };\n    fetch(EMBLEM_API + `/updateNextBatchItem/${batchId}?offset=${offset}&_vercel_no_cache=1`, requestOptions).then(async response => {\n      let record = await response.json();\n      setUpdateCount(record.index);\n      goUpdateLoop();\n    }).catch(err => {\n      console.log(err);\n      goUpdateLoop();\n    });\n  };\n\n  const goCreateLoop = async () => {\n    var requestOptions = {\n      method: 'GET'\n    };\n    fetch(EMBLEM_API + \"/createNextBatchItem?_vercel_no_cache=1\", requestOptions).then(async response => {\n      // let records = await response.json()\n      getVaultsForBatch(batchId.toString(), () => {\n        setTimeout(() => {\n          goCreateLoop();\n        }, 10000);\n      });\n    }).catch(err => {\n      console.log(err);\n      goCreateLoop();\n    });\n  };\n\n  const getBatches = async () => {\n    var requestOptions = {\n      method: 'GET'\n    };\n    fetch(EMBLEM_API + `/batches`, requestOptions).then(async response => {\n      let records = await response.json();\n      console.log(records);\n      setBatches(records);\n      setState({\n        loaded: true\n      });\n    }).catch(err => {\n      console.log(err);\n    });\n  };\n\n  const startBatch = async () => {\n    var myHeaders = new Headers();\n    myHeaders.append(\"Content-Type\", \"application/json\");\n    var raw = JSON.stringify({\n      \"batchId\": batchId\n    });\n    var requestOptions = {\n      method: 'POST',\n      headers: myHeaders,\n      body: raw\n    };\n    fetch(EMBLEM_API + \"/startBatch\", requestOptions).then(async response => {\n      let results = await response.json();\n      location.href = \"/batch?action=view&batch_id=\" + batchId;\n    });\n  };\n\n  const handleSubmit = async event => {\n    event.preventDefault();\n    var myHeaders = new Headers();\n    myHeaders.append(\"Content-Type\", \"application/json\");\n    let jsonData = await csvToJson(batchData);\n    const serializedForm = {\n      batchName,\n      imageBaseUrl,\n      inscriptionBaseUrl,\n      addressType,\n      titleTemplate,\n      descriptionTemplate,\n      total,\n      batchId,\n      batchData: jsonData.data\n    };\n    fetch(EMBLEM_API + '/addBatch', {\n      method: 'POST',\n      headers: myHeaders,\n      body: JSON.stringify(serializedForm)\n    }).then(async response => {\n      let data = await response.json();\n\n      if (data.id) {\n        setBatchId(data.id);\n      }\n    }).catch(err => {\n      console.log(err);\n    });\n  };\n\n  function csvToJson(data) {\n    return new Promise((resolve, reject) => {\n      readString(data, {\n        worker: true,\n        complete: results => {\n          resolve(results);\n        }\n      });\n    });\n  }\n\n  function parseTemplate(index, template) {\n    let tokens = listTokens(template);\n    let modifiedTitle = template;\n    tokens.forEach(item => {\n      let value = item == 'batch_name' ? batchName : item == 'asset_number' ? batchDataJson[index][0] : item == 'inscription_number' ? batchDataJson[index][1] : item == 'inscription_base_url' ? inscriptionBaseUrl : item == 'inscription_hash' ? batchDataJson[index][2] : '';\n      modifiedTitle = modifiedTitle.replace(item, value);\n    });\n    modifiedTitle = modifiedTitle.replaceAll('{', '').replaceAll('}', '');\n    return modifiedTitle;\n  }\n\n  function parseImage(index) {\n    return imageBaseUrl + batchDataJson[index][2];\n  }\n\n  function parseTo(index) {\n    return batchDataJson[index][3];\n  }\n\n  function listTokens(str) {\n    let regex = /\\{(.*?)\\}/g;\n    let result;\n    let items = [];\n\n    while (result = regex.exec(str)) {\n      items = items.concat(result[1].split(','));\n    }\n\n    return items;\n  }\n\n  function isValidBatchData(statusCheck) {\n    if (!batchDataJson) return false;\n    let hasRows = batchDataJson.length > 1;\n    if (!hasRows) return false; // alert(JSON.stringify(batchDataJson))\n\n    let correctColumns = batchDataJson[0].length == 4;\n    let correctHeaders = batchDataJson[0][0] == 'asset_number' && batchDataJson[0][1] == 'inscription_number' && batchDataJson[0][2] == 'inscription_hash' && batchDataJson[0][3] == 'to';\n    let batchNotStarted = status == statusCheck || 'configure';\n    return hasRows && correctColumns && correctHeaders && batchNotStarted;\n  }\n\n  return __jsx(Loader, {\n    loaded: state.loaded\n  }, __jsx(Flex, {\n    width: \"full\",\n    align: \"center\",\n    justifyContent: \"center\"\n  }, action && (action == 'edit' || action == 'add') ? __jsx(React.Fragment, null, __jsx(Stack, null, __jsx(Box, {\n    maxW: \"sm\",\n    borderWidth: \"1px\",\n    rounded: \"lg\",\n    overflow: \"hidden\"\n  }, __jsx(Stack, null, __jsx(Link, {\n    margin: \"10px\",\n    href: \"/batch?action=list\"\n  }, \" All Batch Jobs\"), batchId ? __jsx(Link, {\n    margin: \"10px\",\n    href: \"/batch?action=view&batch_id=\" + batchId\n  }, \" View Job\") : null), __jsx(\"form\", {\n    onSubmit: handleSubmit\n  }, __jsx(Stack, {\n    direction: \"row\",\n    align: \"flex-start\",\n    padding: \"25px\",\n    spacing: \"2rem\",\n    flexWrap: \"wrap\",\n    shouldWrapChildren: true\n  }, __jsx(FormControl, {\n    isRequired: true\n  }, __jsx(FormLabel, {\n    htmlFor: \"batch-name\"\n  }, \"Batch Name\"), __jsx(Input, {\n    type: \"text\",\n    id: \"batch-name\",\n    \"aria-describedby\": \"batch-name-text\",\n    value: batchName,\n    onChange: e => setBatchName(e.target.value),\n    autoComplete: \"off\"\n  }), __jsx(FormHelperText, {\n    id: \"batch-name-text\"\n  }, \"Give it a unique name for this batch.\")), __jsx(FormControl, {\n    isRequired: true\n  }, __jsx(FormLabel, {\n    htmlFor: \"image-base-url\"\n  }, \"Image Base Url\"), __jsx(Input, {\n    type: \"text\",\n    id: \"image-base-url\",\n    \"aria-describedby\": \"image-base-url-text\",\n    value: imageBaseUrl,\n    onChange: e => setImageBaseUrl(e.target.value),\n    autoComplete: \"off\"\n  }), __jsx(FormHelperText, {\n    id: \"image-base-url-text\"\n  }, \"Enter the base url for the images in this batch.\")), __jsx(FormControl, {\n    isRequired: true\n  }, __jsx(FormLabel, {\n    htmlFor: \"inscription-base-url\"\n  }, \"Inscription Base Url\"), __jsx(Input, {\n    type: \"text\",\n    id: \"inscription-base-url\",\n    \"aria-describedby\": \"inscription-base-url-text\",\n    value: inscriptionBaseUrl,\n    onChange: e => setInscriptionBaseUrl(e.target.value),\n    autoComplete: \"off\"\n  }), __jsx(FormHelperText, {\n    id: \"inscription-base-url-text\"\n  }, \"Enter the base url for the inscriptions in this batch.\")), __jsx(FormControl, {\n    isRequired: true\n  }, __jsx(FormLabel, {\n    htmlFor: \"address-type\"\n  }, \"Address Type\"), __jsx(Input, {\n    type: \"text\",\n    id: \"address-type\",\n    \"aria-describedby\": \"address-type-text\",\n    value: addressType,\n    onChange: e => setAddressType(e.target.value),\n    autoComplete: \"off\"\n  }), __jsx(FormHelperText, {\n    id: \"address-type-text\"\n  }, \"Enter the address type for the items in this batch.\")), __jsx(FormControl, {\n    isRequired: true\n  }, __jsx(FormLabel, {\n    htmlFor: \"title-template\"\n  }, \"Title Template\"), __jsx(Textarea, {\n    id: \"title-template\",\n    fontSize: 'x-small',\n    size: \"lg\",\n    \"aria-describedby\": \"title-template-text\",\n    minLength: 3,\n    maxLength: 4024,\n    value: titleTemplate,\n    onChange: e => setTitleTemplate(e.target.value),\n    autoComplete: \"off\"\n  }), __jsx(FormHelperText, {\n    id: \"title-template-text\"\n  }, \"Enter the title template for the items in this batch.\")), __jsx(FormControl, {\n    isRequired: true\n  }, __jsx(FormLabel, {\n    htmlFor: \"description-template\"\n  }, \"Description Template\"), __jsx(Textarea, {\n    id: \"description-template\",\n    fontSize: 'x-small',\n    size: \"lg\",\n    \"aria-describedby\": \"description-template-text\",\n    minLength: 3,\n    maxLength: 1024,\n    value: descriptionTemplate,\n    onChange: e => setDescriptionTemplate(e.target.value),\n    autoComplete: \"off\"\n  }), __jsx(FormHelperText, {\n    id: \"description-template-text\"\n  }, \"Enter the description template for the items in this batch.\")), __jsx(FormControl, {\n    isRequired: true\n  }, __jsx(FormLabel, {\n    htmlFor: \"total\"\n  }, \"Total\"), __jsx(Input, {\n    isDisabled: true,\n    type: \"number\",\n    id: \"total\",\n    \"aria-describedby\": \"total-text\",\n    value: total,\n    onChange: e => setTotal(e.target.value),\n    autoComplete: \"off\"\n  }), __jsx(FormHelperText, {\n    id: \"total-text\"\n  }, \"Enter the total number of items in this batch.\")), __jsx(FormControl, {\n    isRequired: true\n  }, __jsx(FormLabel, {\n    htmlFor: \"description-template\"\n  }, \"Records\"), __jsx(Textarea, {\n    id: \"records\",\n    size: \"lg\",\n    fontSize: 'xx-small',\n    \"aria-describedby\": \"records-text\",\n    minLength: 3,\n    value: batchData,\n    onChange: async e => {\n      setBatchData(e.target.value);\n      let jsonData = await csvToJson(e.target.value);\n      setBatchDataJson(jsonData.data);\n      setTotal(jsonData.data.length > 1 ? (jsonData.data.length - 1).toString() : '0');\n    },\n    autoComplete: \"off\"\n  }), __jsx(FormHelperText, {\n    id: \"records-text\"\n  }, \"Enter the CSV rows from the helper spreadsheet\"))), __jsx(Stack, {\n    direction: \"row\",\n    align: \"flex-start\",\n    padding: \"15px\",\n    spacing: \"2rem\",\n    flexWrap: \"wrap\",\n    shouldWrapChildren: true\n  }, __jsx(Button, {\n    mt: 4,\n    type: \"submit\",\n    isDisabled: false\n  }, \"Save Batch Job\"), __jsx(Button, {\n    mt: 4,\n    isDisabled: !isValidBatchData('configure') || !isValidBatchData('running'),\n    onClick: startBatch\n  }, \"Start Batch Job\")), __jsx(Stack, {\n    direction: \"row\",\n    align: \"flex-start\",\n    padding: \"15px\",\n    spacing: \"2rem\",\n    flexWrap: \"wrap\",\n    shouldWrapChildren: true\n  }, !isValidBatchData('running') && isValidBatchData('configure') ? __jsx(Select, {\n    id: \"type-selector\",\n    w: \"100%\",\n    value: demoIndex,\n    onChange: e => {\n      setDemoIndex(Number(e.target.value));\n    }\n  }, __jsx(\"option\", {\n    value: \"-1\"\n  }, \"Select # to preview\"), batchDataJson.map((item, index) => {\n    console.log(item);\n\n    if (index > 0) {\n      return __jsx(\"option\", {\n        value: index\n      }, parseTemplate(index, titleTemplate));\n    }\n  })) : null), __jsx(Stack, null, demoIndex && demoIndex > -1 ? __jsx(React.Fragment, null, __jsx(Text, {\n    mt: 2,\n    as: \"h4\",\n    ml: \"4\",\n    mr: \"4\",\n    fontSize: \"xs\",\n    fontStyle: \"italic\",\n    className: \"md\"\n  }, __jsx(ReactMarkdown, {\n    plugins: [gfm],\n    children: parseTemplate(demoIndex, descriptionTemplate)\n  })), __jsx(Embed, {\n    className: \"d-block w-100 NFT-image\",\n    url: parseImage(demoIndex)\n  }), __jsx(Text, null, \"Vault For: \", parseTo(demoIndex))) : null))))) : action == 'list' ? __jsx(Box, {\n    maxW: \"lg\",\n    borderWidth: \"1px\",\n    rounded: \"lg\",\n    overflow: \"hidden\"\n  }, batches.length > 0 ? batches.map((item, index) => {\n    return __jsx(Stack, null, __jsx(Link, {\n      margin: \"10px\",\n      href: \"/batch?action=edit&batch_id=\" + item.id\n    }, \" \", item.batch_name, \" (\", item.status, \")\"));\n  }) : null, __jsx(Link, {\n    margin: \"10px\",\n    href: \"/batch?action=add\"\n  }, \" Add New Batch\")) : action == 'view' ? __jsx(Box, {\n    maxW: \"lg\",\n    margin: \"10px\",\n    borderWidth: \"1px\",\n    rounded: \"lg\",\n    overflow: \"hidden\"\n  }, __jsx(Stack, null, __jsx(Link, {\n    margin: \"10px\",\n    href: \"/batch?action=list\"\n  }, \" All Batch Jobs\"), batchId ? __jsx(Link, {\n    margin: \"10px\",\n    href: \"/batch?action=edit&batch_id=\" + batchId\n  }, \" Edit Job\") : null, __jsx(Text, {\n    padding: \"10px\"\n  }, batchVaults.length, \" of \", total, \" vaults created\"), __jsx(Text, {\n    padding: \"10px\"\n  }, updateCount, \" of \", total, \" vaults updated\"), __jsx(Link, {\n    padding: \"10px\",\n    isDisabled: running,\n    onClick: () => {\n      goCreateLoop();\n      setRunning(true);\n    }\n  }, \"Start Mint Loop\"), __jsx(Link, {\n    padding: \"10px\",\n    isDisabled: running,\n    onClick: () => {\n      goUpdateLoop();\n    }\n  }, \"Start Update Loop\"), __jsx(Link, {\n    padding: \"10px\",\n    href: `${location.href.replace(`offset=${offset}`, `offset=${offset + 25}`)}`,\n    isDisabled: running,\n    onClick: () => {}\n  }, \"spawn offset\")), __jsx(Textarea, {\n    id: \"addresses\",\n    size: \"lg\",\n    fontSize: 'xx-small',\n    \"aria-describedby\": \"addresses-text\",\n    minLength: 3,\n    value: JSON.stringify(vaultAddresses),\n    autoComplete: \"off\"\n  }), __jsx(Link, {\n    padding: \"10px\",\n    isDisabled: running,\n    onClick: () => {\n      goCreateLoop();\n      setRunning(true);\n    }\n  }, \"Start Mint Loop\")) : null));\n}","map":null,"metadata":{},"sourceType":"module"}