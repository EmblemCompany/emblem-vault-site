{"ast":null,"code":"var __jsx = React.createElement;\nimport React, { useEffect, useState } from 'react';\nimport { Modal, ModalOverlay, ModalContent, ModalHeader, ModalCloseButton, ModalBody, ModalFooter, Text, Stack, Button, useColorMode, Select, Input } from '@chakra-ui/core';\nimport copy from 'copy-to-clipboard';\nimport { COLOR, contractAddresses } from '../constants';\nimport { useWeb3React } from '@web3-react/core';\nimport { NETWORK_SHORTNAMES } from '../utils'; // import { useContract } from '../hooks'\n\nimport { Contract } from '@ethersproject/contracts';\nimport { HStack } from '@chakra-ui/react';\nimport { TransactionToast } from './TransactionToast';\nimport { addTokenToWallet } from '../public/web3';\nexport const EMBLEM_API = 'https://api.emblemvault.io';\nexport default function OfferModal({\n  isOpen,\n  onClose,\n  tokenId,\n  mine\n}) {\n  //   const address = addrAddr\n  //   const coin = addrCoin\n  const {\n    colorMode\n  } = useColorMode();\n  const {\n    account,\n    chainId,\n    library\n  } = useWeb3React();\n  const {\n    0: copied,\n    1: setCopied\n  } = useState(false);\n  const {\n    0: loading,\n    1: setLoading\n  } = useState(false);\n  const {\n    0: loaded,\n    1: setLoaded\n  } = useState(false);\n  const {\n    0: offeringToken,\n    1: setOfferingToken\n  } = useState({\n    address: '',\n    balance: 0,\n    tokenType: '',\n    name: ''\n  });\n  const {\n    0: tokenBalances,\n    1: setTokenBalances\n  } = useState([]);\n  const {\n    0: offeringTokenBalance,\n    1: setOfferingTokenBalance\n  } = useState(0);\n  const {\n    0: acct,\n    1: setAcct\n  } = useState('');\n  const {\n    0: decimals,\n    1: setDecimals\n  } = useState(0);\n  const {\n    0: allowance,\n    1: setAllowance\n  } = useState(0);\n  const {\n    0: approvedForAll,\n    1: setApprovedForAll\n  } = useState(false);\n  const {\n    0: offerAmount,\n    1: setOfferAmount\n  } = useState(0);\n  const {\n    0: offerTokenId,\n    1: setOfferTokenId\n  } = useState(0);\n  const {\n    0: offers,\n    1: setOffers\n  } = useState([]);\n  const {\n    0: myOffers,\n    1: setMyOffers\n  } = useState([]);\n  const {\n    0: hash,\n    1: setHash\n  } = useState(null);\n  const {\n    0: selectedNFTs,\n    1: setSelectedNFTs\n  } = useState([]); // const [offeringTokenId, setOfferingTokenId] = useState()\n\n  const getErc20Contract = address => {\n    console.log(\"contract\", address);\n    return useContract(address, contractAddresses.covalAbi, true);\n  };\n\n  const getVaultContract = (address = null) => {\n    return useContract(address || contractAddresses.emblemVault[chainId], contractAddresses.emblemAbi, true);\n  };\n\n  const getTradeContract = () => {\n    return useContract(contractAddresses.nftrade[chainId], contractAddresses.nftradeAbi, true);\n  };\n\n  const useContract = (address, ABI, withSigner = false) => {\n    return new Contract(address, ABI, withSigner ? library.getSigner(account).connectUnchecked() : library);\n  };\n\n  useEffect(() => {\n    if (account && acct != account) {\n      setAcct(account);\n      setLoaded(false);\n    }\n  }, [account, acct]);\n  useEffect(() => {\n    if (copied) {\n      const timeout = setTimeout(() => {\n        setCopied(false);\n      }, 750);\n      return () => {\n        clearTimeout(timeout);\n      };\n    }\n  }, [copied]);\n  useEffect(() => {\n    if (!loaded && !loading) {\n      setLoading(true);\n      getBalances(account, async balances => {\n        setTokenBalances(balances);\n        getOfferContractInfo();\n        setLoading(false);\n        setLoaded(true);\n      });\n    }\n  });\n\n  const handleApprove = async address => {\n    let contract = getErc20Contract(address);\n    console.log('decimals', decimals);\n    await contract.approve(contractAddresses.nftrade[chainId], offeringTokenBalance * Math.pow(10, +decimals)).then(({\n      hash\n    }) => {\n      setHash(hash);\n    });\n  };\n\n  const handleApproveForAll = async () => {\n    let contract = getVaultContract();\n    await contract.setApprovalForAll(contractAddresses.nftrade[chainId], true).then(({\n      hash\n    }) => {\n      setHash(hash);\n    });\n  };\n\n  const getApprovedForAll = async (address = null) => {\n    let contract = getVaultContract(address);\n    let approved = await contract.isApprovedForAll(account, contractAddresses.nftrade[chainId]);\n    console.log('---approved', approved);\n    setApprovedForAll(approved);\n  };\n\n  const getNFTContractInfo = async address => {\n    let contract = getVaultContract(address);\n    let count = await contract.balanceOf(account);\n    console.log('--------------- NFT Info', account, 'owns', count.toNumber());\n    let nftCollection = [];\n    getSingleNFT(0, () => {\n      console.log(\"GOT ALL NFTs\", nftCollection);\n      setSelectedNFTs(nftCollection);\n    });\n\n    async function getSingleNFT(index, cb) {\n      let nftInfo = await contract.tokenOfOwnerByIndex(account, index);\n      nftCollection.push(nftInfo.toNumber());\n\n      if (index + 1 >= count) {\n        return cb();\n      } else {\n        return getSingleNFT(index + 1, cb);\n      }\n    }\n  };\n\n  const makeOffer = async () => {\n    let contract = getTradeContract(); // console.log(offeringToken.address, offerTokenId, contractAddresses.emblemVault[chainId], tokenId, offerAmount* Math.pow(10, +decimals))\n\n    await contract.addOffer(offeringToken.address, offerTokenId, contractAddresses.emblemVault[chainId], tokenId, offerAmount * Math.pow(10, +decimals)).then(({\n      hash\n    }) => {\n      setHash(hash);\n    });\n  };\n\n  const withdrawOffer = async index => {\n    let contract = getTradeContract(); // console.log(offeringToken.address, offerTokenId, contractAddresses.emblemVault[chainId], tokenId, offerAmount* Math.pow(10, +decimals))\n\n    await contract.withdrawOffer(contractAddresses.emblemVault[chainId], tokenId, index).then(({\n      hash\n    }) => {\n      setHash(hash);\n    });\n  };\n\n  const rejectOffer = async index => {\n    let contract = getTradeContract(); // console.log(offeringToken.address, offerTokenId, contractAddresses.emblemVault[chainId], tokenId, offerAmount* Math.pow(10, +decimals))\n\n    await contract.rejectOffer(contractAddresses.emblemVault[chainId], tokenId, index).then(({\n      hash\n    }) => {\n      setHash(hash);\n    });\n  };\n\n  const acceptOffer = async index => {\n    let contract = getTradeContract(); // console.log(offeringToken.address, offerTokenId, contractAddresses.emblemVault[chainId], tokenId, offerAmount* Math.pow(10, +decimals))\n\n    await contract.acceptOffer(contractAddresses.emblemVault[chainId], tokenId, index).then(({\n      hash\n    }) => {\n      setHash(hash);\n    });\n  };\n\n  const getTokenContractInfo = async address => {\n    let contract = getErc20Contract(address); // console.log(contract)\n\n    let _dec = await contract.decimals();\n\n    setDecimals(_dec);\n    setAllowance(await contract.allowance(account, contractAddresses.nftrade[chainId]).then(balance => (balance * Math.pow(10, -_dec)).toString()));\n    setOfferingTokenBalance(await contract.balanceOf(account).then(balance => (balance * Math.pow(10, -_dec)).toString()));\n  };\n\n  const getOfferContractInfo = async () => {\n    let contract = getTradeContract();\n    let offerCount = (await contract.getOfferCount(contractAddresses.emblemVault[chainId], tokenId)).toNumber();\n\n    if (mine) {\n      getApprovedForAll();\n    }\n\n    let offers = [];\n    let myOffers = [];\n\n    if (offerCount > 0) {\n      getSingleOffer(0, () => {\n        setOffers(offers);\n        setMyOffers(myOffers); // console.log('offers', offers, myOffers)\n      });\n    }\n\n    async function getSingleOffer(index, cb) {\n      let _offer = await contract.getOffer(contractAddresses.emblemVault[chainId], tokenId, index);\n\n      console.log('-------', _offer);\n\n      if (_offer.token !== \"0x0000000000000000000000000000000000000000\") {\n        let offer = {\n          tokenId: _offer.tokenId.toNumber(),\n          _from: _offer._from,\n          token: _offer.token,\n          amount: _offer.amount\n        };\n        let tokenContract = getErc20Contract(offer.token);\n        let tokenName = await tokenContract.name();\n        let tokenDecimals = await tokenContract.decimals();\n        let tokenSymbol = await tokenContract.symbol();\n        offer.symbol = tokenSymbol;\n        offer.name = tokenName;\n        offer.decimals = tokenDecimals;\n        offer.index = index;\n        offer.amount = offer.amount.toNumber() * Math.pow(10, -tokenDecimals);\n        offer.address = offer.token;\n        offers.push(offer); // console.log('-----', offer)\n\n        if (offer._from == account) {\n          myOffers.push(offer);\n        }\n      }\n\n      if (index + 1 >= offerCount) {\n        return cb();\n      } else {\n        return getSingleOffer(index + 1, cb);\n      }\n    }\n\n    console.log(offerCount);\n  };\n\n  const getBalances = async (address, cb) => {\n    const responce = await fetch(EMBLEM_API + '/' + NETWORK_SHORTNAMES[chainId] + '/balance/' + address, {\n      method: 'GET',\n      headers: {\n        'Content-Type': 'application/json',\n        service: 'evmetadata'\n      }\n    });\n    const jsonData = await responce.json(); // console.log(Number(vaultTotalValue), Number(jsonData.totalValue))\n    // setVaultTotalValue(Number(vaultTotalValue) + Number(jsonData.totalValue))\n    // console.log('get eth balances', jsonData.values)\n\n    return cb(jsonData.values);\n  };\n\n  function copyWithFlag(content) {\n    copy(content);\n    setCopied(true);\n  }\n\n  return __jsx(Modal, {\n    isOpen: isOpen,\n    onClose: onClose,\n    isCentered: true\n  }, __jsx(ModalOverlay, null), __jsx(ModalContent, {\n    color: COLOR[colorMode]\n  }, __jsx(ModalHeader, null, __jsx(Text, null, !mine ? 'Make' : null, \" Offer\", mine ? 's' : null, \" for: \", tokenId)), __jsx(ModalCloseButton, null), __jsx(ModalBody, null, !mine ? __jsx(Stack, {\n    direction: \"column\"\n  }, __jsx(Stack, {\n    mt: \"6\"\n  }, __jsx(Text, null, \"Choose your Offer Token\"), __jsx(Select, {\n    w: \"100%\",\n    value: offeringToken.address,\n    onChange: e => {\n      if (e.target.value !== '0') {\n        let token = tokenBalances.filter(item => {\n          return item.address == e.target.value;\n        })[0];\n        setOfferingToken(token);\n        token.tokenType == \"ERC-20\" ? getTokenContractInfo(token.address) : getNFTContractInfo(token.address);\n        console.log(tokenBalances.filter(item => {\n          return item.address == e.target.value;\n        })[0]);\n        console.log(e.target.value);\n      }\n    }\n  }, __jsx(\"option\", {\n    value: \"0\"\n  }, \"Choose a Token\"), tokenBalances.map((coin, index) => {\n    if (coin.tokenType !== 'native') return __jsx(\"option\", {\n      value: coin.address\n    }, coin.name);\n  })), offeringToken.balance > 0 && offeringToken.tokenType == \"ERC-20\" && allowance > 0 ? __jsx(React.Fragment, null, __jsx(Text, null, \"Max: \", offeringTokenBalance), __jsx(Input, {\n    onChange: e => setOfferAmount(e.target.value)\n  })) : null), __jsx(Stack, {\n    direction: \"row\",\n    justify: \"center\"\n  }, offeringToken.tokenType == 'ERC-20' ? offeringTokenBalance > 0 && allowance == 0 ? __jsx(Button, {\n    onClick: () => {\n      handleApprove(offeringToken.address);\n    }\n  }, \"Approve offer of \", offeringToken.name) : offeringToken && offeringTokenBalance == 0 ? __jsx(Text, null, \"Insufficient Balance\") : __jsx(Button, {\n    onClick: () => {\n      makeOffer();\n    }\n  }, \"Make Offer\") : selectedNFTs.length > 0 ? __jsx(Select, {\n    width: \"100%\",\n    onChange: e => {\n      if (e.target.value !== '0') {\n        console.log(\"Picked TokenID: \", e.target.value, offeringToken);\n        setOfferTokenId(Number(e.target.value));\n        getApprovedForAll(offeringToken.address);\n      }\n    }\n  }, __jsx(\"option\", {\n    value: \"0\"\n  }, \"Select TokenId\"), selectedNFTs.map((tokenId, index) => {\n    return __jsx(\"option\", {\n      value: tokenId\n    }, tokenId);\n  })) : null, offeringToken.name && offeringToken.tokenType != \"ERC-20\" && !approvedForAll && offerTokenId != 0 ? __jsx(Button, {\n    onClick: () => {\n      handleApprove(offeringToken.address);\n    }\n  }, \"Approve offer of \", offeringToken.name) : offeringToken.name && offeringToken.tokenType != \"ERC-20\" && approvedForAll ? __jsx(Button, {\n    onClick: () => {\n      makeOffer();\n    }\n  }, \"Make Offer\") : null), __jsx(Stack, null, __jsx(Text, null, \"My Offers\"), myOffers.map((offer, index) => {\n    return __jsx(HStack, null, __jsx(Text, null, offer.name, \" \", offer.amount), __jsx(Button, {\n      onClick: () => {\n        withdrawOffer(offer.index);\n      }\n    }, \"Withdraw Offer\"));\n  }))) : null, mine ? __jsx(Stack, {\n    direction: \"column\"\n  }, !approvedForAll ? __jsx(Button, {\n    onClick: () => {\n      handleApproveForAll();\n    }\n  }, \"Allow accepting of Offers\") : null, __jsx(Text, null, \"Offers\"), offers.map((offer, index) => {\n    return __jsx(HStack, null, __jsx(Text, {\n      onClick: () => {\n        addTokenToWallet(offer);\n      }\n    }, offer.name, \" \", offer.amount), __jsx(Button, {\n      onClick: () => {\n        rejectOffer(offer.index);\n      }\n    }, \"Reject Offer\"), approvedForAll ? __jsx(Button, {\n      onClick: () => {\n        acceptOffer(offer.index);\n      }\n    }, \"Accept Offer\") : null);\n  })) : null, hash ? __jsx(TransactionToast, {\n    hash: hash,\n    onComplete: () => {\n      setHash(null);\n      setLoaded(false);\n    }\n  }) : null), __jsx(ModalFooter, null)));\n}","map":null,"metadata":{},"sourceType":"module"}