{"ast":null,"code":"import { useCallback, useEffect, useState, useMemo, useRef } from 'react';\nimport { useWeb3React } from '@web3-react/core';\nimport { Route, WETH, ChainId, TradeType, Trade, Fraction, JSBI } from '@uniswap/sdk';\nimport { injected } from './connectors';\nimport { useReserves, useBlockNumber } from './data';\nimport { Contract } from '@ethersproject/contracts';\nimport { useRouter } from 'next/router';\nimport { QueryParameters } from './constants';\nimport { getAddress } from '@ethersproject/address';\nimport { DAI, USDC } from './tokens';\nexport function useWindowSize() {\n  function getSize() {\n    const isClient = false;\n    return {\n      width: isClient ? window.innerWidth : undefined,\n      height: isClient ? window.innerHeight : undefined\n    };\n  }\n\n  const {\n    0: windowSize,\n    1: setWindowSize\n  } = useState(getSize());\n  useEffect(() => {\n    const handleResize = () => {\n      setWindowSize(getSize());\n    };\n\n    window.addEventListener('resize', handleResize);\n    return () => {\n      window.removeEventListener('resize', handleResize);\n    };\n  }, []);\n  return windowSize;\n} // https://usehooks.com/useDebounce/\n\nexport function useDefaultedDebounce(value, initialValue, delay) {\n  const {\n    0: defaultedDebounce,\n    1: setDefaultedDebounce\n  } = useState(initialValue);\n  useEffect(() => {\n    const handler = setTimeout(() => {\n      setDefaultedDebounce(value);\n    }, delay);\n    return () => {\n      clearTimeout(handler);\n      setDefaultedDebounce(initialValue);\n    };\n  }, [value, initialValue, delay]);\n  return defaultedDebounce;\n} // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\nexport function useBodyKeyDown(targetKey, onKeyDown, suppress = false) {\n  const downHandler = useCallback(event => {\n    if (!suppress && event.key === targetKey && event.target.tagName === 'BODY' && !event.altKey && !event.ctrlKey && !event.metaKey && !event.shiftKey) {\n      onKeyDown(event);\n    }\n  }, [suppress, targetKey, onKeyDown]);\n  useEffect(() => {\n    window.addEventListener('keydown', downHandler);\n    return () => {\n      window.removeEventListener('keydown', downHandler);\n    };\n  }, [suppress, targetKey, downHandler]);\n} // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\nexport function useKeepSWRDataLiveAsBlocksArrive(mutate) {\n  // because we don't care about the referential identity of mutate, just bind it to a ref\n  const mutateRef = useRef(mutate);\n  useEffect(() => {\n    mutateRef.current = mutate;\n  }); // then, whenever a new block arrives, trigger a mutation\n\n  const {\n    data\n  } = useBlockNumber();\n  useEffect(() => {\n    mutateRef.current();\n  }, [data]);\n}\nexport function useEagerConnect() {\n  const {\n    activate,\n    active\n  } = useWeb3React();\n  const {\n    0: tried,\n    1: setTried\n  } = useState(false);\n  useEffect(() => {\n    injected.isAuthorized().then(isAuthorized => {\n      if (isAuthorized) {\n        activate(injected, undefined, true).catch(() => {\n          setTried(true);\n        });\n      } else {\n        setTried(true);\n      }\n    });\n  }, [activate]); // if the connection worked, wait until we get confirmation of that to flip the flag\n\n  useEffect(() => {\n    if (!tried && active) {\n      setTried(true);\n    }\n  }, [tried, active]);\n  return tried;\n}\nconst chainMappings = {\n  '1': 1,\n  mainnet: 1,\n  '3': 3,\n  ropsten: 3,\n  '4': 4,\n  rinkeby: 4,\n  '5': 5,\n  gÃ¶rli: 5,\n  goerli: 5,\n  '42': 42,\n  kovan: 42,\n  '80001': 80001,\n  mumbai: 80001\n};\nexport function useQueryParameters() {\n  const {\n    query\n  } = useRouter();\n  let candidateChainId;\n\n  try {\n    candidateChainId = chainMappings[query[QueryParameters.CHAIN]];\n  } catch {}\n\n  const chainId = !!injected.supportedChainIds && typeof candidateChainId === 'number' && injected.supportedChainIds.includes(candidateChainId) ? candidateChainId : undefined;\n  let input;\n\n  try {\n    if (typeof query[QueryParameters.INPUT] === 'string') input = getAddress(query[QueryParameters.INPUT]);\n  } catch {}\n\n  let output;\n\n  try {\n    if (typeof query[QueryParameters.OUTPUT] === 'string') output = getAddress(query[QueryParameters.OUTPUT]);\n  } catch {}\n\n  return useMemo(() => ({\n    [QueryParameters.CHAIN]: chainId,\n    [QueryParameters.INPUT]: input,\n    [QueryParameters.OUTPUT]: output\n  }), [chainId, input, output]);\n}\n\nfunction useDirectPair(inputToken, outputToken) {\n  const {\n    data: pair\n  } = useReserves(inputToken, outputToken);\n\n  if (!!inputToken && !!outputToken && inputToken.equals(outputToken)) {\n    return null;\n  }\n\n  return pair;\n}\n\nexport function useRoute(inputToken, outputToken) {\n  // direct pair\n  const directPair = useDirectPair(inputToken, outputToken); // WETH pairs\n\n  const WETHInputPair = useDirectPair(inputToken ? WETH[inputToken.chainId] : undefined, inputToken);\n  const WETHOutputPair = useDirectPair(outputToken ? WETH[outputToken.chainId] : undefined, outputToken); // DAI pairs\n\n  const DAIInputPair = useDirectPair((inputToken === null || inputToken === void 0 ? void 0 : inputToken.chainId) === ChainId.MAINNET ? DAI : undefined, inputToken);\n  const DAIOutputPair = useDirectPair((outputToken === null || outputToken === void 0 ? void 0 : outputToken.chainId) === ChainId.MAINNET ? DAI : undefined, outputToken); // USDC pairs\n\n  const USDCInputPair = useDirectPair((inputToken === null || inputToken === void 0 ? void 0 : inputToken.chainId) === ChainId.MAINNET ? USDC : undefined, inputToken);\n  const USDCOutputPair = useDirectPair((outputToken === null || outputToken === void 0 ? void 0 : outputToken.chainId) === ChainId.MAINNET ? USDC : undefined, outputToken); // connecting pairs\n\n  const DAIWETH = useDirectPair((inputToken === null || inputToken === void 0 ? void 0 : inputToken.chainId) === ChainId.MAINNET ? DAI : undefined, WETH[DAI.chainId]);\n  const USDCWETH = useDirectPair((inputToken === null || inputToken === void 0 ? void 0 : inputToken.chainId) === ChainId.MAINNET ? USDC : undefined, WETH[USDC.chainId]);\n  const DAIUSDC = useDirectPair((inputToken === null || inputToken === void 0 ? void 0 : inputToken.chainId) === ChainId.MAINNET ? DAI : undefined, (inputToken === null || inputToken === void 0 ? void 0 : inputToken.chainId) === ChainId.MAINNET ? USDC : undefined);\n  const pairs = [directPair, WETHInputPair, WETHOutputPair, DAIInputPair, DAIOutputPair, USDCInputPair, USDCOutputPair, DAIWETH, USDCWETH, DAIUSDC].filter((p, i, pairs) => {\n    // filter out invalid pairs or pairs whose data hasn't been fetched yet\n    if (!!!p) {\n      return false;\n    } else {\n      return i === pairs.findIndex(pair => {\n        var _pair$liquidityToken;\n\n        return (pair === null || pair === void 0 ? void 0 : (_pair$liquidityToken = pair.liquidityToken) === null || _pair$liquidityToken === void 0 ? void 0 : _pair$liquidityToken.address) === p.liquidityToken.address;\n      });\n    }\n  });\n  const directRoute = useMemo(() => directPair && inputToken ? new Route([directPair], inputToken) : directPair === null ? null : undefined, [directPair, inputToken]);\n  const WETHRoute = useMemo(() => WETHInputPair && WETHOutputPair && inputToken ? new Route([WETHInputPair, WETHOutputPair], inputToken) : WETHInputPair === null || WETHOutputPair === null ? null : undefined, [WETHInputPair, WETHOutputPair, inputToken]);\n  const DAIRoute = useMemo(() => DAIInputPair && DAIOutputPair && inputToken ? new Route([DAIInputPair, DAIOutputPair], inputToken) : DAIInputPair === null || DAIOutputPair === null ? null : undefined, [DAIInputPair, DAIOutputPair, inputToken]);\n  const USDCRoute = useMemo(() => USDCInputPair && USDCOutputPair && inputToken ? new Route([USDCInputPair, USDCOutputPair], inputToken) : USDCInputPair === null || USDCOutputPair === null ? null : undefined, [USDCInputPair, USDCOutputPair, inputToken]);\n  const routes = [directRoute, WETHRoute, DAIRoute, USDCRoute];\n  return [routes.filter(route => !!route).length > 0 ? routes.filter(route => !!route)[0] : routes.some(route => route === undefined) ? undefined : null, pairs];\n}\nexport function useTrade(inputToken, outputToken, pairs, independentAmount, tradeType) {\n  const canCompute = !!inputToken && !!outputToken && pairs.length > 0 && !!independentAmount;\n  let trade;\n\n  if (canCompute) {\n    if (tradeType === TradeType.EXACT_INPUT) {\n      trade = Trade.bestTradeExactIn(pairs, independentAmount, outputToken, {\n        maxNumResults: 1\n      })[0];\n    } else {\n      trade = Trade.bestTradeExactOut(pairs, inputToken, independentAmount, {\n        maxNumResults: 1\n      })[0];\n    }\n  }\n\n  return trade;\n}\nexport function useContract(address, ABI, withSigner = false) {\n  const {\n    library,\n    account\n  } = useWeb3React();\n  return useMemo(() => !!address && !!ABI && !!library ? new Contract(address, ABI, withSigner ? library.getSigner(account).connectUnchecked() : library) : undefined, [address, ABI, withSigner, library, account]);\n}\nexport function useUSDETHPrice() {\n  const {\n    chainId\n  } = useWeb3React();\n  const DAIWETH = useDirectPair(chainId === ChainId.MAINNET ? DAI : undefined, WETH[ChainId.MAINNET]);\n  const USDCWETH = useDirectPair(chainId === ChainId.MAINNET ? USDC : undefined, WETH[ChainId.MAINNET]);\n  const price = useMemo(() => {\n    var _Route, _Route$midPrice, _Route2, _Route2$midPrice;\n\n    const priceFractions = [DAIWETH && ((_Route = new Route([DAIWETH], WETH[ChainId.MAINNET])) === null || _Route === void 0 ? void 0 : (_Route$midPrice = _Route.midPrice) === null || _Route$midPrice === void 0 ? void 0 : _Route$midPrice.adjusted), USDCWETH && ((_Route2 = new Route([USDCWETH], WETH[ChainId.MAINNET])) === null || _Route2 === void 0 ? void 0 : (_Route2$midPrice = _Route2.midPrice) === null || _Route2$midPrice === void 0 ? void 0 : _Route2$midPrice.adjusted)].filter(price => !!price);\n    return priceFractions.reduce((accumulator, priceFraction) => accumulator.add(priceFraction), new Fraction('0')).divide(priceFractions.length.toString());\n  }, [DAIWETH, USDCWETH]);\n  return price.equalTo('0') ? undefined : price;\n}\nexport function useUSDTokenPrice(token) {\n  const USDETHPrice = useUSDETHPrice();\n  const DAIWETH = useDirectPair(USDETHPrice ? DAI : undefined, WETH[ChainId.MAINNET]);\n  const USDCWETH = useDirectPair(USDETHPrice ? USDC : undefined, WETH[ChainId.MAINNET]);\n  const tokenWETH = useDirectPair((token === null || token === void 0 ? void 0 : token.chainId) === ChainId.MAINNET ? token : undefined, WETH[ChainId.MAINNET]);\n  const tokenDAI = useDirectPair((token === null || token === void 0 ? void 0 : token.chainId) === ChainId.MAINNET ? token : undefined, DAI);\n  const tokenUSDC = useDirectPair((token === null || token === void 0 ? void 0 : token.chainId) === ChainId.MAINNET ? token : undefined, USDC);\n  const price = useMemo(() => {\n    // early return if the token is WETH\n    if (token && token.equals(WETH[ChainId.MAINNET])) {\n      return USDETHPrice || new Fraction('0');\n    }\n\n    let priceFractions = []; // if the token has a WETH pair with at least 5 ETH\n\n    if (token && USDETHPrice && tokenWETH && tokenWETH.reserveOf(WETH[ChainId.MAINNET]).greaterThan(JSBI.BigInt(5))) {\n      const ETHTokenPrice = new Route([tokenWETH], token).midPrice.adjusted;\n      priceFractions.push(USDETHPrice.multiply(ETHTokenPrice));\n    } // if DAIWETH pair exists and the token has a DAI pair with at least 1000 DAI\n\n\n    if (token && USDETHPrice && DAIWETH && tokenDAI && tokenDAI.reserveOf(DAI).greaterThan(JSBI.BigInt(1000))) {\n      const WETHDAIPrice = new Route([DAIWETH], DAI).midPrice.adjusted;\n      const DAITokenPrice = new Route([tokenDAI], token).midPrice.adjusted;\n      priceFractions.push(USDETHPrice.multiply(WETHDAIPrice).multiply(DAITokenPrice));\n    } // if USDCWETH pair exists and the token has a USDC pair with at least 1000 USDC\n\n\n    if (token && USDETHPrice && USDCWETH && tokenUSDC && tokenUSDC.reserveOf(USDC).greaterThan(JSBI.BigInt(1000))) {\n      const WETHUSDCPrice = new Route([USDCWETH], USDC).midPrice.adjusted;\n      const USDCTokenPrice = new Route([tokenUSDC], token).midPrice.adjusted;\n      priceFractions.push(USDETHPrice.multiply(WETHUSDCPrice).multiply(USDCTokenPrice));\n    }\n\n    priceFractions = priceFractions.filter(price => !!price);\n    return priceFractions.reduce((accumulator, priceFraction) => accumulator.add(priceFraction), new Fraction('0')).divide(priceFractions.length.toString());\n  }, [tokenWETH, token, USDETHPrice, DAIWETH, tokenDAI, USDCWETH, tokenUSDC]);\n  return price.equalTo('0') ? undefined : price;\n}","map":null,"metadata":{},"sourceType":"module"}