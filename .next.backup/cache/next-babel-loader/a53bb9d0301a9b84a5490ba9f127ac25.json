{"ast":null,"code":"var __jsx = React.createElement;\nimport React, { useEffect, useState } from 'react';\nimport { Modal, ModalOverlay, ModalContent, ModalHeader, ModalCloseButton, ModalBody, ModalFooter, Text, Stack, Button, useColorMode, Select, Input, Box, useDisclosure, Link } from '@chakra-ui/core';\n// import { Accordion } from 'react-bootstrap';\nimport copy from 'copy-to-clipboard';\nimport { COLOR, contractAddresses } from '../constants';\nimport { useWeb3React } from '@web3-react/core';\nimport { ExplorerTXType, formatEtherscanLink, NETWORK_SHORTNAMES } from '../utils'; // import { useContract } from '../hooks'\n\nimport { Contract } from '@ethersproject/contracts';\nimport { TransactionToast } from './TransactionToast';\nimport Embed from './Embed';\nexport const EMBLEM_API = 'https://api.emblemvault.io';\nexport default function OfferModal({\n  isOpen,\n  onClose,\n  tokenId,\n  mine\n}) {\n  //   const address = addrAddr\n  //   const coin = addrCoin\n  const {\n    colorMode\n  } = useColorMode();\n  const {\n    account,\n    chainId,\n    library\n  } = useWeb3React();\n  const {\n    0: copied,\n    1: setCopied\n  } = useState(false);\n  const {\n    0: loading,\n    1: setLoading\n  } = useState(false);\n  const {\n    0: loaded,\n    1: setLoaded\n  } = useState(false);\n  const {\n    0: offeringToken,\n    1: setOfferingToken\n  } = useState({\n    address: '',\n    balance: 0,\n    tokenType: '',\n    name: '',\n    symbol: ''\n  });\n  const {\n    0: tokenBalances,\n    1: setTokenBalances\n  } = useState([]);\n  const {\n    0: offeringTokenBalance,\n    1: setOfferingTokenBalance\n  } = useState(0);\n  const {\n    0: acct,\n    1: setAcct\n  } = useState('');\n  const {\n    0: decimals,\n    1: setDecimals\n  } = useState(0);\n  const {\n    0: allowance,\n    1: setAllowance\n  } = useState(0);\n  const {\n    0: approvedForAll,\n    1: setApprovedForAll\n  } = useState(false);\n  const {\n    0: offerAmount,\n    1: setOfferAmount\n  } = useState(0);\n  const {\n    0: offerTokenId,\n    1: setOfferTokenId\n  } = useState(0);\n  const {\n    0: offers,\n    1: setOffers\n  } = useState([]);\n  const {\n    0: myOffers,\n    1: setMyOffers\n  } = useState([]);\n  const {\n    0: hash,\n    1: setHash\n  } = useState(null);\n  const {\n    0: selectedNFTs,\n    1: setSelectedNFTs\n  } = useState([]);\n  const {\n    0: makeOfferPrice,\n    1: setMakeOfferPrice\n  } = useState(0);\n  const {\n    0: payToMakeOffer,\n    1: setPayToMakeOffer\n  } = useState(false);\n  const {\n    0: acceptOfferPrice,\n    1: setAcceptOfferPrice\n  } = useState(0);\n  const {\n    0: payToAcceptOffer,\n    1: setPayToAcceptOffer\n  } = useState(false);\n  const {\n    0: paymentToken,\n    1: setPaymentToken\n  } = useState(null);\n  const {\n    0: paymentDecimals,\n    1: setPaymentDecimals\n  } = useState(0);\n  const {\n    isOpen: isDetailOpen,\n    onToggle: onDetailToggle\n  } = useDisclosure();\n  const {\n    0: takePercentageOfERC20,\n    1: setTakePercentageOfERC20\n  } = useState(false);\n  const {\n    0: percentageOfERC20,\n    1: setPercentageOfERC20\n  } = useState(0); // const [offeringTokenId, setOfferingTokenId] = useState()\n\n  const getMetadata = async function (uri, cb) {\n    // alert(0)\n    uri = uri.replace('http://104.154.252.216', 'https://api.emblemvault.io/s:evmetadata');\n    let responce;\n\n    try {\n      responce = await fetch(uri, {\n        method: 'GET',\n        headers: {// redirect:'follow'\n        }\n      });\n      let jsonData = await responce.json();\n      return cb(jsonData);\n    } catch (err) {\n      // alert(0)\n      return cb(false);\n    }\n  };\n\n  const getErc20Contract = address => {\n    console.log(\"contract\", address);\n    return useContract(address, contractAddresses.covalAbi, true);\n  };\n\n  const getVaultContract = (address = null) => {\n    return useContract(address || contractAddresses.emblemVault[chainId], contractAddresses.emblemAbi, true);\n  };\n\n  const getTradeContract = () => {\n    return useContract(contractAddresses.nftrade[chainId], contractAddresses.nftradeAbi, true);\n  };\n\n  const useContract = (address, ABI, withSigner = false) => {\n    return new Contract(address, ABI, withSigner ? library.getSigner(account).connectUnchecked() : library);\n  };\n\n  useEffect(() => {\n    if (account && acct != account) {\n      setAcct(account);\n      setLoaded(false);\n    }\n  }, [account, acct]);\n  useEffect(() => {\n    if (copied) {\n      const timeout = setTimeout(() => {\n        setCopied(false);\n      }, 750);\n      return () => {\n        clearTimeout(timeout);\n      };\n    }\n  }, [copied]);\n  useEffect(() => {\n    if (!loaded && !loading) {\n      setLoading(true);\n      getBalances(account, async balances => {\n        setTokenBalances(balances);\n        getOfferContractInfo();\n        setLoaded(true);\n        setLoading(false);\n      });\n    }\n  });\n\n  const handleApprove = async (address, _decimals = decimals) => {\n    let contract = getErc20Contract(address);\n    console.log('decimals', decimals);\n    await contract.approve(contractAddresses.nftrade[chainId], offeringTokenBalance * Math.pow(10, +_decimals)).then(({\n      hash\n    }) => {\n      setHash(hash);\n    });\n  };\n\n  const handleApproveForAll = async (address = null) => {\n    let contract = getVaultContract(address);\n    await contract.setApprovalForAll(contractAddresses.nftrade[chainId], true).then(({\n      hash\n    }) => {\n      setHash(hash);\n    });\n  };\n\n  const getApprovedForAll = async (address = null) => {\n    let contract = getVaultContract(address);\n    let approved = await contract.isApprovedForAll(account, contractAddresses.nftrade[chainId]); // console.log('---approved', approved)\n\n    setApprovedForAll(approved);\n  };\n\n  const getNFTContractInfo = async address => {\n    let contract = getVaultContract(address);\n    let count = await contract.balanceOf(account); // console.log('--------------- NFT Info', account, 'owns', count.toNumber())\n\n    let nftCollection = [];\n    getSingleNFT(0, () => {\n      // console.log(\"GOT ALL NFTs\", nftCollection)\n      setSelectedNFTs(nftCollection);\n    });\n\n    async function getSingleNFT(index, cb) {\n      let nftInfo = await contract.tokenOfOwnerByIndex(account, index);\n      nftCollection.push(nftInfo.toNumber());\n\n      if (index + 1 >= count) {\n        return cb();\n      } else {\n        return getSingleNFT(index + 1, cb);\n      }\n    }\n  };\n\n  const makeOffer = async () => {\n    let contract = getTradeContract(); // console.log(offeringToken.address, offerTokenId, contractAddresses.emblemVault[chainId], tokenId, offerAmount* Math.pow(10, +decimals))\n\n    await contract.addOffer(offeringToken.address, offerTokenId, contractAddresses.emblemVault[chainId], tokenId, offerAmount * Math.pow(10, +decimals)).then(({\n      hash\n    }) => {\n      setHash(hash);\n    });\n  };\n\n  const withdrawOffer = async index => {\n    let contract = getTradeContract(); // console.log(offeringToken.address, offerTokenId, contractAddresses.emblemVault[chainId], tokenId, offerAmount* Math.pow(10, +decimals))\n\n    await contract.withdrawOffer(contractAddresses.emblemVault[chainId], tokenId, index).then(({\n      hash\n    }) => {\n      setHash(hash);\n    });\n  };\n\n  const rejectOffer = async index => {\n    let contract = getTradeContract(); // console.log(offeringToken.address, offerTokenId, contractAddresses.emblemVault[chainId], tokenId, offerAmount* Math.pow(10, +decimals))\n\n    await contract.rejectOffer(contractAddresses.emblemVault[chainId], tokenId, index).then(({\n      hash\n    }) => {\n      setHash(hash);\n    });\n  };\n\n  const acceptOffer = async index => {\n    let contract = getTradeContract(); // console.log(offeringToken.address, offerTokenId, contractAddresses.emblemVault[chainId], tokenId, offerAmount* Math.pow(10, +decimals))\n\n    await contract.acceptOffer(contractAddresses.emblemVault[chainId], tokenId, index).then(({\n      hash\n    }) => {\n      setHash(hash);\n    });\n  };\n\n  const getTokenContractInfo = async address => {\n    let contract = getErc20Contract(address); // console.log(contract)\n\n    let _dec = await contract.decimals();\n\n    setDecimals(_dec);\n    setAllowance(await contract.allowance(account, contractAddresses.nftrade[chainId]).then(balance => (balance * Math.pow(10, -_dec)).toString()));\n    setOfferingTokenBalance(await contract.balanceOf(account).then(balance => (balance * Math.pow(10, -_dec)).toString()));\n  };\n\n  const getOfferContractInfo = async () => {\n    let contract = getTradeContract();\n\n    let _paymentToken = await contract.paymentAddress();\n\n    setPaymentToken(_paymentToken);\n    await getTokenContractInfo(_paymentToken);\n    let offerCount = (await contract.getOfferCount(contractAddresses.emblemVault[chainId], tokenId)).toNumber();\n\n    let _payToMakeOffer = await contract.payToMakeOffer();\n\n    setPayToMakeOffer(_payToMakeOffer);\n\n    let _makeOfferPrice = (await contract.makeOfferPrice()).toNumber();\n\n    setMakeOfferPrice(_makeOfferPrice);\n\n    let _payToAcceptOffer = await contract.payToAcceptOffer();\n\n    setPayToAcceptOffer(_payToAcceptOffer);\n\n    let _acceptOfferPrice = (await contract.acceptOfferPrice()).toNumber();\n\n    setAcceptOfferPrice(_acceptOfferPrice);\n    let tokenContract = getErc20Contract(_paymentToken);\n\n    let _takePercentageOfERC20 = await contract.takePercentageOfERC20();\n\n    setTakePercentageOfERC20(_takePercentageOfERC20);\n\n    let _percentageOfERC20 = (await contract.percentageFee()).toNumber();\n\n    setPercentageOfERC20(_percentageOfERC20);\n    console.log('-----%', _takePercentageOfERC20, _percentageOfERC20);\n    console.log('dec', await tokenContract.decimals());\n    setPaymentDecimals(await tokenContract.decimals());\n    console.log('_paymentToken', _paymentToken);\n    getApprovedForAll();\n    console.log('--------- payment ---------', _payToMakeOffer, _makeOfferPrice, _payToAcceptOffer, _acceptOfferPrice, _paymentToken, allowance);\n    console.log('------ offer count ------', offerCount); // let offers = []\n    // let myOffers = []\n\n    if (offerCount > 0) {\n      getSingleOffer(0, [], [], (offers, myOffers) => {\n        setOffers(offers);\n        setMyOffers(myOffers);\n        console.log('offers', offers, myOffers);\n      });\n    }\n\n    async function getSingleOffer(index, offers, myOffers, cb) {\n      let _offer = await contract.getOffer(contractAddresses.emblemVault[chainId], tokenId, index);\n\n      console.log('-------', _offer);\n\n      if (_offer.token !== \"0x0000000000000000000000000000000000000000\") {\n        let offer = {\n          tokenId: _offer.tokenId.toNumber(),\n          _from: _offer._from,\n          token: _offer.token,\n          amount: _offer.amount\n        };\n        let tokenContract = getErc20Contract(offer.token);\n        let tokenName = await tokenContract.name();\n        console.log('----- name ----', tokenName);\n        offer.name = tokenName;\n        offer.index = index;\n        offer.address = offer.token;\n        console.log('----- offer tokenid ----', _offer.tokenId.toNumber());\n\n        if (_offer.tokenId.toNumber() == 0) {\n          let tokenDecimals = await tokenContract.decimals();\n          let tokenSymbol = await tokenContract.symbol();\n          offer.symbol = tokenSymbol;\n          offer.decimals = tokenDecimals;\n          offer.amount = offer.amount.toNumber() * Math.pow(10, -tokenDecimals);\n          offers.push(offer);\n\n          if (offer._from == account) {\n            myOffers.push(offer);\n          }\n\n          finished();\n        } else {\n          let nftContract = getVaultContract(offer.token);\n          let tokenMetadata = await nftContract.tokenURI(offer.tokenId);\n          tokenMetadata = tokenMetadata.replace('ipfs://', 'https://gateway.ipfs.io/');\n          console.log('---------URI---------', tokenMetadata);\n          getMetadata(tokenMetadata, metadata => {\n            console.log('metadata', metadata);\n            offer.metadata = metadata;\n            offer.amount = _offer.amount.toNumber();\n            offer.tokenId = _offer.tokenId.toNumber();\n            offers.push(offer);\n\n            if (offer._from == account) {\n              myOffers.push(offer);\n            }\n\n            finished();\n          });\n        }\n      } else {\n        console.log('----- wtf -----');\n        finished();\n      }\n\n      function finished() {\n        if (index + 1 >= offerCount) {\n          return cb(offers, myOffers);\n        } else {\n          return getSingleOffer(index + 1, offers, myOffers, cb);\n        }\n      }\n    } // console.log(offerCount)\n\n  };\n\n  const getBalances = async (address, cb) => {\n    if (mine) return cb([]);\n    const responce = await fetch(EMBLEM_API + '/' + NETWORK_SHORTNAMES[chainId] + '/balance/' + address, {\n      method: 'GET',\n      headers: {\n        'Content-Type': 'application/json',\n        service: 'evmetadata'\n      }\n    });\n    const jsonData = await responce.json();\n    return cb(jsonData.values);\n  };\n\n  function copyWithFlag(content) {\n    copy(content);\n    setCopied(true);\n  }\n\n  return __jsx(Modal, {\n    isOpen: isOpen,\n    onClose: onClose,\n    isCentered: true\n  }, __jsx(ModalOverlay, null), __jsx(ModalContent, {\n    color: COLOR[colorMode]\n  }, __jsx(ModalHeader, null, __jsx(Text, null, !mine ? 'Make' : null, \" Offer\", mine ? 's' : null, \" for: \", tokenId)), __jsx(ModalCloseButton, null), __jsx(ModalBody, null, !mine ? __jsx(Stack, {\n    direction: \"column\"\n  }, __jsx(Stack, {\n    mt: \"6\"\n  }, __jsx(Text, null, \"Choose your Offer Token\"), __jsx(Select, {\n    w: \"100%\",\n    value: offeringToken.address,\n    onChange: e => {\n      if (e.target.value !== '0') {\n        let token = tokenBalances.filter(item => {\n          return item.address == e.target.value;\n        })[0];\n        console.log(token);\n        setOfferingToken(token);\n        setOfferTokenId(0);\n        token.tokenType == \"ERC-20\" ? getTokenContractInfo(token.address) : getNFTContractInfo(token.address);\n        console.log(tokenBalances.filter(item => {\n          return item.address == e.target.value;\n        })[0]);\n        console.log(e.target.value);\n      }\n    }\n  }, __jsx(\"option\", {\n    value: \"0\"\n  }, \"Choose a Token\"), tokenBalances.map((coin, index) => {\n    if (coin.tokenType !== 'native') return __jsx(\"option\", {\n      value: coin.address\n    }, coin.name);\n  })), offeringToken.balance > 0 && offeringToken.tokenType == \"ERC-20\" && allowance > 0 ? __jsx(React.Fragment, null, __jsx(Text, null, \"Max: \", Number(offeringTokenBalance) > Number(allowance) ? allowance : offeringTokenBalance, \" \"), __jsx(Input, {\n    onChange: e => setOfferAmount(e.target.value)\n  })) : null), __jsx(Stack, {\n    direction: \"row\",\n    justify: \"center\"\n  }, offeringToken.tokenType == 'ERC-20' ? offeringTokenBalance > 0 && allowance == 0 ? __jsx(Button, {\n    onClick: () => {\n      handleApprove(offeringToken.address);\n    }\n  }, \"Approve offer of \", offeringToken.name) : offeringToken && offeringTokenBalance == 0 ? __jsx(Text, null, \"Insufficient Balance\") : __jsx(Button, {\n    onClick: () => {\n      makeOffer();\n    }\n  }, \"Make Offer\") : selectedNFTs.length > 0 ? __jsx(Select, {\n    width: \"100%\",\n    onChange: e => {\n      if (e.target.value !== '0') {\n        // console.log(\"Picked TokenID: \", e.target.value, offeringToken)\n        setOfferTokenId(Number(e.target.value));\n        getApprovedForAll(offeringToken.address);\n      }\n    }\n  }, __jsx(\"option\", {\n    key: -1,\n    value: \"0\"\n  }, \"Select TokenId\"), selectedNFTs.map((tokenId, index) => {\n    return __jsx(\"option\", {\n      key: index,\n      value: tokenId\n    }, tokenId);\n  })) : null, offeringToken.name && offeringToken.tokenType != \"ERC-20\" && !approvedForAll && offerTokenId != 0 ? __jsx(Button, {\n    width: \"100%\",\n    onClick: () => {\n      handleApproveForAll(offeringToken.address);\n    }\n  }, \"Approve \", offeringToken.name) : offeringToken.name && offeringToken.tokenType != \"ERC-20\" && approvedForAll ? __jsx(Button, {\n    onClick: () => {\n      makeOffer();\n    }\n  }, \"Make Offer\") : null), payToMakeOffer ? __jsx(Text, null, \" Cost: \", acceptOfferPrice * Math.pow(10, -paymentDecimals), \" $Coval to make offers\") : null, takePercentageOfERC20 && offeringToken.tokenType == \"ERC-20\" && offerAmount ? __jsx(React.Fragment, null, __jsx(Text, null, \"Fee: \", percentageOfERC20, \"%  (\", offerAmount * (percentageOfERC20 / 100), \" \", offeringToken.symbol, \")\")) : null, __jsx(Stack, {\n    maxHeight: \"200px\",\n    overflow: \"scroll\"\n  }, myOffers.length > 0 ? __jsx(Text, {\n    as: \"h2\"\n  }, \"My Offers\") : null, payToMakeOffer && offeringTokenBalance > 0 && allowance * Math.pow(10, +paymentDecimals) < makeOfferPrice ? __jsx(React.Fragment, null, __jsx(Button, {\n    onClick: () => {\n      handleApprove(paymentToken, paymentDecimals);\n    }\n  }, \"Approve spending \")) : offeringToken && offeringTokenBalance < makeOfferPrice * Math.pow(10, -paymentDecimals) ? __jsx(Text, null, \"Insufficient Balance\") : null, myOffers.map((offer, index) => {\n    return __jsx(Box, {\n      borderRadius: \"0.25rem\",\n      borderWidth: 1,\n      p: 2,\n      mb: 2\n    }, __jsx(Text, {\n      fontSize: \"bold\",\n      color: colorMode == \"dark\" ? \"lightgreen\" : \"forestgreen\"\n    }, offer.amount > 0 ? offer.amount : null, __jsx(Link, {\n      ml: 3,\n      color: colorMode == \"dark\" ? \"white\" : \"black\",\n      href: formatEtherscanLink(ExplorerTXType.Token, [chainId, offer.token]),\n      isExternal: true\n    }, offer.name), offer.amount < 1 ? ' [' + offer.tokenId + ']' : null), __jsx(Button, {\n      onClick: () => {\n        withdrawOffer(offer.index);\n      },\n      m: 2\n    }, \"Withdraw Offer\"), offer.metadata ? __jsx(Box, null, __jsx(Embed, {\n      className: \"\",\n      url: offer.metadata.image.replace('ipfs://', 'https://gateway.ipfs.io/')\n    })) : null);\n  }))) : null, mine ? __jsx(Box, null, !approvedForAll ? __jsx(Button, {\n    onClick: () => {\n      handleApproveForAll();\n    }\n  }, \"Allow accepting of Offers\") : null, __jsx(Stack, {\n    direction: \"column\",\n    maxHeight: \"200px\",\n    overflow: \"scroll\"\n  }, payToAcceptOffer && offeringTokenBalance > 0 && allowance * Math.pow(10, +paymentDecimals) < acceptOfferPrice ? __jsx(React.Fragment, null, __jsx(Text, null, \"Cost: \", acceptOfferPrice * Math.pow(10, -paymentDecimals), \" $Coval to accept offers\"), __jsx(Button, {\n    onClick: () => {\n      handleApprove(paymentToken, paymentDecimals);\n    }\n  }, \"Approve spending \")) : offeringToken && offeringTokenBalance < acceptOfferPrice * Math.pow(10, -paymentDecimals) ? __jsx(Text, null, \"Insufficient Balance\") : null, offers.map((offer, index) => {\n    return __jsx(Box, {\n      borderRadius: \"0.25rem\",\n      borderWidth: 1,\n      p: 2,\n      mb: 2\n    }, __jsx(Text, {\n      fontSize: \"bold\",\n      color: colorMode == \"dark\" ? \"lightgreen\" : \"forestgreen\"\n    }, offer.amount > 0 ? offer.amount : null, __jsx(Link, {\n      ml: 3,\n      color: colorMode == \"dark\" ? \"white\" : \"black\",\n      href: formatEtherscanLink(ExplorerTXType.Token, [chainId, offer.token]),\n      isExternal: true\n    }, offer.name), offer.amount < 1 ? '[' + offer.tokenId + ']' : null), __jsx(Text, {\n      color: colorMode == \"dark\" ? \"#baaa94\" : \"gray\",\n      fontSize: \"xs\"\n    }, \"From:\", __jsx(Link, {\n      ml: 3,\n      color: colorMode == \"dark\" ? \"white\" : \"darkgray\",\n      href: formatEtherscanLink(ExplorerTXType.Account, [chainId, offer._from]),\n      isExternal: true\n    }, offer._from)), __jsx(Button, {\n      onClick: () => {\n        rejectOffer(offer.index);\n      },\n      m: 2\n    }, \"Reject Offer\"), approvedForAll ? __jsx(Button, {\n      onClick: () => {\n        acceptOffer(offer.index);\n      },\n      m: 2\n    }, \"Accept Offer\") : null, offer.metadata ? __jsx(Box, null, __jsx(Embed, {\n      className: \"\",\n      url: offer.metadata.image.replace('ipfs://', 'https://gateway.ipfs.io/')\n    })) : null);\n  }))) : null, hash ? __jsx(TransactionToast, {\n    hash: hash,\n    onComplete: () => {\n      setHash(null);\n      setLoaded(false);\n    }\n  }) : null), __jsx(ModalFooter, null)));\n}","map":null,"metadata":{},"sourceType":"module"}