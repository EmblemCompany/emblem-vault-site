{"ast":null,"code":"import _JSXStyle from \"styled-jsx/style\";\nimport React from \"react\";\nvar __jsx = React.createElement;\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nimport { useRef, useState, useLayoutEffect, useMemo, Suspense, useEffect } from 'react';\nimport { Token, WETH, ChainId } from '@uniswap/sdk';\nimport { Input, Stack, Text, useColorMode, useTheme, List, ListItem, IconButton, Divider, Spinner, Flex, Icon, Box } from '@chakra-ui/core';\nimport { Combobox, ComboboxInput, ComboboxPopover, ComboboxList, ComboboxOption } from '@reach/combobox';\nimport { getAddress } from '@ethersproject/address';\nimport { useWeb3React } from '@web3-react/core';\nimport { useAllTokens, DEFAULT_TOKENS } from '../tokens';\nimport { getTokenDisplayValue, shortenHex } from '../utils';\nimport TokenLogo, { TokenLogoColor } from './TokenLogo';\nimport { useFirstToken, useSecondToken } from '../context';\nimport { useOnchainToken, useRemoteTokens } from '../data';\nimport { useDefaultedDebounce } from '../hooks';\nimport ErrorBoundary from './ErrorBoundary';\n\nfunction PastedToken({\n  address\n}) {\n  return __jsx(ErrorBoundary, {\n    fallback: __jsx(Flex, {\n      justifyContent: \"center\",\n      width: \"100%\",\n      px: \"1rem\",\n      py: \"0.5rem\"\n    }, __jsx(Icon, {\n      name: \"warning\",\n      size: \"1rem\"\n    }))\n  }, __jsx(Suspense, {\n    fallback: __jsx(Flex, {\n      justifyContent: \"center\",\n      width: \"100%\",\n      px: \"1rem\",\n      py: \"0.5rem\"\n    }, __jsx(Spinner, {\n      color: \"gray.500\",\n      size: \"sm\"\n    }))\n  }, __jsx(PastedTokenData, {\n    address: address\n  })));\n}\n\nfunction PastedTokenData({\n  address\n}) {\n  const {\n    data\n  } = useOnchainToken(address, true);\n  return data === null ? __jsx(Text, {\n    textAlign: \"center\",\n    px: \"1rem\",\n    py: \"0.5rem\"\n  }, \"Invalid token address\") : __jsx(React.Fragment, null, __jsx(Divider, {\n    m: 0\n  }), __jsx(Text, {\n    mx: \"1rem\",\n    my: \"0.5rem\",\n    textAlign: \"center\",\n    fontSize: \"1rem\"\n  }, \"Token Found By Address\"), __jsx(ComboboxList, {\n    as: List\n  }, __jsx(ComboboxOption, {\n    as: ListItem,\n    key: data.address,\n    value: data.address\n  }, __jsx(Stack, {\n    direction: \"row\",\n    align: \"center\",\n    p: \"0.5rem\",\n    shouldWrapChildren: true\n  }, __jsx(TokenLogo, {\n    token: data,\n    size: \"1.5rem\"\n  }), __jsx(Stack, {\n    direction: \"column\",\n    ml: \"1rem\",\n    spacing: 0\n  }, __jsx(Text, null, data.symbol), __jsx(Text, {\n    fontSize: \"1rem\"\n  }, data.name))))));\n}\n\nfunction RemoteTokens({\n  query\n}) {\n  const debouncedValue = useDefaultedDebounce(query, '', 200);\n  return debouncedValue.length === 0 ? null : __jsx(React.Fragment, null, __jsx(Divider, {\n    m: 0\n  }), __jsx(Text, {\n    mx: \"1rem\",\n    my: \"0.5rem\",\n    textAlign: \"center\",\n    fontSize: \"1rem\"\n  }, \"Unverified Tokens\"), __jsx(ErrorBoundary, {\n    fallback: __jsx(Flex, {\n      justifyContent: \"center\",\n      width: \"100%\",\n      pb: \"0.5rem\"\n    }, __jsx(Icon, {\n      name: \"warning\",\n      size: \"1rem\"\n    }))\n  }, __jsx(Suspense, {\n    fallback: __jsx(Flex, {\n      justifyContent: \"center\",\n      width: \"100%\",\n      pb: \"0.5rem\"\n    }, __jsx(Spinner, {\n      color: \"gray.500\",\n      size: \"sm\"\n    }))\n  }, __jsx(RemoteTokensData, {\n    query: query\n  }))));\n}\n\nfunction RemoteTokensData({\n  query\n}) {\n  const {\n    chainId\n  } = useWeb3React();\n  const [tokens] = useAllTokens();\n  const {\n    data: remoteTokensCased\n  } = useRemoteTokens(query, true);\n  const {\n    data: remoteTokensLower\n  } = useRemoteTokens(query.toLowerCase(), true);\n  const {\n    data: remoteTokensUpper\n  } = useRemoteTokens(query.toUpperCase(), true);\n  const remoteTokens = useMemo(() => (remoteTokensCased || []).concat(remoteTokensLower || []).concat(remoteTokensUpper || []), [remoteTokensCased, remoteTokensLower, remoteTokensUpper]);\n  const remoteTokensFiltered = useMemo(() => Array.from(new Set(remoteTokens.map(remoteToken => remoteToken.address))) // get unique addresses\n  .filter(address => !tokens.some(token => token.address === address)) // filter out tokens already in our list\n  .map(address => remoteTokens.find(remoteToken => remoteToken.address === address)), // get the full remote tokens\n  [remoteTokens, tokens]).sort((a, b) => {\n    var _a$symbol, _a$symbol$slice, _b$symbol, _b$symbol$slice;\n\n    const aExact = (a === null || a === void 0 ? void 0 : (_a$symbol = a.symbol) === null || _a$symbol === void 0 ? void 0 : (_a$symbol$slice = _a$symbol.slice(0, query.length)) === null || _a$symbol$slice === void 0 ? void 0 : _a$symbol$slice.toLowerCase()) === query.toLowerCase();\n    const bExact = (b === null || b === void 0 ? void 0 : (_b$symbol = b.symbol) === null || _b$symbol === void 0 ? void 0 : (_b$symbol$slice = _b$symbol.slice(0, query.length)) === null || _b$symbol$slice === void 0 ? void 0 : _b$symbol$slice.toLowerCase()) === query.toLowerCase();\n\n    if (aExact && !bExact) {\n      return -1;\n    } else if (!aExact && bExact) {\n      return 1;\n    } else {\n      var _a$symbol$toLowerCase, _a$symbol2, _b$symbol$toLowerCase, _b$symbol2;\n\n      return ((_a$symbol$toLowerCase = a === null || a === void 0 ? void 0 : (_a$symbol2 = a.symbol) === null || _a$symbol2 === void 0 ? void 0 : _a$symbol2.toLowerCase()) !== null && _a$symbol$toLowerCase !== void 0 ? _a$symbol$toLowerCase : 0) > ((_b$symbol$toLowerCase = b === null || b === void 0 ? void 0 : (_b$symbol2 = b.symbol) === null || _b$symbol2 === void 0 ? void 0 : _b$symbol2.toLowerCase()) !== null && _b$symbol$toLowerCase !== void 0 ? _b$symbol$toLowerCase : 0) ? 1 : -1;\n    }\n  });\n  return remoteTokensFiltered.length === 0 ? __jsx(Text, {\n    textAlign: \"center\",\n    pb: \"0.5rem\"\n  }, \"No results\") : __jsx(ComboboxList, {\n    as: List\n  }, remoteTokensFiltered.map(token => {\n    const DUMMY = new Token(chainId, token.address, 18); // we don't know if it actually has 18 decimals\n\n    return __jsx(ComboboxOption, {\n      as: ListItem,\n      key: token.address,\n      value: token.address\n    }, __jsx(Stack, {\n      direction: \"row\",\n      align: \"center\",\n      p: \"0.5rem\",\n      shouldWrapChildren: true\n    }, __jsx(TokenLogo, {\n      token: DUMMY,\n      size: \"1.5rem\"\n    }), __jsx(Stack, {\n      direction: \"column\",\n      ml: \"1rem\",\n      spacing: 0\n    }, __jsx(Text, null, token.symbol), __jsx(Text, {\n      fontSize: \"1rem\"\n    }, token.name))));\n  }));\n}\n\nexport default function TokenSelect({\n  tokenAddress,\n  isInvalid,\n  isDisabled,\n  onAddressSelect\n}) {\n  const {\n    colors\n  } = useTheme();\n  const {\n    colorMode\n  } = useColorMode();\n  const {\n    chainId\n  } = useWeb3React();\n  const [firstToken] = useFirstToken();\n  const [secondToken] = useSecondToken(); // if the currently selected token address is in our list, pluck it out\n\n  const [tokens, {\n    removeToken\n  }] = useAllTokens();\n  const tokenDerivedFromProps = tokens.filter(token => token.address === tokenAddress)[0];\n  const {\n    0: value,\n    1: setValue\n  } = useState(tokenAddress !== null && tokenAddress !== void 0 ? tokenAddress : ''); // keep the state in sync with the prop\n\n  useEffect(() => {\n    setValue(tokenAddress !== null && tokenAddress !== void 0 ? tokenAddress : '');\n  }, [tokenAddress]); // try to parse the value as an address\n\n  let valueAsAddress;\n\n  try {\n    valueAsAddress = getAddress(value);\n  } catch {\n    valueAsAddress = null;\n  }\n\n  const ref = useRef(null);\n  useLayoutEffect(() => {\n    if (ref.current) ref.current.size = tokenDerivedFromProps ? getTokenDisplayValue(tokenDerivedFromProps).length : valueAsAddress === null ? value.length === 0 ? 7 : value.length : shortenHex(valueAsAddress, 4).length;\n  });\n\n  function onSelect(tokenAddress) {\n    onAddressSelect(tokenAddress);\n  } // set up a hack. when a user has selected a token, and modifies the input text, the value will get cleared, so we\n  // have to store the modified text and reset it after the clear\n\n\n  const {\n    0: temporaryInput,\n    1: setTemporaryInput\n  } = useState();\n  useEffect(() => {\n    if (temporaryInput && !tokenAddress) {\n      setValue(temporaryInput);\n      setTemporaryInput(undefined);\n    }\n  }, [temporaryInput, tokenAddress]);\n\n  function onChange(event) {\n    // try to parse the input as an address\n    let valueAsAddress;\n\n    try {\n      valueAsAddress = getAddress(event.target.value);\n    } catch {\n      valueAsAddress = null;\n    } // if they pasted an address that's already in our list, select it\n\n\n    if (valueAsAddress && tokens.filter(token => token.address === valueAsAddress)[0]) {\n      onSelect(valueAsAddress);\n    } else {\n      if (tokenAddress) {\n        onAddressSelect(undefined); // unset the selected address\n\n        setTemporaryInput(event.target.value); // set the temporary input\n      } else {\n        setValue(event.target.value);\n      }\n    }\n  }\n\n  const filteredTokens = tokens.filter(token => {\n    var _token$name, _token$name$toLowerCa;\n\n    const addressMatch = valueAsAddress === token.address;\n    const displayMatch = value.toLowerCase() === getTokenDisplayValue(token).slice(0, value.length).toLowerCase();\n    const nameMatch = !token.equals(WETH[token.chainId]) && (token === null || token === void 0 ? void 0 : (_token$name = token.name) === null || _token$name === void 0 ? void 0 : (_token$name$toLowerCa = _token$name.toLowerCase()) === null || _token$name$toLowerCa === void 0 ? void 0 : _token$name$toLowerCa.includes(value.toLowerCase()));\n    return addressMatch || displayMatch || nameMatch;\n  }).sort((a, b) => {\n    const aExact = valueAsAddress === a.address || value.toLowerCase() === getTokenDisplayValue(a).slice(0, value.length).toLowerCase();\n    const bExact = valueAsAddress === b.address || value.toLowerCase() === getTokenDisplayValue(b).slice(0, value.length).toLowerCase();\n\n    if (tokenDerivedFromProps && a.equals(tokenDerivedFromProps)) {\n      return -1;\n    } else if (tokenDerivedFromProps && b.equals(tokenDerivedFromProps)) {\n      return 1;\n    } else if (aExact && !bExact) {\n      return -1;\n    } else if (!aExact && bExact) {\n      return 1;\n    } else if (a.equals(WETH[a.chainId])) {\n      return -1;\n    } else if (b.equals(WETH[b.chainId])) {\n      return 1;\n    } else {\n      return getTokenDisplayValue(a).toLowerCase() < getTokenDisplayValue(b).toLowerCase() ? -1 : 1;\n    }\n  });\n  return __jsx(React.Fragment, null, __jsx(Combobox, {\n    openOnFocus: true,\n    onSelect: onSelect\n  }, __jsx(TokenLogoColor, {\n    token: tokenDerivedFromProps\n  }, swatch => __jsx(ComboboxInput, _extends({\n    selectOnClick: true,\n    autocomplete: false,\n    as: Input,\n    ref: ref,\n    value: tokenDerivedFromProps ? getTokenDisplayValue(tokenDerivedFromProps) : valueAsAddress === null ? value : shortenHex(valueAsAddress, 4),\n    onChange: onChange,\n    title: \"Token Select\" // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    ,\n    onCopy: event => {\n      // copy the full address if we've shortened it\n      if (valueAsAddress) {\n        event.preventDefault();\n        event.clipboardData.setData('text/plain', valueAsAddress);\n      }\n    } // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    ,\n    onCut: event => {\n      // cut the full address if we've shortened it\n      if (valueAsAddress) {\n        event.preventDefault();\n        event.clipboardData.setData('text/plain', valueAsAddress); // simulate an onChange\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n        onChange({\n          target: {\n            value: ''\n          }\n        });\n      }\n    } // chakra props\n    ,\n    variant: \"flushed\",\n    placeholder: \"Select\\u2026\",\n    textAlign: \"center\",\n    fontSize: \"1.875rem\"\n  }, !!(swatch === null || swatch === void 0 ? void 0 : swatch.hex) && {\n    color: swatch.hex\n  }, {\n    isInvalid: isInvalid,\n    isDisabled: isDisabled,\n    _disabled: {\n      opacity: 0.4,\n      cursor: 'not-allowed'\n    }\n  }))), __jsx(Box, {\n    maxHeight: 0,\n    position: \"relative\",\n    zIndex: 2\n  }, __jsx(Box, {\n    position: \"absolute\"\n  }, __jsx(ComboboxPopover, {\n    portal: false\n  }, !tokenDerivedFromProps && __jsx(React.Fragment, null, (value === '' || tokenAddress === value) && __jsx(Text, {\n    mx: \"1rem\",\n    my: \"0.5rem\",\n    textAlign: \"center\",\n    color: \"gray.500\"\n  }, \"Paste token address or search\"), __jsx(ComboboxList, {\n    as: List\n  }, filteredTokens.map(token => {\n    const userAdded = !DEFAULT_TOKENS.some(defaultToken => defaultToken.equals(token));\n    return __jsx(ComboboxOption, {\n      as: ListItem,\n      key: token.address,\n      value: token.address\n    }, __jsx(Stack, {\n      direction: \"row\",\n      align: \"center\",\n      p: \"0.5rem\"\n    }, __jsx(Box, null, __jsx(TokenLogo, {\n      token: token,\n      size: \"1.5rem\"\n    })), __jsx(Stack, {\n      direction: \"column\",\n      ml: \"1rem\",\n      spacing: 0,\n      shouldWrapChildren: true\n    }, __jsx(Text, null, getTokenDisplayValue(token)), __jsx(Text, {\n      fontSize: \"1rem\"\n    }, WETH[token.chainId].equals(token) ? 'Ethereum' : token.name)), userAdded && __jsx(Flex, {\n      flexGrow: 1,\n      mb: \"auto\",\n      justifyContent: \"flex-end\"\n    }, __jsx(IconButton, {\n      isDisabled: !!firstToken && firstToken.equals(token) || !!secondToken && secondToken.equals(token),\n      icon: \"close\",\n      variant: \"ghost\",\n      size: \"sm\",\n      \"aria-label\": \"Remove\",\n      onClick: event => {\n        event.preventDefault();\n        removeToken(token);\n      }\n    }))));\n  })), valueAsAddress !== null && !tokens.some(token => token.address === valueAsAddress) ? __jsx(PastedToken, {\n    address: valueAsAddress\n  }) : null, value.length >= 2 && valueAsAddress === null && chainId === ChainId.MAINNET ? __jsx(RemoteTokens, {\n    query: value\n  }) : null))))), __jsx(_JSXStyle, {\n    id: \"3788667905\",\n    dynamic: [colorMode === 'light' ? colors.gray[50] : colors.gray[900], colorMode === 'light' ? 'black' : 'white', colorMode === 'light' ? colors.gray[100] : 'rgba(255,255,255,0.04)', colorMode === 'light' ? colors.gray[100] : 'rgba(255,255,255,0.04)']\n  }, [`[data-reach-combobox-popover]{width:-webkit-max-content !important;width:-moz-max-content !important;width:max-content !important;max-height:25rem;overflow-y:auto;background:${colorMode === 'light' ? colors.gray[50] : colors.gray[900]};color:${colorMode === 'light' ? 'black' : 'white'};border-radius:0.5rem;border-top-left-radius:0;}`, `[data-reach-combobox-list] :hover{background:${colorMode === 'light' ? colors.gray[100] : 'rgba(255,255,255,0.04)'};}`, \"[data-reach-combobox-option]{font-size:1.25rem;background:none;}\", \"[data-reach-combobox-option] :hover{background:none;}\", `[data-reach-combobox-option][data-highlighted]{background:${colorMode === 'light' ? colors.gray[100] : 'rgba(255,255,255,0.04)'} !important;}`]));\n}","map":null,"metadata":{},"sourceType":"module"}