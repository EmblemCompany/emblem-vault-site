{"ast":null,"code":"function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\nimport { ChainId } from '@uniswap/sdk';\nimport { splitSignature, hexDataSlice } from '@ethersproject/bytes';\nimport { PERMIT_AND_CALL_ADDRESS, MAX_UINT256 } from './constants';\nimport { Contract } from '@ethersproject/contracts';\nimport { id } from '@ethersproject/hash';\nimport { defaultAbiCoder } from '@ethersproject/abi';\nconst EIP712Domain = [{\n  name: 'name',\n  type: 'string'\n}, {\n  name: 'version',\n  type: 'string'\n}, {\n  name: 'chainId',\n  type: 'uint256'\n}, {\n  name: 'verifyingContract',\n  type: 'address'\n}];\n\nconst DAIPermitGatherer = async (address, deadline, _, token, library) => {\n  const Permit = [{\n    name: 'holder',\n    type: 'address'\n  }, {\n    name: 'spender',\n    type: 'address'\n  }, {\n    name: 'nonce',\n    type: 'uint256'\n  }, {\n    name: 'expiry',\n    type: 'uint256'\n  }, {\n    name: 'allowed',\n    type: 'bool'\n  }];\n  const domain = {\n    name: 'Dai Stablecoin',\n    version: '1'\n  };\n  const DAI = new Contract(token.address, ['function nonces(address holder) view returns (uint256 nonce)'], library);\n  const nonce = await DAI.nonces(address);\n  const message = {\n    holder: address,\n    spender: PERMIT_AND_CALL_ADDRESS,\n    nonce: await Promise.resolve(nonce.toNumber()).catch(() => nonce.toString()),\n    expiry: deadline,\n    allowed: true\n  };\n  const inputs = ['address', 'address', 'uint256', 'uint256', 'bool', 'uint8', 'bytes32', 'bytes32'];\n  return {\n    types: {\n      EIP712Domain,\n      Permit\n    },\n    domain,\n    message,\n    permitSelector: hexDataSlice(id(`permit(${inputs.join(',')})`), 0, 4),\n    getPermitData: ({\n      v,\n      r,\n      s\n    }) => defaultAbiCoder.encode(inputs, [address, PERMIT_AND_CALL_ADDRESS, nonce, deadline, true, v, r, s])\n  };\n};\n\nconst USDCPermitGatherer = async (address, deadline, _, token, library) => {\n  const Permit = [{\n    name: 'owner',\n    type: 'address'\n  }, {\n    name: 'spender',\n    type: 'address'\n  }, {\n    name: 'value',\n    type: 'uint256'\n  }, {\n    name: 'nonce',\n    type: 'uint256'\n  }, {\n    name: 'deadline',\n    type: 'uint256'\n  }];\n  const domain = {\n    name: 'USD Coin',\n    version: '2'\n  };\n  const USDC = new Contract(token.address, ['function nonces(address owner) view returns (uint256 nonce)'], library);\n  const nonce = await USDC.nonces(address);\n  const value = `0x${MAX_UINT256.toString(16)}`;\n  const message = {\n    owner: address,\n    spender: PERMIT_AND_CALL_ADDRESS,\n    value,\n    nonce: await Promise.resolve(nonce.toNumber()).catch(() => nonce.toString()),\n    deadline\n  };\n  const inputs = ['address', 'address', 'uint256', 'uint256', 'uint8', 'bytes32', 'bytes32'];\n  return {\n    types: {\n      EIP712Domain,\n      Permit\n    },\n    domain,\n    message,\n    permitSelector: hexDataSlice(id(`permit(${inputs.join(',')})`), 0, 4),\n    getPermitData: ({\n      v,\n      r,\n      s\n    }) => defaultAbiCoder.encode(inputs, [address, PERMIT_AND_CALL_ADDRESS, value, deadline, v, r, s])\n  };\n};\n\nconst permitGatherers = {\n  [ChainId.MAINNET]: {\n    '0x6B175474E89094C44Da98b954EedeAC495271d0F': DAIPermitGatherer,\n    '0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48': USDCPermitGatherer\n  },\n  [ChainId.KOVAN]: {\n    '0x4F96Fe3b7A6Cf9725f59d353F723c1bDb64CA6Aa': DAIPermitGatherer\n  }\n};\nexport function canPermit(token) {\n  var _permitGatherers$toke;\n\n  return !token ? false : !!((_permitGatherers$toke = permitGatherers[token.chainId]) === null || _permitGatherers$toke === void 0 ? void 0 : _permitGatherers$toke[token.address]);\n}\nexport async function gatherPermit(address, deadline, approveMax, token, library) {\n  const _await$permitGatherer = await permitGatherers[token.chainId][token.address](address, deadline, approveMax, token, library),\n        {\n    permitSelector,\n    getPermitData,\n    domain\n  } = _await$permitGatherer,\n        data = _objectWithoutProperties(_await$permitGatherer, [\"permitSelector\", \"getPermitData\", \"domain\"]);\n\n  const signature = await library.send('eth_signTypedData_v4', [address, JSON.stringify(_objectSpread(_objectSpread({}, data), {}, {\n    domain: _objectSpread(_objectSpread({}, domain), {}, {\n      chainId: token.chainId,\n      verifyingContract: token.address\n    }),\n    primaryType: 'Permit'\n  }))]).then(splitSignature);\n  return {\n    permitSelector,\n    permitData: getPermitData(signature)\n  };\n}","map":null,"metadata":{},"sourceType":"module"}