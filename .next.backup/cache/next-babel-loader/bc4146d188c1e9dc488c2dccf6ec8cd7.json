{"ast":null,"code":"import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport _slicedToArray from \"@babel/runtime/helpers/esm/slicedToArray\";\nimport _JSXStyle from \"styled-jsx/style\";\nimport React from \"react\";\nvar __jsx = React.createElement;\nimport { useRef, useState, useLayoutEffect, useMemo, Suspense, useEffect } from 'react';\nimport { Token, WETH, ChainId } from '@uniswap/sdk';\nimport { Input, Stack, Text, useColorMode, useTheme, List, ListItem, IconButton, Divider, Spinner, Flex, Icon, Box } from '@chakra-ui/core';\nimport { Combobox, ComboboxInput, ComboboxPopover, ComboboxList, ComboboxOption } from '@reach/combobox';\nimport { getAddress } from '@ethersproject/address';\nimport { useWeb3React } from '@web3-react/core';\nimport { useAllTokens, DEFAULT_TOKENS } from '../tokens';\nimport { getTokenDisplayValue, shortenHex } from '../utils';\nimport TokenLogo, { TokenLogoColor } from './TokenLogo';\nimport { useFirstToken, useSecondToken } from '../context';\nimport { useOnchainToken, useRemoteTokens } from '../data';\nimport { useDefaultedDebounce } from '../hooks';\nimport ErrorBoundary from './ErrorBoundary';\n\nfunction PastedToken(_ref) {\n  var address = _ref.address;\n  return __jsx(ErrorBoundary, {\n    fallback: __jsx(Flex, {\n      justifyContent: \"center\",\n      width: \"100%\",\n      px: \"1rem\",\n      py: \"0.5rem\"\n    }, __jsx(Icon, {\n      name: \"warning\",\n      size: \"1rem\"\n    }))\n  }, __jsx(Suspense, {\n    fallback: __jsx(Flex, {\n      justifyContent: \"center\",\n      width: \"100%\",\n      px: \"1rem\",\n      py: \"0.5rem\"\n    }, __jsx(Spinner, {\n      color: \"gray.500\",\n      size: \"sm\"\n    }))\n  }, __jsx(PastedTokenData, {\n    address: address\n  })));\n}\n\nfunction PastedTokenData(_ref2) {\n  var address = _ref2.address;\n\n  var _useOnchainToken = useOnchainToken(address, true),\n      data = _useOnchainToken.data;\n\n  return data === null ? __jsx(Text, {\n    textAlign: \"center\",\n    px: \"1rem\",\n    py: \"0.5rem\"\n  }, \"Invalid token address\") : __jsx(React.Fragment, null, __jsx(Divider, {\n    m: 0\n  }), __jsx(Text, {\n    mx: \"1rem\",\n    my: \"0.5rem\",\n    textAlign: \"center\",\n    fontSize: \"1rem\"\n  }, \"Token Found By Address\"), __jsx(ComboboxList, {\n    as: List\n  }, __jsx(ComboboxOption, {\n    as: ListItem,\n    key: data.address,\n    value: data.address\n  }, __jsx(Stack, {\n    direction: \"row\",\n    align: \"center\",\n    p: \"0.5rem\",\n    shouldWrapChildren: true\n  }, __jsx(TokenLogo, {\n    token: data,\n    size: \"1.5rem\"\n  }), __jsx(Stack, {\n    direction: \"column\",\n    ml: \"1rem\",\n    spacing: 0\n  }, __jsx(Text, null, data.symbol), __jsx(Text, {\n    fontSize: \"1rem\"\n  }, data.name))))));\n}\n\nfunction RemoteTokens(_ref3) {\n  var query = _ref3.query;\n  var debouncedValue = useDefaultedDebounce(query, '', 200);\n  return debouncedValue.length === 0 ? null : __jsx(React.Fragment, null, __jsx(Divider, {\n    m: 0\n  }), __jsx(Text, {\n    mx: \"1rem\",\n    my: \"0.5rem\",\n    textAlign: \"center\",\n    fontSize: \"1rem\"\n  }, \"Unverified Tokens\"), __jsx(ErrorBoundary, {\n    fallback: __jsx(Flex, {\n      justifyContent: \"center\",\n      width: \"100%\",\n      pb: \"0.5rem\"\n    }, __jsx(Icon, {\n      name: \"warning\",\n      size: \"1rem\"\n    }))\n  }, __jsx(Suspense, {\n    fallback: __jsx(Flex, {\n      justifyContent: \"center\",\n      width: \"100%\",\n      pb: \"0.5rem\"\n    }, __jsx(Spinner, {\n      color: \"gray.500\",\n      size: \"sm\"\n    }))\n  }, __jsx(RemoteTokensData, {\n    query: query\n  }))));\n}\n\nfunction RemoteTokensData(_ref4) {\n  var query = _ref4.query;\n\n  var _useWeb3React = useWeb3React(),\n      chainId = _useWeb3React.chainId;\n\n  var _useAllTokens = useAllTokens(),\n      _useAllTokens2 = _slicedToArray(_useAllTokens, 1),\n      tokens = _useAllTokens2[0];\n\n  var _useRemoteTokens = useRemoteTokens(query, true),\n      remoteTokensCased = _useRemoteTokens.data;\n\n  var _useRemoteTokens2 = useRemoteTokens(query.toLowerCase(), true),\n      remoteTokensLower = _useRemoteTokens2.data;\n\n  var _useRemoteTokens3 = useRemoteTokens(query.toUpperCase(), true),\n      remoteTokensUpper = _useRemoteTokens3.data;\n\n  var remoteTokens = useMemo(function () {\n    return (remoteTokensCased || []).concat(remoteTokensLower || []).concat(remoteTokensUpper || []);\n  }, [remoteTokensCased, remoteTokensLower, remoteTokensUpper]);\n  var remoteTokensFiltered = useMemo(function () {\n    return Array.from(new Set(remoteTokens.map(function (remoteToken) {\n      return remoteToken.address;\n    }))) // get unique addresses\n    .filter(function (address) {\n      return !tokens.some(function (token) {\n        return token.address === address;\n      });\n    }) // filter out tokens already in our list\n    .map(function (address) {\n      return remoteTokens.find(function (remoteToken) {\n        return remoteToken.address === address;\n      });\n    });\n  }, // get the full remote tokens\n  [remoteTokens, tokens]).sort(function (a, b) {\n    var _a$symbol, _a$symbol$slice, _b$symbol, _b$symbol$slice;\n\n    var aExact = (a === null || a === void 0 ? void 0 : (_a$symbol = a.symbol) === null || _a$symbol === void 0 ? void 0 : (_a$symbol$slice = _a$symbol.slice(0, query.length)) === null || _a$symbol$slice === void 0 ? void 0 : _a$symbol$slice.toLowerCase()) === query.toLowerCase();\n    var bExact = (b === null || b === void 0 ? void 0 : (_b$symbol = b.symbol) === null || _b$symbol === void 0 ? void 0 : (_b$symbol$slice = _b$symbol.slice(0, query.length)) === null || _b$symbol$slice === void 0 ? void 0 : _b$symbol$slice.toLowerCase()) === query.toLowerCase();\n\n    if (aExact && !bExact) {\n      return -1;\n    } else if (!aExact && bExact) {\n      return 1;\n    } else {\n      var _a$symbol$toLowerCase, _a$symbol2, _b$symbol$toLowerCase, _b$symbol2;\n\n      return ((_a$symbol$toLowerCase = a === null || a === void 0 ? void 0 : (_a$symbol2 = a.symbol) === null || _a$symbol2 === void 0 ? void 0 : _a$symbol2.toLowerCase()) !== null && _a$symbol$toLowerCase !== void 0 ? _a$symbol$toLowerCase : 0) > ((_b$symbol$toLowerCase = b === null || b === void 0 ? void 0 : (_b$symbol2 = b.symbol) === null || _b$symbol2 === void 0 ? void 0 : _b$symbol2.toLowerCase()) !== null && _b$symbol$toLowerCase !== void 0 ? _b$symbol$toLowerCase : 0) ? 1 : -1;\n    }\n  });\n  return remoteTokensFiltered.length === 0 ? __jsx(Text, {\n    textAlign: \"center\",\n    pb: \"0.5rem\"\n  }, \"No results\") : __jsx(ComboboxList, {\n    as: List\n  }, remoteTokensFiltered.map(function (token) {\n    var DUMMY = new Token(chainId, token.address, 18); // we don't know if it actually has 18 decimals\n\n    return __jsx(ComboboxOption, {\n      as: ListItem,\n      key: token.address,\n      value: token.address\n    }, __jsx(Stack, {\n      direction: \"row\",\n      align: \"center\",\n      p: \"0.5rem\",\n      shouldWrapChildren: true\n    }, __jsx(TokenLogo, {\n      token: DUMMY,\n      size: \"1.5rem\"\n    }), __jsx(Stack, {\n      direction: \"column\",\n      ml: \"1rem\",\n      spacing: 0\n    }, __jsx(Text, null, token.symbol), __jsx(Text, {\n      fontSize: \"1rem\"\n    }, token.name))));\n  }));\n}\n\nexport default function TokenSelect(_ref5) {\n  var tokenAddress = _ref5.tokenAddress,\n      isInvalid = _ref5.isInvalid,\n      isDisabled = _ref5.isDisabled,\n      onAddressSelect = _ref5.onAddressSelect;\n\n  var _useTheme = useTheme(),\n      colors = _useTheme.colors;\n\n  var _useColorMode = useColorMode(),\n      colorMode = _useColorMode.colorMode;\n\n  var _useWeb3React2 = useWeb3React(),\n      chainId = _useWeb3React2.chainId;\n\n  var _useFirstToken = useFirstToken(),\n      _useFirstToken2 = _slicedToArray(_useFirstToken, 1),\n      firstToken = _useFirstToken2[0];\n\n  var _useSecondToken = useSecondToken(),\n      _useSecondToken2 = _slicedToArray(_useSecondToken, 1),\n      secondToken = _useSecondToken2[0]; // if the currently selected token address is in our list, pluck it out\n\n\n  var _useAllTokens3 = useAllTokens(),\n      _useAllTokens4 = _slicedToArray(_useAllTokens3, 2),\n      tokens = _useAllTokens4[0],\n      removeToken = _useAllTokens4[1].removeToken;\n\n  var tokenDerivedFromProps = tokens.filter(function (token) {\n    return token.address === tokenAddress;\n  })[0];\n\n  var _useState = useState(tokenAddress !== null && tokenAddress !== void 0 ? tokenAddress : ''),\n      value = _useState[0],\n      setValue = _useState[1]; // keep the state in sync with the prop\n\n\n  useEffect(function () {\n    setValue(tokenAddress !== null && tokenAddress !== void 0 ? tokenAddress : '');\n  }, [tokenAddress]); // try to parse the value as an address\n\n  var valueAsAddress;\n\n  try {\n    valueAsAddress = getAddress(value);\n  } catch (_unused) {\n    valueAsAddress = null;\n  }\n\n  var ref = useRef(null);\n  useLayoutEffect(function () {\n    if (ref.current) ref.current.size = tokenDerivedFromProps ? getTokenDisplayValue(tokenDerivedFromProps).length : valueAsAddress === null ? value.length === 0 ? 7 : value.length : shortenHex(valueAsAddress, 4).length;\n  });\n\n  function onSelect(tokenAddress) {\n    onAddressSelect(tokenAddress);\n  } // set up a hack. when a user has selected a token, and modifies the input text, the value will get cleared, so we\n  // have to store the modified text and reset it after the clear\n\n\n  var _useState2 = useState(),\n      temporaryInput = _useState2[0],\n      setTemporaryInput = _useState2[1];\n\n  useEffect(function () {\n    if (temporaryInput && !tokenAddress) {\n      setValue(temporaryInput);\n      setTemporaryInput(undefined);\n    }\n  }, [temporaryInput, tokenAddress]);\n\n  function onChange(event) {\n    // try to parse the input as an address\n    var valueAsAddress;\n\n    try {\n      valueAsAddress = getAddress(event.target.value);\n    } catch (_unused2) {\n      valueAsAddress = null;\n    } // if they pasted an address that's already in our list, select it\n\n\n    if (valueAsAddress && tokens.filter(function (token) {\n      return token.address === valueAsAddress;\n    })[0]) {\n      onSelect(valueAsAddress);\n    } else {\n      if (tokenAddress) {\n        onAddressSelect(undefined); // unset the selected address\n\n        setTemporaryInput(event.target.value); // set the temporary input\n      } else {\n        setValue(event.target.value);\n      }\n    }\n  }\n\n  var filteredTokens = tokens.filter(function (token) {\n    var _token$name, _token$name$toLowerCa;\n\n    var addressMatch = valueAsAddress === token.address;\n    var displayMatch = value.toLowerCase() === getTokenDisplayValue(token).slice(0, value.length).toLowerCase();\n    var nameMatch = !token.equals(WETH[token.chainId]) && (token === null || token === void 0 ? void 0 : (_token$name = token.name) === null || _token$name === void 0 ? void 0 : (_token$name$toLowerCa = _token$name.toLowerCase()) === null || _token$name$toLowerCa === void 0 ? void 0 : _token$name$toLowerCa.includes(value.toLowerCase()));\n    return addressMatch || displayMatch || nameMatch;\n  }).sort(function (a, b) {\n    var aExact = valueAsAddress === a.address || value.toLowerCase() === getTokenDisplayValue(a).slice(0, value.length).toLowerCase();\n    var bExact = valueAsAddress === b.address || value.toLowerCase() === getTokenDisplayValue(b).slice(0, value.length).toLowerCase();\n\n    if (tokenDerivedFromProps && a.equals(tokenDerivedFromProps)) {\n      return -1;\n    } else if (tokenDerivedFromProps && b.equals(tokenDerivedFromProps)) {\n      return 1;\n    } else if (aExact && !bExact) {\n      return -1;\n    } else if (!aExact && bExact) {\n      return 1;\n    } else if (a.equals(WETH[a.chainId])) {\n      return -1;\n    } else if (b.equals(WETH[b.chainId])) {\n      return 1;\n    } else {\n      return getTokenDisplayValue(a).toLowerCase() < getTokenDisplayValue(b).toLowerCase() ? -1 : 1;\n    }\n  });\n  return __jsx(React.Fragment, null, __jsx(Combobox, {\n    openOnFocus: true,\n    onSelect: onSelect\n  }, __jsx(TokenLogoColor, {\n    token: tokenDerivedFromProps\n  }, function (swatch) {\n    return __jsx(ComboboxInput, _extends({\n      selectOnClick: true,\n      autocomplete: false,\n      as: Input,\n      ref: ref,\n      value: tokenDerivedFromProps ? getTokenDisplayValue(tokenDerivedFromProps) : valueAsAddress === null ? value : shortenHex(valueAsAddress, 4),\n      onChange: onChange,\n      title: \"Token Select\" // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      ,\n      onCopy: function onCopy(event) {\n        // copy the full address if we've shortened it\n        if (valueAsAddress) {\n          event.preventDefault();\n          event.clipboardData.setData('text/plain', valueAsAddress);\n        }\n      } // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      ,\n      onCut: function onCut(event) {\n        // cut the full address if we've shortened it\n        if (valueAsAddress) {\n          event.preventDefault();\n          event.clipboardData.setData('text/plain', valueAsAddress); // simulate an onChange\n          // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n          onChange({\n            target: {\n              value: ''\n            }\n          });\n        }\n      } // chakra props\n      ,\n      variant: \"flushed\",\n      placeholder: \"Select\\u2026\",\n      textAlign: \"center\",\n      fontSize: \"1.875rem\"\n    }, !!(swatch === null || swatch === void 0 ? void 0 : swatch.hex) && {\n      color: swatch.hex\n    }, {\n      isInvalid: isInvalid,\n      isDisabled: isDisabled,\n      _disabled: {\n        opacity: 0.4,\n        cursor: 'not-allowed'\n      }\n    }));\n  }), __jsx(Box, {\n    maxHeight: 0,\n    position: \"relative\",\n    zIndex: 2\n  }, __jsx(Box, {\n    position: \"absolute\"\n  }, __jsx(ComboboxPopover, {\n    portal: false\n  }, !tokenDerivedFromProps && __jsx(React.Fragment, null, (value === '' || tokenAddress === value) && __jsx(Text, {\n    mx: \"1rem\",\n    my: \"0.5rem\",\n    textAlign: \"center\",\n    color: \"gray.500\"\n  }, \"Paste token address or search\"), __jsx(ComboboxList, {\n    as: List\n  }, filteredTokens.map(function (token) {\n    var userAdded = !DEFAULT_TOKENS.some(function (defaultToken) {\n      return defaultToken.equals(token);\n    });\n    return __jsx(ComboboxOption, {\n      as: ListItem,\n      key: token.address,\n      value: token.address\n    }, __jsx(Stack, {\n      direction: \"row\",\n      align: \"center\",\n      p: \"0.5rem\"\n    }, __jsx(Box, null, __jsx(TokenLogo, {\n      token: token,\n      size: \"1.5rem\"\n    })), __jsx(Stack, {\n      direction: \"column\",\n      ml: \"1rem\",\n      spacing: 0,\n      shouldWrapChildren: true\n    }, __jsx(Text, null, getTokenDisplayValue(token)), __jsx(Text, {\n      fontSize: \"1rem\"\n    }, WETH[token.chainId].equals(token) ? 'Ethereum' : token.name)), userAdded && __jsx(Flex, {\n      flexGrow: 1,\n      mb: \"auto\",\n      justifyContent: \"flex-end\"\n    }, __jsx(IconButton, {\n      isDisabled: !!firstToken && firstToken.equals(token) || !!secondToken && secondToken.equals(token),\n      icon: \"close\",\n      variant: \"ghost\",\n      size: \"sm\",\n      \"aria-label\": \"Remove\",\n      onClick: function onClick(event) {\n        event.preventDefault();\n        removeToken(token);\n      }\n    }))));\n  })), valueAsAddress !== null && !tokens.some(function (token) {\n    return token.address === valueAsAddress;\n  }) ? __jsx(PastedToken, {\n    address: valueAsAddress\n  }) : null, value.length >= 2 && valueAsAddress === null && chainId === ChainId.MAINNET ? __jsx(RemoteTokens, {\n    query: value\n  }) : null))))), __jsx(_JSXStyle, {\n    id: \"3788667905\",\n    dynamic: [colorMode === 'light' ? colors.gray[50] : colors.gray[900], colorMode === 'light' ? 'black' : 'white', colorMode === 'light' ? colors.gray[100] : 'rgba(255,255,255,0.04)', colorMode === 'light' ? colors.gray[100] : 'rgba(255,255,255,0.04)']\n  }, [\"[data-reach-combobox-popover]{width:-webkit-max-content !important;width:-moz-max-content !important;width:max-content !important;max-height:25rem;overflow-y:auto;background:\".concat(colorMode === 'light' ? colors.gray[50] : colors.gray[900], \";color:\").concat(colorMode === 'light' ? 'black' : 'white', \";border-radius:0.5rem;border-top-left-radius:0;}\"), \"[data-reach-combobox-list] :hover{background:\".concat(colorMode === 'light' ? colors.gray[100] : 'rgba(255,255,255,0.04)', \";}\"), \"[data-reach-combobox-option]{font-size:1.25rem;background:none;}\", \"[data-reach-combobox-option] :hover{background:none;}\", \"[data-reach-combobox-option][data-highlighted]{background:\".concat(colorMode === 'light' ? colors.gray[100] : 'rgba(255,255,255,0.04)', \" !important;}\")]));\n}","map":null,"metadata":{},"sourceType":"module"}