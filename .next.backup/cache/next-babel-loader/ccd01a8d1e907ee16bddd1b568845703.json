{"ast":null,"code":"import React from \"react\";\nvar __jsx = React.createElement;\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nimport { Box, Flex, Image, Text, Stack, Button, ButtonGroup, Input, useDisclosure } from '@chakra-ui/core';\nimport { useWeb3React } from '@web3-react/core';\nimport { useEffect, useState } from 'react';\nimport { useRouter } from 'next/router';\nimport Refreshing from './Refreshing';\nimport Loader from 'react-loader';\nimport dynamic from 'next/dynamic';\nimport { validImage } from '../utils';\nimport { TransactionToast } from './TransactionToast';\nimport { EMBLEM_API, BURN_ADDRESS, contractAddresses } from '../constants';\nimport { useContract } from '../hooks';\nimport Tilt from 'react-tilt';\nconst AddrModal = dynamic(() => import('./AddrModal'), {\n  loadableGenerated: {\n    webpack: () => [require.resolveWeak('./AddrModal')],\n    modules: ['./AddrModal']\n  }\n});\nconst KeysModal = dynamic(() => import('./KeysModal'), {\n  loadableGenerated: {\n    webpack: () => [require.resolveWeak('./KeysModal')],\n    modules: ['./KeysModal']\n  }\n});\nexport default function Vault() {\n  const {\n    account,\n    chainId,\n    library\n  } = useWeb3React();\n  const {\n    query,\n    pathname,\n    replace\n  } = useRouter();\n  const {\n    0: tokenId,\n    1: setTokenId\n  } = useState(query.id);\n  const {\n    0: experimental,\n    1: setExperimental\n  } = useState(query.experimental);\n  const {\n    0: vaultName,\n    1: setVaultName\n  } = useState('');\n  const {\n    0: vaultDesc,\n    1: setVaultDesc\n  } = useState('');\n  const {\n    0: vaultImage,\n    1: setVaultImage\n  } = useState('');\n  const {\n    0: vaultValues,\n    1: setVaultValues\n  } = useState([]);\n  const {\n    0: vaultAddresses,\n    1: setVaultAddresses\n  } = useState([]);\n  const {\n    0: vaultPrivacy,\n    1: setVaultPrivacy\n  } = useState(false);\n  const {\n    0: vaultChainId,\n    1: setVaultChainId\n  } = useState(null);\n  const {\n    0: hash,\n    1: setHash\n  } = useState(null);\n  const {\n    0: currCoin,\n    1: setCurrCoin\n  } = useState('');\n  const {\n    0: currAddr,\n    1: setCurrAddr\n  } = useState('');\n  const {\n    0: state,\n    1: setState\n  } = useState({\n    loaded: false\n  });\n  const {\n    0: allowed,\n    1: setAllowed\n  } = useState(false);\n  const {\n    0: mine,\n    1: setMine\n  } = useState(false);\n  const {\n    0: claiming,\n    1: setClaiming\n  } = useState(false);\n  const {\n    0: status,\n    1: setStatus\n  } = useState('claimed');\n  const {\n    0: claimedBy,\n    1: setClaimedBy\n  } = useState(null);\n  const {\n    0: mnemonic,\n    1: setMnemonic\n  } = useState('');\n  const {\n    0: privKeyBTC,\n    1: setPrivKeyBTC\n  } = useState('');\n  const {\n    0: privKeyETH,\n    1: setPrivKeyETH\n  } = useState('');\n  const {\n    0: loadingApi,\n    1: setLoadingApi\n  } = useState(false);\n  const {\n    0: decryptedEffect,\n    1: setDecryptedEffect\n  } = useState('');\n  const emblemContract = useContract(contractAddresses.emblemVault[chainId], contractAddresses.emblemAbi, true);\n  const {\n    isOpen: isOpenAddrModal,\n    onOpen: onOpenAddrModal,\n    onClose: onCloseAddrModal\n  } = useDisclosure();\n  const {\n    isOpen: isOpenKeysModal,\n    onOpen: onOpenKeysModal,\n    onClose: onCloseKeysModal\n  } = useDisclosure();\n\n  const getVault = async () => {\n    loadCache();\n    const responce = await fetch(EMBLEM_API + '/meta/' + tokenId, {\n      method: 'GET',\n      headers: {\n        'Content-Type': 'application/json',\n        service: 'evmetadata'\n      }\n    });\n    const jsonData = await responce.json();\n    console.log(jsonData);\n    setStates(jsonData);\n    saveCache(jsonData);\n    setLoadingApi(false);\n  };\n\n  const setStates = jsonData => {\n    setVaultName(jsonData.name);\n    setVaultImage(jsonData.image);\n    setVaultDesc(jsonData.description);\n    setVaultValues(jsonData.values);\n    setVaultDesc(jsonData.description);\n    setVaultAddresses(jsonData.addresses);\n    setVaultChainId(jsonData.network == 'mainnet' ? 1 : 4);\n    setStatus(jsonData.status);\n\n    if (status === 'claimed') {\n      setClaimedBy(jsonData.claimedBy);\n    }\n\n    setState({\n      loaded: true\n    });\n    let isPvt = jsonData.addresses.filter(item => {\n      return item.address.includes('private:');\n    }).length > 0;\n    console.log(\"pvt\", isPvt);\n    setVaultPrivacy(isPvt);\n  };\n\n  const loadCache = () => {\n    let vault = JSON.parse(localStorage.getItem(account + '_' + chainId + '_' + tokenId + '_vault')); // Load vaults from storage before updating from server!\n\n    if (vault) {\n      setState({\n        loaded: true\n      });\n      setStates(vault);\n      setLoadingApi(true);\n    }\n  };\n\n  const saveCache = vault => {\n    localStorage.setItem(account + '_' + chainId + '_' + tokenId + '_vault', JSON.stringify(vault)); // Save new state for later\n  };\n\n  const getKeys = async (signature, tokenId, cb) => {\n    var myHeaders = new Headers();\n    myHeaders.append('chainId', chainId.toString());\n    myHeaders.append('service', 'evmetadata');\n    myHeaders.append('Content-Type', 'application/json');\n    var raw = JSON.stringify({\n      signature: signature\n    });\n    const responce = await fetch(EMBLEM_API + '/verify/' + tokenId, {\n      method: 'POST',\n      headers: myHeaders,\n      body: raw,\n      redirect: 'follow'\n    });\n    const jsonData = await responce.json();\n    return cb(jsonData);\n  };\n\n  const getContractStates = async () => {\n    let owner = await emblemContract.ownerOf(tokenId);\n    setMine(owner === account);\n\n    if (mine) {\n      setAllowed(true);\n    }\n\n    console.log('status', status, 'claimedBy', claimedBy);\n  };\n\n  const handleApprove = async () => {\n    emblemContract.setApprovalForAll(contractAddresses.vaultHandler[chainId], true).then(({\n      hash\n    }) => {\n      setHash(hash);\n    });\n  };\n\n  const handleSign = async () => {\n    // library. .personal.sign(library.toHex(\"Claim:358746\"),library.eth.defaultAccount, (err,res) => console.log(err,res))\n    library.getSigner(account).signMessage('Claim: ' + tokenId).then(signature => {\n      getKeys(signature, tokenId, result => {\n        // alert('Mnemonic: ' + result.decrypted.phrase)\n        setMnemonic(result.decrypted.phrase);\n        setPrivKeyBTC('BTC KEY');\n        setPrivKeyETH('ETH KEY');\n        onOpenKeysModal();\n        console.log(result.decrypted);\n      });\n    });\n  };\n\n  const handleClaim = async () => {\n    emblemContract.transferFrom(account, BURN_ADDRESS, tokenId).then(({\n      hash\n    }) => {\n      setClaiming(true);\n      setTimeout(() => {\n        setHash(hash);\n        handleSign();\n        onOpenKeysModal();\n      }, 100); // Solving State race condition where transaction watcher wouldn't notice we were claiming\n    });\n  };\n\n  const startDecryptEffect = async () => {\n    var theLetters = \"abcdefghijklmnopqrstuvwxyz\"; //You can customize what letters it will cycle through\n\n    var ctnt = \"Decrypting\"; // Your text goes here\n\n    var speed = 5; // ms per frame\n\n    var increment = 8; // frames per step. Must be >2\n\n    var clen = ctnt.length;\n    var si = 0;\n    var stri = 0;\n    var block = \"\";\n    var fixed = \"\";\n\n    (function rustle(i) {\n      setTimeout(function () {\n        if (--i) {\n          rustle(i);\n        }\n\n        nextFrame(i);\n        si = si + 1;\n      }, speed);\n    })(clen * increment + 1);\n\n    function nextFrame(pos) {\n      for (var i = 0; i < clen - stri; i++) {\n        //Random number\n        var num = Math.floor(theLetters.length * Math.random()); //Get random letter\n\n        var letter = theLetters.charAt(num);\n        block = block + letter;\n      }\n\n      if (si == increment - 1) {\n        stri++;\n      }\n\n      if (si == increment) {\n        // Add a letter; \n        // every speed*10 ms\n        fixed = fixed + ctnt.charAt(stri - 1);\n        si = 0;\n      } // $(\"#output\").html(fixed + block);\n\n\n      setDecryptedEffect(fixed + block);\n      block = \"\";\n    }\n  };\n\n  useEffect(() => {\n    getVault();\n  }, []);\n  useEffect(() => {\n    console.log('Account chainid = ' + chainId + ' and vaultchainid = ' + vaultChainId);\n    account && chainId && vaultChainId && chainId == vaultChainId ? getContractStates() : null;\n  });\n\n  function splitDescription(words) {\n    var desc = words.split('\\n\\n\\n\\n');\n    return desc[0].trim();\n  }\n\n  function tryDecrypt(pass) {\n    startDecryptEffect();\n    console.log(pass);\n  }\n\n  return __jsx(React.Fragment, null, __jsx(AddrModal, {\n    isOpen: isOpenAddrModal,\n    onClose: onCloseAddrModal,\n    addrCoin: currCoin,\n    addrAddr: currAddr\n  }), __jsx(KeysModal, {\n    isOpen: isOpenKeysModal,\n    onClose: onCloseKeysModal,\n    mnemonic: mnemonic,\n    privKeyBTC: privKeyBTC,\n    privKeyETH: privKeyETH\n  }), __jsx(Loader, {\n    loaded: state.loaded\n  }, loadingApi ? __jsx(Refreshing, null) : '', __jsx(Tilt, {\n    className: \"Tilt\",\n    options: {\n      max: experimental ? 19 : 0,\n      scale: 1\n    }\n  }, __jsx(Flex, {\n    width: \"full\",\n    align: \"center\",\n    justifyContent: \"center\"\n  }, __jsx(Box, {\n    maxW: \"sm\",\n    borderWidth: \"1px\",\n    borderColor: vaultChainId != chainId ? 'orange.500' : status == 'claimed' ? 'green.500' : null,\n    rounded: \"lg\",\n    overflow: \"hidden\",\n    alignItems: \"center\",\n    mt: 15\n  }, vaultChainId != chainId ? __jsx(Box, {\n    mt: \"1\",\n    fontWeight: \"semibold\",\n    as: \"h3\",\n    lineHeight: \"tight\",\n    p: 2,\n    textAlign: \"center\",\n    textTransform: \"uppercase\",\n    alignItems: \"center\",\n    color: \"orange.500\"\n  }, \"Vault is on a different network than you are.\") : null, __jsx(Box, {\n    mt: \"1\",\n    fontWeight: \"semibold\",\n    as: \"h3\",\n    lineHeight: \"tight\",\n    p: 2,\n    textAlign: \"center\",\n    textTransform: \"uppercase\",\n    alignItems: \"center\"\n  }, vaultName), __jsx(Stack, {\n    align: \"center\"\n  }, __jsx(Image, {\n    src: validImage(vaultImage) ? vaultImage : 'https://circuitsofvalue.com/public/coval-logo.png',\n    width: \"250px\"\n  })), __jsx(Stack, {\n    align: \"center\"\n  }, __jsx(Box, {\n    mt: \"1\",\n    ml: \"4\",\n    lineHeight: \"tight\"\n  }, __jsx(Text, {\n    as: \"h4\",\n    ml: \"4\",\n    mr: \"4\"\n  }, splitDescription(vaultDesc)))), __jsx(Box, {\n    p: \"6\"\n  }, __jsx(Box, {\n    d: \"flex\",\n    alignItems: \"baseline\"\n  }, __jsx(Box, {\n    color: \"gray.500\",\n    letterSpacing: \"wide\",\n    fontSize: \"sm\",\n    ml: \"2\"\n  }, __jsx(Text, {\n    as: \"h4\",\n    fontWeight: \"semibold\"\n  }, \"Current Contents:\"), vaultPrivacy ? __jsx(React.Fragment, null, __jsx(Text, {\n    pb: 2,\n    color: decryptedEffect ? 'green.500' : null\n  }, decryptedEffect ? decryptedEffect : 'Contents hidden. Enter password to unlock.'), __jsx(Input, {\n    type: \"password\",\n    id: \"vault-password\",\n    onChange: e => tryDecrypt(e.target.value),\n    \"aria-describedby\": \"password-helper-text\"\n  })) : vaultValues.length ? vaultValues.map(coin => {\n    return __jsx(Text, {\n      key: coin.name,\n      isTruncated: true\n    }, coin.name, \": \", coin.balance);\n  }) : __jsx(Text, null, \"Nothing in here! Fill 'er up!\"))), !vaultPrivacy ? __jsx(Box, {\n    d: \"flex\",\n    alignItems: \"baseline\",\n    justifyContent: \"space-between\",\n    mt: \"4\"\n  }, __jsx(Stack, {\n    direction: \"row\",\n    align: \"center\",\n    spacing: \"1rem\",\n    flexWrap: \"wrap\",\n    shouldWrapChildren: true\n  }, __jsx(ButtonGroup, {\n    spacing: 4\n  }, vaultAddresses.map(addr => {\n    return __jsx(Button, {\n      key: addr.address,\n      onClick: () => {\n        setCurrCoin(addr.coin);\n        setCurrAddr(addr.address);\n        onOpenAddrModal();\n      }\n    }, \"Put \", addr.coin == 'ETH' ? addr.coin + '/ERC20' : addr.coin, \" In\");\n  })))) : null, status === 'claimed' && claimedBy === account ? __jsx(Box, {\n    d: \"flex\",\n    alignItems: \"baseline\",\n    justifyContent: \"space-between\",\n    mt: \"4\"\n  }, __jsx(Button, {\n    width: \"100%\",\n    onClick: handleSign\n  }, \"Get Keys\")) : __jsx(Box, {\n    d: \"flex\",\n    alignItems: \"baseline\",\n    justifyContent: \"space-between\",\n    mt: \"4\"\n  }, __jsx(Button, _extends({\n    width: \"100%\",\n    as: \"a\"\n  }, {\n    href: 'https://' + (vaultChainId == 4 ? 'rinkeby.' : '') + 'opensea.io/assets/' + contractAddresses.emblemVault[vaultChainId] + '/' + tokenId,\n    target: '_blank',\n    rel: 'noopener noreferrer'\n  }), mine ? 'Sell/Gift/Send' : 'Make an Offer')), __jsx(Box, {\n    d: \"flex\",\n    alignItems: \"baseline\",\n    justifyContent: \"space-between\",\n    mt: \"4\"\n  }, mine ? __jsx(Button, {\n    width: \"100%\",\n    onClick: () => {\n      if (allowed) {\n        handleClaim();\n      } else {\n        handleApprove();\n      }\n    }\n  }, allowed ? 'Claim' : 'Approve') : ''))))), hash ? __jsx(TransactionToast, {\n    hash: hash,\n    onComplete: () => {\n      if (claiming) {\n        setHash(null);\n      }\n    }\n  }) : null));\n}","map":null,"metadata":{},"sourceType":"module"}