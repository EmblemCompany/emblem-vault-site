{"ast":null,"code":"import React from \"react\";\nvar __jsx = React.createElement;\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nimport { Box, Flex, Text, Link, Stack, Button, FormControl, Input, FormHelperText, Select } from '@chakra-ui/core';\nimport Loader from 'react-loader';\nimport Refreshing from './Refreshing';\nimport { useRouter } from 'next/router';\nimport { useWeb3React } from '@web3-react/core';\nimport { useEffect, useState } from 'react';\nimport { Embed } from './Embed';\nimport { useContract } from '../hooks';\nimport { EMBLEM_API, contractAddresses } from '../constants';\nimport { TransactionToast } from './TransactionToast';\nexport default function NFTrade() {\n  const {\n    account,\n    chainId,\n    library\n  } = useWeb3React();\n  const {\n    query\n  } = useRouter();\n  const {\n    0: vaults,\n    1: setVaults\n  } = useState([]);\n  const {\n    0: myVaults,\n    1: setMyVaults\n  } = useState([]);\n  const {\n    0: myVaultsLoaded,\n    1: setMyVaultsLoaded\n  } = useState(false);\n  const {\n    0: collectionsLoaded,\n    1: setCollectionsLoaded\n  } = useState(false);\n  const {\n    0: state,\n    1: setState\n  } = useState({\n    loaded: false\n  });\n  const {\n    0: loadingApi,\n    1: setLoadingApi\n  } = useState(false);\n  const {\n    0: hash,\n    1: setHash\n  } = useState(null);\n  const {\n    0: q,\n    1: setQ\n  } = useState(query.q);\n  const {\n    0: temp_q,\n    1: setTempQ\n  } = useState(q || '');\n  const {\n    0: network,\n    1: setNetwork\n  } = useState(query.network || null);\n  const {\n    0: address,\n    1: setAddress\n  } = useState(query.address);\n  const {\n    0: experimental,\n    1: setExperimental\n  } = useState(query.experimental);\n  const {\n    0: offeringTokenId,\n    1: setOfferingTokenId\n  } = useState(null);\n  const {\n    0: offeringTokenAllowed,\n    1: setOfferingTokenAllowed\n  } = useState(null);\n  const {\n    0: acceptingOfferingIndex,\n    1: setAcceptingOfferIndex\n  } = useState(null);\n  const {\n    0: acceptingTokenAllowed,\n    1: setAcceptingTokenAllowed\n  } = useState(null);\n  const {\n    0: acceptingTokenId,\n    1: setAcceptingTokenId\n  } = useState(null);\n  const {\n    0: collection,\n    1: setCollection\n  } = useState(query.collection || null);\n  const {\n    0: collections,\n    1: setCollections\n  } = useState([]);\n  const emblemContract = useContract(contractAddresses.emblemVault[chainId], contractAddresses.emblemAbi, true);\n  const nftradeContract = useContract(contractAddresses.nftrade[chainId], contractAddresses.nftradeAbi, true);\n\n  const getVaults = async () => {\n    setLoadingApi(true);\n\n    try {\n      const response = await fetch(EMBLEM_API + '/search', {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n          service: 'evmetadata'\n        },\n        body: JSON.stringify({\n          q: q,\n          network: network == \"null\" ? null : network,\n          external: true,\n          collections: [collection]\n        })\n      });\n      let jsonData = await response.json();\n      jsonData = jsonData.records;\n      setState({\n        loaded: true\n      });\n      jsonData.forEach(async (data, index) => {\n        // debugger\n        if (data && data.network === \"matic\") {\n          let owner = await checkOwner(data.tokenId);\n          let offerCount = await getOfferCount(data.tokenId);\n          let mine = owner === account;\n          let offers = await getOffers(offerCount, data.tokenId); // debugger\n\n          if (offers.length < offerCount) {\n            offerCount = offers.length;\n          }\n\n          jsonData[index].offers = offers;\n          jsonData[index].mine = mine;\n          jsonData[index].offerCount = offerCount;\n        }\n\n        if (!data) {\n          delete jsonData[index];\n        }\n\n        if (index + 1 === jsonData.length) {\n          // debugger\n          setVaults(jsonData);\n          setLoadingApi(false);\n        }\n      });\n    } catch (error) {}\n  };\n\n  const getMyVaults = async () => {\n    console.log(\"Getting My Vaults\");\n    setMyVaultsLoaded(true);\n\n    try {\n      const response = await fetch(EMBLEM_API + '/vaults/' + (address ? address : account) + (experimental ? '?experimental=true' : ''), {\n        method: 'GET',\n        headers: {\n          'Content-Type': 'application/json',\n          service: 'evmetadata',\n          chainId: chainId.toString()\n        }\n      });\n      const jsonData = await response.json();\n      setMyVaults(jsonData); // console.log(jsonData)\n    } catch (error) {}\n  };\n\n  const getCollections = async () => {\n    console.log(\"Getting Collections\");\n    setCollectionsLoaded(true);\n\n    try {\n      const response = await fetch(EMBLEM_API + '/opensea/collections/', {\n        method: 'GET',\n        headers: {\n          'Content-Type': 'application/json',\n          service: 'evmetadata'\n        }\n      });\n      const jsonData = await response.json();\n      setCollections(jsonData); // console.log(jsonData)\n    } catch (error) {}\n  };\n\n  useEffect(() => {\n    // console.log(q, state, loadingApi)\n    nftradeStuff();\n\n    if (q && !state.loaded && !loadingApi) {\n      console.log(\"Load Search\");\n      getVaults();\n    }\n  });\n\n  async function nftradeStuff() {\n    !myVaultsLoaded ? await getMyVaults() : null;\n    !collectionsLoaded ? await getCollections() : null; // let _owner  = await nftradeContract.ownerOf(tokenId)\n  }\n\n  async function getOfferCount(tokenId) {\n    let offerCount = await nftradeContract.getOfferCount(contractAddresses.emblemVault[chainId], tokenId);\n    return Number(offerCount);\n  }\n\n  async function getOffers(count, tokenId) {\n    let offers = [];\n\n    for (let i = 0; i < count; i++) {\n      let offer = await nftradeContract.getOffer(contractAddresses.emblemVault[chainId], tokenId, i); // debugger\n\n      if (offer.nft !== \"0x0000000000000000000000000000000000000000\") {\n        offers.push(offer);\n      }\n    }\n\n    console.log('offers', offers);\n    return offers;\n  }\n\n  async function checkOfferingAllowance(tokenId) {\n    let allowed = await emblemContract.getApproved(tokenId);\n    setOfferingTokenAllowed(allowed != \"0x0000000000000000000000000000000000000000\");\n  }\n\n  async function checkAcceptingAllowance(tokenId) {\n    let allowed = await emblemContract.getApproved(tokenId);\n    setAcceptingTokenAllowed(allowed != \"0x0000000000000000000000000000000000000000\");\n  }\n\n  async function checkOwner(tokenId) {\n    //debugger\n    console.log(\"checking owner for\", tokenId);\n    let owner = await emblemContract.ownerOf(tokenId).catch(() => {});\n    return owner;\n  }\n\n  const approveOffer = tokenId => {\n    // debugger\n    console.log(\"checking offer for\", tokenId);\n    emblemContract.approve(contractAddresses.nftrade[chainId], tokenId && typeof tokenId === \"string\" ? tokenId : offeringTokenId).then(({\n      hash\n    }) => {\n      setHash(hash);\n    }); // .catch((error: ErrorWithCode) => {\n    //   if (error?.code == 4001) {\n    //     setApproving(false)\n    //   }\n    // })\n  };\n\n  const makeOffer = tokenId => {\n    ;\n    nftradeContract.addOffer(contractAddresses.emblemVault[chainId], offeringTokenId, contractAddresses.emblemVault[chainId], tokenId).then(({\n      hash\n    }) => {\n      setHash(hash);\n    }); // .catch((error: ErrorWithCode) => {\n    //   if (error?.code == 4001) {\n    //     setApproving(false)\n    //   }\n    // })\n  };\n\n  const acceptOffer = () => {\n    ;\n    nftradeContract.acceptOffer(contractAddresses.emblemVault[chainId], acceptingTokenId, Number(acceptingOfferingIndex)).then(({\n      hash\n    }) => {\n      setHash(hash);\n    }); // .catch((error: ErrorWithCode) => {\n    //   if (error?.code == 4001) {\n    //     setApproving(false)\n    //   }\n    // })\n  };\n\n  const rejectOffer = () => {\n    ;\n    nftradeContract.rejectOffer(contractAddresses.emblemVault[chainId], acceptingTokenId, Number(acceptingOfferingIndex)).then(({\n      hash\n    }) => {\n      setHash(hash);\n    }); // .catch((error: ErrorWithCode) => {\n    //   if (error?.code == 4001) {\n    //     setApproving(false)\n    //   }\n    // })\n  };\n\n  return __jsx(Loader, {\n    loaded: state.loaded || !q\n  }, loadingApi ? __jsx(Refreshing, null) : '', __jsx(Flex, {\n    width: \"full\",\n    align: \"center\",\n    justifyContent: \"center\"\n  }, __jsx(FormControl, {\n    isRequired: true\n  }, __jsx(Flex, {\n    width: \"full\",\n    align: \"center\",\n    justifyContent: \"center\",\n    flexWrap: \"wrap\"\n  }, __jsx(Input, {\n    type: \"text\",\n    id: \"search-query\",\n    width: \"45%\",\n    \"aria-describedby\": \"search-query-helper-text\",\n    placeholder: \"0xdeadbeef\",\n    maxLength: 42,\n    value: temp_q,\n    onChange: e => setTempQ(e.target.value)\n  }), __jsx(Button, {\n    m: 2,\n    onClick: () => {\n      setState({\n        loaded: false\n      });\n      setQ(temp_q);\n      let loc = location.href.split('?')[0] + \"?q=\" + temp_q + \"&network=\" + network + \"&collection=\" + collection;\n      window.history.pushState(temp_q, 'Title', loc);\n    }\n  }, \"Search\"), __jsx(Select, {\n    w: \"45%\",\n    placeholder: \"All Networks\",\n    value: network || '',\n    onChange: e => {\n      setNetwork(e.target.value);\n      console.log(e.target.value);\n    }\n  }, __jsx(\"option\", {\n    value: \"matic\"\n  }, \"Matic\"), __jsx(\"option\", {\n    value: \"mainnet\"\n  }, \"Ethereum Mainnet\"), __jsx(\"option\", {\n    value: \"rinkeby\"\n  }, \"Ethereum Rinkeby\")), __jsx(Select, {\n    ml: 2,\n    w: \"45%\",\n    placeholder: \"All Collections\",\n    value: collection || '',\n    onChange: e => {\n      setCollection(e.target.value);\n      console.log(e.target.value);\n    }\n  }, collections ? collections.map((collection, index) => {\n    return __jsx(\"option\", {\n      key: collection.slug,\n      value: collection.slug\n    }, collection.name);\n  }) : null)), __jsx(FormHelperText, {\n    id: \"search-query-helper-text\"\n  }, \"Search for Emblem Vaults by: Name, Description, Type, Contents\"))), __jsx(Flex, {\n    w: \"100%\",\n    justify: \"center\",\n    flexWrap: \"wrap\",\n    mt: 10\n  }, vaults.length ? vaults.map((vault, index) => {\n    if (vault.name && vault.image) {\n      let pieces = location.pathname.split('/');\n      pieces.pop(); // let url = location.origin + pieces.join('/') + '/nft?id=' + vault.tokenId\n\n      let url = vault.external_url;\n      const flexSettings = {\n        flex: '1',\n        minW: '300px',\n        maxW: '300px',\n        borderWidth: '1px',\n        color: 'white',\n        mx: '6',\n        mb: '6',\n        rounded: 'lg',\n        overflow: 'hidden',\n        borderColor: vault.status == 'claimed' ? 'green !important' : '',\n        cursor: 'pointer'\n      };\n\n      const redirect = function () {\n        location.href = url;\n      };\n\n      return __jsx(Stack, {\n        key: \"stack_\" + index\n      }, __jsx(Box, _extends({\n        key: index\n      }, flexSettings), __jsx(Text, {\n        fontWeight: \"semibold\",\n        textAlign: \"center\",\n        mt: 2\n      }, vault.name, !vault.private && vault.totalValue ? ': ~$' + vault.totalValue : vault.contract && vault.contract.name ? \" : \" + vault.contract.name : null), __jsx(Stack, {\n        align: \"center\"\n      }, __jsx(Embed, {\n        url: vault.image\n      })), __jsx(Box, {\n        d: \"flex\",\n        alignItems: \"baseline\"\n      }, __jsx(Stack, null, __jsx(Box, {\n        onClick: redirect,\n        width: \"100%\",\n        color: \"gray.500\",\n        fontWeight: \"semibold\",\n        letterSpacing: \"wide\",\n        fontSize: \"sm\",\n        ml: \"2\"\n      }, vault.private ? __jsx(React.Fragment, null, __jsx(Text, null, \"Contents hidden. Click to view the vault and unlock values.\")) : vault.values.length ? vault.values.map((coin, index) => {\n        if (index < 4) return __jsx(Text, {\n          key: coin.name,\n          isTruncated: true\n        }, coin.name, \": \", coin.balance);else if (index == 4) return __jsx(Text, {\n          fontWeight: \"bold\",\n          mt: 2\n        }, \"... Click to see the rest ...\");\n      }) : __jsx(Text, null, \"Nothing in here! \", __jsx(\"br\", null), \"Click to fill 'er up!\"), __jsx(Text, null, \"Offers: \", vault.offerCount)), __jsx(Box, _extends({\n        key: \"offer_\" + index\n      }, flexSettings, {\n        minW: \"250px\"\n      }), !vault.mine ? __jsx(Select, {\n        p: 2,\n        m: 2,\n        w: \"84%%\",\n        placeholder: \"Offer NFT\",\n        onChange: e => {\n          let tokenId = e.target.value; // console.log(e.target.value)\n\n          setOfferingTokenId(tokenId);\n          checkOfferingAllowance(tokenId);\n        }\n      }, myVaults.map((vault, index) => {\n        return __jsx(\"option\", {\n          key: index,\n          value: vault.tokenId\n        }, vault.name);\n      })) : __jsx(Select, {\n        p: 2,\n        m: 2,\n        w: \"34%\",\n        placeholder: \"Offers\",\n        onChange: e => {\n          let index = e.target.value;\n          console.log(e.target.value);\n          setAcceptingOfferIndex(index);\n          setAcceptingTokenId(vault.tokenId);\n          checkAcceptingAllowance(vault.tokenId);\n        }\n      }, vault.offers.map((offer, index) => {\n        return __jsx(\"option\", {\n          key: index,\n          value: index\n        }, Number(offer.tokenId));\n      })), offeringTokenId && !vault.mine ? offeringTokenAllowed ? __jsx(Button, {\n        m: 2,\n        onClick: () => {\n          makeOffer(vault.tokenId);\n        }\n      }, \"Make Offer\") : __jsx(Button, {\n        m: 2,\n        w: \"94%\",\n        onClick: approveOffer\n      }, \"Approve\") : null, acceptingOfferingIndex && vault.mine ? acceptingTokenAllowed ? __jsx(Button, {\n        m: 2,\n        w: \"94%\",\n        onClick: () => {\n          acceptOffer();\n        }\n      }, \"Accept Offer\") : __jsx(Button, {\n        m: 2,\n        onClick: () => {\n          approveOffer(vault.tokenId);\n        }\n      }, \"Approve\") : null, acceptingOfferingIndex && vault.mine ? __jsx(Button, {\n        m: 2,\n        w: \"94%\",\n        onClick: () => {\n          rejectOffer();\n        }\n      }, \"Reject Offer\") : null))), __jsx(Stack, {\n        align: \"center\",\n        mt: 3\n      }, vault.status == 'claimed' ? __jsx(Text, {\n        color: \"green.500\"\n      }, \"CLAIMED\") : null)));\n    }\n  }) : __jsx(Text, null, \"Search Resulted in 0 Vaults.\", ' ', __jsx(Link, {\n    color: \"#638cd8\",\n    href: \"../create\"\n  }, \"CREATE ONE HERE!\"))), hash ? __jsx(TransactionToast, {\n    hash: hash,\n    onComplete: () => {\n      setHash(null);\n    }\n  }) : null);\n}","map":null,"metadata":{},"sourceType":"module"}