{"ast":null,"code":"var __jsx = React.createElement;\nimport React from 'react';\nimport { makeStyles } from '@material-ui/core/styles';\nimport Table from '@material-ui/core/Table';\nimport TableBody from '@material-ui/core/TableBody';\nimport TableCell from '@material-ui/core/TableCell';\nimport TableContainer from '@material-ui/core/TableContainer';\nimport TableHead from '@material-ui/core/TableHead';\nimport TableRow from '@material-ui/core/TableRow';\nimport Paper from '@material-ui/core/Paper';\nimport { useWeb3React } from '@web3-react/core';\nimport { useState } from 'react';\nimport { EMBLEM_API } from '../../constants';\nimport { fromContractValue, CHAIN_ID_NAMES } from '../../utils';\nconst useStyles = makeStyles({\n  table: {\n    minWidth: 650\n  }\n});\n\nfunction createData(name, calories, fat, carbs, protein) {\n  return {\n    name,\n    calories,\n    fat,\n    carbs,\n    protein\n  };\n}\n\nlet rows = [//   createData('Frozen yoghurt', 159, 6.0, 24, 4.0),\n  //   createData('Ice cream sandwich', 237, 9.0, 37, 4.3),\n  //   createData('Eclair', 262, 16.0, 24, 6.0),\n  //   createData('Cupcake', 305, 3.7, 67, 4.3),\n  //   createData('Gingerbread', 356, 16.0, 49, 3.9),\n];\nexport default function BridgeDeposits(props) {\n  let previousChainId;\n  const {\n    account\n  } = useWeb3React();\n  const {\n    0: showPending,\n    1: setShowPending\n  } = useState(false);\n  const {\n    0: hasDataRows,\n    1: setHasDataRows\n  } = useState(false);\n  const {\n    0: dataRows,\n    1: setDataRows\n  } = useState([]);\n  const {\n    0: chainId,\n    1: setChainId\n  } = useState(props.chainId);\n  const classes = useStyles();\n  React.useEffect(() => {\n    console.log(chainId, props.chainId);\n\n    if (chainId !== props.chainId) {\n      setChainId(props.chainId);\n      console.log(\"refresh data\");\n      setHasDataRows(false);\n    }\n  });\n  !hasDataRows ? getDeposits(deposits => {\n    setHasDataRows(true);\n    setDataRows(deposits);\n  }) : null;\n  return __jsx(React.Fragment, null, __jsx(TableContainer, {\n    component: Paper\n  }, __jsx(Table, {\n    className: classes.table,\n    \"aria-label\": \"simple table\"\n  }, __jsx(TableHead, null, __jsx(TableRow, null, __jsx(TableCell, null, \"Amount \"), __jsx(TableCell, {\n    align: \"right\"\n  }, \"For\"), __jsx(TableCell, {\n    align: \"left\"\n  }, \"Hash\"), __jsx(TableCell, {\n    align: \"right\"\n  }, \"To Chain\"), __jsx(TableCell, {\n    align: \"right\"\n  }, \"Status\"))), __jsx(TableBody, null, dataRows.sort((a, b) => b.blockNumber > a.blockNumber ? 1 : -1).map(row => Number(row.returnValues.amount) < 200000000000000 ? __jsx(TableRow, {\n    className: account == row.returnValues.sender ? \"MyRow\" : \"\",\n    key: row.name\n  }, __jsx(TableCell, {\n    component: \"th\",\n    scope: \"row\"\n  }, Number(fromContractValue(row.returnValues.amount, 'gwei') * 10).toLocaleString()), __jsx(TableCell, {\n    align: \"right\"\n  }, row.returnValues.sender), __jsx(TableCell, {\n    align: \"left\"\n  }, row.transactionHash), __jsx(TableCell, {\n    align: \"right\"\n  }, CHAIN_ID_NAMES[row.returnValues.chainId]), __jsx(TableCell, {\n    align: \"right\"\n  }, row.transferred ? \"Complete\" : \"Pending\")) : null)))));\n\n  async function getDeposits(cb) {\n    const responce = await fetch(EMBLEM_API + '/transfersOutDb?pending=' + showPending, {\n      method: 'GET',\n      headers: {\n        'Content-Type': 'application/json',\n        'chainid': chainId.toString(),\n        'service': 'evmetadata'\n      }\n    });\n    const jsonData = await responce.json();\n    return cb(jsonData);\n  }\n}","map":null,"metadata":{},"sourceType":"module"}